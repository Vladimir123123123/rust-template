using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using ConVar;
using Facepunch;
using Facepunch.Rust;
using Facepunch.Rust.Profiling;
using Network;
using Network.Visibility;
using Oxide.Core;
using ProtoBuf;
using Rust;
using Rust.Registry;
using SilentOrbit.ProtocolBuffers;
using UnityEngine;
using UnityEngine.Assertions;

public abstract class BaseNetworkable : BaseMonoBehaviour, IEntity, NetworkHandler, IPrefabPostProcess
{
	public struct SaveInfo
	{
		public Entity msg;

		public bool forDisk;

		public bool forTransfer;

		public Connection forConnection;

		internal bool SendingTo(Connection ownerConnection)
		{
			if (ownerConnection == null)
			{
				return false;
			}
			if (forConnection == null)
			{
				return false;
			}
			return forConnection == ownerConnection;
		}
	}

	public struct LoadInfo
	{
		public Entity msg;

		public bool fromDisk;

		public bool fromCopy;

		public bool fromTransfer;
	}

	public class EntityRealmServer : EntityRealm
	{
		protected override Manager visibilityManager
		{
			get
			{
				if (Net.sv == null)
				{
					return null;
				}
				return Net.sv.visibility;
			}
		}
	}

	public abstract class EntityRealm : IEnumerable<BaseNetworkable>, IEnumerable
	{
		public HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>> entityList = new HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>>(new ListDictionary<NetworkableId, BaseNetworkable>());

		public int Count => entityList.Get().Count;

		protected abstract Manager visibilityManager { get; }

		public bool Contains(NetworkableId uid)
		{
			//IL_000b: Unknown result type (might be due to invalid IL or missing references)
			return entityList.Get().Contains(uid);
		}

		public BaseNetworkable Find(NetworkableId uid)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			BaseNetworkable result = null;
			if (!entityList.Get().TryGetValue(uid, ref result))
			{
				return null;
			}
			return result;
		}

		public void RegisterID(BaseNetworkable ent)
		{
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			if (ent.net != null)
			{
				ListDictionary<NetworkableId, BaseNetworkable> val = entityList.Get();
				if (val.Contains(ent.net.ID))
				{
					val[ent.net.ID] = ent;
				}
				else
				{
					val.Add(ent.net.ID, ent);
				}
			}
		}

		public void UnregisterID(BaseNetworkable ent)
		{
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			if (ent.net != null)
			{
				entityList.Get().Remove(ent.net.ID);
			}
		}

		public Group FindGroup(uint uid)
		{
			Manager val = visibilityManager;
			if (val == null)
			{
				return null;
			}
			return val.Get(uid);
		}

		public Group TryFindGroup(uint uid)
		{
			Manager val = visibilityManager;
			if (val == null)
			{
				return null;
			}
			return val.TryGet(uid);
		}

		public void FindInGroup(uint uid, List<BaseNetworkable> list)
		{
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			Group val = TryFindGroup(uid);
			if (val == null)
			{
				return;
			}
			int count = val.networkables.Values.Count;
			Networkable[] buffer = val.networkables.Values.Buffer;
			for (int i = 0; i < count; i++)
			{
				Networkable val2 = buffer[i];
				BaseNetworkable baseNetworkable = Find(val2.ID);
				if (!((Object)(object)baseNetworkable == (Object)null) && baseNetworkable.net != null && baseNetworkable.net.group != null)
				{
					if (baseNetworkable.net.group.ID != uid)
					{
						Debug.LogWarning((object)("Group ID mismatch: " + ((object)baseNetworkable).ToString()));
					}
					else
					{
						list.Add(baseNetworkable);
					}
				}
			}
		}

		public Enumerator<BaseNetworkable> GetEnumerator()
		{
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			return entityList.Get().Values.GetEnumerator();
		}

		IEnumerator<BaseNetworkable> IEnumerable<BaseNetworkable>.GetEnumerator()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return (IEnumerator<BaseNetworkable>)(object)GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			return (IEnumerator)(object)GetEnumerator();
		}

		public void Clear()
		{
			entityList.Get().Clear();
		}
	}

	public enum DestroyMode : byte
	{
		None,
		Gib
	}

	[ReadOnly]
	[Header("BaseNetworkable")]
	public uint prefabID;

	[Tooltip("If enabled the entity will send to everyone on the server - regardless of position")]
	public bool globalBroadcast;

	[Tooltip("Global broadcast a cut down version of the entity to show buildings across the map")]
	public bool globalBuildingBlock;

	[NonSerialized]
	public Networkable net;

	private string _prefabName;

	private string _prefabNameWithoutExtension;

	public static EntityRealm serverEntities = new EntityRealmServer();

	private const bool isServersideEntity = true;

	public static List<Connection> connectionsInSphereList = new List<Connection>();

	public List<Component> postNetworkUpdateComponents = new List<Component>();

	public bool _limitedNetworking;

	[NonSerialized]
	public EntityRef parentEntity;

	[NonSerialized]
	public readonly List<BaseEntity> children = new List<BaseEntity>();

	[NonSerialized]
	public bool canTriggerParent = true;

	public int creationFrame;

	public bool isSpawned;

	public ListHashSet<BaseNetworkable> occludees;

	private int lastDemoIndex = -1;

	public MemoryStream _NetworkCache;

	public static Queue<MemoryStream> EntityMemoryStreamPool = new Queue<MemoryStream>();

	private MemoryStream _SaveCache;

	public bool IsDestroyed { get; private set; }

	public string PrefabName
	{
		get
		{
			if (_prefabName == null)
			{
				_prefabName = StringPool.Get(prefabID);
			}
			return _prefabName;
		}
	}

	public string ShortPrefabName
	{
		get
		{
			if (_prefabNameWithoutExtension == null)
			{
				_prefabNameWithoutExtension = Path.GetFileNameWithoutExtension(PrefabName);
			}
			return _prefabNameWithoutExtension;
		}
	}

	public bool isServer => true;

	public bool isClient => false;

	public bool limitNetworking
	{
		get
		{
			return _limitedNetworking;
		}
		set
		{
			if (value != _limitedNetworking)
			{
				_limitedNetworking = value;
				if (_limitedNetworking)
				{
					OnNetworkLimitStart();
				}
				else
				{
					OnNetworkLimitEnd();
				}
				UpdateNetworkGroup();
			}
		}
	}

	public GameManager gameManager
	{
		get
		{
			if (isServer)
			{
				return GameManager.server;
			}
			throw new NotImplementedException("Missing gameManager path");
		}
	}

	public PrefabAttribute.Library prefabAttribute
	{
		get
		{
			if (isServer)
			{
				return PrefabAttribute.server;
			}
			throw new NotImplementedException("Missing prefabAttribute path");
		}
	}

	public static Group GlobalNetworkGroup => Net.sv.visibility.Get(0u);

	public static Group LimboNetworkGroup => Net.sv.visibility.Get(1u);

	public virtual Vector3 GetNetworkPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.localPosition;
	}

	public virtual Quaternion GetNetworkRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.localRotation;
	}

	public string InvokeString()
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		List<InvokeAction> list = Pool.Get<List<InvokeAction>>();
		InvokeHandler.FindInvokes((Behaviour)(object)this, list);
		foreach (InvokeAction item in list)
		{
			if (stringBuilder.Length > 0)
			{
				stringBuilder.Append(", ");
			}
			stringBuilder.Append(item.action.Method.Name);
		}
		Pool.FreeUnmanaged<InvokeAction>(ref list);
		return stringBuilder.ToString();
	}

	public BaseEntity LookupPrefab()
	{
		return gameManager.FindPrefab(PrefabName).ToBaseEntity();
	}

	public bool EqualNetID(BaseNetworkable other)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if (!other.IsRealNull() && other.net != null && net != null)
		{
			return other.net.ID == net.ID;
		}
		return false;
	}

	public bool EqualNetID(NetworkableId otherID)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (net != null)
		{
			return otherID == net.ID;
		}
		return false;
	}

	public virtual void ResetState()
	{
		if (children.Count > 0)
		{
			children.Clear();
		}
		if (this is ILootableEntity lootableEntity)
		{
			lootableEntity.LastLootedBy = 0uL;
		}
	}

	public virtual void InitShared()
	{
	}

	public virtual void PreInitShared()
	{
	}

	public virtual void PostInitShared()
	{
	}

	public virtual void DestroyShared()
	{
	}

	public virtual void OnNetworkGroupEnter(Group group)
	{
		Interface.CallHook("OnNetworkGroupEntered", (object)this, (object)group);
	}

	public virtual void OnNetworkGroupLeave(Group group)
	{
		Interface.CallHook("OnNetworkGroupLeft", (object)this, (object)group);
	}

	public void OnNetworkGroupChange()
	{
		if (children != null && net.group != null)
		{
			foreach (BaseEntity child in children)
			{
				if (child.IsRealNull())
				{
					Debug.LogError((object)"Child is null when switching groups", (Object)(object)this);
				}
				else if (child.net != null)
				{
					if (child.ShouldInheritNetworkGroup())
					{
						child.net.SwitchGroup(net.group);
					}
					else if (isServer)
					{
						child.UpdateNetworkGroup();
					}
				}
			}
		}
		if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
		{
			ListHashSet<BaseNetworkable> value;
			if (net.group == null)
			{
				occludees = null;
			}
			else if (ServerOcclusion.Occludees.TryGetValue(net.group, out value))
			{
				occludees = value;
			}
			else
			{
				occludees = null;
			}
		}
	}

	public void OnNetworkSubscribersEnter(List<Connection> connections)
	{
		if (!((BaseNetwork)Net.sv).IsConnected())
		{
			return;
		}
		foreach (Connection connection in connections)
		{
			BasePlayer basePlayer = connection.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null))
			{
				basePlayer.QueueUpdate(BasePlayer.NetworkQueue.Update, this as BaseEntity);
			}
		}
	}

	public void OnNetworkSubscribersLeave(List<Connection> connections)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (((BaseNetwork)Net.sv).IsConnected())
		{
			LogEntry(RustLog.EntryType.Network, 2, "LeaveVisibility");
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)6);
			obj.EntityID(net.ID);
			obj.UInt8((byte)0);
			obj.Send(new SendInfo(connections));
		}
	}

	public void EntityDestroy()
	{
		if (Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			ResetState();
			gameManager.Retire(((Component)this).gameObject);
		}
	}

	private void DoEntityDestroy()
	{
		if (IsDestroyed)
		{
			return;
		}
		IsDestroyed = true;
		if (Application.isQuitting)
		{
			return;
		}
		DestroyShared();
		if (isServer)
		{
			DoServerDestroy();
		}
		TimeWarning val = TimeWarning.New("Registry.Entity.Unregister", 0);
		try
		{
			Entity.Unregister(((Component)this).gameObject);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void SpawnShared()
	{
		IsDestroyed = false;
		TimeWarning val = TimeWarning.New("Registry.Entity.Register", 0);
		try
		{
			Entity.Register(((Component)this).gameObject, (IEntity)(object)this);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual void Save(SaveInfo info)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (prefabID == 0)
		{
			Debug.LogError((object)("PrefabID is 0! " + ((Component)this).transform.GetRecursiveName()), (Object)(object)((Component)this).gameObject);
		}
		info.msg.baseNetworkable = Pool.Get<BaseNetworkable>();
		info.msg.baseNetworkable.uid = net.ID;
		info.msg.baseNetworkable.prefabID = prefabID;
		if (net.group != null)
		{
			info.msg.baseNetworkable.group = net.group.ID;
		}
		if (!info.forDisk)
		{
			info.msg.createdThisFrame = creationFrame == Time.frameCount;
		}
	}

	public virtual void PostSave(SaveInfo info)
	{
	}

	public void InitLoad(NetworkableId entityID)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		net = Net.sv.CreateNetworkable(entityID);
		serverEntities.RegisterID(this);
	}

	public virtual void PreServerLoad()
	{
	}

	public virtual void Load(LoadInfo info)
	{
		if (info.msg.baseNetworkable != null)
		{
			LoadInfo loadInfo = info;
			Interface.CallHook("OnEntityLoaded", (object)this, (object)info);
			BaseNetworkable baseNetworkable = loadInfo.msg.baseNetworkable;
			if (prefabID != baseNetworkable.prefabID)
			{
				Debug.LogError((object)("Prefab IDs don't match! " + prefabID + "/" + baseNetworkable.prefabID + " -> " + (object)((Component)this).gameObject), (Object)(object)((Component)this).gameObject);
			}
		}
	}

	public virtual void PostServerLoad()
	{
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public T ToServer<T>() where T : BaseNetworkable
	{
		if (isServer)
		{
			return this as T;
		}
		return null;
	}

	public virtual bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		return false;
	}

	public static List<Connection> GetConnectionsWithin(Vector3 position, float distance, bool addSecondaryConnections = false, bool useRcEntityPosition = true)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		connectionsInSphereList.Clear();
		float num = distance * distance;
		List<Connection> subscribers = GlobalNetworkGroup.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (!val.active)
			{
				continue;
			}
			BasePlayer basePlayer = val.player as BasePlayer;
			if ((Object)(object)basePlayer == (Object)null)
			{
				continue;
			}
			if (addSecondaryConnections)
			{
				if (useRcEntityPosition)
				{
					if (basePlayer.RcEntityPosition.HasValue)
					{
						AddSecondaryConnectionsWithin(basePlayer.RcEntityPosition.Value, num, basePlayer);
					}
				}
				else
				{
					AddSecondaryConnectionsWithin(position, num, basePlayer);
				}
			}
			if (!(basePlayer.SqrDistance(position) > num))
			{
				connectionsInSphereList.Add(val);
			}
		}
		return connectionsInSphereList;
	}

	private static void AddSecondaryConnectionsWithin(Vector3 position, float sqrDistance, BasePlayer player)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (position == Vector3.zero || player.net.secondaryGroup == null)
		{
			return;
		}
		foreach (Connection subscriber in player.net.secondaryGroup.subscribers)
		{
			BasePlayer basePlayer = subscriber.player as BasePlayer;
			if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > sqrDistance))
			{
				connectionsInSphereList.Add(player.Connection);
			}
		}
	}

	public static void GetCloseConnections(Vector3 position, float distance, List<Connection> foundConnections)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || Net.sv.visibility == null)
		{
			return;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					foundConnections.Add(basePlayer.Connection);
				}
			}
		}
	}

	public static void GetCloseConnections(Vector3 position, float distance, List<BasePlayer> players)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null || Net.sv.visibility == null)
		{
			return;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					players.Add(basePlayer);
				}
			}
		}
	}

	public static bool HasCloseConnections(Vector3 position, float distance)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null)
		{
			return false;
		}
		if (Net.sv.visibility == null)
		{
			return false;
		}
		float num = distance * distance;
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return false;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active)
			{
				BasePlayer basePlayer = val.player as BasePlayer;
				if (!((Object)(object)basePlayer == (Object)null) && !(basePlayer.SqrDistance(position) > num))
				{
					return true;
				}
			}
		}
		return false;
	}

	public static bool HasConnections(Vector3 position)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (Net.sv == null)
		{
			return false;
		}
		if (Net.sv.visibility == null)
		{
			return false;
		}
		Group group = Net.sv.visibility.GetGroup(position);
		if (group == null)
		{
			return false;
		}
		List<Connection> subscribers = group.subscribers;
		for (int i = 0; i < subscribers.Count; i++)
		{
			Connection val = subscribers[i];
			if (val.active && !((Object)(object)(val.player as BasePlayer) == (Object)null))
			{
				return true;
			}
		}
		return false;
	}

	public void BroadcastOnPostNetworkUpdate(BaseEntity entity)
	{
		foreach (Component postNetworkUpdateComponent in postNetworkUpdateComponents)
		{
			(postNetworkUpdateComponent as IOnPostNetworkUpdate)?.OnPostNetworkUpdate(entity);
		}
		foreach (BaseEntity child in children)
		{
			child.BroadcastOnPostNetworkUpdate(entity);
		}
	}

	public virtual void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!serverside)
		{
			postNetworkUpdateComponents = ((Component)this).GetComponentsInChildren<IOnPostNetworkUpdate>(true).Cast<Component>().ToList();
		}
	}

	private void OnNetworkLimitStart()
	{
		LogEntry(RustLog.EntryType.Network, 2, "OnNetworkLimitStart");
		List<Connection> subscribers = GetSubscribers();
		if (subscribers == null)
		{
			return;
		}
		subscribers = subscribers.ToList();
		subscribers.RemoveAll((Connection x) => ShouldNetworkTo(x.player as BasePlayer));
		OnNetworkSubscribersLeave(subscribers);
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.OnNetworkLimitStart();
		}
	}

	private void OnNetworkLimitEnd()
	{
		LogEntry(RustLog.EntryType.Network, 2, "OnNetworkLimitEnd");
		List<Connection> subscribers = GetSubscribers();
		if (subscribers == null)
		{
			return;
		}
		OnNetworkSubscribersEnter(subscribers);
		if (children == null)
		{
			return;
		}
		foreach (BaseEntity child in children)
		{
			child.OnNetworkLimitEnd();
		}
	}

	public BaseEntity GetParentEntity()
	{
		return parentEntity.Get(isServer);
	}

	public bool HasParent()
	{
		return parentEntity.IsValid(isServer);
	}

	public void AddChild(BaseEntity child)
	{
		if (!children.Contains(child))
		{
			children.Add(child);
			OnChildAdded(child);
		}
	}

	protected virtual void OnChildAdded(BaseEntity child)
	{
	}

	public void RemoveChild(BaseEntity child)
	{
		children.Remove(child);
		OnChildRemoved(child);
	}

	protected virtual void OnChildRemoved(BaseEntity child)
	{
	}

	public virtual float GetNetworkTime()
	{
		return Time.time;
	}

	public virtual void Spawn()
	{
		EntityProfiler.spawned++;
		if (EntityProfiler.mode >= 2)
		{
			EntityProfiler.OnSpawned(this);
		}
		SpawnShared();
		if (net == null)
		{
			net = Net.sv.CreateNetworkable();
		}
		creationFrame = Time.frameCount;
		PreInitShared();
		InitShared();
		ServerInit();
		PostInitShared();
		UpdateNetworkGroup();
		ServerInitPostNetworkGroupAssign();
		isSpawned = true;
		Interface.CallHook("OnEntitySpawned", (object)this);
		SendNetworkUpdateImmediate(justCreated: true);
		((FacepunchBehaviour)this).Invoke((Action)SendGlobalNetworkUpdate, 0f);
		if (Application.isLoading && !Application.isLoadingSave)
		{
			((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
		}
	}

	private void SendGlobalNetworkUpdate()
	{
		GlobalNetworkHandler.server?.TrySendNetworkUpdate(this);
	}

	public bool IsFullySpawned()
	{
		return isSpawned;
	}

	public virtual void ServerInit()
	{
		serverEntities.RegisterID(this);
		if (net != null)
		{
			net.handler = (NetworkHandler)(object)this;
		}
		lastDemoIndex = -1;
	}

	public virtual void ServerInitPostNetworkGroupAssign()
	{
	}

	public List<Connection> GetSubscribers()
	{
		if (net == null)
		{
			return null;
		}
		if (net.group == null)
		{
			return null;
		}
		return net.group.subscribers;
	}

	protected ListHashSet<BaseNetworkable> GetOccludees()
	{
		return occludees;
	}

	public void KillMessage()
	{
		Kill();
	}

	public virtual void AdminKill()
	{
		Kill(DestroyMode.Gib);
	}

	public virtual void OnKilled()
	{
	}

	public void Kill(DestroyMode mode = DestroyMode.None)
	{
		if (IsDestroyed)
		{
			Debug.LogWarning((object)("Calling kill - but already IsDestroyed!? " + (object)this));
		}
		else if (Interface.CallHook("OnEntityKill", (object)this) == null)
		{
			EntityProfiler.killed++;
			if (EntityProfiler.mode >= 2)
			{
				EntityProfiler.OnKilled(this);
			}
			((Component)this).gameObject.BroadcastOnParentDestroying();
			OnKilled();
			DoEntityDestroy();
			TerminateOnClient(mode);
			TerminateOnServer();
			EntityDestroy();
		}
	}

	public void KillAsMapEntity()
	{
		if (IsFullySpawned())
		{
			Kill();
			return;
		}
		IsDestroyed = true;
		Object.Destroy((Object)(object)((Component)this).gameObject);
	}

	public void TerminateOnClient(DestroyMode mode)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		if (net != null && net.group != null && ((BaseNetwork)Net.sv).IsConnected())
		{
			LogEntry(RustLog.EntryType.Network, 2, "Term {0}", mode);
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)6);
			obj.EntityID(net.ID);
			obj.UInt8((byte)mode);
			obj.Send(new SendInfo(net.group.subscribers));
			GlobalNetworkHandler.server?.OnEntityKilled(this);
		}
	}

	public void TerminateOnServer()
	{
		if (net != null)
		{
			InvalidateNetworkCache();
			serverEntities.UnregisterID(this);
			Net.sv.DestroyNetworkable(ref net);
			((MonoBehaviour)this).StopAllCoroutines();
			((Component)this).gameObject.SetActive(false);
		}
	}

	internal virtual void DoServerDestroy()
	{
		isSpawned = false;
		Analytics.Azure.OnEntityDestroyed(this);
	}

	public virtual bool ShouldNetworkTo(BasePlayer player)
	{
		object obj = Interface.CallHook("CanNetworkTo", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (net.group == null)
		{
			return true;
		}
		return player.net.subscriber.IsSubscribed(net.group);
	}

	public void SendNetworkGroupChange()
	{
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (isSpawned && ((BaseNetwork)Net.sv).IsConnected() && (!(this is BasePlayer basePlayer) || !basePlayer.IsSpectating()))
		{
			if (net.group == null)
			{
				Debug.LogWarning((object)(((object)this).ToString() + " changed its network group to null"));
				return;
			}
			NetWrite obj = ((BaseNetwork)Net.sv).StartWrite();
			obj.PacketID((Type)7);
			obj.EntityID(net.ID);
			obj.GroupID(net.group.ID);
			obj.Send(new SendInfo(net.group.subscribers));
		}
	}

	public void SendAsSnapshot(Connection connection, bool justCreated = false)
	{
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnEntitySnapshot", (object)this, (object)connection) == null)
		{
			NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
			connection.validate.entityUpdates++;
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forConnection = connection;
			saveInfo.forDisk = false;
			SaveInfo saveInfo2 = saveInfo;
			val.PacketID((Type)5);
			val.UInt32(connection.validate.entityUpdates);
			ToStreamForNetwork((Stream)(object)val, saveInfo2);
			val.Send(new SendInfo(connection));
			if (DemoConVars.ServerDemosEnabled)
			{
				lastDemoIndex = ((BaseNetwork)Net.sv).serverDemos.DemoCount;
			}
		}
	}

	public void SendAsSnapshotWithChildren(BasePlayer player, bool includeChildrensChildren = false)
	{
		Connection connection = player.net.connection;
		SendAsSnapshot(connection);
		SendChildren(children);
		void SendChildren(List<BaseEntity> children)
		{
			foreach (BaseEntity child in children)
			{
				if (child.ShouldNetworkTo(player))
				{
					child.SendAsSnapshot(connection);
					if (includeChildrensChildren && child.children != null)
					{
						SendChildren(child.children);
					}
				}
			}
		}
	}

	public void SendDemoTransientEntity()
	{
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		if (!DemoConVars.ServerDemosEnabled)
		{
			return;
		}
		BaseEntity baseEntity = this as BaseEntity;
		if (!baseEntity.enableSaving && lastDemoIndex != ((BaseNetwork)Net.sv).serverDemos.DemoCount)
		{
			lastDemoIndex = ((BaseNetwork)Net.sv).serverDemos.DemoCount;
			NetWrite val = ((BaseNetwork)Net.sv).StartWrite();
			val.PacketID((Type)51);
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forDisk = true;
			SaveInfo saveInfo2 = saveInfo;
			bool flag = true;
			try
			{
				ToStream((Stream)(object)val, saveInfo2);
			}
			catch (Exception ex)
			{
				Debug.LogError((object)$"ServerDemo: Failed to take a snapshot of transient ${baseEntity.ShortPrefabName}[${net.ID}]", (Object)(object)baseEntity);
				Debug.LogException(ex, (Object)(object)this);
				flag = false;
			}
			if (flag)
			{
				Server sv = Net.sv;
				DemoQueueItem val2 = default(DemoQueueItem);
				((DemoQueueItem)(ref val2))..ctor(val);
				val2.IgnoreNoConnections = true;
				((BaseNetwork)sv).EnqueueToDemoThread(val2);
			}
			val.RemoveReference();
		}
	}

	public void SendNetworkUpdate(BasePlayer.NetworkQueue queue = BasePlayer.NetworkQueue.Update)
	{
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdate", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate");
			InvalidateNetworkCache();
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null && subscribers.Count > 0)
			{
				for (int i = 0; i < subscribers.Count; i++)
				{
					BasePlayer basePlayer = subscribers[i].player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						basePlayer.QueueUpdate(queue, this);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public void SendNetworkUpdateImmediate(bool justCreated = false)
	{
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdateImmediate", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdateImmediate");
			InvalidateNetworkCache();
			List<Connection> subscribers = GetSubscribers();
			if (subscribers != null && subscribers.Count > 0)
			{
				for (int i = 0; i < subscribers.Count; i++)
				{
					Connection val2 = subscribers[i];
					BasePlayer basePlayer = val2.player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						SendAsSnapshot(val2, justCreated);
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		((Component)this).gameObject.SendOnSendNetworkUpdate(this as BaseEntity);
	}

	public void SendNetworkUpdate_Position()
	{
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		if (Application.isLoading || Application.isLoadingSave || IsDestroyed || net == null || !isSpawned)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("SendNetworkUpdate_Position", 0);
		try
		{
			LogEntry(RustLog.EntryType.Network, 3, "SendNetworkUpdate_Position");
			List<Connection> list = GetSubscribers();
			if (list == null || list.Count <= 0)
			{
				return;
			}
			if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
			{
				List<Connection> list2 = Pool.Get<List<Connection>>();
				foreach (Connection item in list)
				{
					BasePlayer basePlayer = item.player as BasePlayer;
					if (!((Object)(object)basePlayer == (Object)null) && ShouldNetworkTo(basePlayer))
					{
						list2.Add(item);
					}
				}
				list = list2;
			}
			if (list.Count > 0)
			{
				SendDemoTransientEntity();
				NetWrite val2 = ((BaseNetwork)Net.sv).StartWrite();
				val2.PacketID((Type)10);
				val2.EntityID(net.ID);
				Vector3 networkPosition = GetNetworkPosition();
				val2.Vector3(ref networkPosition);
				Quaternion networkRotation = GetNetworkRotation();
				networkPosition = ((Quaternion)(ref networkRotation)).eulerAngles;
				val2.Vector3(ref networkPosition);
				val2.Float(GetNetworkTime());
				NetworkableId uid = parentEntity.uid;
				if (((NetworkableId)(ref uid)).IsValid)
				{
					val2.EntityID(uid);
				}
				SendInfo val3 = new SendInfo(list);
				val3.method = (SendMethod)1;
				val3.priority = (Priority)0;
				SendInfo val4 = val3;
				val2.Send(val4);
			}
			if (ServerOcclusion.OcclusionEnabled && SupportsServerOcclusion())
			{
				Pool.FreeUnmanaged<Connection>(ref list);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void ToStream(Stream stream, SaveInfo saveInfo)
	{
		Entity val = (saveInfo.msg = Pool.Get<Entity>());
		try
		{
			Save(saveInfo);
			if (saveInfo.msg.baseEntity == null)
			{
				Debug.LogError((object)(((object)this)?.ToString() + ": ToStream - no BaseEntity!?"));
			}
			if (saveInfo.msg.baseNetworkable == null)
			{
				Debug.LogError((object)(((object)this)?.ToString() + ": ToStream - no baseNetworkable!?"));
			}
			Interface.CallHook("IOnEntitySaved", (object)this, (object)saveInfo);
			ProtoStreamExtensions.WriteToStream((IProto)(object)saveInfo.msg, stream, false, 2097152);
			PostSave(saveInfo);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool CanUseNetworkCache(Connection connection)
	{
		return ConVar.Server.netcache;
	}

	public void ToStreamForNetwork(Stream stream, SaveInfo saveInfo)
	{
		if (!CanUseNetworkCache(saveInfo.forConnection))
		{
			ToStream(stream, saveInfo);
			return;
		}
		if (_NetworkCache == null)
		{
			_NetworkCache = ((EntityMemoryStreamPool.Count > 0) ? (_NetworkCache = EntityMemoryStreamPool.Dequeue()) : new MemoryStream(8));
			ToStream(_NetworkCache, saveInfo);
			ConVar.Server.netcachesize += (int)_NetworkCache.Length;
		}
		_NetworkCache.WriteTo(stream);
	}

	public void InvalidateNetworkCache()
	{
		TimeWarning val = TimeWarning.New("InvalidateNetworkCache", 0);
		try
		{
			if (_SaveCache != null)
			{
				ConVar.Server.savecachesize -= (int)_SaveCache.Length;
				_SaveCache.SetLength(0L);
				_SaveCache.Position = 0L;
				EntityMemoryStreamPool.Enqueue(_SaveCache);
				_SaveCache = null;
			}
			if (_NetworkCache != null)
			{
				ConVar.Server.netcachesize -= (int)_NetworkCache.Length;
				_NetworkCache.SetLength(0L);
				_NetworkCache.Position = 0L;
				EntityMemoryStreamPool.Enqueue(_NetworkCache);
				_NetworkCache = null;
			}
			LogEntry(RustLog.EntryType.Network, 3, "InvalidateNetworkCache");
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public MemoryStream GetSaveCache()
	{
		if (_SaveCache == null)
		{
			if (EntityMemoryStreamPool.Count > 0)
			{
				_SaveCache = EntityMemoryStreamPool.Dequeue();
			}
			else
			{
				_SaveCache = new MemoryStream(8);
			}
			SaveInfo saveInfo = default(SaveInfo);
			saveInfo.forDisk = true;
			SaveInfo saveInfo2 = saveInfo;
			ToStream(_SaveCache, saveInfo2);
			ConVar.Server.savecachesize += (int)_SaveCache.Length;
		}
		return _SaveCache;
	}

	public virtual void UpdateNetworkGroup()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		Assert.IsTrue(isServer, "UpdateNetworkGroup called on clientside entity!");
		if (net == null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("UpdateGroups", 0);
		try
		{
			if (net.UpdateGroups(((Component)this).transform.position))
			{
				SendNetworkGroupChange();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public virtual bool SupportsServerOcclusion()
	{
		return false;
	}
}


using Network;
using ProtoBuf;

public struct SaveInfo
{
	public Entity msg;

	public bool forDisk;

	public bool forTransfer;

	public Connection forConnection;

	internal bool SendingTo(Connection ownerConnection)
	{
		if (ownerConnection == null)
		{
			return false;
		}
		if (forConnection == null)
		{
			return false;
		}
		return forConnection == ownerConnection;
	}
}


using ProtoBuf;

public struct LoadInfo
{
	public Entity msg;

	public bool fromDisk;

	public bool fromCopy;

	public bool fromTransfer;
}


using Network;
using Network.Visibility;

public class EntityRealmServer : EntityRealm
{
	protected override Manager visibilityManager
	{
		get
		{
			if (Net.sv == null)
			{
				return null;
			}
			return Net.sv.visibility;
		}
	}
}


using System.Collections;
using System.Collections.Generic;
using Network;
using Network.Visibility;
using UnityEngine;

public abstract class EntityRealm : IEnumerable<BaseNetworkable>, IEnumerable
{
	public HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>> entityList = new HiddenValue<ListDictionary<NetworkableId, BaseNetworkable>>(new ListDictionary<NetworkableId, BaseNetworkable>());

	public int Count => entityList.Get().Count;

	protected abstract Manager visibilityManager { get; }

	public bool Contains(NetworkableId uid)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return entityList.Get().Contains(uid);
	}

	public BaseNetworkable Find(NetworkableId uid)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		BaseNetworkable result = null;
		if (!entityList.Get().TryGetValue(uid, ref result))
		{
			return null;
		}
		return result;
	}

	public void RegisterID(BaseNetworkable ent)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (ent.net != null)
		{
			ListDictionary<NetworkableId, BaseNetworkable> val = entityList.Get();
			if (val.Contains(ent.net.ID))
			{
				val[ent.net.ID] = ent;
			}
			else
			{
				val.Add(ent.net.ID, ent);
			}
		}
	}

	public void UnregisterID(BaseNetworkable ent)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (ent.net != null)
		{
			entityList.Get().Remove(ent.net.ID);
		}
	}

	public Group FindGroup(uint uid)
	{
		Manager val = visibilityManager;
		if (val == null)
		{
			return null;
		}
		return val.Get(uid);
	}

	public Group TryFindGroup(uint uid)
	{
		Manager val = visibilityManager;
		if (val == null)
		{
			return null;
		}
		return val.TryGet(uid);
	}

	public void FindInGroup(uint uid, List<BaseNetworkable> list)
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		Group val = TryFindGroup(uid);
		if (val == null)
		{
			return;
		}
		int count = val.networkables.Values.Count;
		Networkable[] buffer = val.networkables.Values.Buffer;
		for (int i = 0; i < count; i++)
		{
			Networkable val2 = buffer[i];
			BaseNetworkable baseNetworkable = Find(val2.ID);
			if (!((Object)(object)baseNetworkable == (Object)null) && baseNetworkable.net != null && baseNetworkable.net.group != null)
			{
				if (baseNetworkable.net.group.ID != uid)
				{
					Debug.LogWarning((object)("Group ID mismatch: " + ((object)baseNetworkable).ToString()));
				}
				else
				{
					list.Add(baseNetworkable);
				}
			}
		}
	}

	public Enumerator<BaseNetworkable> GetEnumerator()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		return entityList.Get().Values.GetEnumerator();
	}

	IEnumerator<BaseNetworkable> IEnumerable<BaseNetworkable>.GetEnumerator()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerator<BaseNetworkable>)(object)GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return (IEnumerator)(object)GetEnumerator();
	}

	public void Clear()
	{
		entityList.Get().Clear();
	}
}


public enum DestroyMode : byte
{
	None,
	Gib
}


using UnityEngine;

public static class BaseNetworkableEx
{
	public static bool IsValid(this BaseNetworkable ent)
	{
		if ((Object)(object)ent == (Object)null)
		{
			return false;
		}
		if (ent.net == null)
		{
			return false;
		}
		return true;
	}

	public static bool Is<T>(this Object ent, out T entAsT) where T : Object
	{
		entAsT = default(T);
		if (ent == (Object)null)
		{
			return false;
		}
		entAsT = (T)(object)((ent is T) ? ent : null);
		if ((Object)(object)entAsT == (Object)null)
		{
			return false;
		}
		return true;
	}

	public static bool IsRealNull(this BaseNetworkable ent)
	{
		return ent == null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class BaseRagdoll : BaseMountable
{
	[Header("Ragdolling")]
	[SerializeField]
	private Ragdoll Ragdoll;

	[SerializeField]
	private PlayerBonePosData BonePosData;

	[SerializeField]
	private List<DamageTypeEntry> impactDamage;

	[SerializeField]
	private List<Rigidbody> flailBodies;

	private EntityRef<BasePlayer> parentPlayer;

	private BaseEntity initiator;

	private bool dieOnImpact;

	private float lastMovingTime;

	private float largestNegYVelocityOnCollision;

	private bool inTheAir;

	private bool flailInAir;

	private float spinDampening;

	private Vector3 ragdollSpinDirection;

	private bool matchPlayerGravity;

	private int clippedFrameCount;

	private Vector3 lastTransformPos;

	private Vector3 lastEyePos;

	private Vector3 lastPelvisPoint;

	private List<(Vector3, Quaternion)> lastRagdollRbPosRot;

	public GameObjectRef fleshImpact;

	[ClientVar]
	public static bool debug_vis;

	protected override bool BypassClothingMountBlocks => true;

	public override bool DirectlyMountable()
	{
		return false;
	}

	public override void Save(SaveInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		if (parentPlayer.IsValid(base.isServer))
		{
			info.msg.temporaryRagdoll.parentID = parentPlayer.uid;
			info.msg.temporaryRagdoll.mountPose = (int)mountPose;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.temporaryRagdoll != null)
		{
			Load(info.msg.temporaryRagdoll);
		}
	}

	private void Load(TemporaryRagdoll tempRagdoll)
	{
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		base.OnPlayerDismounted(player);
		player.SetPlayerFlag(BasePlayer.PlayerFlags.Ragdolling, b: false);
		PlayerEyes eyes = player.eyes;
		Quaternion rotation = player.eyes.rotation;
		eyes.rotation = Quaternion.Euler(Vector3Ex.WithX(((Quaternion)(ref rotation)).eulerAngles, 0f));
		if (dieOnImpact)
		{
			KillPlayerImpact(player, doRadiusDamage: true);
		}
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val.mass = 10f;
			val.drag = 0f;
			val.angularDrag = 0f;
		}
		val.useGravity = true;
		val.collisionDetectionMode = (CollisionDetectionMode)3;
		val.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
		lastMovingTime = Time.time;
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)GetMounted()).gameObject, true);
		((FacepunchBehaviour)this).Invoke((Action)StopRagdolling, 10f);
	}

	public override void VehicleFixedUpdate()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseRagdoll.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			BasePlayer mounted = GetMounted();
			if ((Object)(object)mounted == (Object)null)
			{
				Kill();
				return;
			}
			AdjustForClipping();
			Vector3 val2 = rigidBody.velocity;
			if (!(((Vector3)(ref val2)).magnitude > 2f))
			{
				val2 = rigidBody.angularVelocity;
				if (!(((Vector3)(ref val2)).magnitude > 2f))
				{
					goto IL_0073;
				}
			}
			lastMovingTime = Time.time;
			goto IL_0073;
			IL_0073:
			if (matchPlayerGravity)
			{
				Vector3 val3 = 2.5f * Physics.gravity - Physics.gravity;
				foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
				{
					rigidbody.AddForce(val3, (ForceMode)5);
				}
			}
			if (inTheAir && flailInAir)
			{
				foreach (Rigidbody flailBody in flailBodies)
				{
					Vector3 val4 = new Vector3(Random.Range(-0.5f, 0.5f), Random.Range(-0.5f, 0.5f), Random.Range(-0.5f, 0.5f)) * (Random.Range(5f, 10f) * spinDampening);
					flailBody.AddForce(val4 * 15f, (ForceMode)5);
				}
				rigidBody.AddTorque(ragdollSpinDirection * spinDampening, (ForceMode)5);
				spinDampening *= 0.98f;
			}
			if (largestNegYVelocityOnCollision < 0f)
			{
				if (Object.op_Implicit((Object)(object)mounted))
				{
					mounted.ApplyFallDamageFromVelocity(largestNegYVelocityOnCollision);
				}
				largestNegYVelocityOnCollision = 0f;
			}
			if (Time.time > lastMovingTime + 1.25f)
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)StopRagdolling);
				StopRagdolling();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void AdjustForClipping()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		//IL_0258: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0261: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("AdjustForClipping", 0);
		try
		{
			Vector3 position = lastTransformPos;
			lastTransformPos = ((Component)this).transform.position;
			Vector3 start = lastEyePos;
			Vector3 end = (lastEyePos = GetMounted().eyes.position);
			Vector3 start2 = lastPelvisPoint;
			Vector3 end2 = (lastPelvisPoint = Ragdoll.primaryBody.position);
			BasePlayer basePlayer = parentPlayer.Get(serverside: true);
			Vector3 velocity = rigidBody.velocity;
			bool flag = ((Vector3)(ref velocity)).sqrMagnitude > 3f;
			bool flag2 = false;
			bool flag3 = false;
			List<RaycastHit> hits = Pool.Get<List<RaycastHit>>();
			bool flag4 = flag && ClippedOnPath(start, end, 0.3f, in hits, basePlayer);
			bool flag5 = ClippedOnPath(start, end, 0f, in hits, basePlayer);
			flag2 = flag2 || flag4 || flag5;
			flag3 = flag3 || flag5;
			bool flag6 = flag && ClippedOnPath(start2, end2, 0.3f, in hits, basePlayer);
			bool flag7 = ClippedOnPath(start2, end2, 0f, in hits, basePlayer);
			flag2 = flag2 || flag6 || flag7;
			flag3 = flag3 || flag7;
			Pool.FreeUnmanaged<RaycastHit>(ref hits);
			if (!flag2)
			{
				for (int i = 0; i < Ragdoll.rigidbodies.Count; i++)
				{
					Rigidbody val2 = Ragdoll.rigidbodies[i];
					lastRagdollRbPosRot[i] = (val2.position, val2.rotation);
				}
				return;
			}
			if (flag3 && ++clippedFrameCount >= 3)
			{
				basePlayer.Hurt(new HitInfo(initiator, basePlayer, DamageType.Blunt, 1000f));
				StopRagdolling();
				return;
			}
			for (int j = 0; j < Ragdoll.rigidbodies.Count; j++)
			{
				Rigidbody val3 = Ragdoll.rigidbodies[j];
				if (!((Object)(object)val3 == (Object)null))
				{
					var (position2, rotation) = lastRagdollRbPosRot[j];
					val3.position = position2;
					val3.rotation = rotation;
					val3.velocity = Vector3.zero;
					val3.angularVelocity = Vector3.zero;
				}
			}
			((Component)this).transform.position = position;
			lastTransformPos = position;
			lastEyePos = start;
			lastPelvisPoint = start2;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool ClippedOnPath(Vector3 start, Vector3 end, float radius, in List<RaycastHit> hits, BasePlayer ignorePlayer)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		Vector3 val = end - start;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (magnitude < Mathf.Epsilon)
		{
			return false;
		}
		val /= magnitude;
		Ray ray = new Ray(start, val);
		hits.Clear();
		GamePhysics.TraceAllUnordered(ray, radius, hits, magnitude, -910884607, (QueryTriggerInteraction)1);
		foreach (RaycastHit hit in hits)
		{
			BaseEntity entity = hit.GetEntity();
			if (!GamePhysics.CompareEntity(entity, this) && !GamePhysics.CompareEntity(entity, ignorePlayer))
			{
				result = true;
				break;
			}
		}
		return result;
	}

	public void InitFromPlayer(BasePlayer bp, Vector3 velocityOverride = default(Vector3), bool matchPlayerGravity = true, bool flailInAir = false, bool dieOnImpact = false, BaseEntity initiator = null)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0151: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0238: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0253: Unknown result type (might be due to invalid IL or missing references)
		//IL_025a: Unknown result type (might be due to invalid IL or missing references)
		//IL_025f: Unknown result type (might be due to invalid IL or missing references)
		parentPlayer.Set(bp);
		lastEyePos = bp.eyes.position;
		if (bp.isMounted)
		{
			mountPose = bp.GetMounted().mountPose;
		}
		PlayerBonePosData.BonePosData bonePositionData = BonePosData.GetBonePositionData(bp.playerFlags, bp.modelState);
		if (bonePositionData != null)
		{
			model.skeleton.CopyFrom(bonePositionData.bonePositions, bonePositionData.boneRotations, true);
			Transform transform = model.skeleton.Bones[0].transform;
			transform.localEulerAngles += bonePositionData.rootRotationOffset;
		}
		float x = ((Component)bp).transform.eulerAngles.x;
		Quaternion bodyRotation = bp.eyes.bodyRotation;
		Quaternion val = Quaternion.Euler(x, ((Quaternion)(ref bodyRotation)).eulerAngles.y, ((Component)bp).transform.eulerAngles.z);
		((Component)this).transform.SetPositionAndRotation(((Component)bp).transform.position, val);
		lastTransformPos = ((Component)this).transform.position;
		Ragdoll.ServerInit();
		rigidBody.drag = 0f;
		rigidBody.angularDrag = 0f;
		inTheAir = true;
		Vector3 val2 = ((velocityOverride != Vector3.zero) ? velocityOverride : (bp.isMounted ? bp.GetMountVelocity() : bp.estimatedVelocity));
		rigidBody.AddForce(val2, (ForceMode)1);
		lastRagdollRbPosRot = new List<(Vector3, Quaternion)>(Ragdoll.rigidbodies.Count);
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.drag = 0f;
			rigidbody.angularDrag = 0f;
			rigidbody.AddForceAtPosition(val2, ((Component)rigidbody).transform.position, (ForceMode)2);
			rigidbody.collisionDetectionMode = (CollisionDetectionMode)3;
			lastRagdollRbPosRot.Add((rigidbody.position, rigidbody.rotation));
		}
		lastPelvisPoint = Ragdoll.primaryBody.position;
		this.flailInAir = flailInAir;
		if (flailInAir)
		{
			spinDampening = 1f;
			Vector3 zero = Vector3.zero;
			((Vector3)(ref zero))[Random.Range(0, 3)] = 1f;
			ragdollSpinDirection = zero * 0.8f;
		}
		if (Object.op_Implicit((Object)(object)initiator))
		{
			GameObjectExtensions.SetIgnoreCollisions(((Component)this).gameObject, ((Component)initiator).gameObject, true);
		}
		this.matchPlayerGravity = matchPlayerGravity;
		this.initiator = initiator;
		this.dieOnImpact = dieOnImpact;
	}

	public override bool GetDismountPosition(BasePlayer player, out Vector3 res, bool silent = false)
	{
		List<Collider> list = Pool.Get<List<Collider>>();
		((Component)this).GetComponentsInChildren<Collider>(list);
		foreach (Collider item in list)
		{
			item.enabled = false;
		}
		bool dismountPosition = base.GetDismountPosition(player, out res, silent);
		foreach (Collider item2 in list)
		{
			item2.enabled = true;
		}
		Pool.FreeUnmanaged<Collider>(ref list);
		return dismountPosition;
	}

	private void StopRagdolling()
	{
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			mounted.SetPlayerFlag(BasePlayer.PlayerFlags.Ragdolling, b: false);
		}
		DismountAllPlayers();
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public override bool AllowPlayerInstigatedDismount(BasePlayer player)
	{
		object obj = Interface.CallHook("CanRagdollDismount", (object)this, (object)player);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	protected void ProcessCollision(Collision collision, BaseEntity hitEntity, Rigidbody ourRigidbody)
	{
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted == (Object)null)
		{
			return;
		}
		if (dieOnImpact)
		{
			KillPlayerImpact(mounted, doRadiusDamage: true);
		}
		else
		{
			largestNegYVelocityOnCollision = Mathf.Min(largestNegYVelocityOnCollision, 0f - collision.relativeVelocity.y);
		}
		if (!inTheAir)
		{
			return;
		}
		inTheAir = false;
		if (!flailInAir)
		{
			return;
		}
		rigidBody.drag = 1f;
		rigidBody.angularDrag = 1f;
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.drag = 1f;
			rigidbody.angularDrag = 1f;
		}
	}

	private void KillPlayerImpact(BasePlayer mounted, bool doRadiusDamage)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(mounted.fallDamageEffect.resourcePath, ((Component)this).transform.position, Vector3.zero);
		Effect.server.Run(fleshImpact.resourcePath, ((Component)this).transform.position, Vector3.zero);
		if (doRadiusDamage)
		{
			DamageUtil.RadiusDamage(mounted, initiator, ((Component)mounted).transform.position, 1f, 3.5f, impactDamage, 133120, useLineOfSight: true);
		}
		((FacepunchBehaviour)this).Invoke((Action)delegate
		{
			StopRagdolling();
			mounted.Hurt(new HitInfo(initiator, mounted, DamageType.Blunt, 1000f));
		}, 1f);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, hitEntity, rigidBody);
		}
	}
}


using Rust;
using UnityEngine;

public class AnimatedBuildingBlock : StabilityEntity
{
	private bool animatorNeedsInitializing = true;

	private bool animatorIsOpen = true;

	[HideInInspector]
	public bool isAnimating;

	[HideInInspector]
	public float lastAnimationStateChange;

	private static readonly int Open = Animator.StringToHash("open");

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			UpdateAnimationParameters(init: true);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		UpdateAnimationParameters(init: true);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		if (!isAnimating)
		{
			return Time.time - lastAnimationStateChange <= 10f;
		}
		return true;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		UpdateAnimationParameters(init: false);
	}

	protected virtual void ApplySubAnimationParameters(bool init, Animator toAnimator)
	{
	}

	protected void UpdateAnimationParameters(bool init)
	{
		if (!Object.op_Implicit((Object)(object)model) || !Object.op_Implicit((Object)(object)model.animator) || !model.animator.isInitialized)
		{
			return;
		}
		bool num = animatorNeedsInitializing || animatorIsOpen != IsOpen() || (init && isAnimating);
		bool flag = animatorNeedsInitializing || init;
		lastAnimationStateChange = GetNetworkTime();
		if (num)
		{
			isAnimating = true;
			((Behaviour)model.animator).enabled = true;
			model.animator.SetBool(Open, animatorIsOpen = IsOpen());
			ApplySubAnimationParameters(init, model.animator);
			if (flag)
			{
				model.animator.fireEvents = false;
				if (((Behaviour)model.animator).isActiveAndEnabled)
				{
					model.animator.Update(0f);
					model.animator.Update(20f);
				}
				PutAnimatorToSleep();
				isAnimating = false;
			}
			else
			{
				model.animator.fireEvents = base.isClient;
				if (base.isServer)
				{
					SetFlag(Flags.Busy, b: true);
				}
			}
		}
		else if (flag)
		{
			PutAnimatorToSleep();
		}
		animatorNeedsInitializing = false;
	}

	protected virtual void OnAnimatorFinished()
	{
		if (!isAnimating)
		{
			PutAnimatorToSleep();
		}
		isAnimating = false;
	}

	private void PutAnimatorToSleep()
	{
		if (!Object.op_Implicit((Object)(object)model) || !Object.op_Implicit((Object)(object)model.animator))
		{
			Debug.LogWarning((object)(((Component)this).transform.GetRecursiveName() + " has missing model/animator"), (Object)(object)((Component)this).gameObject);
			return;
		}
		((Behaviour)model.animator).enabled = false;
		if (base.isServer)
		{
			SetFlag(Flags.Busy, b: false);
		}
		OnAnimatorDisabled();
	}

	protected virtual void OnAnimatorDisabled()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BuildingPrivilegeRetro : BuildingPrivlidge
{
	[Serializable]
	public struct ToolSetting
	{
		public ItemDefinition item;

		public Transform[] parents;
	}

	[Serializable]
	public struct ToolModel
	{
		public ItemDefinition item;

		public GameObjectRef model;
	}

	public BuildingPrivilegeRetroScreen screens;

	public GameObjectRef[] boxPrefabs;

	public GameObjectRef[] doubleBoxPrefabs;

	public int boxesAmount = 12;

	public Transform boxesParent;

	public Vector3 boxSpacing = new Vector3(0.33f, 0.3f, 0.3f);

	public ToolSetting[] toolSettings;

	public ToolModel[] toolCustomModels;

	public Material hammerOriginalMaterial;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingPrivilegeRetro = Pool.Get<BuildingPrivilegeRetro>();
		if (info.forDisk || !((Object)(object)info.forConnection?.player != (Object)null) || !IsAuthed(info.forConnection.player as BasePlayer))
		{
			return;
		}
		List<float> list = Pool.Get<List<float>>();
		list.Add(GetResourceProportion(-151838493));
		list.Add(GetResourceProportion(-2099697608));
		list.Add(GetResourceProportion(69511070));
		list.Add(GetResourceProportion(317398316));
		info.msg.buildingPrivilegeRetro.resources = list;
		info.msg.buildingPrivilegeRetro.tools = Pool.Get<List<BuildingPrivilegeRetroTool>>();
		for (int i = 24; i <= 28; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			BuildingPrivilegeRetroTool val = Pool.Get<BuildingPrivilegeRetroTool>();
			if (slot != null)
			{
				foreach (ItemDefinition allowedConstructionItem in allowedConstructionItems)
				{
					if (slot.info.itemid == allowedConstructionItem.itemid)
					{
						val.itemID = allowedConstructionItem.itemid;
						val.skinid = slot.skin;
					}
				}
			}
			info.msg.buildingPrivilegeRetro.tools.Add(val);
		}
	}

	private float GetResourceProportion(int id)
	{
		int amount = base.inventory.GetAmount(id, onlyUsableAmounts: false);
		float num = ItemManager.FindItemDefinition(id).stackable;
		return (float)amount / ((float)(base.inventory.capacity - 5) * num);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.buildingPrivilegeRetro;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct ToolSetting
{
	public ItemDefinition item;

	public Transform[] parents;
}


using System;

[Serializable]
public struct ToolModel
{
	public ItemDefinition item;

	public GameObjectRef model;
}


using System;
using Rust.UI;
using UnityEngine;

public class BuildingPrivilegeRetroScreen : FacepunchBehaviour, INotifyLOD, IClientComponent
{
	[Serializable]
	public struct Screen
	{
		public CanvasGroup group;

		public CanvasGroup onGroup;

		public CanvasGroup offGroup;

		public void TurnOnOff(bool on)
		{
			((Component)onGroup).gameObject.SetActive(on);
			onGroup.alpha = (on ? 1 : 0);
			((Component)offGroup).gameObject.SetActive(!on);
			offGroup.alpha = ((!on) ? 1 : 0);
		}
	}

	[SerializeField]
	private CanvasGroup screenCanvas;

	[Space]
	[Header("PROTECTED TIME")]
	public RustText protectedTimeText;

	public int decayWarningThreshold = 130;

	public GameObject decayWarningGroup;

	public GameObject decayingGroup;

	[Space]
	[Header("UPKEEP")]
	public VirtualItemIcon[] costIcons;

	public RustText[] paginationTexts;

	[Space]
	[Header("BLOCKS")]
	public GameObject[] blocksType;

	public RustText blockCountText;

	public RustText doorCountText;

	[Space]
	public Renderer screenRenderer;

	[ColorUsage(true, true)]
	public Color fromScreenEmissionColor;

	[ColorUsage(true, true)]
	public Color screenEmissionColor;

	public AnimationCurve tweenCurve;

	public float animDuration = 0.7f;

	public Animation screensAnim;

	public Screen[] screens;
}


using System;
using UnityEngine;

[Serializable]
public struct Screen
{
	public CanvasGroup group;

	public CanvasGroup onGroup;

	public CanvasGroup offGroup;

	public void TurnOnOff(bool on)
	{
		((Component)onGroup).gameObject.SetActive(on);
		onGroup.alpha = (on ? 1 : 0);
		((Component)offGroup).gameObject.SetActive(!on);
		offGroup.alpha = ((!on) ? 1 : 0);
	}
}


using UnityEngine;

public class DoorWithLock : Door
{
	[ItemSelector(ItemCategory.All)]
	[Header("Lock Settings")]
	public GameObjectRef lockObject;
}


public class Gate : Door, INotifyTrigger, ISimpleUpgradable
{
}


using UnityEngine;

public class OBBComponent : MonoBehaviour
{
	public Bounds Bounds;

	public OBB GetObb()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new OBB(((Component)this).transform, Bounds);
	}
}


using UnityEngine;

public class ProceduralLiftCabin : MonoBehaviour
{
}


using UnityEngine;

public class ProceduralLiftStop : MonoBehaviour
{
}


using System;

public class SimpleBuildingBlockModelVariant : PrefabAttribute
{
	public GameObjectRef prefab;

	public BaseEntity.Flags Flag;

	protected override Type GetIndexedType()
	{
		return typeof(SimpleBuildingBlockModelVariant);
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SimplePrivilege : BaseEntity
{
	public List<PlayerNameID> authorizedPlayers = new List<PlayerNameID>();

	public const Flags Flag_MaxAuths = Flags.Reserved5;

	public override void ResetState()
	{
		base.ResetState();
		authorizedPlayers.Clear();
	}

	public bool IsAuthed(BasePlayer player)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == (ulong)player.userID);
	}

	public bool IsAuthed(ulong userID)
	{
		return authorizedPlayers.Any((PlayerNameID x) => x.userid == userID);
	}

	public bool AnyAuthed()
	{
		return authorizedPlayers.Count > 0;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.buildingPrivilege = Pool.Get<BuildingPrivilege>();
		info.msg.buildingPrivilege.users = authorizedPlayers;
	}

	public override void PostSave(SaveInfo info)
	{
		info.msg.buildingPrivilege.users = null;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		authorizedPlayers.Clear();
		if (info.msg.buildingPrivilege != null && info.msg.buildingPrivilege.users != null)
		{
			authorizedPlayers = info.msg.buildingPrivilege.users;
			info.msg.buildingPrivilege.users = null;
		}
	}

	public bool AtMaxAuthCapacity()
	{
		return HasFlag(Flags.Reserved5);
	}

	public void UpdateMaxAuthCapacity()
	{
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		if (Object.op_Implicit((Object)(object)activeGameMode) && activeGameMode.limitTeamAuths)
		{
			SetFlag(Flags.Reserved5, authorizedPlayers.Count >= activeGameMode.GetMaxRelationshipTeamSize());
		}
	}
}


public interface ISimpleUpgradable
{
	bool UpgradingEnabled();

	bool CanUpgrade(BasePlayer player);

	bool CostIsItem();

	void DoUpgrade(BasePlayer player);

	ItemDefinition GetUpgradeItem();
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

internal static class SimpleUpgrade
{
	public static bool CanUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if ((Object)(object)upgradeItem == (Object)null)
		{
			return false;
		}
		if (!player.CanInteract())
		{
			return false;
		}
		if (player.IsBuildingBlocked(((Component)entity).transform.position, ((Component)entity).transform.rotation, entity.bounds))
		{
			return false;
		}
		if ((Object)(object)((Component)upgradeItem).GetComponent<ItemModDeployable>() == (Object)null)
		{
			return false;
		}
		if (IsUpgradeBlocked(entity, upgradeItem, player))
		{
			return false;
		}
		if (!CanAffordUpgrade(entity, upgradeItem, player))
		{
			return false;
		}
		return true;
	}

	public static bool CanAffordUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		ISimpleUpgradable simpleUpgradable = entity as ISimpleUpgradable;
		if ((Object)(object)entity == (Object)null)
		{
			return false;
		}
		if (player.IsInCreativeMode && Creative.freeBuild)
		{
			return true;
		}
		if (simpleUpgradable.CostIsItem())
		{
			return player.inventory.GetAmount(upgradeItem) > 0;
		}
		if ((Object)(object)upgradeItem.Blueprint == (Object)null)
		{
			return false;
		}
		if (!ItemModStudyBlueprint.IsBlueprintUnlocked(upgradeItem, player))
		{
			return false;
		}
		foreach (ItemAmount ingredient in upgradeItem.Blueprint.GetIngredients())
		{
			if ((float)player.inventory.GetAmount(ingredient.itemid) < ingredient.amount)
			{
				return false;
			}
		}
		return true;
	}

	public static void PayForUpgrade(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		if ((Object)(object)player == (Object)null || (player.IsInCreativeMode && Creative.freeBuild) || !(entity is ISimpleUpgradable simpleUpgradable))
		{
			return;
		}
		List<Item> list = new List<Item>();
		if (simpleUpgradable.CostIsItem())
		{
			player.inventory.Take(list, upgradeItem.itemid, 1);
			player.Command("note.inv " + upgradeItem.itemid + " " + -1);
		}
		else
		{
			foreach (ItemAmount ingredient in upgradeItem.Blueprint.GetIngredients())
			{
				player.inventory.Take(list, ingredient.itemid, (int)ingredient.amount);
				player.Command("note.inv " + ingredient.itemid + " " + ingredient.amount * -1f);
			}
		}
		foreach (Item item in list)
		{
			item.Remove();
		}
	}

	public static void DoUpgrade(BaseEntity entity, BasePlayer player)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		if (!(entity is ISimpleUpgradable simpleUpgradable) || !simpleUpgradable.CanUpgrade(player))
		{
			return;
		}
		ItemDefinition upgradeItem = simpleUpgradable.GetUpgradeItem();
		PayForUpgrade(entity, upgradeItem, player);
		EntityRef[] slots = entity.GetSlots();
		BaseEntity parentEntity = entity.GetParentEntity();
		ItemModDeployable component = ((Component)upgradeItem).GetComponent<ItemModDeployable>();
		BaseEntity baseEntity = GameManager.server.CreateEntity(component.entityPrefab.resourcePath, ((Component)entity).transform.position, ((Component)entity).transform.rotation);
		baseEntity.SetParent(parentEntity);
		baseEntity.OwnerID = player.userID;
		Deployable component2 = component.entityPrefab.Get().GetComponent<Deployable>();
		if (component2 != null && component2.placeEffect.isValid)
		{
			Effect.server.Run(component2.placeEffect.resourcePath, ((Component)entity).transform.position, Vector3.up);
		}
		DecayEntity decayEntity = baseEntity as DecayEntity;
		if ((Object)(object)decayEntity != (Object)null)
		{
			decayEntity.timePlaced = entity.GetNetworkTime();
		}
		List<SprayCan.ChildPreserveInfo> list = Pool.Get<List<SprayCan.ChildPreserveInfo>>();
		foreach (BaseEntity child in entity.children)
		{
			list.Add(new SprayCan.ChildPreserveInfo
			{
				TargetEntity = child,
				TargetBone = child.parentBone,
				LocalPosition = ((Component)child).transform.localPosition,
				LocalRotation = ((Component)child).transform.localRotation
			});
		}
		foreach (SprayCan.ChildPreserveInfo item in list)
		{
			item.TargetEntity.SetParent(null, worldPositionStays: true);
		}
		entity.Kill();
		if (baseEntity is DecayEntity decayEntity2)
		{
			decayEntity2.AttachToBuilding(null);
		}
		baseEntity.Spawn();
		foreach (SprayCan.ChildPreserveInfo item2 in list)
		{
			item2.TargetEntity.SetParent(baseEntity, item2.TargetBone, worldPositionStays: true);
			((Component)item2.TargetEntity).transform.localPosition = item2.LocalPosition;
			((Component)item2.TargetEntity).transform.localRotation = item2.LocalRotation;
			item2.TargetEntity.SendNetworkUpdate();
		}
		baseEntity.SetSlots(slots);
		Pool.FreeUnmanaged<SprayCan.ChildPreserveInfo>(ref list);
	}

	public static bool IsUpgradeBlocked(BaseEntity entity, ItemDefinition upgradeItem, BasePlayer player)
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)upgradeItem == (Object)null)
		{
			return true;
		}
		if ((Object)(object)entity == (Object)null)
		{
			return true;
		}
		if (entity is DecorDeployable)
		{
			return false;
		}
		ItemModDeployable component = ((Component)upgradeItem).GetComponent<ItemModDeployable>();
		if ((Object)(object)component == (Object)null)
		{
			return false;
		}
		DeployVolume[] volumes = PrefabAttribute.server.FindAll<DeployVolume>(component.entityPrefab.resourceID);
		if (DeployVolume.Check(((Component)entity).transform.position, ((Component)entity).transform.rotation, volumes, ~((1 << ((Component)entity).gameObject.layer) | 0x20000000)))
		{
			return true;
		}
		return false;
	}
}


using UnityEngine;

public class WallpaperModelRenderer : MonoBehaviour, ICustomMaterialReplacer, IClientComponent
{
	public Renderer rend;

	public Material baseMaterial;

	public bool autoLoad;

	public Material targetMaterial;
}


using Facepunch.Rust;
using UnityEngine;

public class WallpaperPlanner : Planner
{
	private static ItemDefinition _wallpaperItem;

	private static WallpaperSettings _settings;

	public static ItemDefinition WallpaperItemDef
	{
		get
		{
			if ((Object)(object)_wallpaperItem == (Object)null)
			{
				_wallpaperItem = ItemManager.FindItemDefinition("wallpaper");
			}
			return _wallpaperItem;
		}
	}

	public static WallpaperSettings Settings
	{
		get
		{
			if (_settings == null)
			{
				_settings = FileSystem.Load<WallpaperSettings>("Assets/Prefabs/Wallpaper/Wallpaper Settings.asset", true);
			}
			return _settings;
		}
	}

	public override bool isTypeDeployable => true;

	public override Deployable GetDeployable(NetworkableId entityId)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (((NetworkableId)(ref entityId)).IsValid)
		{
			BaseEntity baseEntity = BaseNetworkable.serverEntities.Find(entityId) as BaseEntity;
			return Settings.GetDeployable(baseEntity as BuildingBlock);
		}
		return null;
	}

	public override BaseEntity DoBuild(Construction.Target target, Construction component)
	{
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer ownerPlayer = GetOwnerPlayer();
		if ((Object)(object)ownerPlayer == (Object)null)
		{
			return null;
		}
		if (target.entity is BuildingBlock buildingBlock)
		{
			int side = ((!target.socket.socketName.EndsWith("1")) ? 1 : 0);
			if (buildingBlock.HasWallpaper(side))
			{
				return null;
			}
			if (!buildingBlock.CanSeeWallpaperSocket(ownerPlayer, side))
			{
				ownerPlayer.ShowToast(GameTip.Styles.Error, ConstructionErrors.LineOfSightBlocked, false);
				return null;
			}
			buildingBlock.SetWallpaper(skinID, side);
			PayForPlacement(ownerPlayer, component);
			Analytics.Azure.OnWallpaperPlaced(ownerPlayer, buildingBlock, skinID, side, reskin: false);
			if (component.deployable.placeEffect.isValid)
			{
				Effect.server.Run(component.deployable.placeEffect.resourcePath, ((Component)buildingBlock).transform.TransformPoint(target.socket.worldPosition), ((Component)buildingBlock).transform.up);
			}
		}
		return null;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Wallpaper/Wallpaper Settings")]
public class WallpaperSettings : BaseScriptableObject
{
	public GameObjectRef[] WallpaperPrefabs;

	public BuildingBlock[] BuildingBlocks;

	public GameObjectRef GetWallpaperPrefab(BuildingBlock buildingBlock)
	{
		if ((Object)(object)buildingBlock != (Object)null)
		{
			for (int i = 0; i < BuildingBlocks.Length; i++)
			{
				if (BuildingBlocks[i].prefabID == buildingBlock.prefabID)
				{
					return WallpaperPrefabs[i];
				}
			}
		}
		return null;
	}

	public Construction GetConstruction(BuildingBlock buildingBlock)
	{
		GameObjectRef wallpaperPrefab = GetWallpaperPrefab(buildingBlock);
		if (wallpaperPrefab == null)
		{
			return null;
		}
		if (buildingBlock.isServer)
		{
			return PrefabAttribute.server.Find<Construction>(wallpaperPrefab.resourceID);
		}
		return null;
	}

	public Deployable GetDeployable(BuildingBlock buildingBlock)
	{
		GameObjectRef wallpaperPrefab = GetWallpaperPrefab(buildingBlock);
		if (wallpaperPrefab == null)
		{
			return null;
		}
		if (buildingBlock.isServer)
		{
			return PrefabAttribute.server.Find<Deployable>(wallpaperPrefab.resourceID);
		}
		return null;
	}
}


using UnityEngine;

public class DeployableToSlot : MonoBehaviour
{
	public BaseEntity.Slot slot;
}


using UnityEngine;

public class EntityCollisionMessage : EntityComponent<BaseEntity>
{
	private void OnCollisionEnter(Collision collision)
	{
		if ((Object)(object)base.baseEntity == (Object)null || base.baseEntity.IsDestroyed)
		{
			return;
		}
		BaseEntity baseEntity = collision.GetEntity();
		if ((Object)(object)baseEntity == (Object)(object)base.baseEntity)
		{
			return;
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			if (baseEntity.IsDestroyed)
			{
				return;
			}
			if (base.baseEntity.isServer)
			{
				baseEntity = baseEntity.ToServer<BaseEntity>();
			}
		}
		base.baseEntity.OnCollision(collision, baseEntity);
	}
}


using System;
using UnityEngine;

public class EntityComponent<T> : EntityComponentBase where T : BaseEntity
{
	[NonSerialized]
	public T _baseEntity;

	public T baseEntity
	{
		get
		{
			if ((Object)(object)_baseEntity == (Object)null)
			{
				UpdateBaseEntity();
			}
			return _baseEntity;
		}
	}

	protected void UpdateBaseEntity()
	{
		if (Object.op_Implicit((Object)(object)this) && Object.op_Implicit((Object)(object)((Component)this).gameObject))
		{
			_baseEntity = ((Component)this).gameObject.ToBaseEntity() as T;
		}
	}

	public override BaseEntity GetBaseEntity()
	{
		return baseEntity;
	}

	public T GetCastedEntity()
	{
		return baseEntity;
	}
}


using Network;

public class EntityComponentBase : BaseMonoBehaviour
{
	public virtual BaseEntity GetBaseEntity()
	{
		return null;
	}

	public virtual void InitShared()
	{
	}

	public virtual void ResetState()
	{
	}

	public virtual void DestroyShared()
	{
	}

	public virtual void SaveComponent(BaseNetworkable.SaveInfo info)
	{
	}

	public virtual void LoadComponent(BaseNetworkable.LoadInfo info)
	{
	}

	public virtual void Hurt(HitInfo hitInfo)
	{
	}

	public virtual bool OnDied(HitInfo info)
	{
		return true;
	}

	public virtual bool OnRpcMessage(BasePlayer player, uint rpc, Message msg)
	{
		return false;
	}
}


using System.Diagnostics;
using UnityEngine;

public class EntityDebug : EntityComponent<BaseEntity>
{
	internal Stopwatch stopwatch = Stopwatch.StartNew();

	private void Update()
	{
		if (!base.baseEntity.IsValid() || !base.baseEntity.IsDebugging())
		{
			((Behaviour)this).enabled = false;
		}
		else if (!(stopwatch.Elapsed.TotalSeconds < 0.5))
		{
			_ = base.baseEntity.isClient;
			if (base.baseEntity.isServer)
			{
				base.baseEntity.DebugServer(1, (float)stopwatch.Elapsed.TotalSeconds);
			}
			stopwatch.Reset();
			stopwatch.Start();
		}
	}
}


using UnityEngine;

public class EntityFlag_Animator : EntityFlag_Toggle
{
	public enum AnimatorMode
	{
		Bool,
		Float,
		Trigger,
		Integer
	}

	public Animator TargetAnimator;

	public string ParamName = string.Empty;

	public AnimatorMode AnimationMode;

	public float FloatOnState;

	public float FloatOffState;

	public int IntegerOnState;

	public int IntegerOffState;
}


public enum AnimatorMode
{
	Bool,
	Float,
	Trigger,
	Integer
}


using System;
using UnityEngine;

public class EntityFlag_TOD : EntityComponent<BaseEntity>
{
	public BaseEntity.Flags desiredFlag;

	public bool onAtNight = true;

	public void Start()
	{
		((FacepunchBehaviour)this).Invoke((Action)Initialize, 1f);
	}

	public void Initialize()
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && !base.baseEntity.isClient)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)DoTimeCheck, 0f, 5f, 1f);
		}
	}

	public bool WantsOn()
	{
		if ((Object)(object)TOD_Sky.Instance == (Object)null)
		{
			return false;
		}
		bool isNight = TOD_Sky.Instance.IsNight;
		if (onAtNight == isNight)
		{
			return true;
		}
		return false;
	}

	private void DoTimeCheck()
	{
		bool num = base.baseEntity.HasFlag(desiredFlag);
		bool flag = WantsOn();
		if (num != flag)
		{
			base.baseEntity.SetFlag(desiredFlag, flag);
		}
	}
}


using UnityEngine;
using UnityEngine.Events;

public class EntityFlag_Toggle : EntityComponent<BaseEntity>, IOnPostNetworkUpdate, IOnSendNetworkUpdate, IPrefabPreProcess
{
	private enum FlagCheck
	{
		All,
		Any
	}

	public bool runClientside = true;

	[Tooltip("Server-side only works if the EntityFlag_Toggle is on the same GameObject as the Entity")]
	public bool runServerside = true;

	public BaseEntity.Flags flag;

	[SerializeField]
	[Tooltip("If multiple flags are defined in 'flag', should they all be set, or any?")]
	private FlagCheck flagCheck;

	[Tooltip("Specify any flags that must NOT be on for this toggle to be on")]
	[SerializeField]
	private BaseEntity.Flags notFlag;

	[SerializeField]
	private UnityEvent onFlagEnabled = new UnityEvent();

	[SerializeField]
	private UnityEvent onFlagDisabled = new UnityEvent();

	internal bool hasRunOnce;

	internal bool lastToggleOn;

	protected void OnDisable()
	{
		hasRunOnce = false;
		lastToggleOn = false;
	}

	public void DoUpdate(BaseEntity entity)
	{
		bool flag = ((flagCheck == FlagCheck.All) ? entity.HasFlag(this.flag) : entity.HasAny(this.flag));
		if (entity.HasAny(notFlag))
		{
			flag = false;
		}
		if (!hasRunOnce || flag != lastToggleOn)
		{
			hasRunOnce = true;
			lastToggleOn = flag;
			if (flag)
			{
				onFlagEnabled.Invoke();
			}
			else
			{
				onFlagDisabled.Invoke();
			}
			OnStateToggled(flag);
		}
	}

	protected virtual void OnStateToggled(bool state)
	{
	}

	public void OnPostNetworkUpdate(BaseEntity entity)
	{
		if (!((Object)(object)base.baseEntity != (Object)(object)entity) && runClientside)
		{
			DoUpdate(entity);
		}
	}

	public void OnSendNetworkUpdate(BaseEntity entity)
	{
		if (runServerside)
		{
			DoUpdate(entity);
		}
	}

	public void PreProcess(IPrefabProcessor process, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if ((!clientside || !runClientside) && (!serverside || !runServerside))
		{
			process.RemoveComponent((Component)(object)this);
		}
	}
}


private enum FlagCheck
{
	All,
	Any
}


using UnityEngine;

public class EntityFlag_ToggleNotify : EntityFlag_Toggle
{
	public bool UseEntityParent;

	protected override void OnStateToggled(bool state)
	{
		base.OnStateToggled(state);
		if (!UseEntityParent && (Object)(object)base.baseEntity != (Object)null && base.baseEntity is IFlagNotify flagNotify)
		{
			flagNotify.OnFlagToggled(state);
		}
		if (UseEntityParent && (Object)(object)base.baseEntity != (Object)null && (Object)(object)base.baseEntity.GetParentEntity() != (Object)null && base.baseEntity.GetParentEntity() is IFlagNotify flagNotify2)
		{
			flagNotify2.OnFlagToggled(state);
		}
	}
}


public interface IFlagNotify
{
	void OnFlagToggled(bool state);
}


using System;
using UnityEngine;

public class EntityItem_RotateWhenOn : EntityComponent<BaseEntity>
{
	[Serializable]
	public class State
	{
		public Vector3 rotation;

		public float initialDelay;

		public float timeToTake = 2f;

		public AnimationCurve animationCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
		{
			new Keyframe(0f, 0f),
			new Keyframe(1f, 1f)
		});

		public string effectOnStart = "";

		public string effectOnFinish = "";

		public SoundDefinition movementLoop;

		public float movementLoopFadeOutTime = 0.1f;

		public SoundDefinition startSound;

		public SoundDefinition stopSound;
	}

	public State on;

	public State off;

	internal bool currentlyOn;

	internal bool stateInitialized;

	public BaseEntity.Flags targetFlag = BaseEntity.Flags.On;
}


using System;
using UnityEngine;

[Serializable]
public class State
{
	public Vector3 rotation;

	public float initialDelay;

	public float timeToTake = 2f;

	public AnimationCurve animationCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 0f),
		new Keyframe(1f, 1f)
	});

	public string effectOnStart = "";

	public string effectOnFinish = "";

	public SoundDefinition movementLoop;

	public float movementLoopFadeOutTime = 0.1f;

	public SoundDefinition startSound;

	public SoundDefinition stopSound;
}


using System;
using UnityEngine;

public class EntityTimedDestroy : EntityComponent<BaseEntity>
{
	public float secondsTillDestroy = 1f;

	private void OnEnable()
	{
		((FacepunchBehaviour)this).Invoke((Action)TimedDestroy, secondsTillDestroy);
	}

	private void TimedDestroy()
	{
		if ((Object)(object)base.baseEntity != (Object)null)
		{
			base.baseEntity.Kill();
		}
		else
		{
			Debug.LogWarning((object)"EntityTimedDestroy failed, baseEntity was already null!");
		}
	}
}


using UnityEngine;

public class HeadDispenser : EntityComponent<BaseEntity>
{
	public ItemDefinition HeadDef;

	public GameObjectRef SourceEntity;

	private bool hasDispensed;

	public BaseEntity overrideEntity { get; set; }

	public void DispenseHead(HitInfo info, BaseCorpse corpse)
	{
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		if (hasDispensed || !(info.Weapon is BaseMelee baseMelee) || !baseMelee.gathering.ProduceHeadItem)
		{
			return;
		}
		if ((Object)(object)info.InitiatorPlayer != (Object)null)
		{
			Item item = ItemManager.CreateByItemID(HeadDef.itemid, 1, 0uL);
			item.SetItemOwnership(info.InitiatorPlayer, ItemOwnershipPhrases.Beheaded);
			HeadEntity associatedEntity = ItemModAssociatedEntity<HeadEntity>.GetAssociatedEntity(item);
			BaseEntity baseEntity = (((Object)(object)overrideEntity != (Object)null) ? overrideEntity : SourceEntity.GetEntity());
			overrideEntity = null;
			if ((Object)(object)associatedEntity != (Object)null && (Object)(object)baseEntity != (Object)null)
			{
				associatedEntity.SetupSourceId(baseEntity.prefabID);
				if (corpse is PlayerCorpse playerCorpse)
				{
					associatedEntity.SetupPlayerId(playerCorpse.playerName, playerCorpse.playerSteamID);
					associatedEntity.AssignClothing(playerCorpse.containers[1]);
				}
				else if (corpse is HorseCorpse horseCorpse)
				{
					associatedEntity.AssignHorseBreed(horseCorpse.breedIndex);
				}
			}
			if (info.InitiatorPlayer.inventory.GiveItem(item))
			{
				info.InitiatorPlayer.Command("note.inv", HeadDef.itemid, 1);
			}
			else
			{
				item.DropAndTossUpwards(info.HitPositionWorld);
			}
		}
		hasDispensed = true;
	}
}


using UnityEngine;

public class HideIfOwnerFirstPerson : EntityComponent<BaseEntity>, IClientComponent, IViewModeChanged
{
	public GameObject[] disableGameObjects;

	public bool worldModelEffect;
}


using UnityEngine;

public class HumanBodyResourceDispenser : ResourceDispenser
{
	public override bool OverrideOwnership(Item item, AttackEntity weapon)
	{
		if (item.info.shortname == "skull.human")
		{
			PlayerCorpse component = ((Component)this).GetComponent<PlayerCorpse>();
			if (Object.op_Implicit((Object)(object)component))
			{
				item.name = CreateSkullName(component.playerName);
				item.streamerName = CreateSkullName(component.streamerName);
				return true;
			}
		}
		return false;
	}

	public static string CreateSkullName(string playerName)
	{
		return "Skull of \"" + playerName + "\"";
	}
}


using UnityEngine;

public class LerpBetweenPointsBool : MonoBehaviour, IClientComponent
{
	public Vector3 offsetPosLocal;

	public float speed;

	public bool UseAsOffset;

	public void SetAtOffset(bool should)
	{
	}
}


using UnityEngine;

public class LootDistanceOverride : MonoBehaviour
{
	public float amount = 2.1f;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class ResourceDispenser : EntityComponent<BaseEntity>, IServerComponent
{
	public enum GatherType
	{
		Tree,
		Ore,
		Flesh,
		UNSET,
		LAST
	}

	[Serializable]
	public class GatherPropertyEntry
	{
		public float gatherDamage;

		public float destroyFraction;

		public float conditionLost;
	}

	[Serializable]
	public class GatherProperties
	{
		public GatherPropertyEntry Tree;

		public GatherPropertyEntry Ore;

		public GatherPropertyEntry Flesh;

		public bool ProduceHeadItem;

		public float GetProficiency()
		{
			float num = 0f;
			for (int i = 0; i < 3; i++)
			{
				GatherPropertyEntry fromIndex = GetFromIndex(i);
				float num2 = fromIndex.gatherDamage * fromIndex.destroyFraction;
				if (num2 > 0f)
				{
					num += fromIndex.gatherDamage / num2;
				}
			}
			return num;
		}

		public bool Any()
		{
			for (int i = 0; i < 3; i++)
			{
				GatherPropertyEntry fromIndex = GetFromIndex(i);
				if (fromIndex.gatherDamage > 0f || fromIndex.conditionLost > 0f)
				{
					return true;
				}
			}
			return false;
		}

		public GatherPropertyEntry GetFromIndex(int index)
		{
			return GetFromIndex((GatherType)index);
		}

		public GatherPropertyEntry GetFromIndex(GatherType index)
		{
			return index switch
			{
				GatherType.Tree => Tree, 
				GatherType.Ore => Ore, 
				GatherType.Flesh => Flesh, 
				_ => null, 
			};
		}
	}

	public Phrase OwnershipPhrase;

	public GatherType gatherType = GatherType.UNSET;

	public List<ItemAmount> containedItems;

	public float maxDestroyFractionForFinishBonus = 0.2f;

	public List<ItemAmount> finishBonus;

	public bool forceFullFinishBonus;

	public float fractionRemaining = 1f;

	private float categoriesRemaining;

	private float startingItemCounts;

	private static Dictionary<GatherType, HashSet<int>> cachedResourceItemTypes;

	public void Start()
	{
		Initialize();
	}

	public void Initialize()
	{
		CacheResourceTypeItems();
		UpdateFraction();
		UpdateRemainingCategories();
		CountAllItems();
	}

	private void CacheResourceTypeItems()
	{
		if (cachedResourceItemTypes == null)
		{
			cachedResourceItemTypes = new Dictionary<GatherType, HashSet<int>>();
			HashSet<int> hashSet = new HashSet<int>();
			hashSet.Add(ItemManager.FindItemDefinition("wood").itemid);
			cachedResourceItemTypes.Add(GatherType.Tree, hashSet);
			HashSet<int> hashSet2 = new HashSet<int>();
			hashSet2.Add(ItemManager.FindItemDefinition("stones").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("sulfur.ore").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("metal.ore").itemid);
			hashSet2.Add(ItemManager.FindItemDefinition("hq.metal.ore").itemid);
			cachedResourceItemTypes.Add(GatherType.Ore, hashSet2);
		}
	}

	public void DoGather(HitInfo info, BaseCorpse corpse = null)
	{
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0230: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		if (!base.baseEntity.isServer || !info.CanGather || info.DidGather)
		{
			return;
		}
		if (gatherType == GatherType.UNSET)
		{
			Debug.LogWarning((object)("Object :" + ((Object)((Component)this).gameObject).name + ": has unset gathertype!"));
			return;
		}
		float num = 0f;
		float num2 = 0f;
		float num3 = (((Object)(object)info.InitiatorPlayer != (Object)null && info.InitiatorPlayer.HasPlayerFlag(BasePlayer.PlayerFlags.IsInTutorial)) ? 3f : 1f);
		BaseMelee baseMelee = (((Object)(object)info.Weapon == (Object)null) ? null : (info.Weapon as BaseMelee));
		if ((Object)(object)baseMelee != (Object)null)
		{
			GatherPropertyEntry gatherInfoFromIndex = baseMelee.GetGatherInfoFromIndex(gatherType);
			num = gatherInfoFromIndex.gatherDamage * info.gatherScale * num3;
			num2 = gatherInfoFromIndex.destroyFraction;
			if (num == 0f)
			{
				return;
			}
			baseMelee.SendPunch(new Vector3(Random.Range(0.5f, 1f), Random.Range(-0.25f, -0.5f), 0f) * -30f * (gatherInfoFromIndex.conditionLost / 6f), 0.05f);
			baseMelee.LoseCondition(gatherInfoFromIndex.conditionLost);
			if (!baseMelee.IsValid() || baseMelee.IsBroken())
			{
				return;
			}
			info.DidGather = true;
		}
		else
		{
			num = info.damageTypes.Total();
			num2 = 0.5f;
		}
		float num4 = fractionRemaining;
		GiveResources(info.InitiatorPlayer, num, num2, info.Weapon);
		UpdateFraction();
		float num5 = 0f;
		if (fractionRemaining <= 0f)
		{
			num5 = base.baseEntity.MaxHealth();
			if (info.DidGather && num2 < maxDestroyFractionForFinishBonus)
			{
				AssignFinishBonus(info.InitiatorPlayer, 1f - num2, info.Weapon);
			}
			HeadDispenser headDispenser = default(HeadDispenser);
			if (((Component)this).gameObject.TryGetComponent<HeadDispenser>(ref headDispenser))
			{
				headDispenser.DispenseHead(info, corpse);
			}
		}
		else
		{
			num5 = (num4 - fractionRemaining) * base.baseEntity.MaxHealth();
		}
		HitInfo hitInfo = new HitInfo(info.Initiator, base.baseEntity, DamageType.Generic, num5, ((Component)this).transform.position);
		hitInfo.gatherScale = 0f;
		hitInfo.PointStart = info.PointStart;
		hitInfo.PointEnd = info.PointEnd;
		hitInfo.WeaponPrefab = info.WeaponPrefab;
		hitInfo.Weapon = info.Weapon;
		base.baseEntity.OnAttacked(hitInfo);
	}

	public void AssignFinishBonus(BasePlayer player, float fraction, AttackEntity weapon)
	{
		if (forceFullFinishBonus)
		{
			fraction = 1f;
		}
		((Component)this).SendMessage("FinishBonusAssigned", (SendMessageOptions)1);
		if (fraction <= 0f || finishBonus == null)
		{
			return;
		}
		foreach (ItemAmount finishBonu in finishBonus)
		{
			int num = Mathf.CeilToInt((float)(int)finishBonu.amount * Mathf.Clamp01(fraction));
			int num2 = CalculateGatherBonus(player, finishBonu, num);
			Item item = ItemManager.Create(finishBonu.itemDef, num + num2, 0uL);
			if (item != null)
			{
				object obj = Interface.CallHook("OnDispenserBonus", (object)this, (object)player, (object)item);
				if (obj is Item)
				{
					item = (Item)obj;
				}
				ApplyItemOwnership(player, item);
				Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);
				Interface.CallHook("OnDispenserBonusReceived", (object)this, (object)player, (object)item);
				player.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

	public void OnAttacked(HitInfo info)
	{
		DoGather(info);
	}

	private void GiveResources(BasePlayer entity, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		//IL_0252: Unknown result type (might be due to invalid IL or missing references)
		if (!entity.IsValid() || gatherDamage <= 0f)
		{
			return;
		}
		ItemAmount itemAmount = null;
		int num = containedItems.Count;
		int num2 = Random.Range(0, containedItems.Count);
		while (num > 0)
		{
			if (num2 >= containedItems.Count)
			{
				num2 = 0;
			}
			if (containedItems[num2].amount > 0f)
			{
				itemAmount = containedItems[num2];
				break;
			}
			num2++;
			num--;
		}
		if (itemAmount == null)
		{
			return;
		}
		GiveResourceFromItem(entity, itemAmount, gatherDamage, destroyFraction, attackWeapon);
		UpdateVars();
		if (Object.op_Implicit((Object)(object)entity))
		{
			Debug.Assert(attackWeapon.GetItem() != null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " has no Item");
			Debug.Assert(((ItemId)(ref attackWeapon.ownerItemUID)).IsValid, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerItemUID is 0");
			Debug.Assert((Object)(object)attackWeapon.GetParentEntity() != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is null");
			Debug.Assert(attackWeapon.GetParentEntity().IsValid(), "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not valid");
			Debug.Assert((Object)(object)attackWeapon.GetParentEntity().ToPlayer() != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not a player");
			Debug.Assert(!attackWeapon.GetParentEntity().ToPlayer().IsDead(), "Attack Weapon " + ((object)attackWeapon)?.ToString() + " GetParentEntity is not valid");
			BasePlayer ownerPlayer = attackWeapon.GetOwnerPlayer();
			Debug.Assert((Object)(object)ownerPlayer != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer is null");
			Debug.Assert((Object)(object)ownerPlayer == (Object)(object)entity, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer is not player");
			if ((Object)(object)ownerPlayer != (Object)null)
			{
				Debug.Assert((Object)(object)ownerPlayer.inventory != (Object)null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " ownerPlayer inventory is null");
				Debug.Assert(ownerPlayer.inventory.FindItemByUID(attackWeapon.ownerItemUID) != null, "Attack Weapon " + ((object)attackWeapon)?.ToString() + " FindItemByUID is null");
			}
		}
	}

	public void DestroyFraction(float fraction)
	{
		foreach (ItemAmount containedItem in containedItems)
		{
			if (containedItem.amount > 0f)
			{
				containedItem.amount -= fraction / categoriesRemaining;
			}
		}
		UpdateVars();
	}

	private void GiveResourceFromItem(BasePlayer entity, ItemAmount itemAmt, float gatherDamage, float destroyFraction, AttackEntity attackWeapon)
	{
		if (itemAmt.amount == 0f)
		{
			return;
		}
		float num = Mathf.Min(gatherDamage, base.baseEntity.Health()) / base.baseEntity.MaxHealth();
		float num2 = itemAmt.startAmount / startingItemCounts;
		float num3 = Mathf.Clamp(itemAmt.startAmount * num / num2, 0f, itemAmt.amount);
		num3 = Mathf.Round(num3);
		float num4 = num3 * destroyFraction * 2f;
		if (itemAmt.amount <= num3 + num4)
		{
			float num5 = (num3 + num4) / itemAmt.amount;
			num3 /= num5;
			num4 /= num5;
		}
		itemAmt.amount -= Mathf.Floor(num3);
		itemAmt.amount -= Mathf.Floor(num4);
		if (num3 < 1f)
		{
			num3 = ((Random.Range(0f, 1f) <= num3) ? 1f : 0f);
			itemAmt.amount = 0f;
		}
		if (itemAmt.amount < 0f)
		{
			itemAmt.amount = 0f;
		}
		if (num3 >= 1f)
		{
			int num6 = CalculateGatherBonus(entity, itemAmt, num3);
			int iAmount = Mathf.FloorToInt(num3) + num6;
			Item item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);
			if (Interface.CallHook("OnDispenserGather", (object)this, (object)entity, (object)item) == null && item != null)
			{
				ApplyItemOwnership(entity, item);
				OverrideOwnership(item, attackWeapon);
				Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);
				Interface.CallHook("OnDispenserGathered", (object)this, (object)entity, (object)item);
				entity.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
			}
		}
	}

	private void ApplyItemOwnership(BasePlayer player, Item item)
	{
		if (OwnershipPhrase != null && !string.IsNullOrEmpty(OwnershipPhrase.token))
		{
			item.SetItemOwnership(player, OwnershipPhrase.token);
		}
		else
		{
			item.SetItemOwnership(player, ItemOwnershipPhrases.GatheredPhrase);
		}
	}

	private int CalculateGatherBonus(BaseEntity entity, ItemAmount item, float amountToGive)
	{
		if ((Object)(object)entity == (Object)null)
		{
			return 0;
		}
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null)
		{
			return 0;
		}
		if ((Object)(object)basePlayer.modifiers == (Object)null)
		{
			return 0;
		}
		amountToGive = Mathf.FloorToInt(amountToGive);
		float num = 1f;
		Modifier.ModifierType type;
		switch (gatherType)
		{
		case GatherType.Tree:
			type = Modifier.ModifierType.Wood_Yield;
			break;
		case GatherType.Ore:
			type = Modifier.ModifierType.Ore_Yield;
			break;
		case GatherType.Flesh:
			type = Modifier.ModifierType.Harvesting;
			break;
		default:
			return 0;
		}
		if (!IsProducedItemOfGatherType(item))
		{
			return 0;
		}
		num += basePlayer.modifiers.GetValue(type);
		float variableValue = basePlayer.modifiers.GetVariableValue(type, 0f);
		float num2 = ((num > 1f) ? Mathf.Max(amountToGive * num - amountToGive, 0f) : 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(type, variableValue);
		return num3;
	}

	private bool IsProducedItemOfGatherType(ItemAmount item)
	{
		if (gatherType == GatherType.Tree)
		{
			return cachedResourceItemTypes[GatherType.Tree].Contains(item.itemid);
		}
		if (gatherType == GatherType.Ore)
		{
			return cachedResourceItemTypes[GatherType.Ore].Contains(item.itemid);
		}
		if (gatherType == GatherType.Flesh)
		{
			return item.startAmount > 1f;
		}
		return false;
	}

	public virtual bool OverrideOwnership(Item item, AttackEntity weapon)
	{
		return false;
	}

	private void UpdateVars()
	{
		UpdateFraction();
		UpdateRemainingCategories();
	}

	public void UpdateRemainingCategories()
	{
		int num = 0;
		foreach (ItemAmount containedItem in containedItems)
		{
			if (containedItem.amount > 0f)
			{
				num++;
			}
		}
		categoriesRemaining = num;
	}

	public void CountAllItems()
	{
		startingItemCounts = containedItems.Sum((ItemAmount x) => x.startAmount);
	}

	private void UpdateFraction()
	{
		float num = containedItems.Sum((ItemAmount x) => x.startAmount);
		float num2 = containedItems.Sum((ItemAmount x) => x.amount);
		if (num == 0f)
		{
			fractionRemaining = 0f;
		}
		else
		{
			fractionRemaining = num2 / num;
		}
	}

	public bool HasItemToDispense(ItemDefinition def)
	{
		if ((Object)(object)def == (Object)null)
		{
			return false;
		}
		foreach (ItemAmount containedItem in containedItems)
		{
			if ((Object)(object)containedItem.itemDef == (Object)(object)def && containedItem.amount > 0f)
			{
				return true;
			}
		}
		return false;
	}
}


public enum GatherType
{
	Tree,
	Ore,
	Flesh,
	UNSET,
	LAST
}


using System;

[Serializable]
public class GatherPropertyEntry
{
	public float gatherDamage;

	public float destroyFraction;

	public float conditionLost;
}


using System;

[Serializable]
public class GatherProperties
{
	public GatherPropertyEntry Tree;

	public GatherPropertyEntry Ore;

	public GatherPropertyEntry Flesh;

	public bool ProduceHeadItem;

	public float GetProficiency()
	{
		float num = 0f;
		for (int i = 0; i < 3; i++)
		{
			GatherPropertyEntry fromIndex = GetFromIndex(i);
			float num2 = fromIndex.gatherDamage * fromIndex.destroyFraction;
			if (num2 > 0f)
			{
				num += fromIndex.gatherDamage / num2;
			}
		}
		return num;
	}

	public bool Any()
	{
		for (int i = 0; i < 3; i++)
		{
			GatherPropertyEntry fromIndex = GetFromIndex(i);
			if (fromIndex.gatherDamage > 0f || fromIndex.conditionLost > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public GatherPropertyEntry GetFromIndex(int index)
	{
		return GetFromIndex((GatherType)index);
	}

	public GatherPropertyEntry GetFromIndex(GatherType index)
	{
		return index switch
		{
			GatherType.Tree => Tree, 
			GatherType.Ore => Ore, 
			GatherType.Flesh => Flesh, 
			_ => null, 
		};
	}
}


using System;
using Rust;
using Unity.AI.Navigation;
using UnityEngine;
using UnityEngine.AI;

public class Barricade : DecayEntity
{
	public float reflectDamage = 5f;

	public GameObjectRef reflectEffect;

	public bool canNpcSmash = true;

	public NavMeshModifierVolume NavMeshVolumeAnimals;

	public NavMeshModifierVolume NavMeshVolumeHumanoids;

	[NonSerialized]
	public NPCBarricadeTriggerBox NpcTriggerBox;

	private static int nonWalkableArea = -1;

	private static int animalAgentTypeId = -1;

	private static int humanoidAgentTypeId = -1;

	public override void ServerInit()
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (nonWalkableArea < 0)
		{
			nonWalkableArea = NavMesh.GetAreaFromName("Not Walkable");
		}
		NavMeshBuildSettings settingsByIndex;
		if (animalAgentTypeId < 0)
		{
			settingsByIndex = NavMesh.GetSettingsByIndex(1);
			animalAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
		}
		if ((Object)(object)NavMeshVolumeAnimals == (Object)null)
		{
			NavMeshVolumeAnimals = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
			NavMeshVolumeAnimals.area = nonWalkableArea;
			NavMeshVolumeAnimals.AddAgentType(animalAgentTypeId);
			NavMeshVolumeAnimals.center = Vector3.zero;
			NavMeshVolumeAnimals.size = Vector3.one;
		}
		if (!canNpcSmash)
		{
			if (humanoidAgentTypeId < 0)
			{
				settingsByIndex = NavMesh.GetSettingsByIndex(0);
				humanoidAgentTypeId = ((NavMeshBuildSettings)(ref settingsByIndex)).agentTypeID;
			}
			if ((Object)(object)NavMeshVolumeHumanoids == (Object)null)
			{
				NavMeshVolumeHumanoids = ((Component)this).gameObject.AddComponent<NavMeshModifierVolume>();
				NavMeshVolumeHumanoids.area = nonWalkableArea;
				NavMeshVolumeHumanoids.AddAgentType(humanoidAgentTypeId);
				NavMeshVolumeHumanoids.center = Vector3.zero;
				NavMeshVolumeHumanoids.size = Vector3.one;
			}
		}
		else if ((Object)(object)NpcTriggerBox == (Object)null)
		{
			NpcTriggerBox = new GameObject("NpcTriggerBox").AddComponent<NPCBarricadeTriggerBox>();
			NpcTriggerBox.Setup(this);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && info.WeaponPrefab is BaseMelee && !info.IsProjectile())
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer) && reflectDamage > 0f)
			{
				basePlayer.Hurt(reflectDamage * Random.Range(0.75f, 1.25f), DamageType.Stab, this);
				if (reflectEffect.isValid)
				{
					Effect.server.Run(reflectEffect.resourcePath, basePlayer, StringPool.closest, ((Component)this).transform.position, Vector3.up);
				}
			}
		}
		base.OnAttacked(info);
	}
}


public class BaseFuelLightSource : BaseOven
{
}


public class BaseLadder : BaseCombatEntity
{
	public override bool ShouldBlockProjectiles()
	{
		return false;
	}
}


using UnityEngine;

public class BoxStorage : StorageContainer
{
	public Hopper.MountType HopperMountType;

	public override Vector3 GetDropPosition()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		return ClosestPoint(base.GetDropPosition() + base.LastAttackedDir * 10f);
	}

	public override bool SupportsChildDeployables()
	{
		return true;
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (children.Count == 0)
		{
			return base.CanPickup(player);
		}
		return false;
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class ElectricOven : BaseOven
{
	public GameObjectRef IoEntity;

	public Transform IoEntityAnchor;

	public EntityRef<IOEntity> spawnedIo;

	public override bool CanRunWithNoFuel
	{
		get
		{
			if (spawnedIo.IsValid(serverside: true))
			{
				return spawnedIo.Get(serverside: true).IsPowered();
			}
			return false;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnIOEnt();
		}
	}

	public void SpawnIOEnt()
	{
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		if (IoEntity.isValid && (Object)(object)IoEntityAnchor != (Object)null)
		{
			IOEntity iOEntity = GameManager.server.CreateEntity(IoEntity.resourcePath, IoEntityAnchor.position, IoEntityAnchor.rotation) as IOEntity;
			iOEntity.SetParent(this, worldPositionStays: true);
			spawnedIo.Set(iOEntity);
			iOEntity.Spawn();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.msg.simpleUID == null)
		{
			info.msg.simpleUID = Pool.Get<SimpleUID>();
		}
		info.msg.simpleUID.uid = spawnedIo.uid;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			spawnedIo.uid = info.msg.simpleUID.uid;
		}
	}

	public override void OvenFull()
	{
		((FacepunchBehaviour)this).Invoke((Action)PauseCooking, 0f);
	}

	private void PauseCooking()
	{
		UpdateAttachmentTemperature();
		if (base.inventory != null)
		{
			base.inventory.temperature = 15f;
			foreach (Item item in base.inventory.itemList)
			{
				if (item.HasFlag(Item.Flag.OnFire))
				{
					item.SetFlag(Item.Flag.OnFire, b: false);
					item.MarkDirty();
				}
				if (item.HasFlag(Item.Flag.Cooking))
				{
					item.SetFlag(Item.Flag.Cooking, b: false);
					item.MarkDirty();
				}
			}
		}
		SetFlag(Flags.Reserved8, b: true);
	}

	public override void OnItemAddedOrRemoved(Item item, bool bAdded)
	{
		base.OnItemAddedOrRemoved(item, bAdded);
		if (item != null && !bAdded && HasFlag(Flags.Reserved8))
		{
			SetFlag(Flags.Reserved8, b: false);
		}
	}

	protected override bool CanPickupOven()
	{
		return children.Count == 1;
	}
}


public interface IImageReceiver
{
}


using UnityEngine;

public class ItemModSculpture : ItemModAssociatedEntity<AssociatedSculptureStorage>
{
	protected override bool AllowNullParenting => true;

	protected override bool ShouldAutoCreateEntity => false;

	public void OnSculpturePickUp(NetworkableId id, uint crc, Item item)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		AssociatedSculptureStorage associatedSculptureStorage = CreateAssociatedEntity(item);
		if ((Object)(object)associatedSculptureStorage != (Object)null)
		{
			associatedSculptureStorage.InitFromSculpture(crc, id);
		}
	}
}


using UnityEngine;

public class ItemModSign : ItemModAssociatedEntity<SignContent>
{
	protected override bool AllowNullParenting => true;

	protected override bool ShouldAutoCreateEntity => false;

	public void OnSignPickedUp(ISignage s, IUGCBrowserEntity ugc, Item toItem)
	{
		SignContent signContent = CreateAssociatedEntity(toItem);
		if ((Object)(object)signContent != (Object)null)
		{
			signContent.CopyInfoFromSign(s, ugc);
		}
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class PercentFullStorageContainer : StorageContainer
{
	private float prevPercentFull = -1f;

	public bool IsFull()
	{
		return GetPercentFull() == 1f;
	}

	public bool IsEmpty()
	{
		return GetPercentFull() == 0f;
	}

	protected virtual void OnPercentFullChanged(float newPercentFull)
	{
	}

	public float GetPercentFull()
	{
		if (base.isServer)
		{
			float num = 0f;
			if (base.inventory != null)
			{
				foreach (Item item in base.inventory.itemList)
				{
					num += (float)item.amount / (float)item.MaxStackable();
				}
				num /= (float)base.inventory.capacity;
			}
			return num;
		}
		return 0f;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		_ = info.msg.simpleInt;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.simpleInt = Pool.Get<SimpleInt>();
		info.msg.simpleInt.value = Mathf.CeilToInt(GetPercentFull() * 100f);
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		float percentFull = GetPercentFull();
		if (percentFull != prevPercentFull)
		{
			OnPercentFullChanged(percentFull);
			SendNetworkUpdate();
			prevPercentFull = percentFull;
		}
	}
}


using System;
using UnityEngine;

public class PoweredWaterPurifier : WaterPurifier
{
	public float ConvertInterval = 5f;

	public int PowerDrain = 5;

	public Material PoweredMaterial;

	public Material UnpoweredMaterial;

	public MeshRenderer TargetRenderer;

	public override void ResetState()
	{
		base.ResetState();
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.isClient)
		{
			return base.CanPickup(player);
		}
		if (base.CanPickup(player) && !HasDirtyWater() && (Object)(object)waterStorage != (Object)null)
		{
			if (waterStorage.inventory != null)
			{
				return waterStorage.inventory.itemList.Count == 0;
			}
			return true;
		}
		return false;
	}

	protected override void SpawnStorageEnt(bool load)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		if (load)
		{
			foreach (BaseEntity child in children)
			{
				if (child is LiquidContainer liquidContainer)
				{
					waterStorage = liquidContainer;
				}
			}
		}
		if ((Object)(object)waterStorage != (Object)null)
		{
			waterStorage.SetConnectedTo(this);
			return;
		}
		waterStorage = GameManager.server.CreateEntity(storagePrefab.resourcePath, storagePrefabAnchor.position, storagePrefabAnchor.rotation) as LiquidContainer;
		waterStorage.SetParent(this, worldPositionStays: true);
		waterStorage.Spawn();
		waterStorage.SetConnectedTo(this);
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (HasLiquidItem())
		{
			if (HasFlag(Flags.Reserved8) && !((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)ConvertWater, ConvertInterval, ConvertInterval, ConvertInterval * 0.1f);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ConvertWater);
		}
	}

	private void ConvertWater()
	{
		if (HasDirtyWater())
		{
			ConvertWater(ConvertInterval);
		}
	}

	public override int ConsumptionAmount()
	{
		return PowerDrain;
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!base.isServer)
		{
			return;
		}
		if (old.HasFlag(Flags.Reserved8) != next.HasFlag(Flags.Reserved8))
		{
			if (next.HasFlag(Flags.Reserved8))
			{
				if (!((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
				{
					((FacepunchBehaviour)this).InvokeRandomized((Action)ConvertWater, ConvertInterval, ConvertInterval, ConvertInterval * 0.1f);
				}
			}
			else if (((FacepunchBehaviour)this).IsInvoking((Action)ConvertWater))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)ConvertWater);
			}
		}
		if ((Object)(object)waterStorage != (Object)null)
		{
			waterStorage.SetFlag(Flags.Reserved8, HasFlag(Flags.Reserved8));
		}
	}
}


using UnityEngine;

public interface ISignage
{
	Vector2i TextureSize { get; }

	int TextureCount { get; }

	NetworkableId NetworkID { get; }

	FileStorage.Type FileType { get; }

	bool CanUpdateSign(BasePlayer player);

	float Distance(Vector3 position);

	uint[] GetTextureCRCs();

	void SetTextureCRCs(uint[] crcs);
}


using System.Collections.Generic;

public interface IUGCBrowserEntity
{
	uint[] GetContentCRCs { get; }

	UGCType ContentType { get; }

	List<ulong> EditingHistory { get; }

	BaseNetworkable UgcEntity { get; }

	string ContentString { get; }

	void ClearContent();
}


public enum UGCType
{
	ImageJpg,
	ImagePng,
	AudioOgg,
	Sculpt,
	PatternBoomer,
	VendingMachine
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;

public class SignContent : ImageStorageEntity, IUGCBrowserEntity
{
	public uint[] textureIDs = new uint[1];

	private List<ulong> editHistory = new List<ulong>();

	protected override uint CrcToLoad => textureIDs[0];

	protected override FileStorage.Type StorageType => FileStorage.Type.png;

	public UGCType ContentType => UGCType.ImagePng;

	public uint[] GetContentCRCs => textureIDs;

	public FileStorage.Type FileType => StorageType;

	public List<ulong> EditingHistory => editHistory;

	public BaseNetworkable UgcEntity => this;

	public string ContentString => string.Empty;

	public void CopyInfoFromSign(ISignage s, IUGCBrowserEntity b)
	{
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		uint[] textureCRCs = s.GetTextureCRCs();
		textureIDs = new uint[textureCRCs.Length];
		textureCRCs.CopyTo(textureIDs, 0);
		editHistory.Clear();
		foreach (ulong item in b.EditingHistory)
		{
			editHistory.Add(item);
		}
		FileStorage.server.ReassignEntityId(s.NetworkID, net.ID);
	}

	public void CopyInfoToSign(ISignage s, IUGCBrowserEntity b)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		FileStorage.server.ReassignEntityId(net.ID, s.NetworkID);
		s.SetTextureCRCs(textureIDs);
		b.EditingHistory.Clear();
		foreach (ulong item in editHistory)
		{
			b.EditingHistory.Add(item);
		}
		Interface.CallHook("OnSignContentCopied", (object)this, (object)s, (object)b);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.paintableSign == null)
		{
			info.msg.paintableSign = Pool.Get<PaintableSign>();
		}
		info.msg.paintableSign.crcs = Pool.Get<List<uint>>();
		uint[] array = textureIDs;
		foreach (uint item in array)
		{
			info.msg.paintableSign.crcs.Add(item);
		}
	}

	internal override void DoServerDestroy()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		FileStorage.server.RemoveAllByEntity(net.ID);
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.paintableSign != null)
		{
			textureIDs = new uint[info.msg.paintableSign.crcs.Count];
			for (int i = 0; i < info.msg.paintableSign.crcs.Count; i++)
			{
				textureIDs[i] = info.msg.paintableSign.crcs[i];
			}
		}
	}

	public void ClearContent()
	{
		Kill();
	}
}


using UnityEngine;

public class VisualFoodModel : MonoBehaviour, IClientComponent
{
	public MeshRenderer[] meshRenderers;

	public Animator animator;

	public bool stopEffectOnEnd;

	public ParticleSystemContainer particleContainer;

	public bool lerpScale;

	public Vector3 startScale;

	public Vector3 endScale;

	public AnimationCurve riseCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve colorCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public SoundDefinition cookingSound;
}


using System;

public class VisualFoodSettings : PrefabAttribute, IClientComponent
{
	protected override Type GetIndexedType()
	{
		return typeof(VisualFoodSettings);
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class WaterCatcher : LiquidContainer
{
	[Header("Water Catcher")]
	public ItemDefinition itemToCreate;

	public WaterCatcherCollectRate collectionRates;

	public float maxItemToCreate = 10f;

	[Header("Outside Test")]
	public Vector3 rainTestPosition = new Vector3(0f, 1f, 0f);

	public float rainTestSize = 1f;

	public const float collectInterval = 60f;

	public override void ServerInit()
	{
		base.ServerInit();
		AddResource(1);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CollectWater, 60f, 60f, 6f);
	}

	public void CollectWater()
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFull() && Interface.CallHook("OnWaterCollect", (object)this) == null)
		{
			float baseRate = collectionRates.baseRate;
			baseRate += Climate.GetFog(((Component)this).transform.position) * collectionRates.fogRate;
			if (TestIsOutside(((Component)this).transform, rainTestPosition, rainTestSize, 256f))
			{
				baseRate += Climate.GetRain(((Component)this).transform.position) * collectionRates.rainRate;
				baseRate += Climate.GetSnow(((Component)this).transform.position) * collectionRates.snowRate;
			}
			AddResource(Mathf.CeilToInt(maxItemToCreate * baseRate));
		}
	}

	public bool IsFull()
	{
		if (base.inventory.itemList.Count == 0)
		{
			return false;
		}
		if (base.inventory.itemList[0].amount < base.inventory.maxStackSize)
		{
			return false;
		}
		return true;
	}

	public static bool TestIsOutside(Transform t, Vector3 testPositionOffset, float testSize, float testDistance)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 localToWorldMatrix = t.localToWorldMatrix;
		return !Physics.SphereCast(new Ray(((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(testPositionOffset), Vector3.up), testSize, testDistance, 161546513);
	}

	public void AddResource(int iAmount)
	{
		if (outputs.Length != 0)
		{
			IOEntity iOEntity = CheckPushLiquid(outputs[0].connectedTo.Get(), iAmount, this, IOEntity.backtracking * 2);
			if ((Object)(object)iOEntity != (Object)null && iOEntity is LiquidContainer liquidContainer)
			{
				liquidContainer.inventory.AddItem(itemToCreate, iAmount, 0uL);
				return;
			}
		}
		base.inventory.AddItem(itemToCreate, iAmount, 0uL);
		UpdateOnFlag();
	}

	private IOEntity CheckPushLiquid(IOEntity connected, int amount, IOEntity fromSource, int depth)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if (depth <= 0 || (Object)(object)itemToCreate == (Object)null)
		{
			return null;
		}
		if ((Object)(object)connected == (Object)null)
		{
			return null;
		}
		Vector3 worldHandlePosition = Vector3.zero;
		IOEntity iOEntity = connected.FindGravitySource(ref worldHandlePosition, IOEntity.backtracking, ignoreSelf: true);
		if ((Object)(object)iOEntity != (Object)null && !connected.AllowLiquidPassthrough(iOEntity, worldHandlePosition))
		{
			return null;
		}
		if ((Object)(object)connected == (Object)(object)this || ConsiderConnectedTo(connected))
		{
			return null;
		}
		if (connected.prefabID == 2150367216u)
		{
			return null;
		}
		IOSlot[] array = connected.outputs;
		foreach (IOSlot iOSlot in array)
		{
			IOEntity iOEntity2 = iOSlot.connectedTo.Get();
			Vector3 sourceWorldPosition = ((Component)connected).transform.TransformPoint(iOSlot.handlePosition);
			if ((Object)(object)iOEntity2 != (Object)null && (Object)(object)iOEntity2 != (Object)(object)fromSource && iOEntity2.AllowLiquidPassthrough(connected, sourceWorldPosition))
			{
				IOEntity iOEntity3 = CheckPushLiquid(iOEntity2, amount, fromSource, depth - 1);
				if ((Object)(object)iOEntity3 != (Object)null)
				{
					return iOEntity3;
				}
			}
		}
		if (connected is LiquidContainer liquidContainer && liquidContainer.inventory.GetAmount(itemToCreate.itemid, onlyUsableAmounts: false) + amount < liquidContainer.maxStackSize)
		{
			return connected;
		}
		return null;
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Water Catcher Rates", fileName = "Water Catcher Collection Rates.asset")]
public class WaterCatcherCollectRate : ScriptableObject
{
	[Tooltip("Base collection rate that happens at all times")]
	public float baseRate = 0.25f;

	[Tooltip("Additional rate during rain")]
	public float rainRate = 1f;

	[Tooltip("Additional rate during snow")]
	public float snowRate = 0.5f;

	[Tooltip("Additional rate during fog. Fog water is also collected indoors")]
	public float fogRate = 2f;
}


using System;
using Oxide.Core;
using UnityEngine;

public class WaterPump : LiquidContainer
{
	public Transform WaterResourceLocation;

	public float PumpInterval = 20f;

	public int AmountPerPump = 30;

	public int PowerConsumption = 5;

	public override bool IsGravitySource => true;

	public override int ConsumptionAmount()
	{
		return PowerConsumption;
	}

	public void CreateWater()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		if (!IsFull())
		{
			ItemDefinition itemDefinition = WaterResource.SV_GetAtPoint(WaterResourceLocation.position);
			if ((Object)(object)itemDefinition != (Object)null && Interface.CallHook("OnWaterCollect", (object)this, (object)itemDefinition) == null)
			{
				base.inventory.AddItem(itemDefinition, AmountPerPump, 0uL);
				UpdateOnFlag();
			}
		}
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		bool flag = next.HasFlag(Flags.Reserved8);
		if (!base.isServer || old.HasFlag(Flags.Reserved8) == flag)
		{
			return;
		}
		if (flag)
		{
			if (!((FacepunchBehaviour)this).IsInvoking((Action)CreateWater))
			{
				((FacepunchBehaviour)this).InvokeRandomized((Action)CreateWater, PumpInterval, PumpInterval, PumpInterval * 0.1f);
			}
		}
		else if (((FacepunchBehaviour)this).IsInvoking((Action)CreateWater))
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)CreateWater);
		}
	}

	public override int GetPassthroughAmount(int outputSlot = 0)
	{
		return Mathf.Clamp(GetLiquidCount(), 0, maxOutputFlow);
	}

	public bool IsFull()
	{
		if (base.inventory.itemList.Count == 0)
		{
			return false;
		}
		if (base.inventory.itemList[0].amount < base.inventory.maxStackSize)
		{
			return false;
		}
		return true;
	}
}


using System;
using Oxide.Core;
using Rust;
using UnityEngine;

public class WaterPurifier : LiquidContainer
{
	public static class WaterPurifierFlags
	{
		public const Flags Boiling = Flags.Reserved1;
	}

	public GameObjectRef storagePrefab;

	public Transform storagePrefabAnchor;

	public ItemDefinition freshWater;

	public int waterToProcessPerMinute = 120;

	public int freshWaterRatio = 4;

	public bool stopWhenOutputFull;

	public LiquidContainer waterStorage;

	public float dirtyWaterProcssed;

	public float pendingFreshWater;

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SpawnStorageEnt(load: false);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		SpawnStorageEnt(load: true);
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if ((Object)(object)waterStorage != (Object)null)
		{
			waterStorage.Kill();
		}
	}

	protected virtual void SpawnStorageEnt(bool load)
	{
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		if (load)
		{
			BaseEntity baseEntity = GetParentEntity();
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				foreach (BaseEntity child in baseEntity.children)
				{
					if ((Object)(object)child != (Object)(object)this && child is LiquidContainer liquidContainer)
					{
						waterStorage = liquidContainer;
						break;
					}
				}
			}
		}
		if ((Object)(object)waterStorage != (Object)null)
		{
			waterStorage.SetConnectedTo(this);
			return;
		}
		waterStorage = GameManager.server.CreateEntity(storagePrefab.resourcePath, storagePrefabAnchor.localPosition, storagePrefabAnchor.localRotation) as LiquidContainer;
		waterStorage.SetParent(GetParentEntity());
		waterStorage.Spawn();
		waterStorage.SetConnectedTo(this);
	}

	internal override void OnParentRemoved()
	{
		Kill(DestroyMode.Gib);
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if (!waterStorage.IsDestroyed)
		{
			waterStorage.Kill();
		}
	}

	public void ParentTemperatureUpdate(float temp)
	{
	}

	public void CheckCoolDown()
	{
		if (!Object.op_Implicit((Object)(object)GetParentEntity()) || !GetParentEntity().IsOn() || !HasDirtyWater())
		{
			SetFlag(Flags.Reserved1, b: false);
			((FacepunchBehaviour)this).CancelInvoke((Action)CheckCoolDown);
		}
	}

	public bool HasDirtyWater()
	{
		Item slot = base.inventory.GetSlot(0);
		if (slot != null && slot.info.itemType == ItemContainer.ContentsType.Liquid)
		{
			return slot.amount > 0;
		}
		return false;
	}

	public void Cook(float timeCooked)
	{
		if (!((Object)(object)waterStorage == (Object)null))
		{
			bool flag = HasDirtyWater();
			if (!IsBoiling() && flag)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)CheckCoolDown, 2f, 2f);
				SetFlag(Flags.Reserved1, b: true);
			}
			if (IsBoiling() && flag)
			{
				ConvertWater(timeCooked);
			}
		}
	}

	protected void ConvertWater(float timeCooked)
	{
		if (stopWhenOutputFull)
		{
			Item slot = waterStorage.inventory.GetSlot(0);
			if (slot != null && slot.amount >= slot.MaxStackable())
			{
				return;
			}
		}
		if (Interface.CallHook("OnWaterPurify", (object)this, (object)timeCooked) != null)
		{
			return;
		}
		float num = timeCooked * ((float)waterToProcessPerMinute / 60f);
		dirtyWaterProcssed += num;
		if (dirtyWaterProcssed >= 1f)
		{
			Item slot2 = base.inventory.GetSlot(0);
			int num2 = Mathf.Min(Mathf.FloorToInt(dirtyWaterProcssed), slot2.amount);
			num = num2;
			slot2.UseItem(num2);
			dirtyWaterProcssed -= num2;
			SendNetworkUpdate();
		}
		pendingFreshWater += num / (float)freshWaterRatio;
		if (!(pendingFreshWater >= 1f))
		{
			return;
		}
		int num3 = Mathf.FloorToInt(pendingFreshWater);
		pendingFreshWater -= num3;
		Item slot3 = waterStorage.inventory.GetSlot(0);
		if (slot3 != null && (Object)(object)slot3.info != (Object)(object)freshWater)
		{
			slot3.RemoveFromContainer();
			slot3.Remove();
		}
		if (slot3 == null)
		{
			Item item = ItemManager.Create(freshWater, num3, 0uL);
			if (!item.MoveToContainer(waterStorage.inventory))
			{
				item.Remove();
			}
		}
		else
		{
			slot3.amount += num3;
			slot3.amount = Mathf.Clamp(slot3.amount, 0, waterStorage.maxStackSize);
			waterStorage.inventory.MarkDirty();
		}
		Interface.CallHook("OnWaterPurified", (object)this, (object)timeCooked);
		waterStorage.SendNetworkUpdate();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk)
		{
			SetFlag(Flags.On, b: false);
		}
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (base.isServer)
		{
			if (base.CanPickup(player) && (Object)(object)waterStorage != (Object)null && waterStorage.inventory != null)
			{
				return waterStorage.inventory.IsEmpty();
			}
			return false;
		}
		return base.CanPickup(player);
	}

	public bool IsBoiling()
	{
		return HasFlag(Flags.Reserved1);
	}
}


public static class WaterPurifierFlags
{
	public const Flags Boiling = Flags.Reserved1;
}


using System;
using ConVar;

public class DebrisEntity : BaseCombatEntity
{
	public float DebrisDespawnOverride;

	public override void ServerInit()
	{
		ResetRemovalTime();
		base.ServerInit();
	}

	public void RemoveCorpse()
	{
		Kill();
	}

	public void ResetRemovalTime(float dur)
	{
		TimeWarning val = TimeWarning.New("ResetRemovalTime", 0);
		try
		{
			if (((FacepunchBehaviour)this).IsInvoking((Action)RemoveCorpse))
			{
				((FacepunchBehaviour)this).CancelInvoke((Action)RemoveCorpse);
			}
			((FacepunchBehaviour)this).Invoke((Action)RemoveCorpse, dur);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public float GetRemovalTime()
	{
		if (!(DebrisDespawnOverride > 0f))
		{
			return Server.debrisdespawn;
		}
		return DebrisDespawnOverride;
	}

	public void ResetRemovalTime()
	{
		ResetRemovalTime(GetRemovalTime());
	}

	public override string Categorize()
	{
		return "debris";
	}
}


using ConVar;
using UnityEngine;

public class BuildingBlockDecay : Decay
{
	private bool isFoundation;

	public override float GetDecayDelay(BaseEntity entity)
	{
		BuildingBlock buildingBlock = entity as BuildingBlock;
		BuildingGrade.Enum grade = (Object.op_Implicit((Object)(object)buildingBlock) ? buildingBlock.grade : BuildingGrade.Enum.Twigs);
		return GetDecayDelay(grade);
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		BuildingBlock buildingBlock = entity as BuildingBlock;
		BuildingGrade.Enum grade = (Object.op_Implicit((Object)(object)buildingBlock) ? buildingBlock.grade : BuildingGrade.Enum.Twigs);
		return GetDecayDuration(grade);
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (entity.net.group != null && entity.net.group.restricted)
		{
			return false;
		}
		if (ConVar.Decay.upkeep)
		{
			return true;
		}
		if (isFoundation)
		{
			return true;
		}
		BuildingBlock buildingBlock = entity as BuildingBlock;
		return !Object.op_Implicit((Object)(object)buildingBlock) || buildingBlock.grade == BuildingGrade.Enum.Twigs;
	}

	protected override void AttributeSetup(GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		isFoundation = name.Contains("foundation");
	}
}


using ConVar;

public class BuildingGradeDecay : Decay
{
	public BuildingGrade.Enum decayGrade;

	public override float GetDecayDelay(BaseEntity entity)
	{
		return GetDecayDelay(decayGrade);
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return GetDecayDuration(decayGrade);
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (ConVar.Decay.upkeep)
		{
			return true;
		}
		return entity.IsOutside();
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;

public abstract class Decay : PrefabAttribute, IServerComponent
{
	private const float hours = 3600f;

	protected float GetDecayDelay(BuildingGrade.Enum grade)
	{
		if (ConVar.Decay.upkeep)
		{
			if (ConVar.Decay.delay_override > 0f)
			{
				return ConVar.Decay.delay_override;
			}
			return grade switch
			{
				BuildingGrade.Enum.Wood => ConVar.Decay.delay_wood * 3600f, 
				BuildingGrade.Enum.Stone => ConVar.Decay.delay_stone * 3600f, 
				BuildingGrade.Enum.Metal => ConVar.Decay.delay_metal * 3600f, 
				BuildingGrade.Enum.TopTier => ConVar.Decay.delay_toptier * 3600f, 
				_ => ConVar.Decay.delay_twig * 3600f, 
			};
		}
		return grade switch
		{
			BuildingGrade.Enum.Wood => 64800f, 
			BuildingGrade.Enum.Stone => 64800f, 
			BuildingGrade.Enum.Metal => 64800f, 
			BuildingGrade.Enum.TopTier => 86400f, 
			_ => 3600f, 
		};
	}

	protected float GetDecayDuration(BuildingGrade.Enum grade)
	{
		if (ConVar.Decay.upkeep)
		{
			if (ConVar.Decay.duration_override > 0f)
			{
				return ConVar.Decay.duration_override;
			}
			return grade switch
			{
				BuildingGrade.Enum.Wood => ConVar.Decay.duration_wood * 3600f, 
				BuildingGrade.Enum.Stone => ConVar.Decay.duration_stone * 3600f, 
				BuildingGrade.Enum.Metal => ConVar.Decay.duration_metal * 3600f, 
				BuildingGrade.Enum.TopTier => ConVar.Decay.duration_toptier * 3600f, 
				_ => ConVar.Decay.duration_twig * 3600f, 
			};
		}
		return grade switch
		{
			BuildingGrade.Enum.Wood => 86400f, 
			BuildingGrade.Enum.Stone => 172800f, 
			BuildingGrade.Enum.Metal => 259200f, 
			BuildingGrade.Enum.TopTier => 432000f, 
			_ => 3600f, 
		};
	}

	public static void BuildingDecayTouch(BuildingBlock buildingBlock)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.Decay.upkeep)
		{
			return;
		}
		List<DecayEntity> list = Pool.Get<List<DecayEntity>>();
		Vis.Entities(((Component)buildingBlock).transform.position, 40f, list, 2097408, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			DecayEntity decayEntity = list[i];
			BuildingBlock buildingBlock2 = decayEntity as BuildingBlock;
			if (!Object.op_Implicit((Object)(object)buildingBlock2) || buildingBlock2.buildingID == buildingBlock.buildingID)
			{
				decayEntity.DecayTouch();
			}
		}
		Pool.FreeUnmanaged<DecayEntity>(ref list);
	}

	public static void EntityLinkDecayTouch(BaseEntity ent)
	{
		if (!ConVar.Decay.upkeep)
		{
			ent.EntityLinkBroadcast(delegate(DecayEntity decayEnt)
			{
				decayEnt.DecayTouch();
			});
		}
	}

	public static void RadialDecayTouch(Vector3 pos, float radius, int mask)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if (!ConVar.Decay.upkeep)
		{
			List<DecayEntity> list = Pool.Get<List<DecayEntity>>();
			Vis.Entities(pos, radius, list, mask, (QueryTriggerInteraction)2);
			for (int i = 0; i < list.Count; i++)
			{
				list[i].DecayTouch();
			}
			Pool.FreeUnmanaged<DecayEntity>(ref list);
		}
	}

	public virtual bool ShouldDecay(BaseEntity entity)
	{
		return true;
	}

	public abstract float GetDecayDelay(BaseEntity entity);

	public abstract float GetDecayDuration(BaseEntity entity);

	public virtual float GetDecayTickOverride()
	{
		return 0f;
	}

	public virtual float GetHealScale(BaseEntity entity)
	{
		return ConVar.Decay.upkeep_heal_scale;
	}

	public virtual float GetHealDelay(DecayEntity decayEntity)
	{
		return 600f;
	}

	protected override Type GetIndexedType()
	{
		return typeof(Decay);
	}
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;

public class DecayEntity : BaseCombatEntity
{
	[Serializable]
	public struct DebrisPosition
	{
		public Vector3 Position;

		public Vector3 Rotation;

		public bool dropToTerrain;
	}

	public GameObjectRef debrisPrefab;

	public Vector3 debrisRotationOffset = Vector3.zero;

	public DebrisPosition[] DebrisPositions;

	[NonSerialized]
	public uint buildingID;

	public float timePlaced;

	public float decayTimer;

	public float upkeepTimer;

	public Upkeep upkeep;

	public Decay decay;

	public DecayPoint[] decayPoints;

	public float lastDecayTick;

	public float decayVariance = 1f;

	public Upkeep Upkeep => upkeep;

	public virtual bool BypassInsideDecayMultiplier => false;

	public virtual bool AllowOnCargoShip => false;

	public override void ResetState()
	{
		base.ResetState();
		buildingID = 0u;
		if (base.isServer)
		{
			decayTimer = 0f;
		}
	}

	public void AttachToBuilding(uint id)
	{
		if (base.isServer)
		{
			BuildingManager.server.Remove(this);
			buildingID = id;
			BuildingManager.server.Add(this);
			SendNetworkUpdate();
		}
	}

	public BuildingManager.Building GetBuilding()
	{
		if (base.isServer)
		{
			return BuildingManager.server.GetBuilding(buildingID);
		}
		return null;
	}

	public override BuildingPrivlidge GetBuildingPrivilege()
	{
		BuildingManager.Building building = GetBuilding();
		if (building != null)
		{
			BuildingPrivlidge dominatingBuildingPrivilege = building.GetDominatingBuildingPrivilege();
			if ((Object)(object)dominatingBuildingPrivilege != (Object)null || CanReturnEmptyBuildingPrivilege())
			{
				return dominatingBuildingPrivilege;
			}
		}
		return base.GetBuildingPrivilege();
	}

	public virtual bool CanReturnEmptyBuildingPrivilege()
	{
		return false;
	}

	public void CalculateUpkeepCostAmounts(List<ItemAmount> itemAmounts, float multiplier)
	{
		if (upkeep == null)
		{
			return;
		}
		float num = upkeep.upkeepMultiplier * multiplier;
		if (num == 0f)
		{
			return;
		}
		List<ItemAmount> list = BuildCost();
		if (list == null)
		{
			return;
		}
		foreach (ItemAmount item in list)
		{
			if (item.itemDef.category != ItemCategory.Resources)
			{
				continue;
			}
			float num2 = item.amount * num;
			bool flag = false;
			foreach (ItemAmount itemAmount in itemAmounts)
			{
				if ((Object)(object)itemAmount.itemDef == (Object)(object)item.itemDef)
				{
					itemAmount.amount += num2;
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				itemAmounts.Add(new ItemAmount(item.itemDef, num2));
			}
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		decayVariance = Random.Range(0.95f, 1f);
		decay = PrefabAttribute.server.Find<Decay>(prefabID);
		decayPoints = PrefabAttribute.server.FindAll<DecayPoint>(prefabID);
		upkeep = PrefabAttribute.server.Find<Upkeep>(prefabID);
		BuildingManager.server.Add(this);
		if (!Application.isLoadingSave)
		{
			BuildingManager.server.CheckMerge(this);
		}
		lastDecayTick = Time.time;
	}

	public override void DoServerDestroy()
	{
		base.DoServerDestroy();
		BuildingManager.server.Remove(this);
		BuildingManager.server.CheckSplit(this);
	}

	public override bool ShouldUseCastNoClipChecks()
	{
		return Time.time - timePlaced <= 5f;
	}

	public virtual void AttachToBuilding(DecayEntity other)
	{
		if ((Object)(object)other != (Object)null)
		{
			AttachToBuilding(other.buildingID);
			BuildingManager.server.CheckMerge(this);
			return;
		}
		BuildingBlock nearbyBuildingBlock = GetNearbyBuildingBlock();
		if (Object.op_Implicit((Object)(object)nearbyBuildingBlock))
		{
			AttachToBuilding(nearbyBuildingBlock.buildingID);
		}
	}

	public BuildingBlock GetNearbyBuildingBlock()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		float num = float.MaxValue;
		BuildingBlock result = null;
		Vector3 position = PivotPoint();
		List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
		Vis.Entities(position, 1.5f, list, 2097152, (QueryTriggerInteraction)2);
		for (int i = 0; i < list.Count; i++)
		{
			BuildingBlock buildingBlock = list[i];
			if (buildingBlock.isServer == base.isServer)
			{
				float num2 = buildingBlock.SqrDistance(position);
				if (!buildingBlock.grounded)
				{
					num2 += 1f;
				}
				if (num2 < num)
				{
					num = num2;
					result = buildingBlock;
				}
			}
		}
		Pool.FreeUnmanaged<BuildingBlock>(ref list);
		return result;
	}

	public void ResetUpkeepTime()
	{
		upkeepTimer = 0f;
	}

	public void DecayTouch()
	{
		decayTimer = 0f;
	}

	public void AddUpkeepTime(float time)
	{
		upkeepTimer -= time;
	}

	public float GetProtectedSeconds()
	{
		return Mathf.Max(0f, 0f - upkeepTimer);
	}

	public virtual float GetEntityDecayDuration()
	{
		return decay.GetDecayDuration(this);
	}

	public virtual float GetEntityHealScale()
	{
		return decay.GetHealScale(this);
	}

	public virtual float GetEntityDecayDelay()
	{
		return decay.GetDecayDelay(this);
	}

	public virtual void DecayTick()
	{
		if (!(decay == null))
		{
			float num = decay.GetDecayTickOverride();
			if (num == 0f)
			{
				num = ConVar.Decay.tick;
			}
			float num2 = Time.time - lastDecayTick;
			if (!(num2 < num))
			{
				OnDecay(decay, num2);
			}
		}
	}

	public virtual void OnDecay(Decay decay, float decayDeltaTime)
	{
		lastDecayTick = Time.time;
		if (HasParent() || !decay.ShouldDecay(this))
		{
			return;
		}
		float num = decayDeltaTime * ConVar.Decay.scale;
		if (ConVar.Decay.upkeep)
		{
			upkeepTimer += num;
			if (upkeepTimer > 0f)
			{
				BuildingPrivlidge buildingPrivilege = GetBuildingPrivilege();
				if ((Object)(object)buildingPrivilege != (Object)null)
				{
					upkeepTimer -= buildingPrivilege.PurchaseUpkeepTime(this, Mathf.Max(upkeepTimer, 600f));
				}
			}
			if (upkeepTimer < 1f)
			{
				if (base.healthFraction < 1f && GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f && Interface.CallHook("OnDecayHeal", (object)this) == null)
				{
					float num2 = decayDeltaTime / GetEntityDecayDuration() * GetEntityHealScale();
					Heal(MaxHealth() * num2);
				}
				return;
			}
			upkeepTimer = 1f;
		}
		decayTimer += num;
		if (decayTimer < GetEntityDecayDelay())
		{
			return;
		}
		TimeWarning val = TimeWarning.New("DecayTick", 0);
		try
		{
			float num3 = 1f;
			if (ConVar.Decay.upkeep)
			{
				if (!BypassInsideDecayMultiplier && !IsOutside())
				{
					num3 *= ConVar.Decay.upkeep_inside_decay_scale;
				}
			}
			else
			{
				for (int i = 0; i < decayPoints.Length; i++)
				{
					DecayPoint decayPoint = decayPoints[i];
					if (decayPoint.IsOccupied(this))
					{
						num3 -= decayPoint.protection;
					}
				}
			}
			if (Interface.CallHook("OnDecayDamage", (object)this) == null && num3 > 0f)
			{
				float num4 = num / GetEntityDecayDuration() * MaxHealth();
				Hurt(num4 * num3 * decayVariance, DamageType.Decay);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		DecayTouch();
	}

	public override void OnDied(HitInfo info)
	{
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		if (debrisPrefab.isValid)
		{
			if (DebrisPositions != null && DebrisPositions.Length != 0)
			{
				DebrisPosition[] debrisPositions = DebrisPositions;
				for (int i = 0; i < debrisPositions.Length; i++)
				{
					DebrisPosition debrisPosition = debrisPositions[i];
					SpawnDebris(debrisPosition.Position, Quaternion.Euler(debrisPosition.Rotation), debrisPosition.dropToTerrain);
				}
			}
			else
			{
				SpawnDebris(Vector3.zero, Quaternion.Euler(debrisRotationOffset), dropToTerrain: false);
			}
		}
		base.OnDied(info);
	}

	private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnDebrisSpawn", (object)this, (object)localPos, (object)rot, (object)dropToTerrain) != null)
		{
			return;
		}
		Vector3 val = ((Component)this).transform.TransformPoint(localPos);
		RaycastHit val2 = default(RaycastHit);
		if (dropToTerrain && Physics.Raycast(val, Vector3.down, ref val2, 6f, 8388608))
		{
			float num = val.y - ((RaycastHit)(ref val2)).point.y;
			val.y = ((RaycastHit)(ref val2)).point.y;
			localPos.y -= num;
		}
		List<DebrisEntity> list = Pool.Get<List<DebrisEntity>>();
		Vis.Entities(val, 0.1f, list, 256, (QueryTriggerInteraction)2);
		if (list.Count > 0)
		{
			Pool.FreeUnmanaged<DebrisEntity>(ref list);
			return;
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(debrisPrefab.resourcePath, ((Component)this).transform.TransformPoint(localPos), ((Component)this).transform.rotation * rot);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			baseEntity.SetParent(parentEntity.Get(serverside: true), worldPositionStays: true);
			baseEntity.Spawn();
		}
		Pool.FreeUnmanaged<DebrisEntity>(ref list);
	}

	public override bool SupportsChildDeployables()
	{
		BaseEntity baseEntity = GetParentEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return false;
		}
		return baseEntity.ForceDeployableSetParent();
	}

	public override bool ForceDeployableSetParent()
	{
		BaseEntity baseEntity = GetParentEntity();
		if (!((Object)(object)baseEntity != (Object)null))
		{
			return false;
		}
		return baseEntity.ForceDeployableSetParent();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.decayEntity = Pool.Get<DecayEntity>();
		info.msg.decayEntity.buildingID = buildingID;
		if (info.forDisk)
		{
			info.msg.decayEntity.decayTimer = decayTimer;
			info.msg.decayEntity.upkeepTimer = upkeepTimer;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.decayEntity == null)
		{
			return;
		}
		decayTimer = info.msg.decayEntity.decayTimer;
		upkeepTimer = info.msg.decayEntity.upkeepTimer;
		if (buildingID != info.msg.decayEntity.buildingID)
		{
			AttachToBuilding(info.msg.decayEntity.buildingID);
			if (info.fromDisk)
			{
				BuildingManager.server.LoadBuildingID(buildingID);
			}
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public struct DebrisPosition
{
	public Vector3 Position;

	public Vector3 Rotation;

	public bool dropToTerrain;
}


using ConVar;

public class DeployableDecay : Decay
{
	public float decayDelay = 8f;

	public float decayDuration = 8f;

	public bool overrideHealRate;

	public float decayTickOverride;

	public bool decayIndoors;

	public float healRate = 1f;

	public override float GetDecayDelay(BaseEntity entity)
	{
		return decayDelay * 60f * 60f;
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return decayDuration * 60f * 60f;
	}

	public override float GetHealScale(BaseEntity entity)
	{
		if (!overrideHealRate)
		{
			return base.GetHealScale(entity);
		}
		return healRate;
	}

	public override float GetDecayTickOverride()
	{
		return decayTickOverride;
	}

	public override bool ShouldDecay(BaseEntity entity)
	{
		if (ConVar.Decay.upkeep || decayIndoors)
		{
			return true;
		}
		return entity.IsOutside();
	}
}


using ConVar;
using UnityEngine;

public class SprayDecay : Decay
{
	public override bool ShouldDecay(BaseEntity entity)
	{
		return true;
	}

	public override float GetDecayDelay(BaseEntity entity)
	{
		return 0f;
	}

	public override float GetDecayDuration(BaseEntity entity)
	{
		return Mathf.Max(Global.SprayDuration, 1f);
	}
}


using System;

public class Upkeep : PrefabAttribute
{
	public float upkeepMultiplier = 1f;

	protected override Type GetIndexedType()
	{
		return typeof(Upkeep);
	}
}


using System;
using UnityEngine;

public class DestroyOutsideMonument : FacepunchBehaviour
{
	[SerializeField]
	private BaseCombatEntity baseCombatEntity;

	[SerializeField]
	private float checkEvery = 10f;

	private MonumentInfo ourMonument;

	private Vector3 OurPos => ((Component)baseCombatEntity).transform.position;

	protected void OnEnable()
	{
		if ((Object)(object)ourMonument == (Object)null)
		{
			ourMonument = GetOurMonument();
		}
		if ((Object)(object)ourMonument == (Object)null)
		{
			DoOutsideMonument();
		}
		else
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckPosition, checkEvery, checkEvery, checkEvery * 0.1f);
		}
	}

	protected void OnDisable()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)CheckPosition);
	}

	private MonumentInfo GetOurMonument()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
		{
			if (monument.IsInBounds(OurPos))
			{
				return monument;
			}
		}
		return null;
	}

	private void CheckPosition()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ourMonument == (Object)null)
		{
			DoOutsideMonument();
		}
		if (!ourMonument.IsInBounds(OurPos))
		{
			DoOutsideMonument();
		}
	}

	private void DoOutsideMonument()
	{
		baseCombatEntity.Kill(BaseNetworkable.DestroyMode.Gib);
	}
}


using UnityEngine;

public class DisableSave : MonoBehaviour
{
	private void OnValidate()
	{
		BaseEntity component = ((Component)this).GetComponent<BaseEntity>();
		if ((Object)(object)component != (Object)null)
		{
			Debug.LogWarning((object)"DisableSave is attached to a GameObject but can't find entity");
		}
		else if (component.enableSaving)
		{
			Debug.LogError((object)"BaseEntity.enableSaving must be disabled for the DisableSave component to work");
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class EntityLink : IPooled
{
	public BaseEntity owner;

	public Socket_Base socket;

	public List<EntityLink> connections = new List<EntityLink>(8);

	public int capacity = int.MaxValue;

	public string name => socket.socketName;

	public void Setup(BaseEntity owner, Socket_Base socket)
	{
		this.owner = owner;
		this.socket = socket;
		if (socket.monogamous)
		{
			capacity = 1;
		}
	}

	public void EnterPool()
	{
		owner = null;
		socket = null;
		capacity = int.MaxValue;
	}

	public void LeavePool()
	{
	}

	public bool Contains(EntityLink entity)
	{
		return connections.Contains(entity);
	}

	public void Add(EntityLink entity)
	{
		connections.Add(entity);
	}

	public void Remove(EntityLink entity)
	{
		connections.Remove(entity);
	}

	public void Clear()
	{
		for (int i = 0; i < connections.Count; i++)
		{
			connections[i].Remove(this);
		}
		connections.Clear();
	}

	public bool IsEmpty()
	{
		return connections.Count == 0;
	}

	public bool IsOccupied()
	{
		return connections.Count >= capacity;
	}

	public bool IsMale()
	{
		return socket.male;
	}

	public bool IsFemale()
	{
		return socket.female;
	}

	public bool CanConnect(EntityLink link)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (IsOccupied())
		{
			return false;
		}
		if (link == null)
		{
			return false;
		}
		if (link.IsOccupied())
		{
			return false;
		}
		return socket.CanConnect(((Component)owner).transform.position, ((Component)owner).transform.rotation, link.socket, ((Component)link.owner).transform.position, ((Component)link.owner).transform.rotation);
	}
}


using System.Collections.Generic;
using Facepunch;

public static class EntityLinkEx
{
	public static void FreeLinks(this List<EntityLink> links)
	{
		for (int i = 0; i < links.Count; i++)
		{
			EntityLink entityLink = links[i];
			entityLink.Clear();
			Pool.Free<EntityLink>(ref entityLink);
		}
		links.Clear();
	}

	public static void ClearLinks(this List<EntityLink> links)
	{
		for (int i = 0; i < links.Count; i++)
		{
			links[i].Clear();
		}
	}

	public static void AddLinks(this List<EntityLink> links, BaseEntity entity, Socket_Base[] sockets)
	{
		foreach (Socket_Base socket in sockets)
		{
			EntityLink entityLink = Pool.Get<EntityLink>();
			entityLink.Setup(entity, socket);
			links.Add(entityLink);
		}
	}
}


using UnityEngine;

public struct EntityRef
{
	internal BaseEntity ent_cached;

	internal NetworkableId id_cached;

	public NetworkableId uid
	{
		get
		{
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001e: Unknown result type (might be due to invalid IL or missing references)
			if (ent_cached.IsValid())
			{
				id_cached = ent_cached.net.ID;
			}
			return id_cached;
		}
		set
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			id_cached = value;
			if (!((NetworkableId)(ref id_cached)).IsValid)
			{
				ent_cached = null;
			}
			else if (!ent_cached.IsValid() || !(ent_cached.net.ID == id_cached))
			{
				ent_cached = null;
			}
		}
	}

	public bool IsSet()
	{
		return ((NetworkableId)(ref id_cached)).IsValid;
	}

	public bool IsValid(bool serverside)
	{
		return Get(serverside).IsValid();
	}

	public void Set(BaseEntity ent)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		ent_cached = ent;
		id_cached = default(NetworkableId);
		if (ent_cached.IsValid())
		{
			id_cached = ent_cached.net.ID;
		}
	}

	public BaseEntity Get(bool serverside)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent_cached == (Object)null && ((NetworkableId)(ref id_cached)).IsValid)
		{
			if (serverside)
			{
				ent_cached = BaseNetworkable.serverEntities.Find(id_cached) as BaseEntity;
			}
			else
			{
				Debug.LogWarning((object)"EntityRef: Looking for clientside entities on pure server!");
			}
		}
		if (!ent_cached.IsValid())
		{
			ent_cached = null;
		}
		return ent_cached;
	}
}


public struct EntityRef<T> where T : BaseEntity
{
	private EntityRef entityRef;

	public bool IsSet => entityRef.IsSet();

	public NetworkableId uid
	{
		get
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return entityRef.uid;
		}
		set
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			entityRef.uid = value;
		}
	}

	public EntityRef(NetworkableId uid)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		entityRef = new EntityRef
		{
			uid = uid
		};
	}

	public bool IsValid(bool serverside)
	{
		return Get(serverside).IsValid();
	}

	public void Set(T entity)
	{
		entityRef.Set(entity);
	}

	public T Get(bool serverside)
	{
		BaseEntity baseEntity = entityRef.Get(serverside);
		if (baseEntity == null)
		{
			return null;
		}
		if (!(baseEntity is T result))
		{
			Set(null);
			return null;
		}
		return result;
	}

	public bool TryGet(bool serverside, out T entity)
	{
		entity = Get(serverside);
		return entity != null;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using Rust;
using UnityEngine;

public class FireBall : BaseEntity, ISplashable
{
	private const Flags StationaryFlag = Flags.Reserved1;

	public float lifeTimeMin = 20f;

	public float lifeTimeMax = 40f;

	public ParticleSystem[] movementSystems;

	public ParticleSystem[] restingSystems;

	[NonSerialized]
	public float generation;

	public GameObjectRef spreadSubEntity;

	public float tickRate = 0.5f;

	public float damagePerSecond = 2f;

	public float radius = 0.5f;

	public int waterToExtinguish = 200;

	public bool canMerge;

	public LayerMask AttackLayers = LayerMask.op_Implicit(1220225809);

	public bool ignoreNPC;

	private Vector3 lastPos = Vector3.zero;

	private float deathTime;

	private int wetness;

	private float spawnTime;

	private Vector3 delayedVelocity;

	private bool IsStationary => HasFlag(Flags.Reserved1);

	public void SetDelayedVelocity(Vector3 delayed)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (!(delayedVelocity != Vector3.zero))
		{
			delayedVelocity = delayed;
			((FacepunchBehaviour)this).Invoke((Action)ApplyDelayedVelocity, 0.1f);
		}
	}

	private void ApplyDelayedVelocity()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		SetVelocity(delayedVelocity);
		delayedVelocity = Vector3.zero;
	}

	public override void ServerInit()
	{
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)Think, Random.Range(0f, 1f), tickRate);
		float num = Random.Range(lifeTimeMin, lifeTimeMax);
		float num2 = num * Random.Range(0.9f, 1.1f);
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, num2);
		((FacepunchBehaviour)this).Invoke((Action)TryToSpread, num * Random.Range(0.3f, 0.5f));
		deathTime = Time.realtimeSinceStartup + num2;
		spawnTime = Time.realtimeSinceStartup;
		((Component)this).transform.rotation = Quaternion.identity;
		SetFlag(Flags.OnFire, b: true);
	}

	public float GetDeathTime()
	{
		return deathTime;
	}

	public void AddLife(float amountToAdd)
	{
		float num = Mathf.Clamp(GetDeathTime() + amountToAdd, 0f, MaxLifeTime());
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, num);
		deathTime = num;
	}

	public float MaxLifeTime()
	{
		return lifeTimeMax * 2.5f;
	}

	public float TimeLeft()
	{
		float num = deathTime - Time.realtimeSinceStartup;
		if (num < 0f)
		{
			num = 0f;
		}
		return num;
	}

	public void TryToSpread()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.9f - generation * 0.1f;
		if (Random.Range(0f, 1f) < num && spreadSubEntity.isValid)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(spreadSubEntity.resourcePath);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				((Component)baseEntity).transform.position = ((Component)this).transform.position + Vector3.up * 0.25f;
				baseEntity.Spawn();
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up);
				baseEntity.creatorEntity = (((Object)(object)creatorEntity == (Object)null) ? baseEntity : creatorEntity);
				Interface.CallHook("OnFireBallSpread", (object)this, (object)baseEntity);
				baseEntity.SetVelocity(modifiedAimConeDirection * Random.Range(5f, 8f));
				((Component)baseEntity).SendMessage("SetGeneration", (object)(generation + 1f));
			}
		}
	}

	public void SetGeneration(int gen)
	{
		generation = gen;
	}

	public void Think()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer)
		{
			Vector3 val = (((Component)this).transform.localPosition - lastPos) / Time.deltaTime;
			UpdateIsStationary(((Vector3)(ref val)).magnitude < 0.05f);
			lastPos = ((Component)this).transform.localPosition;
			if (IsStationary)
			{
				DoRadialDamage();
			}
			if (WaterFactor() > 0.5f)
			{
				Extinguish();
			}
			if (wetness > waterToExtinguish)
			{
				Extinguish();
			}
		}
	}

	public void DoRadialDamage()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		List<BaseCombatEntity> list = Pool.Get<List<BaseCombatEntity>>();
		Vector3 position = ((Component)this).transform.position + new Vector3(0f, radius * 0.75f, 0f);
		Vis.Entities(position, radius, list, LayerMask.op_Implicit(AttackLayers), (QueryTriggerInteraction)1);
		HitInfo hitInfo = new HitInfo();
		hitInfo.DoHitEffects = true;
		hitInfo.DidHit = true;
		hitInfo.HitBone = 0u;
		hitInfo.Initiator = (((Object)(object)creatorEntity == (Object)null) ? ((Component)this).gameObject.ToBaseEntity() : creatorEntity);
		hitInfo.PointStart = ((Component)this).transform.position;
		foreach (BaseCombatEntity item in list)
		{
			if (!((Object)(object)item == (Object)null) && item.isServer && item.IsAlive() && (!ignoreNPC || !item.IsNpc) && item.IsVisible(position))
			{
				if (item is BasePlayer)
				{
					Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", item, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
				}
				hitInfo.PointEnd = ((Component)item).transform.position;
				hitInfo.HitPositionWorld = ((Component)item).transform.position;
				hitInfo.damageTypes.Set(DamageType.Heat, damagePerSecond * tickRate);
				Interface.CallHook("OnFireBallDamage", (object)this, (object)item, (object)hitInfo);
				item.OnAttacked(hitInfo);
			}
		}
		Pool.FreeUnmanaged<BaseCombatEntity>(ref list);
	}

	public bool CanMerge()
	{
		if (canMerge)
		{
			return TimeLeft() < MaxLifeTime() * 0.8f;
		}
		return false;
	}

	public float TimeAlive()
	{
		return Time.realtimeSinceStartup - spawnTime;
	}

	public void UpdateIsStationary(bool shouldBeStationary)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		if (shouldBeStationary != IsStationary && shouldBeStationary && CanMerge())
		{
			List<Collider> list = Pool.Get<List<Collider>>();
			Vis.Colliders<Collider>(((Component)this).transform.position, 0.5f, list, 512, (QueryTriggerInteraction)2);
			foreach (Collider item in list)
			{
				BaseEntity baseEntity = ((Component)item).gameObject.ToBaseEntity();
				if (Object.op_Implicit((Object)(object)baseEntity))
				{
					FireBall fireBall = baseEntity.ToServer<FireBall>();
					if (Object.op_Implicit((Object)(object)fireBall) && fireBall.CanMerge() && (Object)(object)fireBall != (Object)(object)this)
					{
						((FacepunchBehaviour)fireBall).Invoke((Action)Extinguish, 1f);
						fireBall.canMerge = false;
						AddLife(fireBall.TimeLeft() * 0.25f);
					}
				}
			}
			Pool.FreeUnmanaged<Collider>(ref list);
		}
		SetFlag(Flags.Reserved1, shouldBeStationary);
	}

	public void Extinguish()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Extinguish);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return !base.IsDestroyed;
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		wetness += amount;
		return amount;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using UnityEngine;

public class FireSpot : BaseEntity
{
	public GameObject flameEffect;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using Oxide.Core;
using UnityEngine;

public class FlameExplosive : TimedExplosive
{
	public GameObjectRef createOnExplode;

	public bool blockCreateUnderwater;

	public float numToCreate = 10f;

	public float minVelocity = 2f;

	public float maxVelocity = 5f;

	public float spreadAngle = 90f;

	public bool forceUpForExplosion;

	public AnimationCurve velocityCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public AnimationCurve spreadCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[2]
	{
		new Keyframe(0f, 1f),
		new Keyframe(1f, 1f)
	});

	public override void Explode()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		FlameExplode(forceUpForExplosion ? Vector3.up : (-((Component)this).transform.forward));
	}

	public void FlameExplode(Vector3 surfaceNormal)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isServer)
		{
			return;
		}
		Vector3 position = ((Component)this).transform.position;
		if (blockCreateUnderwater && WaterLevel.Test(position, waves: true, volumes: false))
		{
			base.Explode();
			return;
		}
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		for (int i = 0; (float)i < numToCreate; i++)
		{
			BaseEntity baseEntity = GameManager.server.CreateEntity(createOnExplode.resourcePath, position);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				float num = (float)i / numToCreate;
				Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(spreadAngle * spreadCurve.Evaluate(num), surfaceNormal);
				float num2 = Random.Range(0f, 360f);
				Quaternion val = Quaternion.Euler(0f, num2, 0f);
				((Component)baseEntity).transform.SetPositionAndRotation(position, val);
				baseEntity.creatorEntity = (((Object)(object)creatorEntity == (Object)null) ? baseEntity : creatorEntity);
				baseEntity.Spawn();
				Interface.CallHook("OnFlameExplosion", (object)this, (object)component);
				Vector3 val2 = ((Vector3)(ref modifiedAimConeDirection)).normalized * Random.Range(minVelocity, maxVelocity) * velocityCurve.Evaluate(num * Random.Range(1f, 1.1f));
				FireBall component2 = ((Component)baseEntity).GetComponent<FireBall>();
				if ((Object)(object)component2 != (Object)null)
				{
					component2.SetDelayedVelocity(val2);
				}
				else
				{
					baseEntity.SetVelocity(val2);
				}
			}
		}
		base.Explode();
	}

	public override void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		hitNormal = ((RaycastHit)(ref info)).normal;
		FlameExplode(((RaycastHit)(ref info)).normal);
	}
}


public class GrowableGene
{
	public GrowableGenetics.GeneType Type { get; private set; }

	public GrowableGenetics.GeneType PreviousType { get; private set; }

	public void Set(GrowableGenetics.GeneType geneType, bool firstSet = false)
	{
		if (firstSet)
		{
			SetPrevious(geneType);
		}
		else
		{
			SetPrevious(Type);
		}
		Type = geneType;
	}

	public void SetPrevious(GrowableGenetics.GeneType type)
	{
		PreviousType = type;
	}

	public string GetDisplayCharacter()
	{
		return GetDisplayCharacter(Type);
	}

	public static string GetDisplayCharacter(GrowableGenetics.GeneType type)
	{
		return type switch
		{
			GrowableGenetics.GeneType.Empty => "X", 
			GrowableGenetics.GeneType.GrowthSpeed => "G", 
			GrowableGenetics.GeneType.Hardiness => "H", 
			GrowableGenetics.GeneType.WaterRequirement => "W", 
			GrowableGenetics.GeneType.Yield => "Y", 
			_ => "U", 
		};
	}

	public string GetColourCodedDisplayCharacter()
	{
		return GetColourCodedDisplayCharacter(Type);
	}

	public static string GetColourCodedDisplayCharacter(GrowableGenetics.GeneType type)
	{
		return "<color=" + (IsPositive(type) ? "#60891B>" : "#AA4734>") + GetDisplayCharacter(type) + "</color>";
	}

	public static bool IsPositive(GrowableGenetics.GeneType type)
	{
		return type switch
		{
			GrowableGenetics.GeneType.Empty => false, 
			GrowableGenetics.GeneType.GrowthSpeed => true, 
			GrowableGenetics.GeneType.Hardiness => true, 
			GrowableGenetics.GeneType.WaterRequirement => false, 
			GrowableGenetics.GeneType.Yield => true, 
			_ => false, 
		};
	}

	public bool IsPositive()
	{
		return IsPositive(Type);
	}
}


using System.Text;
using ProtoBuf;
using UnityEngine;

public static class GrowableGeneEncoding
{
	public static void EncodeGenesToItem(GrowableEntity sourceGrowable, Item targetItem)
	{
		if (!((Object)(object)sourceGrowable == (Object)null) && sourceGrowable.Genes != null)
		{
			EncodeGenesToItem(EncodeGenesToInt(sourceGrowable.Genes), targetItem);
		}
	}

	public static void EncodeGenesToItem(int genes, Item targetItem)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if (targetItem != null)
		{
			targetItem.instanceData = new InstanceData
			{
				ShouldPool = false,
				dataInt = genes
			};
		}
	}

	public static int EncodeGenesToInt(GrowableGenes genes)
	{
		int num = 0;
		for (int i = 0; i < genes.Genes.Length; i++)
		{
			num = Set(num, i, (int)genes.Genes[i].Type);
		}
		return num;
	}

	public static int EncodePreviousGenesToInt(GrowableGenes genes)
	{
		int num = 0;
		for (int i = 0; i < genes.Genes.Length; i++)
		{
			num = Set(num, i, (int)genes.Genes[i].PreviousType);
		}
		return num;
	}

	public static void DecodeIntToGenes(int data, GrowableGenes genes)
	{
		for (int i = 0; i < 6; i++)
		{
			genes.Genes[i].Set((GrowableGenetics.GeneType)Get(data, i));
		}
	}

	public static void DecodeIntToPreviousGenes(int data, GrowableGenes genes)
	{
		for (int i = 0; i < 6; i++)
		{
			genes.Genes[i].SetPrevious((GrowableGenetics.GeneType)Get(data, i));
		}
	}

	public static string DecodeIntToGeneString(int data)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < 6; i++)
		{
			stringBuilder.Append(GrowableGene.GetColourCodedDisplayCharacter((GrowableGenetics.GeneType)Get(data, i)));
		}
		return stringBuilder.ToString();
	}

	private static int Set(int storage, int slot, int value)
	{
		int num = slot * 5;
		int num2 = 31 << num;
		return (storage & ~num2) | (value << num);
	}

	private static int Get(int storage, int slot)
	{
		int num = slot * 5;
		int num2 = 31 << num;
		return (storage & num2) >> num;
	}
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Growable Gene Properties")]
public class GrowableGeneProperties : ScriptableObject
{
	[Serializable]
	public struct GeneWeight
	{
		public float BaseWeight;

		public float[] SlotWeights;

		public float CrossBreedingWeight;
	}

	[ArrayIndexIsEnum(enumType = typeof(GrowableGenetics.GeneType))]
	public GeneWeight[] Weights = new GeneWeight[5];
}


using System;

[Serializable]
public struct GeneWeight
{
	public float BaseWeight;

	public float[] SlotWeights;

	public float CrossBreedingWeight;
}


using System;
using System.Text;
using Facepunch;
using UnityEngine;

public class GrowableGenes
{
	public GrowableGene[] Genes;

	private static GrowableGenetics.GeneWeighting[] baseWeights = new GrowableGenetics.GeneWeighting[6];

	private static GrowableGenetics.GeneWeighting[] slotWeights = new GrowableGenetics.GeneWeighting[6];

	public GrowableGenes()
	{
		Clear();
	}

	private void Clear()
	{
		Genes = new GrowableGene[6];
		for (int i = 0; i < 6; i++)
		{
			Genes[i] = new GrowableGene();
		}
	}

	public void GenerateFavourableGenes(GrowableEntity growable)
	{
		if (!((Object)(object)growable == (Object)null) && !((Object)(object)growable.Properties.Genes == (Object)null))
		{
			CalculateBaseWeights(growable.Properties.Genes);
			for (int i = 0; i < 6; i++)
			{
				CalculateSlotWeights(growable.Properties.Genes, i);
				Genes[i].Set(PickFavourableGeneType(), firstSet: true);
			}
		}
	}

	public void GenerateRandom(GrowableEntity growable)
	{
		if (!((Object)(object)growable == (Object)null) && !((Object)(object)growable.Properties.Genes == (Object)null))
		{
			CalculateBaseWeights(growable.Properties.Genes);
			for (int i = 0; i < 6; i++)
			{
				CalculateSlotWeights(growable.Properties.Genes, i);
				Genes[i].Set(PickWeightedGeneType(), firstSet: true);
			}
		}
	}

	private void CalculateBaseWeights(GrowableGeneProperties properties)
	{
		int num = 0;
		GrowableGeneProperties.GeneWeight[] weights = properties.Weights;
		for (int i = 0; i < weights.Length; i++)
		{
			GrowableGeneProperties.GeneWeight geneWeight = weights[i];
			baseWeights[num].GeneType = (slotWeights[num].GeneType = (GrowableGenetics.GeneType)num);
			baseWeights[num].Weighting = geneWeight.BaseWeight;
			num++;
		}
	}

	private void CalculateSlotWeights(GrowableGeneProperties properties, int slot)
	{
		int num = 0;
		GrowableGeneProperties.GeneWeight[] weights = properties.Weights;
		for (int i = 0; i < weights.Length; i++)
		{
			GrowableGeneProperties.GeneWeight geneWeight = weights[i];
			slotWeights[num].Weighting = baseWeights[num].Weighting + geneWeight.SlotWeights[slot];
			num++;
		}
	}

	private GrowableGenetics.GeneType PickWeightedGeneType()
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		BufferList<GrowableGenetics.GeneWeighting> val = Pool.Get<BufferList<GrowableGenetics.GeneWeighting>>();
		val.CopyFrom(slotWeights);
		val.Sort((Comparison<GrowableGenetics.GeneWeighting>)((GrowableGenetics.GeneWeighting left, GrowableGenetics.GeneWeighting right) => left.Weighting.CompareTo(right.Weighting)));
		float num = 0f;
		Enumerator<GrowableGenetics.GeneWeighting> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				num += enumerator.Current.Weighting;
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		GrowableGenetics.GeneType result = GrowableGenetics.GeneType.Empty;
		float num2 = Random.Range(0f, num);
		float num3 = 0f;
		enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				GrowableGenetics.GeneWeighting current = enumerator.Current;
				num3 += current.Weighting;
				if (num2 < num3)
				{
					result = current.GeneType;
					break;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
		return result;
	}

	private GrowableGenetics.GeneType PickFavourableGeneType(float favourableGeneChance = -1f)
	{
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		if (favourableGeneChance < 0f)
		{
			favourableGeneChance = PlanterBoxStatic.FavourableGeneChance;
		}
		BufferList<GrowableGenetics.GeneWeighting> val = Pool.Get<BufferList<GrowableGenetics.GeneWeighting>>();
		BufferList<GrowableGenetics.GeneWeighting> val2 = Pool.Get<BufferList<GrowableGenetics.GeneWeighting>>();
		float num = 0f;
		float num2 = 0f;
		GrowableGenetics.GeneWeighting[] array = slotWeights;
		for (int i = 0; i < array.Length; i++)
		{
			GrowableGenetics.GeneWeighting geneWeighting = array[i];
			if (GrowableGene.IsPositive(geneWeighting.GeneType))
			{
				val.Add(geneWeighting);
				num += geneWeighting.Weighting;
			}
			else
			{
				val2.Add(geneWeighting);
				num2 += geneWeighting.Weighting;
			}
		}
		float num3 = Mathx.RemapValClamped(Mathf.Clamp(favourableGeneChance, 0f, 1f), 0f, 1f, 1f, 0f);
		float num4 = num + num2 * num3;
		float num5 = Random.Range(0f, num4);
		float num6 = 0f;
		Enumerator<GrowableGenetics.GeneWeighting> enumerator = val.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				GrowableGenetics.GeneWeighting current = enumerator.Current;
				num6 += current.Weighting;
				if (num5 < num6)
				{
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
					return current.GeneType;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		enumerator = val2.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				GrowableGenetics.GeneWeighting current2 = enumerator.Current;
				num6 += current2.Weighting * num3;
				if (num5 < num6)
				{
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
					Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
					return current2.GeneType;
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val);
		Pool.FreeUnmanaged<GrowableGenetics.GeneWeighting>(ref val2);
		return GrowableGenetics.GeneType.Empty;
	}

	public int GetGeneTypeCount(GrowableGenetics.GeneType geneType)
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (genes[i].Type == geneType)
			{
				num++;
			}
		}
		return num;
	}

	public int GetPositiveGeneCount()
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (genes[i].IsPositive())
			{
				num++;
			}
		}
		return num;
	}

	public int GetNegativeGeneCount()
	{
		int num = 0;
		GrowableGene[] genes = Genes;
		for (int i = 0; i < genes.Length; i++)
		{
			if (!genes[i].IsPositive())
			{
				num++;
			}
		}
		return num;
	}

	public void Save(BaseNetworkable.SaveInfo info)
	{
		info.msg.growableEntity.genes = GrowableGeneEncoding.EncodeGenesToInt(this);
		info.msg.growableEntity.previousGenes = GrowableGeneEncoding.EncodePreviousGenesToInt(this);
	}

	public void Load(BaseNetworkable.LoadInfo info)
	{
		if (info.msg.growableEntity != null)
		{
			GrowableGeneEncoding.DecodeIntToGenes(info.msg.growableEntity.genes, this);
			GrowableGeneEncoding.DecodeIntToPreviousGenes(info.msg.growableEntity.previousGenes, this);
		}
	}

	public void DebugPrint()
	{
		Debug.Log((object)GetDisplayString(previousGenes: false));
	}

	private string GetDisplayString(bool previousGenes)
	{
		StringBuilder stringBuilder = new StringBuilder();
		for (int i = 0; i < 6; i++)
		{
			stringBuilder.Append(GrowableGene.GetDisplayCharacter(previousGenes ? Genes[i].PreviousType : Genes[i].Type));
		}
		return stringBuilder.ToString();
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class GrowableGenetics
{
	public enum GeneType
	{
		Empty,
		WaterRequirement,
		GrowthSpeed,
		Yield,
		Hardiness
	}

	public struct GeneWeighting
	{
		public float Weighting;

		public GeneType GeneType;
	}

	public const int GeneSlotCount = 6;

	public const float CrossBreedingRadius = 1.5f;

	private static GeneWeighting[] neighbourWeights = new GeneWeighting[Enum.GetValues(typeof(GeneType)).Length];

	private static GeneWeighting dominant = default(GeneWeighting);

	public static void CrossBreed(GrowableEntity growable)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		List<GrowableEntity> list = Pool.Get<List<GrowableEntity>>();
		Vis.Entities(((Component)growable).transform.position, 1.5f, list, 524288, (QueryTriggerInteraction)2);
		bool flag = false;
		for (int i = 0; i < 6; i++)
		{
			GrowableGene growableGene = growable.Genes.Genes[i];
			GeneWeighting dominantGeneWeighting = GetDominantGeneWeighting(growable, list, i);
			if (dominantGeneWeighting.Weighting > growable.Properties.Genes.Weights[(int)growableGene.Type].CrossBreedingWeight)
			{
				flag = true;
				growableGene.Set(dominantGeneWeighting.GeneType);
			}
		}
		if (flag)
		{
			growable.SendNetworkUpdate();
		}
	}

	private static GeneWeighting GetDominantGeneWeighting(GrowableEntity crossBreedingGrowable, List<GrowableEntity> neighbours, int slot)
	{
		PlanterBox planter = crossBreedingGrowable.GetPlanter();
		if ((Object)(object)planter == (Object)null)
		{
			dominant.Weighting = -1f;
			return dominant;
		}
		for (int i = 0; i < neighbourWeights.Length; i++)
		{
			neighbourWeights[i].Weighting = 0f;
			neighbourWeights[i].GeneType = (GeneType)i;
		}
		dominant.Weighting = 0f;
		foreach (GrowableEntity neighbour in neighbours)
		{
			if (!neighbour.isServer)
			{
				continue;
			}
			PlanterBox planter2 = neighbour.GetPlanter();
			if (!((Object)(object)planter2 == (Object)null) && !((Object)(object)planter2 != (Object)(object)planter) && !((Object)(object)neighbour == (Object)(object)crossBreedingGrowable) && neighbour.prefabID == crossBreedingGrowable.prefabID && !neighbour.IsDead())
			{
				GeneType type = neighbour.Genes.Genes[slot].Type;
				float crossBreedingWeight = neighbour.Properties.Genes.Weights[(int)type].CrossBreedingWeight;
				float num = (neighbourWeights[(int)type].Weighting += crossBreedingWeight);
				if (num > dominant.Weighting)
				{
					dominant.Weighting = num;
					dominant.GeneType = type;
				}
			}
		}
		return dominant;
	}
}


public enum GeneType
{
	Empty,
	WaterRequirement,
	GrowthSpeed,
	Yield,
	Hardiness
}


public struct GeneWeighting
{
	public float Weighting;

	public GeneType GeneType;
}


using UnityEngine;

public interface IItemContainerEntity : IIdealSlotEntity, ILootableEntity, IInventoryProvider
{
	ItemContainer inventory { get; }

	Transform Transform { get; }

	bool DropsLoot { get; }

	float DestroyLootPercent { get; }

	bool DropFloats { get; }

	void DropItems(BaseEntity initiator = null);

	bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true);

	bool ShouldDropItemsIndividually();

	void DropBonusItems(BaseEntity initiator, ItemContainer container);

	Vector3 GetDropPosition();
}


using System.Collections.Generic;

public interface IInventoryProvider
{
	void GetAllInventories(List<ItemContainer> list);
}


public interface IIdealSlotEntity
{
	int GetIdealSlot(BasePlayer player, ItemContainer container, Item item);

	ItemContainerId GetIdealContainer(BasePlayer player, Item item, ItemMoveModifier modifiers);
}


public interface ILootableEntity
{
	ulong LastLootedBy { get; set; }

	BasePlayer LastLootedByPlayer { get; set; }
}


using Rust.Instruments;
using UnityEngine;

public class InstrumentDebugInput : MonoBehaviour
{
	public InstrumentKeyController KeyController;

	public InstrumentKeyController.KeySet Note = new InstrumentKeyController.KeySet
	{
		Note = Notes.A,
		NoteType = InstrumentKeyController.NoteType.Regular,
		OctaveShift = 3
	};

	public float Frequency = 0.75f;

	public float StopAfter = 0.1f;

	public SoundDefinition OverrideDefinition;
}


using UnityEngine;

public class InstrumentIKController : MonoBehaviour
{
	public Vector3 HitRotationVector = Vector3.forward;

	public Transform[] LeftHandIkTargets = (Transform[])(object)new Transform[0];

	public Transform[] LeftHandIKTargetHitRotations = (Transform[])(object)new Transform[0];

	public Transform[] RightHandIkTargets = (Transform[])(object)new Transform[0];

	public Transform[] RightHandIKTargetHitRotations = (Transform[])(object)new Transform[0];

	public Transform[] RightFootIkTargets = (Transform[])(object)new Transform[0];

	public AnimationCurve HandHeightCurve = AnimationCurve.Constant(0f, 1f, 0f);

	public float HandHeightMultiplier = 1f;

	public float HandMoveLerpSpeed = 50f;

	public bool DebugHitRotation;

	public AnimationCurve HandHitCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public float NoteHitTime = 0.5f;

	[Header("Look IK")]
	public float BodyLookWeight;

	public float HeadLookWeight;

	public float LookWeightLimit;

	public bool HoldHandsAtPlay;
}


using UnityEngine;

public class InstrumentIKTargetAttribute : PropertyAttribute
{
}


using System;
using System.Runtime.InteropServices;
using Rust.Instruments;
using UnityEngine;

public class InstrumentKeyController : MonoBehaviour
{
	public enum IKType
	{
		LeftHand,
		RightHand,
		RightFoot
	}

	public enum NoteType
	{
		Regular,
		Sharp
	}

	public enum InstrumentType
	{
		Note,
		Hold
	}

	public enum AnimationSlot
	{
		None,
		One,
		Two,
		Three,
		Four,
		Five,
		Six,
		Seven
	}

	[Serializable]
	public struct KeySet
	{
		public Notes Note;

		public NoteType NoteType;

		public int OctaveShift;

		public override string ToString()
		{
			return string.Format("{0}{1}{2}", Note, (NoteType == NoteType.Sharp) ? "#" : string.Empty, OctaveShift);
		}
	}

	public struct NoteOverride
	{
		public bool Override;

		public KeySet Note;
	}

	[Serializable]
	public struct IKNoteTarget
	{
		public IKType TargetType;

		public int IkIndex;
	}

	[StructLayout(LayoutKind.Sequential, Size = 1)]
	public struct NoteBinding
	{
	}

	public const float DEFAULT_NOTE_VELOCITY = 1f;

	public NoteBindingCollection Bindings;

	public NoteBinding[] NoteBindings = new NoteBinding[0];

	public Transform[] NoteSoundPositions;

	public InstrumentIKController IKController;

	public Transform LeftHandProp;

	public Transform RightHandProp;

	public Animator InstrumentAnimator;

	public BaseEntity RPCHandler;

	public uint overrideAchievementId;

	private const string ALL_NOTES_STATNAME = "played_notes";

	public bool PlayedNoteThisFrame { get; private set; }

	public void ProcessServerPlayedNote(BasePlayer forPlayer)
	{
		if (!((Object)(object)forPlayer == (Object)null))
		{
			forPlayer.stats.Add(Bindings.NotePlayedStatName, 1, (Stats)5);
			forPlayer.stats.Add("played_notes", 1, (Stats)5);
		}
	}
}


public enum IKType
{
	LeftHand,
	RightHand,
	RightFoot
}


public enum NoteType
{
	Regular,
	Sharp
}


public enum InstrumentType
{
	Note,
	Hold
}


public enum AnimationSlot
{
	None,
	One,
	Two,
	Three,
	Four,
	Five,
	Six,
	Seven
}


using System;
using Rust.Instruments;

[Serializable]
public struct KeySet
{
	public Notes Note;

	public NoteType NoteType;

	public int OctaveShift;

	public override string ToString()
	{
		return string.Format("{0}{1}{2}", Note, (NoteType == NoteType.Sharp) ? "#" : string.Empty, OctaveShift);
	}
}


public struct NoteOverride
{
	public bool Override;

	public KeySet Note;
}


using System;

[Serializable]
public struct IKNoteTarget
{
	public IKType TargetType;

	public int IkIndex;
}


using System.Runtime.InteropServices;

[StructLayout(LayoutKind.Sequential, Size = 1)]
public struct NoteBinding
{
}


using System;
using Rust.Instruments;
using UnityEngine;

[CreateAssetMenu]
public class NoteBindingCollection : ScriptableObject
{
	[Serializable]
	public struct NoteData
	{
		public SoundDefinition NoteSound;

		public SoundDefinition NoteStartSound;

		public Notes Note;

		public InstrumentKeyController.NoteType Type;

		public int MidiNoteNumber;

		public int NoteOctave;

		[InstrumentIKTarget]
		public InstrumentKeyController.IKNoteTarget NoteIKTarget;

		public InstrumentKeyController.AnimationSlot AnimationSlot;

		public int NoteSoundPositionTarget;

		public int[] AdditionalMidiTargets;

		public float PitchOffset;

		public bool MatchMidiCode(int code)
		{
			if (MidiNoteNumber == code)
			{
				return true;
			}
			if (AdditionalMidiTargets != null)
			{
				int[] additionalMidiTargets = AdditionalMidiTargets;
				for (int i = 0; i < additionalMidiTargets.Length; i++)
				{
					if (additionalMidiTargets[i] == code)
					{
						return true;
					}
				}
			}
			return false;
		}

		public string ToNoteString()
		{
			return string.Format("{0}{1}{2}", Note, (Type == InstrumentKeyController.NoteType.Sharp) ? "#" : string.Empty, NoteOctave);
		}
	}

	public NoteData[] BaseBindings;

	public float MinimumNoteTime;

	public float MaximumNoteLength;

	public bool AllowAutoplay = true;

	public float AutoplayLoopDelay = 0.25f;

	public string NotePlayedStatName;

	public string KeyMidiMapShortname = "";

	public bool AllowSustain;

	public bool AllowFullKeyboardInput = true;

	public string InstrumentShortName = "";

	public InstrumentKeyController.InstrumentType NotePlayType;

	public int MaxConcurrentNotes = 3;

	public bool LoopSounds;

	public float SoundFadeInTime;

	public float minimumSoundFadeOutTime = 0.1f;

	public InstrumentKeyController.KeySet PrimaryClickNote;

	public InstrumentKeyController.KeySet SecondaryClickNote = new InstrumentKeyController.KeySet
	{
		Note = Notes.B
	};

	public bool RunInstrumentAnimationController;

	public bool PlayRepeatAnimations = true;

	public float AnimationDeadTime = 1f;

	public float AnimationResetDelay;

	public float RecentlyPlayedThreshold = 1f;

	[Range(0f, 1f)]
	public float CrossfadeNormalizedAnimationTarget;

	public float AnimationCrossfadeDuration = 0.15f;

	public float CrossfadePlayerSpeedMulti = 1f;

	public int DefaultOctave;

	public int ShiftedOctave = 1;

	public bool UseClosestMidiNote = true;

	private const float MidiNoteUpOctaveShift = 2f;

	private const float MidiNoteDownOctaveShift = 0.1f;

	public bool FindNoteData(Notes note, int octave, InstrumentKeyController.NoteType type, out NoteData data, out int noteIndex)
	{
		for (int i = 0; i < BaseBindings.Length; i++)
		{
			NoteData noteData = BaseBindings[i];
			if (noteData.Note == note && noteData.Type == type && noteData.NoteOctave == octave)
			{
				data = noteData;
				noteIndex = i;
				return true;
			}
		}
		data = default(NoteData);
		noteIndex = -1;
		return false;
	}

	public bool FindNoteDataIndex(Notes note, int octave, InstrumentKeyController.NoteType type, out int noteIndex)
	{
		for (int i = 0; i < BaseBindings.Length; i++)
		{
			NoteData noteData = BaseBindings[i];
			if (noteData.Note == note && noteData.Type == type && noteData.NoteOctave == octave)
			{
				noteIndex = i;
				return true;
			}
		}
		noteIndex = -1;
		return false;
	}

	public NoteData CreateMidiBinding(NoteData basedOn, int octave, int midiCode)
	{
		NoteData result = basedOn;
		result.NoteOctave = octave;
		result.MidiNoteNumber = midiCode;
		int num = octave - basedOn.NoteOctave;
		if (octave > basedOn.NoteOctave)
		{
			result.PitchOffset = (float)num * 2f;
		}
		else
		{
			result.PitchOffset = 1f - Mathf.Abs((float)num * 0.1f);
		}
		return result;
	}
}


using System;
using Rust.Instruments;

[Serializable]
public struct NoteData
{
	public SoundDefinition NoteSound;

	public SoundDefinition NoteStartSound;

	public Notes Note;

	public InstrumentKeyController.NoteType Type;

	public int MidiNoteNumber;

	public int NoteOctave;

	[InstrumentIKTarget]
	public InstrumentKeyController.IKNoteTarget NoteIKTarget;

	public InstrumentKeyController.AnimationSlot AnimationSlot;

	public int NoteSoundPositionTarget;

	public int[] AdditionalMidiTargets;

	public float PitchOffset;

	public bool MatchMidiCode(int code)
	{
		if (MidiNoteNumber == code)
		{
			return true;
		}
		if (AdditionalMidiTargets != null)
		{
			int[] additionalMidiTargets = AdditionalMidiTargets;
			for (int i = 0; i < additionalMidiTargets.Length; i++)
			{
				if (additionalMidiTargets[i] == code)
				{
					return true;
				}
			}
		}
		return false;
	}

	public string ToNoteString()
	{
		return string.Format("{0}{1}{2}", Note, (Type == InstrumentKeyController.NoteType.Sharp) ? "#" : string.Empty, NoteOctave);
	}
}


using System;
using UnityEngine;

[Serializable]
public class LODGroupRenderers
{
	public LODGroup lodGroup;

	public Renderer[] renderers;

	public void SetRenderersEnabled(bool enabled)
	{
		Renderer[] array = renderers;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enabled = enabled;
		}
	}
}


public static class BaseMetabolism
{
	public const float targetHeartRate = 0.05f;
}


using System;
using ConVar;
using Rust;
using UnityEngine;

public abstract class BaseMetabolism<T> : EntityComponent<T> where T : BaseCombatEntity
{
	protected T owner;

	public MetabolismAttribute calories = new MetabolismAttribute();

	public MetabolismAttribute hydration = new MetabolismAttribute();

	public MetabolismAttribute heartrate = new MetabolismAttribute();

	protected float timeSinceLastMetabolism;

	public virtual void Reset()
	{
		calories.Reset();
		hydration.Reset();
		heartrate.Reset();
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			owner = null;
		}
	}

	public virtual void ServerInit(T owner)
	{
		Reset();
		this.owner = owner;
	}

	public virtual void ServerUpdate(BaseCombatEntity ownerEntity, float delta)
	{
		timeSinceLastMetabolism += delta;
		if (!(timeSinceLastMetabolism <= ConVar.Server.metabolismtick))
		{
			if (Object.op_Implicit((Object)(object)owner) && !owner.IsDead())
			{
				RunMetabolism(ownerEntity, timeSinceLastMetabolism);
				DoMetabolismDamage(ownerEntity, timeSinceLastMetabolism);
			}
			timeSinceLastMetabolism = 0f;
		}
	}

	protected virtual void DoMetabolismDamage(BaseCombatEntity ownerEntity, float delta)
	{
		if (calories.value <= 20f)
		{
			TimeWarning val = TimeWarning.New("Calories Hurt", 0);
			try
			{
				ownerEntity.Hurt(Mathf.InverseLerp(20f, 0f, calories.value) * delta * (1f / 12f), DamageType.Hunger);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (hydration.value <= 20f)
		{
			TimeWarning val = TimeWarning.New("Hyration Hurt", 0);
			try
			{
				ownerEntity.Hurt(Mathf.InverseLerp(20f, 0f, hydration.value) * delta * (2f / 15f), DamageType.Thirst);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
	}

	protected virtual void RunMetabolism(BaseCombatEntity ownerEntity, float delta)
	{
		if (calories.value > 200f)
		{
			ownerEntity.Heal(Mathf.InverseLerp(200f, 1000f, calories.value) * delta * (1f / 60f));
		}
		if (hydration.value > 200f)
		{
			ownerEntity.Heal(Mathf.InverseLerp(200f, 1000f, hydration.value) * delta * (1f / 60f));
		}
		hydration.MoveTowards(0f, delta * (1f / 120f));
		calories.MoveTowards(0f, delta * (1f / 60f));
		heartrate.MoveTowards(0.05f, delta * (1f / 60f));
	}

	public virtual void ApplyChange(MetabolismAttribute.Type type, float amount, float time)
	{
		FindAttribute(type)?.Add(amount);
	}

	public bool ShouldDie()
	{
		if (Object.op_Implicit((Object)(object)owner))
		{
			return owner.Health() <= 0f;
		}
		return false;
	}

	public virtual MetabolismAttribute FindAttribute(MetabolismAttribute.Type type)
	{
		return type switch
		{
			MetabolismAttribute.Type.Calories => calories, 
			MetabolismAttribute.Type.Hydration => hydration, 
			MetabolismAttribute.Type.Heartrate => heartrate, 
			_ => null, 
		};
	}
}


using System;
using UnityEngine;

[Serializable]
public class MetabolismAttribute
{
	public enum Type
	{
		Calories,
		Hydration,
		Heartrate,
		Poison,
		Radiation,
		Bleeding,
		Health,
		HealthOverTime
	}

	public float startMin;

	public float startMax;

	public float min;

	public float max;

	public float value;

	public float lastValue;

	internal float lastGreatFraction;

	private const float greatInterval = 0.1f;

	public float greatFraction => Mathf.Floor(Fraction() / 0.1f) / 10f;

	public void Reset()
	{
		value = Mathf.Clamp(Random.Range(startMin, startMax), min, max);
	}

	public float Fraction()
	{
		return Mathf.InverseLerp(min, max, value);
	}

	public float InverseFraction()
	{
		return 1f - Fraction();
	}

	public void Add(float val)
	{
		value = Mathf.Clamp(value + val, min, max);
	}

	public void Subtract(float val)
	{
		value = Mathf.Clamp(value - val, min, max);
	}

	public void Set(float val)
	{
		value = Mathf.Clamp(val, min, max);
	}

	public void Increase(float fTarget)
	{
		fTarget = Mathf.Clamp(fTarget, min, max);
		if (!(fTarget <= value))
		{
			value = fTarget;
		}
	}

	public void MoveTowards(float fTarget, float fRate)
	{
		if (fRate != 0f)
		{
			value = Mathf.Clamp(Mathf.MoveTowards(value, fTarget, fRate), min, max);
		}
	}

	public bool HasChanged()
	{
		bool result = lastValue != value;
		lastValue = value;
		return result;
	}

	public bool HasGreatlyChanged()
	{
		float num = greatFraction;
		bool result = lastGreatFraction != num;
		lastGreatFraction = num;
		return result;
	}

	public void SetValue(float newValue)
	{
		value = newValue;
	}
}


public enum Type
{
	Calories,
	Hydration,
	Heartrate,
	Poison,
	Radiation,
	Bleeding,
	Health,
	HealthOverTime
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class BaseResourceExtractor : BaseCombatEntity
{
	public bool canExtractLiquid;

	public bool canExtractSolid = true;

	public override void ServerInit()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (base.isClient)
		{
			return;
		}
		List<SurveyCrater> list = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(((Component)this).transform.position, 3f, list, 1, (QueryTriggerInteraction)2);
		foreach (SurveyCrater item in list)
		{
			if (item.isServer)
			{
				item.Kill();
			}
		}
		Pool.FreeUnmanaged<SurveyCrater>(ref list);
	}
}


using System;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class MiningQuarry : BaseResourceExtractor
{
	[Serializable]
	public enum QuarryType
	{
		None,
		Basic,
		Sulfur,
		HQM
	}

	[Serializable]
	public class ChildPrefab
	{
		public GameObjectRef prefabToSpawn;

		public GameObject origin;

		public BaseEntity instance;

		public void DoSpawn(MiningQuarry owner)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			if (prefabToSpawn.isValid)
			{
				instance = GameManager.server.CreateEntity(prefabToSpawn.resourcePath, origin.transform.localPosition, origin.transform.localRotation);
				instance.SetParent(owner);
				instance.Spawn();
			}
		}
	}

	public Animator beltAnimator;

	public Renderer beltScrollRenderer;

	public int scrollMatIndex = 3;

	public float animatorSpeedChange = 1f;

	public float beltScrollSpeedMultiplier = 1f;

	public SoundPlayer[] onSounds;

	public float processRate = 5f;

	public float workToAdd = 15f;

	public float workPerFuel = 1000f;

	public float pendingWork;

	public GameObjectRef bucketDropEffect;

	public GameObject bucketDropTransform;

	public ChildPrefab engineSwitchPrefab;

	public ChildPrefab hopperPrefab;

	public ChildPrefab fuelStoragePrefab;

	public QuarryType staticType;

	public bool isStatic;

	public ResourceDepositManager.ResourceDeposit _linkedDeposit;

	public bool IsEngineOn()
	{
		return HasFlag(Flags.On);
	}

	public void SetOn(bool isOn)
	{
		SetFlag(Flags.On, isOn);
		engineSwitchPrefab.instance.SetFlag(Flags.On, isOn);
		SendNetworkUpdate();
		engineSwitchPrefab.instance.SendNetworkUpdate();
		if (isOn)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)ProcessResources, processRate, processRate);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)ProcessResources);
		}
	}

	public void EngineSwitch(bool isOn)
	{
		if (isOn && FuelCheck())
		{
			SetOn(isOn: true);
		}
		else
		{
			SetOn(isOn: false);
		}
	}

	public override void ServerInit()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (isStatic)
		{
			UpdateStaticDeposit();
		}
		else
		{
			ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(((Component)this).transform.position);
			_linkedDeposit = orCreate;
		}
		SpawnChildEntities();
		engineSwitchPrefab.instance.SetFlag(Flags.On, HasFlag(Flags.On));
		if (base.isServer)
		{
			ItemContainer inventory = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory;
			inventory.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(inventory.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
		}
	}

	public bool CanAcceptItem(Item item, int targetSlot)
	{
		return item.info.shortname == "diesel_barrel";
	}

	public void UpdateStaticDeposit()
	{
		if (isStatic)
		{
			if (_linkedDeposit == null)
			{
				_linkedDeposit = new ResourceDepositManager.ResourceDeposit();
			}
			else
			{
				_linkedDeposit._resources.Clear();
			}
			if (staticType == QuarryType.None)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 1000, 0.3f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, 5f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, 7.5f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, 75f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.Basic)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, 1000, 1f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
				_linkedDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 1000, 0.2f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.Sulfur)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, 1000, 1f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			else if (staticType == QuarryType.HQM)
			{
				_linkedDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, 1000, 20f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM);
			}
			_linkedDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, 1000, 16.666666f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, liquid: true);
			_linkedDeposit.Add(ItemManager.FindItemDefinition("lowgradefuel"), 1f, 1000, 5.882353f, ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, liquid: true);
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		EngineSwitch(HasFlag(Flags.On));
		UpdateStaticDeposit();
	}

	public void SpawnChildEntities()
	{
		engineSwitchPrefab.DoSpawn(this);
		hopperPrefab.DoSpawn(this);
		fuelStoragePrefab.DoSpawn(this);
	}

	public void ProcessResources()
	{
		if (_linkedDeposit == null || (Object)(object)hopperPrefab.instance == (Object)null)
		{
			return;
		}
		if (!FuelCheck())
		{
			SetOn(isOn: false);
		}
		float num = Mathf.Min(workToAdd, pendingWork);
		pendingWork -= num;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in _linkedDeposit._resources)
		{
			if ((!canExtractLiquid && resource.isLiquid) || (!canExtractSolid && !resource.isLiquid))
			{
				continue;
			}
			float workNeeded = resource.workNeeded;
			int num2 = Mathf.FloorToInt(resource.workDone / workNeeded);
			resource.workDone += num;
			int num3 = Mathf.FloorToInt(resource.workDone / workNeeded);
			if (resource.workDone > workNeeded)
			{
				resource.workDone %= workNeeded;
			}
			if (num2 != num3)
			{
				int iAmount = num3 - num2;
				Item item = ItemManager.Create(resource.type, iAmount, 0uL);
				Analytics.Azure.OnQuarryItem(Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);
				if (Interface.CallHook("OnQuarryGather", (object)this, (object)item) != null)
				{
					item.Remove();
				}
				else if (!item.MoveToContainer(((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory))
				{
					item.Remove();
					SetOn(isOn: false);
				}
			}
		}
	}

	public bool FuelCheck()
	{
		if (pendingWork > 0f)
		{
			return true;
		}
		Item item = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.FindItemByItemName("diesel_barrel");
		object obj = Interface.CallHook("OnQuarryConsumeFuel", (object)this, (object)item);
		if (obj is Item)
		{
			item = (Item)obj;
		}
		if (item != null && item.amount >= 1)
		{
			pendingWork += workPerFuel;
			Analytics.Azure.OnQuarryItem(Analytics.Azure.ResourceMode.Consumed, item.info.shortname, 1, this);
			item.UseItem();
			return true;
		}
		return false;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			if ((Object)(object)fuelStoragePrefab.instance == (Object)null || (Object)(object)hopperPrefab.instance == (Object)null)
			{
				Debug.Log((object)"Cannot save mining quary because children were null");
				return;
			}
			info.msg.miningQuarry = Pool.Get<MiningQuarry>();
			info.msg.miningQuarry.extractor = Pool.Get<ResourceExtractor>();
			info.msg.miningQuarry.extractor.fuelContents = ((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.Save();
			info.msg.miningQuarry.extractor.outputContents = ((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory.Save();
			info.msg.miningQuarry.staticType = (int)staticType;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.fromDisk && info.msg.miningQuarry != null)
		{
			if ((Object)(object)fuelStoragePrefab.instance == (Object)null || (Object)(object)hopperPrefab.instance == (Object)null)
			{
				Debug.Log((object)"Cannot load mining quary because children were null");
				return;
			}
			((Component)fuelStoragePrefab.instance).GetComponent<StorageContainer>().inventory.Load(info.msg.miningQuarry.extractor.fuelContents);
			((Component)hopperPrefab.instance).GetComponent<StorageContainer>().inventory.Load(info.msg.miningQuarry.extractor.outputContents);
			staticType = (QuarryType)info.msg.miningQuarry.staticType;
		}
	}
}


using System;

[Serializable]
public enum QuarryType
{
	None,
	Basic,
	Sulfur,
	HQM
}


using System;
using UnityEngine;

[Serializable]
public class ChildPrefab
{
	public GameObjectRef prefabToSpawn;

	public GameObject origin;

	public BaseEntity instance;

	public void DoSpawn(MiningQuarry owner)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		if (prefabToSpawn.isValid)
		{
			instance = GameManager.server.CreateEntity(prefabToSpawn.resourcePath, origin.transform.localPosition, origin.transform.localRotation);
			instance.SetParent(owner);
			instance.Spawn();
		}
	}
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class ResourceDepositManager : BaseEntity
{
	[Serializable]
	public class ResourceDeposit
	{
		[Serializable]
		public enum surveySpawnType
		{
			ITEM,
			OIL,
			WATER
		}

		[Serializable]
		public class ResourceDepositEntry
		{
			public ItemDefinition type;

			public float efficiency = 1f;

			public int amount;

			public int startAmount;

			public float workNeeded = 1f;

			public float workDone;

			public surveySpawnType spawnType;

			public bool isLiquid;

			public void Subtract(int subamount)
			{
				if (subamount > 0)
				{
					amount -= subamount;
					if (amount < 0)
					{
						amount = 0;
					}
				}
			}
		}

		public float lastSurveyTime = float.NegativeInfinity;

		public Vector3 origin;

		public List<ResourceDepositEntry> _resources;

		public ResourceDeposit()
		{
			_resources = new List<ResourceDepositEntry>();
		}

		public void Add(ItemDefinition type, float efficiency, int amount, float workNeeded, surveySpawnType spawnType, bool liquid = false)
		{
			ResourceDepositEntry resourceDepositEntry = new ResourceDepositEntry();
			resourceDepositEntry.type = type;
			resourceDepositEntry.efficiency = efficiency;
			resourceDepositEntry.startAmount = (resourceDepositEntry.amount = amount);
			resourceDepositEntry.spawnType = spawnType;
			resourceDepositEntry.workNeeded = workNeeded;
			resourceDepositEntry.isLiquid = liquid;
			_resources.Add(resourceDepositEntry);
		}
	}

	public static ResourceDepositManager _manager;

	private const int resolution = 20;

	public Dictionary<Vector2i, ResourceDeposit> _deposits;

	public static Vector2i GetIndexFrom(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		return new Vector2i((int)pos.x / 20, (int)pos.z / 20);
	}

	public static ResourceDepositManager Get()
	{
		return _manager;
	}

	public ResourceDepositManager()
	{
		_manager = this;
		_deposits = new Dictionary<Vector2i, ResourceDeposit>();
	}

	public ResourceDeposit CreateFromPosition(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_034d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_021d: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_023e: Unknown result type (might be due to invalid IL or missing references)
		Vector2i indexFrom = GetIndexFrom(pos);
		State state = Random.state;
		Random.InitState((int)SeedEx.Seed(new Vector2((float)indexFrom.x, (float)indexFrom.y), World.Seed + World.Salt));
		ResourceDeposit resourceDeposit = new ResourceDeposit
		{
			origin = new Vector3((float)(indexFrom.x * 20), 0f, (float)(indexFrom.y * 20))
		};
		if (Random.Range(0f, 1f) < 0.5f)
		{
			resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, 100, 1f, ResourceDeposit.surveySpawnType.ITEM);
		}
		else
		{
			bool flag = false;
			float num = 0f;
			if (World.Procedural)
			{
				if (TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f)
				{
					num += 0.25f;
				}
			}
			else
			{
				num += 0.15f;
			}
			if (Random.Range(0f, 1f) >= 1f - num)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("crude.oil"), 1f, Random.Range(5000, 10000), Random.Range(8f, 10f), ResourceDeposit.surveySpawnType.ITEM, liquid: true);
				flag = true;
			}
			if (!flag)
			{
				resourceDeposit.Add(ItemManager.FindItemDefinition("stones"), 1f, Random.Range(30000, 100000), Random.Range(0.3f, 0.5f), ResourceDeposit.surveySpawnType.ITEM);
				float num2 = 0f;
				num2 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 2) > 0.5f) ? 1f : 0f) * 0.25f));
				if (Random.Range(0f, 1f) >= 1f - num2)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("metal.ore"), 1f, Random.Range(10000, 100000), Random.Range(2f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num3 = 0f;
				num3 = ((!World.Procedural) ? 0.1f : (((TerrainMeta.BiomeMap.GetBiome(pos, 1) > 0.5f) ? 1f : 0f) * (0.25f + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 8) ? 1f : 0f) + 0.25f * (TerrainMeta.TopologyMap.GetTopology(pos, 1) ? 1f : 0f))));
				if (Random.Range(0f, 1f) >= 1f - num3)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("sulfur.ore"), 1f, Random.Range(10000, 100000), Random.Range(4f, 4f), ResourceDeposit.surveySpawnType.ITEM);
				}
				float num4 = 0f;
				if (World.Procedural)
				{
					if (TerrainMeta.BiomeMap.GetBiome(pos, 8) > 0.5f || TerrainMeta.BiomeMap.GetBiome(pos, 4) > 0.5f)
					{
						num4 += 0.25f;
					}
				}
				else
				{
					num4 += 0.15f;
				}
				if (Random.Range(0f, 1f) >= 1f - num4)
				{
					resourceDeposit.Add(ItemManager.FindItemDefinition("hq.metal.ore"), 1f, Random.Range(5000, 10000), Random.Range(30f, 50f), ResourceDeposit.surveySpawnType.ITEM);
				}
			}
		}
		_deposits.Add(indexFrom, resourceDeposit);
		Interface.CallHook("OnResourceDepositCreated", (object)resourceDeposit);
		Random.state = state;
		return resourceDeposit;
	}

	public ResourceDeposit GetFromPosition(Vector3 pos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		ResourceDeposit value = null;
		if (_deposits.TryGetValue(GetIndexFrom(pos), out value))
		{
			return value;
		}
		return null;
	}

	public static ResourceDeposit GetOrCreate(Vector3 pos)
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		ResourceDeposit fromPosition = Get().GetFromPosition(pos);
		if (fromPosition != null)
		{
			return fromPosition;
		}
		return Get().CreateFromPosition(pos);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class ResourceDeposit
{
	[Serializable]
	public enum surveySpawnType
	{
		ITEM,
		OIL,
		WATER
	}

	[Serializable]
	public class ResourceDepositEntry
	{
		public ItemDefinition type;

		public float efficiency = 1f;

		public int amount;

		public int startAmount;

		public float workNeeded = 1f;

		public float workDone;

		public surveySpawnType spawnType;

		public bool isLiquid;

		public void Subtract(int subamount)
		{
			if (subamount > 0)
			{
				amount -= subamount;
				if (amount < 0)
				{
					amount = 0;
				}
			}
		}
	}

	public float lastSurveyTime = float.NegativeInfinity;

	public Vector3 origin;

	public List<ResourceDepositEntry> _resources;

	public ResourceDeposit()
	{
		_resources = new List<ResourceDepositEntry>();
	}

	public void Add(ItemDefinition type, float efficiency, int amount, float workNeeded, surveySpawnType spawnType, bool liquid = false)
	{
		ResourceDepositEntry resourceDepositEntry = new ResourceDepositEntry();
		resourceDepositEntry.type = type;
		resourceDepositEntry.efficiency = efficiency;
		resourceDepositEntry.startAmount = (resourceDepositEntry.amount = amount);
		resourceDepositEntry.spawnType = spawnType;
		resourceDepositEntry.workNeeded = workNeeded;
		resourceDepositEntry.isLiquid = liquid;
		_resources.Add(resourceDepositEntry);
	}
}


using System;

[Serializable]
public enum surveySpawnType
{
	ITEM,
	OIL,
	WATER
}


using System;

[Serializable]
public class ResourceDepositEntry
{
	public ItemDefinition type;

	public float efficiency = 1f;

	public int amount;

	public int startAmount;

	public float workNeeded = 1f;

	public float workDone;

	public surveySpawnType spawnType;

	public bool isLiquid;

	public void Subtract(int subamount)
	{
		if (subamount > 0)
		{
			amount -= subamount;
			if (amount < 0)
			{
				amount = 0;
			}
		}
	}
}


public class ResourceExtractorFuelStorage : StorageContainer
{
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class SurveyCharge : TimedExplosive
{
	public GameObjectRef craterPrefab;

	public GameObjectRef craterPrefab_Oil;

	public override void Explode()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		base.Explode();
		if (WaterLevel.Test(((Component)this).transform.position, waves: true, volumes: true, this))
		{
			return;
		}
		ResourceDepositManager.ResourceDeposit orCreate = ResourceDepositManager.GetOrCreate(((Component)this).transform.position);
		if (orCreate == null || Time.realtimeSinceStartup - orCreate.lastSurveyTime < 10f)
		{
			return;
		}
		orCreate.lastSurveyTime = Time.realtimeSinceStartup;
		if (!TransformUtil.GetGroundInfo(((Component)this).transform.position, out var hitOut, 0.3f, LayerMask.op_Implicit(8388608)))
		{
			return;
		}
		Vector3 point = ((RaycastHit)(ref hitOut)).point;
		_ = ((RaycastHit)(ref hitOut)).normal;
		List<SurveyCrater> list = Pool.Get<List<SurveyCrater>>();
		Vis.Entities(((Component)this).transform.position, 10f, list, 1, (QueryTriggerInteraction)2);
		bool num = list.Count > 0;
		Pool.FreeUnmanaged<SurveyCrater>(ref list);
		if (num)
		{
			return;
		}
		bool flag = false;
		bool flag2 = false;
		foreach (ResourceDepositManager.ResourceDeposit.ResourceDepositEntry resource in orCreate._resources)
		{
			if (resource.spawnType == ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM && !resource.isLiquid && resource.amount >= 1000)
			{
				int num2 = Mathf.Clamp(Mathf.CeilToInt(2.5f / resource.workNeeded * 10f), 0, 5);
				int iAmount = 1;
				flag = true;
				if (resource.isLiquid)
				{
					flag2 = true;
				}
				for (int i = 0; i < num2; i++)
				{
					Item item = ItemManager.Create(resource.type, iAmount, 0uL);
					Interface.CallHook("OnSurveyGather", (object)this, (object)item);
					Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up);
					BaseEntity baseEntity = item.Drop(((Component)this).transform.position + Vector3.up * 1f, GetInheritedDropVelocity() + modifiedAimConeDirection * Random.Range(5f, 10f), Random.rotation);
					Quaternion rotation = Random.rotation;
					baseEntity.SetAngularVelocity(((Quaternion)(ref rotation)).eulerAngles * 5f);
				}
			}
		}
		if (flag)
		{
			string strPrefab = (flag2 ? craterPrefab_Oil.resourcePath : craterPrefab.resourcePath);
			BaseEntity baseEntity2 = GameManager.server.CreateEntity(strPrefab, point, Quaternion.identity);
			if (Object.op_Implicit((Object)(object)baseEntity2))
			{
				baseEntity2.Spawn();
			}
		}
	}
}


using UnityEngine;

public class NPCAutoTurret : AutoTurret
{
	public Transform centerMuzzle;

	public Transform muzzleLeft;

	public Transform muzzleRight;

	public bool useSleeperHostile = true;

	private bool useLeftMuzzle;

	[ReplicatedVar(Help = "How many seconds until a sleeping player is considered hostile")]
	public static float sleeperhostiledelay = 1200f;

	public override void ServerInit()
	{
		base.ServerInit();
		SetOnline();
		SetPeacekeepermode(isOn: true);
	}

	public virtual bool HasAmmo()
	{
		return true;
	}

	public override bool CheckPeekers()
	{
		return false;
	}

	public override float TargetScanRate()
	{
		return 1.25f;
	}

	public override bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		return true;
	}

	public override float GetMaxAngleForEngagement()
	{
		return 15f;
	}

	public override bool HasFallbackWeapon()
	{
		return true;
	}

	public override Transform GetCenterMuzzle()
	{
		return centerMuzzle;
	}

	public override void FireGun(Vector3 targetPos, float aimCone, Transform muzzleToUse = null, BaseCombatEntity target = null)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		muzzleToUse = muzzleRight;
		base.FireGun(targetPos, aimCone, muzzleToUse, target);
	}

	public override bool Ignore(BasePlayer player)
	{
		if (!(player is ScientistNPC))
		{
			return player is BanditGuard;
		}
		return true;
	}

	public override bool IsEntityHostile(BaseCombatEntity ent)
	{
		BasePlayer basePlayer = ent as BasePlayer;
		if ((Object)(object)basePlayer != (Object)null)
		{
			if (basePlayer.IsNpc)
			{
				if (basePlayer is ScientistNPC || basePlayer is BanditGuard)
				{
					return false;
				}
				if (basePlayer is NPCShopKeeper)
				{
					return false;
				}
				if (basePlayer is BasePet)
				{
					return base.IsEntityHostile(basePlayer);
				}
				return true;
			}
			if (basePlayer.IsSleeping() && useSleeperHostile && basePlayer.secondsSleeping >= sleeperhostiledelay)
			{
				return true;
			}
		}
		return base.IsEntityHostile(ent);
	}
}


using UnityEngine;

public class TargetTrigger : TriggerBase
{
	[Tooltip("If set, the entering object must have line of sight to this transform to be added, note this is only checked on entry")]
	public Transform losEyes;

	public override GameObject InterestedInObject(GameObject obj)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if ((Object)(object)losEyes != (Object)null && !baseEntity.IsVisible(((Component)losEyes).transform.position, baseEntity.CenterPoint()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}
}


using UnityEngine;

public class BirthdayBalloonHandler : MonoBehaviour, IClientComponent
{
	public float checkOffset = 1f;

	public float checkRadius = 0.5f;
}


using Facepunch.CardGames;
using UnityEngine;

public class BlackjackMachine : BaseCardGameEntity
{
	[Header("Blackjack Machine")]
	[SerializeField]
	private GameObjectRef mainScreenPrefab;

	[SerializeField]
	private GameObjectRef smallScreenPrefab;

	[SerializeField]
	private Transform mainScreenParent;

	[SerializeField]
	private Transform[] smallScreenParents;

	private static int _maxbet = 500;

	private BlackjackController controller;

	private BlackjackMainScreenUI mainScreenUI;

	private BlackjackSmallScreenUI[] smallScreenUIs = new BlackjackSmallScreenUI[3];

	[ServerVar(Help = "Maximum initial bet per round")]
	public static int maxbet
	{
		get
		{
			return _maxbet;
		}
		set
		{
			_maxbet = Mathf.Clamp(value, 25, 1000000);
		}
	}

	protected override float MaxStorageInteractionDist => 1f;

	public override void InitShared()
	{
		base.InitShared();
		controller = (BlackjackController)base.GameController;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}

	public override void PlayerStorageChanged()
	{
		base.PlayerStorageChanged();
		SendNetworkUpdate();
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class CardGamePlayerStorage : StorageContainer
{
	private EntityRef cardTableRef;

	public BaseCardGameEntity GetCardGameEntity()
	{
		BaseEntity baseEntity = cardTableRef.Get(base.isServer);
		if ((Object)(object)baseEntity != (Object)null && baseEntity.IsValid())
		{
			return baseEntity as BaseCardGameEntity;
		}
		return null;
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.simpleUID != null)
		{
			cardTableRef.uid = info.msg.simpleUID.uid;
		}
	}

	protected override void OnInventoryDirty()
	{
		base.OnInventoryDirty();
		BaseCardGameEntity cardGameEntity = GetCardGameEntity();
		if ((Object)(object)cardGameEntity != (Object)null)
		{
			cardGameEntity.PlayerStorageChanged();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.simpleUID = Pool.Get<SimpleUID>();
		info.msg.simpleUID.uid = cardTableRef.uid;
	}

	public void SetCardTable(BaseCardGameEntity cardGameEntity)
	{
		cardTableRef.Set(cardGameEntity);
	}
}


using System;
using UnityEngine;

public class CardGameSounds : PrefabAttribute
{
	public enum SoundType
	{
		Chips,
		Draw,
		Play,
		Shuffle,
		Win,
		YourTurn,
		Check,
		Hit,
		Stand,
		Bet,
		IncreaseBet,
		DecreaseBet,
		AllIn,
		UIInteract,
		DealerCool,
		DealerHappy,
		DealerLove,
		DealerSad,
		DealerShocked
	}

	public SoundDefinition ChipsSfx;

	public SoundDefinition DrawSfx;

	public SoundDefinition PlaySfx;

	public SoundDefinition ShuffleSfx;

	public SoundDefinition WinSfx;

	public SoundDefinition LoseSfx;

	public SoundDefinition YourTurnSfx;

	public SoundDefinition CheckSfx;

	public SoundDefinition HitSfx;

	public SoundDefinition StandSfx;

	public SoundDefinition BetSfx;

	public SoundDefinition IncreaseBetSfx;

	public SoundDefinition DecreaseBetSfx;

	public SoundDefinition AllInSfx;

	public SoundDefinition UIInteractSfx;

	[Header("Dealer Reactions")]
	public SoundDefinition DealerCoolSfx;

	public SoundDefinition DealerHappySfx;

	public SoundDefinition DealerLoveSfx;

	public SoundDefinition DealerSadSfx;

	public SoundDefinition DealerShockedSfx;

	protected override Type GetIndexedType()
	{
		return typeof(CardGameSounds);
	}

	public void PlaySound(SoundType sound, GameObject forGameObject)
	{
		switch (sound)
		{
		case SoundType.Chips:
			ChipsSfx.Play(forGameObject);
			break;
		case SoundType.Draw:
			DrawSfx.Play(forGameObject);
			break;
		case SoundType.Play:
			PlaySfx.Play(forGameObject);
			break;
		case SoundType.Shuffle:
			ShuffleSfx.Play(forGameObject);
			break;
		case SoundType.Win:
			WinSfx.Play(forGameObject);
			break;
		case SoundType.YourTurn:
			YourTurnSfx.Play(forGameObject);
			break;
		case SoundType.Check:
			CheckSfx.Play(forGameObject);
			break;
		case SoundType.Hit:
			HitSfx.Play(forGameObject);
			break;
		case SoundType.Stand:
			StandSfx.Play(forGameObject);
			break;
		case SoundType.Bet:
			BetSfx.Play(forGameObject);
			break;
		case SoundType.IncreaseBet:
			IncreaseBetSfx.Play(forGameObject);
			break;
		case SoundType.DecreaseBet:
			DecreaseBetSfx.Play(forGameObject);
			break;
		case SoundType.AllIn:
			AllInSfx.Play(forGameObject);
			break;
		case SoundType.UIInteract:
			UIInteractSfx.Play(forGameObject);
			break;
		case SoundType.DealerCool:
			DealerCoolSfx.Play(forGameObject);
			break;
		case SoundType.DealerHappy:
			DealerHappySfx.Play(forGameObject);
			break;
		case SoundType.DealerLove:
			DealerLoveSfx.Play(forGameObject);
			break;
		case SoundType.DealerSad:
			DealerSadSfx.Play(forGameObject);
			break;
		case SoundType.DealerShocked:
			DealerShockedSfx.Play(forGameObject);
			break;
		default:
			throw new ArgumentOutOfRangeException("sound", sound, null);
		}
	}
}


public enum SoundType
{
	Chips,
	Draw,
	Play,
	Shuffle,
	Win,
	YourTurn,
	Check,
	Hit,
	Stand,
	Bet,
	IncreaseBet,
	DecreaseBet,
	AllIn,
	UIInteract,
	DealerCool,
	DealerHappy,
	DealerLove,
	DealerSad,
	DealerShocked
}


using System;
using UnityEngine;
using UnityEngine.UI;

public class CardTable : BaseCardGameEntity
{
	[Serializable]
	public class ChipStack : IComparable<ChipStack>
	{
		public int chipValue;

		public GameObject[] chips;

		public int CompareTo(ChipStack other)
		{
			if (other == null)
			{
				return 1;
			}
			return chipValue.CompareTo(other.chipValue);
		}
	}

	[Header("Card Table")]
	[SerializeField]
	private ViewModel viewModel;

	[SerializeField]
	private CardGameUI.PlayingCardImage[] tableCards;

	[SerializeField]
	private Renderer[] tableCardBackings;

	[SerializeField]
	private Canvas cardUICanvas;

	[SerializeField]
	private Image[] tableCardImages;

	[SerializeField]
	private Sprite blankCard;

	[SerializeField]
	private ChipStack[] chipStacks;

	[SerializeField]
	private ChipStack[] fillerStacks;

	protected override float MaxStorageInteractionDist => 1f;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ChipStack : IComparable<ChipStack>
{
	public int chipValue;

	public GameObject[] chips;

	public int CompareTo(ChipStack other)
	{
		if (other == null)
		{
			return 1;
		}
		return chipValue.CompareTo(other.chipValue);
	}
}


using UnityEngine;

public class CardTableSeat : BaseChair
{
	public Transform CardsMesh;
}


using UnityEngine;
using UnityEngine.UI;

public class PlayingCardsViewmodel : MonoBehaviour
{
	[SerializeField]
	private Canvas cardUICanvas;

	[SerializeField]
	private Image cardA;

	[SerializeField]
	private Image cardB;

	[SerializeField]
	private Sprite blankCard;
}


public class DecorDeployable : DecayEntity
{
}


using ConVar;
using Oxide.Core;
using UnityEngine;

public class DropUtil
{
	public static void DropItems(ItemContainer container, Vector3 position)
	{
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0143: Unknown result type (might be due to invalid IL or missing references)
		//IL_014a: Unknown result type (might be due to invalid IL or missing references)
		if (!Server.dropitems || container == null || container.itemList == null || Interface.CallHook("OnContainerDropItems", (object)container) != null)
		{
			return;
		}
		float num = 0.25f;
		Item[] array = container.itemList.ToArray();
		foreach (Item item in array)
		{
			float num2 = Random.Range(0f, 2f);
			item.RemoveFromContainer();
			BaseEntity baseEntity = item.CreateWorldObject(position + new Vector3(Random.Range(0f - num, num), 1f, Random.Range(0f - num, num)));
			if ((Object)(object)baseEntity == (Object)null)
			{
				item.Remove();
				continue;
			}
			if (baseEntity is DroppedItem droppedItem && container.entityOwner is LootContainer)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Loot;
			}
			if (num2 > 0f)
			{
				baseEntity.SetVelocity(new Vector3(Random.Range(-1f, 1f), Random.Range(0f, 1f), Random.Range(-1f, 1f)) * num2);
				baseEntity.SetAngularVelocity(new Vector3(Random.Range(-10f, 10f), Random.Range(-10f, 10f), Random.Range(-10f, 10f)) * num2);
			}
		}
	}
}


public class DynamicPreventBuilding : BaseEntity
{
}


using System;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class EnvSync : PointEntity
{
	private const float syncInterval = 5f;

	private const float syncIntervalInv = 0.2f;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateNetwork, 5f, 5f);
	}

	private void UpdateNetwork()
	{
		if (NexusServer.Started && NexusServer.LastReset.HasValue && (Object)(object)TOD_Sky.Instance != (Object)null)
		{
			TOD_Time time = TOD_Sky.Instance.Components.Time;
			DateTimeOffset dateTimeOffset = DateTimeOffset.FromUnixTimeSeconds(NexusServer.LastReset.Value);
			double totalMinutes = (DateTimeOffset.UtcNow - dateTimeOffset).TotalMinutes;
			double num = (double)(Nexus.timeOffset / 24f) + totalMinutes / (double)time.DayLengthInMinutes;
			if (time.UseTimeCurve)
			{
				double num2 = Math.Truncate(num);
				double num3 = (num - num2) * 24.0;
				float num4 = time.EvaulateTimeCurve((float)num3);
				num = num2 + (double)(num4 / 24f);
			}
			double value = num * 24.0;
			DateTime dateTime = dateTimeOffset.Date.AddHours(value);
			TOD_Sky.Instance.Cycle.DateTime = dateTime;
		}
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.environment = Pool.Get<Environment>();
		if (Object.op_Implicit((Object)(object)TOD_Sky.Instance))
		{
			info.msg.environment.dateTime = TOD_Sky.Instance.Cycle.DateTime.ToBinary();
		}
		info.msg.environment.engineTime = Time.realtimeSinceStartup;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.environment != null && Object.op_Implicit((Object)(object)TOD_Sky.Instance) && base.isServer)
		{
			TOD_Sky.Instance.Cycle.DateTime = DateTime.FromBinary(info.msg.environment.dateTime);
		}
	}
}


using System;
using UnityEngine;

public class F15 : BaseCombatEntity
{
	public float speed = 150f;

	public float defaultAltitude = 150f;

	public float altitude = 250f;

	public float altitudeLerpSpeed = 30f;

	public float turnRate = 1f;

	public float flybySoundLengthUntilMax = 4.5f;

	public SoundPlayer flybySound;

	public GameObject body;

	public float rollSpeed = 1f;

	public Vector3 movePosition;

	public GameObjectRef missilePrefab;

	private float nextMissileTime;

	private float blockTurningFor;

	private bool isRetiring;

	private CH47PathFinder pathFinder = new CH47PathFinder();

	private float turnSeconds;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public float GetDesiredAltitude()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + ((Component)this).transform.forward * 200f;
		return (TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position) + TerrainMeta.HeightMap.GetHeight(val) + TerrainMeta.HeightMap.GetHeight(val + Vector3.right * 50f) + TerrainMeta.HeightMap.GetHeight(val - Vector3.right * 50f) + TerrainMeta.HeightMap.GetHeight(val + Vector3.forward * 50f) + TerrainMeta.HeightMap.GetHeight(val - Vector3.forward * 50f)) / 6f + defaultAltitude;
	}

	public override void ServerInit()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RetireToSunset, 600f);
		movePosition = ((Component)this).transform.position;
		movePosition.y = defaultAltitude;
		((Component)this).transform.position = movePosition;
	}

	public void RetireToSunset()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		isRetiring = true;
		movePosition = new Vector3(10000f, defaultAltitude, 10000f);
	}

	public void PickNewPatrolPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		movePosition = pathFinder.GetRandomPatrolPoint();
		float num = 0f;
		if ((Object)(object)TerrainMeta.HeightMap != (Object)null)
		{
			num = TerrainMeta.HeightMap.GetHeight(movePosition);
		}
		movePosition.y = num + defaultAltitude;
	}

	private void FixedUpdate()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0175: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_021c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_023c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0241: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		if (isRetiring && Vector3.Distance(((Component)this).transform.position, Vector3.zero) > 4900f)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedDestroy, 0f);
		}
		if (!((FacepunchBehaviour)this).IsInvoking((Action)DelayedDestroy))
		{
			altitude = Mathf.Lerp(altitude, GetDesiredAltitude(), Time.fixedDeltaTime * 0.25f);
			if (Vector3Ex.Distance2D(movePosition, ((Component)this).transform.position) < 10f)
			{
				PickNewPatrolPoint();
				blockTurningFor = 6f;
			}
			blockTurningFor -= Time.fixedDeltaTime;
			bool num = blockTurningFor > 0f;
			movePosition.y = altitude;
			Vector3 val = Vector3Ex.Direction(movePosition, ((Component)this).transform.position);
			if (num)
			{
				Vector3 position = ((Component)this).transform.position;
				position.y = altitude;
				Vector3 val2 = QuaternionEx.LookRotationForcedUp(((Component)this).transform.forward, Vector3.up) * Vector3.forward;
				val = Vector3Ex.Direction(position + val2 * 2000f, ((Component)this).transform.position);
			}
			Vector3 forward = Vector3.Lerp(((Component)this).transform.forward, val, Time.fixedDeltaTime * turnRate);
			((Component)this).transform.forward = forward;
			bool flag = Vector3.Dot(((Component)this).transform.right, val) > 0.55f;
			bool flag2 = Vector3.Dot(-((Component)this).transform.right, val) > 0.55f;
			SetFlag(Flags.Reserved1, flag);
			SetFlag(Flags.Reserved2, flag2);
			if (flag2 || flag)
			{
				turnSeconds += Time.fixedDeltaTime;
			}
			else
			{
				turnSeconds = 0f;
			}
			if (turnSeconds > 10f)
			{
				turnSeconds = 0f;
				blockTurningFor = 8f;
			}
			Transform transform = ((Component)this).transform;
			transform.position += ((Component)this).transform.forward * speed * Time.fixedDeltaTime;
			nextMissileTime = Time.realtimeSinceStartup + 10f;
		}
	}

	public void DelayedDestroy()
	{
		Kill();
	}
}


public interface IAlwaysOn
{
	void SetAlwaysOn(bool flag);

	bool IsAlwaysOn()
	{
		return false;
	}

	void AlwaysOnToggled(bool flag);
}


using UnityEngine;

public interface IIgniteable
{
	void Ignite(Vector3 fromPos);

	bool CanIgnite();
}


public interface IReceivePlayerTickListener
{
	void OnReceivePlayerTick(BasePlayer player, PlayerTick msg);

	bool ShouldRemoveOnPlayerDeath();
}


public interface ISplashable
{
	bool WantsSplash(ItemDefinition splashType, int amount);

	int DoSplash(ItemDefinition splashType, int amount);
}


using System;
using ConVar;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class LootContainer : StorageContainer
{
	public enum spawnType
	{
		GENERIC,
		PLAYER,
		TOWN,
		AIRDROP,
		CRASHSITE,
		ROADSIDE
	}

	[Serializable]
	public struct LootSpawnSlot
	{
		public LootSpawn definition;

		public int numberToSpawn;

		public float probability;

		public string onlyWithLoadoutNamed;

		public Era[] eras;
	}

	public bool destroyOnEmpty = true;

	public LootSpawn lootDefinition;

	public int maxDefinitionsToSpawn;

	public float minSecondsBetweenRefresh = 3600f;

	public float maxSecondsBetweenRefresh = 7200f;

	public bool initialLootSpawn = true;

	public float xpLootedScale = 1f;

	public float xpDestroyedScale = 1f;

	public bool BlockPlayerItemInput;

	public int scrapAmount;

	public string deathStat = "";

	public LootSpawnSlot[] LootSpawnSlots;

	public spawnType SpawnType;

	public ClanScoreEventType clanScoreEventForFirstLooter = (ClanScoreEventType)(-1);

	[NonSerialized]
	public bool HasBeenLooted;

	[NonSerialized]
	public ulong FirstLooterId;

	private static ItemDefinition scrapDef;

	public bool shouldRefreshContents
	{
		get
		{
			if (minSecondsBetweenRefresh > 0f)
			{
				return maxSecondsBetweenRefresh > 0f;
			}
			return false;
		}
	}

	public override void ResetState()
	{
		FirstLooterId = 0uL;
		base.ResetState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (initialLootSpawn)
		{
			SpawnLoot();
		}
		if (BlockPlayerItemInput && !Application.isLoadingSave && base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
		SetFlag(Flags.Reserved6, PlayerInventory.IsBirthday());
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		if (!added)
		{
			HasBeenLooted = true;
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (BlockPlayerItemInput && base.inventory != null)
		{
			base.inventory.SetFlag(ItemContainer.Flag.NoItemInput, b: true);
		}
	}

	public virtual void SpawnLoot()
	{
		if (base.inventory == null)
		{
			Debug.Log((object)"CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!");
			return;
		}
		base.inventory.Clear();
		ItemManager.DoRemoves();
		if (Interface.CallHook("OnLootSpawn", (object)this) == null)
		{
			PopulateLoot();
			if (shouldRefreshContents)
			{
				((FacepunchBehaviour)this).Invoke((Action)SpawnLoot, Random.Range(minSecondsBetweenRefresh, maxSecondsBetweenRefresh));
			}
		}
	}

	public int ScoreForRarity(Rarity rarity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Expected I4, but got Unknown
		return (rarity - 1) switch
		{
			0 => 1, 
			1 => 2, 
			2 => 3, 
			3 => 4, 
			_ => 5000, 
		};
	}

	public virtual void PopulateLoot()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		if (LootSpawnSlots.Length != 0)
		{
			LootSpawnSlot[] lootSpawnSlots = LootSpawnSlots;
			for (int i = 0; i < lootSpawnSlots.Length; i++)
			{
				LootSpawnSlot lootSpawnSlot = lootSpawnSlots[i];
				if (lootSpawnSlot.eras != null && lootSpawnSlot.eras.Length != 0 && Array.IndexOf(lootSpawnSlot.eras, ConVar.Server.Era) == -1)
				{
					continue;
				}
				for (int j = 0; j < lootSpawnSlot.numberToSpawn; j++)
				{
					if (Random.Range(0f, 1f) <= lootSpawnSlot.probability)
					{
						lootSpawnSlot.definition.SpawnIntoContainer(base.inventory);
					}
				}
			}
		}
		else if ((Object)(object)lootDefinition != (Object)null)
		{
			for (int k = 0; k < maxDefinitionsToSpawn; k++)
			{
				lootDefinition.SpawnIntoContainer(base.inventory);
			}
		}
		if (SpawnType == spawnType.ROADSIDE || SpawnType == spawnType.TOWN)
		{
			foreach (Item item in base.inventory.itemList)
			{
				if (item.hasCondition)
				{
					item.condition = Random.Range(item.info.condition.foundCondition.fractionMin, item.info.condition.foundCondition.fractionMax) * item.info.condition.max;
				}
			}
		}
		GenerateScrap();
		HasBeenLooted = false;
	}

	public void GenerateScrap()
	{
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		if (scrapAmount <= 0)
		{
			return;
		}
		if ((Object)(object)scrapDef == (Object)null)
		{
			scrapDef = ItemManager.FindItemDefinition("scrap");
		}
		int num = scrapAmount;
		if (num > 0)
		{
			Item item = ItemManager.Create(scrapDef, num, 0uL);
			if (!item.MoveToContainer(base.inventory))
			{
				item.Drop(((Component)this).transform.position, GetInheritedDropVelocity());
			}
		}
	}

	public override void DropBonusItems(BaseEntity initiator, ItemContainer container)
	{
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		base.DropBonusItems(initiator, container);
		if ((Object)(object)initiator == (Object)null || container == null)
		{
			return;
		}
		BasePlayer basePlayer = initiator as BasePlayer;
		if ((Object)(object)basePlayer == (Object)null || scrapAmount <= 0 || !((Object)(object)scrapDef != (Object)null))
		{
			return;
		}
		float num = (((Object)(object)basePlayer.modifiers != (Object)null) ? (1f + basePlayer.modifiers.GetValue(Modifier.ModifierType.Scrap_Yield)) : 0f);
		if (!(num > 1f))
		{
			return;
		}
		float variableValue = basePlayer.modifiers.GetVariableValue(Modifier.ModifierType.Scrap_Yield, 0f);
		float num2 = Mathf.Max((float)scrapAmount * num - (float)scrapAmount, 0f);
		variableValue += num2;
		int num3 = 0;
		if (variableValue >= 1f)
		{
			num3 = (int)variableValue;
			variableValue -= (float)num3;
		}
		basePlayer.modifiers.SetVariableValue(Modifier.ModifierType.Scrap_Yield, variableValue);
		if (num3 > 0)
		{
			Item item = ItemManager.Create(scrapDef, num3, 0uL);
			if (item != null && Interface.CallHook("OnBonusItemDrop", (object)item, (object)basePlayer, (object)container) == null)
			{
				(item.Drop(GetDropPosition() + new Vector3(0f, 0.5f, 0f), GetInheritedDropVelocity()) as DroppedItem).DropReason = DroppedItem.DropReasonEnum.Loot;
				Interface.CallHook("OnBonusItemDropped", (object)item, (object)basePlayer, (object)container);
			}
		}
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Invalid comparison between Unknown and I4
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (FirstLooterId == 0L)
		{
			FirstLooterId = baseEntity.userID;
			Analytics.Azure.OnFirstLooted(this, baseEntity);
			if ((int)clanScoreEventForFirstLooter != -1)
			{
				baseEntity.AddClanScore(clanScoreEventForFirstLooter);
			}
			if (base.inventory != null && base.inventory.itemList != null)
			{
				foreach (Item item in base.inventory.itemList)
				{
					item?.SetItemOwnership(baseEntity, ItemOwnershipPhrases.LootedPhrase);
				}
			}
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		base.PlayerStoppedLooting(player);
		if (destroyOnEmpty && (base.inventory == null || base.inventory.itemList == null || base.inventory.itemList.Count == 0))
		{
			Kill(DestroyMode.Gib);
		}
	}

	public void RemoveMe()
	{
		Kill(DestroyMode.Gib);
	}

	public override bool ShouldDropItemsIndividually()
	{
		return true;
	}

	public override void DropItems(BaseEntity initiator = null)
	{
		if (initiator is BasePlayer player)
		{
			foreach (Item item in base.inventory.itemList)
			{
				item?.SetItemOwnership(player, ItemOwnershipPhrases.LootedPhrase);
			}
		}
		base.DropItems(initiator);
	}

	public override void OnDied(HitInfo info)
	{
		if (info != null)
		{
			Analytics.Azure.OnLootContainerDestroyed(this, info.InitiatorPlayer, info.Weapon);
		}
		base.OnDied(info);
		if (info != null && (Object)(object)info.InitiatorPlayer != (Object)null && !string.IsNullOrEmpty(deathStat))
		{
			info.InitiatorPlayer.stats.Add(deathStat, 1, Stats.Life);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		base.OnAttacked(info);
	}

	public override void InitShared()
	{
		base.InitShared();
	}
}


public enum spawnType
{
	GENERIC,
	PLAYER,
	TOWN,
	AIRDROP,
	CRASHSITE,
	ROADSIDE
}


using System;
using Rust;

[Serializable]
public struct LootSpawnSlot
{
	public LootSpawn definition;

	public int numberToSpawn;

	public float probability;

	public string onlyWithLoadoutNamed;

	public Era[] eras;
}


public class LootContainerAchievement : LootContainer
{
	public string AchievementName = string.Empty;

	public bool AllowDuringTutorial;

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if (!string.IsNullOrEmpty(AchievementName))
		{
			baseEntity.GiveAchievement(AchievementName, AllowDuringTutorial);
		}
		return base.OnStartBeingLooted(baseEntity);
	}
}


using System;
using UnityEngine;

public class m2bradleyAnimator : MonoBehaviour
{
	public Animator m2Animator;

	public Material treadLeftMaterial;

	public Material treadRightMaterial;

	private Rigidbody mainRigidbody;

	[Header("GunBones")]
	public Transform turret;

	public Transform mainCannon;

	public Transform coaxGun;

	public Transform rocketsPitch;

	public Transform spotLightYaw;

	public Transform spotLightPitch;

	public Transform sideMG;

	public Transform[] sideguns;

	[Header("WheelBones")]
	public Transform[] ShocksBones;

	public Transform[] ShockTraceLineBegin;

	public Vector3[] vecShocksOffsetPosition;

	[Header("Targeting")]
	public Transform targetTurret;

	public Transform targetSpotLight;

	public Transform[] targetSideguns;

	private Vector3 vecTurret = new Vector3(0f, 0f, 0f);

	private Vector3 vecMainCannon = new Vector3(0f, 0f, 0f);

	private Vector3 vecCoaxGun = new Vector3(0f, 0f, 0f);

	private Vector3 vecRocketsPitch = new Vector3(0f, 0f, 0f);

	private Vector3 vecSpotLightBase = new Vector3(0f, 0f, 0f);

	private Vector3 vecSpotLight = new Vector3(0f, 0f, 0f);

	private float sideMGPitchValue;

	[Header("MuzzleFlash locations")]
	public GameObject muzzleflashCannon;

	public GameObject muzzleflashCoaxGun;

	public GameObject muzzleflashSideMG;

	public GameObject[] muzzleflashRockets;

	public GameObject spotLightHaloSawnpoint;

	public GameObject[] muzzleflashSideguns;

	[Header("MuzzleFlash Particle Systems")]
	public GameObjectRef machineGunMuzzleFlashFX;

	public GameObjectRef mainCannonFireFX;

	public GameObjectRef rocketLaunchFX;

	[Header("Misc")]
	public bool rocketsOpen;

	public Vector3[] vecSideGunRotation;

	public float treadConstant = 0.14f;

	public float wheelSpinConstant = 80f;

	[Header("Gun Movement speeds")]
	public float sidegunsTurnSpeed = 30f;

	public float turretTurnSpeed = 6f;

	public float cannonPitchSpeed = 10f;

	public float rocketPitchSpeed = 20f;

	public float spotLightTurnSpeed = 60f;

	public float machineGunSpeed = 20f;

	private float wheelAngle;

	private void Start()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		mainRigidbody = ((Component)this).GetComponent<Rigidbody>();
		for (int i = 0; i < ShocksBones.Length; i++)
		{
			vecShocksOffsetPosition[i] = ShocksBones[i].localPosition;
		}
	}

	private void Update()
	{
		TrackTurret();
		TrackSpotLight();
		TrackSideGuns();
		AnimateWheelsTreads();
		AdjustShocksHeight();
		m2Animator.SetBool("rocketpods", rocketsOpen);
	}

	private void AnimateWheelsTreads()
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		if ((Object)(object)mainRigidbody != (Object)null)
		{
			num = Vector3.Dot(mainRigidbody.velocity, ((Component)this).transform.forward);
		}
		float num2 = Time.time * -1f * num * treadConstant % 1f;
		treadLeftMaterial.SetTextureOffset("_MainTex", new Vector2(num2, 0f));
		treadLeftMaterial.SetTextureOffset("_BumpMap", new Vector2(num2, 0f));
		treadLeftMaterial.SetTextureOffset("_SpecGlossMap", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_MainTex", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_BumpMap", new Vector2(num2, 0f));
		treadRightMaterial.SetTextureOffset("_SpecGlossMap", new Vector2(num2, 0f));
		if (num >= 0f)
		{
			wheelAngle = (wheelAngle + Time.deltaTime * num * wheelSpinConstant) % 360f;
		}
		else
		{
			wheelAngle += Time.deltaTime * num * wheelSpinConstant;
			if (wheelAngle <= 0f)
			{
				wheelAngle = 360f;
			}
		}
		m2Animator.SetFloat("wheel_spin", wheelAngle);
		m2Animator.SetFloat("speed", num);
	}

	private void AdjustShocksHeight()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		Ray val = default(Ray);
		int mask = LayerMask.GetMask(new string[3] { "Terrain", "World", "Construction" });
		int num = ShocksBones.Length;
		float num2 = 0.55f;
		float num3 = 0.79f;
		float num4 = 0.26f;
		RaycastHit val2 = default(RaycastHit);
		for (int i = 0; i < num; i++)
		{
			((Ray)(ref val)).origin = ShockTraceLineBegin[i].position;
			((Ray)(ref val)).direction = ((Component)this).transform.up * -1f;
			num4 = ((!Physics.SphereCast(val, 0.15f, ref val2, num3, mask)) ? 0.26f : (((RaycastHit)(ref val2)).distance - num2));
			vecShocksOffsetPosition[i].y = Mathf.Lerp(vecShocksOffsetPosition[i].y, Mathf.Clamp(num4 * -1f, -0.26f, 0f), Time.deltaTime * 5f);
			ShocksBones[i].localPosition = vecShocksOffsetPosition[i];
		}
	}

	private void TrackTurret()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0223: Unknown result type (might be due to invalid IL or missing references)
		//IL_02bc: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)targetTurret != (Object)null))
		{
			return;
		}
		Vector3 val = targetTurret.position - turret.position;
		_ = ((Vector3)(ref val)).normalized;
		CalculateYawPitchOffset(turret, turret.position, targetTurret.position, out var yaw, out var pitch);
		yaw = NormalizeYaw(yaw);
		float num = Time.deltaTime * turretTurnSpeed;
		if (yaw < -0.5f)
		{
			vecTurret.y = (vecTurret.y - num) % 360f;
		}
		else if (yaw > 0.5f)
		{
			vecTurret.y = (vecTurret.y + num) % 360f;
		}
		turret.localEulerAngles = vecTurret;
		float num2 = Time.deltaTime * cannonPitchSpeed;
		CalculateYawPitchOffset(mainCannon, mainCannon.position, targetTurret.position, out yaw, out pitch);
		if (pitch < -0.5f)
		{
			vecMainCannon.x -= num2;
		}
		else if (pitch > 0.5f)
		{
			vecMainCannon.x += num2;
		}
		vecMainCannon.x = Mathf.Clamp(vecMainCannon.x, -55f, 5f);
		mainCannon.localEulerAngles = vecMainCannon;
		if (pitch < -0.5f)
		{
			vecCoaxGun.x -= num2;
		}
		else if (pitch > 0.5f)
		{
			vecCoaxGun.x += num2;
		}
		vecCoaxGun.x = Mathf.Clamp(vecCoaxGun.x, -65f, 15f);
		coaxGun.localEulerAngles = vecCoaxGun;
		if (rocketsOpen)
		{
			num2 = Time.deltaTime * rocketPitchSpeed;
			CalculateYawPitchOffset(rocketsPitch, rocketsPitch.position, targetTurret.position, out yaw, out pitch);
			if (pitch < -0.5f)
			{
				vecRocketsPitch.x -= num2;
			}
			else if (pitch > 0.5f)
			{
				vecRocketsPitch.x += num2;
			}
			vecRocketsPitch.x = Mathf.Clamp(vecRocketsPitch.x, -45f, 45f);
		}
		else
		{
			vecRocketsPitch.x = Mathf.Lerp(vecRocketsPitch.x, 0f, Time.deltaTime * 1.7f);
		}
		rocketsPitch.localEulerAngles = vecRocketsPitch;
	}

	private void TrackSpotLight()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)targetSpotLight != (Object)null)
		{
			Vector3 val = targetSpotLight.position - spotLightYaw.position;
			_ = ((Vector3)(ref val)).normalized;
			CalculateYawPitchOffset(spotLightYaw, spotLightYaw.position, targetSpotLight.position, out var yaw, out var pitch);
			yaw = NormalizeYaw(yaw);
			float num = Time.deltaTime * spotLightTurnSpeed;
			if (yaw < -0.5f)
			{
				vecSpotLightBase.y = (vecSpotLightBase.y - num) % 360f;
			}
			else if (yaw > 0.5f)
			{
				vecSpotLightBase.y = (vecSpotLightBase.y + num) % 360f;
			}
			spotLightYaw.localEulerAngles = vecSpotLightBase;
			CalculateYawPitchOffset(spotLightPitch, spotLightPitch.position, targetSpotLight.position, out yaw, out pitch);
			if (pitch < -0.5f)
			{
				vecSpotLight.x -= num;
			}
			else if (pitch > 0.5f)
			{
				vecSpotLight.x += num;
			}
			vecSpotLight.x = Mathf.Clamp(vecSpotLight.x, -50f, 50f);
			spotLightPitch.localEulerAngles = vecSpotLight;
			m2Animator.SetFloat("sideMG_pitch", vecSpotLight.x, 0.5f, Time.deltaTime);
		}
	}

	private void TrackSideGuns()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < sideguns.Length; i++)
		{
			if (!((Object)(object)targetSideguns[i] == (Object)null))
			{
				Vector3 val = targetSideguns[i].position - sideguns[i].position;
				_ = ((Vector3)(ref val)).normalized;
				CalculateYawPitchOffset(sideguns[i], sideguns[i].position, targetSideguns[i].position, out var yaw, out var pitch);
				yaw = NormalizeYaw(yaw);
				float num = Time.deltaTime * sidegunsTurnSpeed;
				if (yaw < -0.5f)
				{
					vecSideGunRotation[i].y -= num;
				}
				else if (yaw > 0.5f)
				{
					vecSideGunRotation[i].y += num;
				}
				if (pitch < -0.5f)
				{
					vecSideGunRotation[i].x -= num;
				}
				else if (pitch > 0.5f)
				{
					vecSideGunRotation[i].x += num;
				}
				vecSideGunRotation[i].x = Mathf.Clamp(vecSideGunRotation[i].x, -45f, 45f);
				vecSideGunRotation[i].y = Mathf.Clamp(vecSideGunRotation[i].y, -45f, 45f);
				sideguns[i].localEulerAngles = vecSideGunRotation[i];
			}
		}
	}

	public void CalculateYawPitchOffset(Transform objectTransform, Vector3 vecStart, Vector3 vecEnd, out float yaw, out float pitch)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = objectTransform.InverseTransformDirection(vecEnd - vecStart);
		float num = Mathf.Sqrt(val.x * val.x + val.z * val.z);
		pitch = (0f - Mathf.Atan2(val.y, num)) * (180f / MathF.PI);
		Vector3 val2 = vecEnd - vecStart;
		val = ((Vector3)(ref val2)).normalized;
		Vector3 forward = objectTransform.forward;
		forward.y = 0f;
		((Vector3)(ref forward)).Normalize();
		float num2 = Vector3.Dot(val, forward);
		float num3 = Vector3.Dot(val, objectTransform.right);
		float num4 = 360f * num3;
		float num5 = 360f * (0f - num2);
		yaw = (Mathf.Atan2(num4, num5) + MathF.PI) * (180f / MathF.PI);
	}

	public float NormalizeYaw(float flYaw)
	{
		if (flYaw > 180f)
		{
			return 360f - flYaw;
		}
		return flYaw * -1f;
	}
}


using UnityEngine;

public class M2BradleyPhysics : MonoBehaviour
{
	private m2bradleyAnimator m2Animator;

	public WheelCollider[] Wheels;

	public WheelCollider[] TurningWheels;

	public Rigidbody mainRigidbody;

	public Transform[] waypoints;

	private Vector3 currentWaypoint;

	private Vector3 nextWaypoint;
}


using System.Collections.Generic;
using CompanionServer;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class MapMarker : BaseEntity
{
	public enum ClusterType
	{
		None,
		Vending
	}

	public AppMarkerType appType;

	public GameObjectRef markerObj;

	public static readonly List<MapMarker> serverMapMarkers = new List<MapMarker>();

	public override void InitShared()
	{
		if (base.isServer && !serverMapMarkers.Contains(this))
		{
			serverMapMarkers.Add(this);
		}
		base.InitShared();
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			serverMapMarkers.Remove(this);
		}
		base.DestroyShared();
	}

	public virtual AppMarker GetAppMarkerData()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		AppMarker obj = Pool.Get<AppMarker>();
		Vector2 val = CompanionServer.Util.WorldToMap(((Component)this).transform.position);
		obj.id = net.ID;
		obj.type = appType;
		obj.x = val.x;
		obj.y = val.y;
		return obj;
	}
}


public enum ClusterType
{
	None,
	Vending
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;

public class MapMarkerMissionProvider : MapMarker
{
	private List<BaseMission> missionsProvided = new List<BaseMission>();

	private string providerToken = string.Empty;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.missionMapMarker == null)
		{
			return;
		}
		if (info.msg.missionMapMarker.missionIds != null)
		{
			missionsProvided.Clear();
			foreach (uint missionId in info.msg.missionMapMarker.missionIds)
			{
				BaseMission fromID = MissionManifest.GetFromID(missionId);
				if (fromID != null)
				{
					missionsProvided.Add(fromID);
				}
			}
		}
		providerToken = info.msg.missionMapMarker.providerToken;
	}

	public void AssignMissions(List<BaseMission> missions, string token)
	{
		missionsProvided.Clear();
		foreach (BaseMission mission in missions)
		{
			missionsProvided.Add(mission);
		}
		providerToken = token;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.missionMapMarker = Pool.Get<MissionMapMarker>();
		info.msg.missionMapMarker.missionIds = Pool.Get<List<uint>>();
		foreach (BaseMission item in missionsProvided)
		{
			info.msg.missionMapMarker.missionIds.Add(item.id);
		}
		info.msg.missionMapMarker.providerToken = providerToken;
	}
}


using UnityEngine;

public class PaintableItem : MonoBehaviour
{
	public MeshPaintableSource PaintableSource;
}


using UnityEngine;

public class AIHelicopterAnimation : MonoBehaviour
{
	public PatrolHelicopterAI _ai;

	public float swayAmount = 1f;

	public float impactSwayAmount = 1f;

	public float lastStrafeScalar;

	public float lastForwardBackScalar;

	public float degreeMax = 90f;

	public Vector3 lastPosition = Vector3.zero;

	public float oldMoveSpeed;

	public float smoothRateOfChange;

	public float flareAmount;

	public float swaySmoothingFactor = 0.1f;

	private float smoothedTime;

	private void Awake()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
	}

	public void UpdateAnimation()
	{
		UpdateForwardBackTilting();
		UpdateStrafeTilting();
		ModifyHelicopterAngles();
		smoothedTime = Mathf.Lerp(smoothedTime, Time.time, swaySmoothingFactor * Time.deltaTime);
	}

	public void UpdateLastPosition()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		lastPosition = ((Component)this).transform.position;
	}

	private void UpdateForwardBackTilting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentMoveDirection = GetCurrentMoveDirection();
		float num = Vector3.Angle(currentMoveDirection, ((Component)this).transform.forward);
		float num2 = Vector3.Angle(currentMoveDirection, -((Component)this).transform.forward);
		float num3 = 1f - Mathf.Clamp01(num / degreeMax);
		float num4 = 1f - Mathf.Clamp01(num2 / degreeMax);
		float num5 = num3 - num4;
		lastForwardBackScalar = Mathf.Lerp(lastForwardBackScalar, num5, Time.deltaTime * 2f);
	}

	private void UpdateStrafeTilting()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		Vector3 currentMoveDirection = GetCurrentMoveDirection();
		float num = Vector3.Angle(currentMoveDirection, ((Component)this).transform.right);
		float num2 = Vector3.Angle(currentMoveDirection, -((Component)this).transform.right);
		float num3 = 1f - Mathf.Clamp01(num / degreeMax);
		float num4 = 1f - Mathf.Clamp01(num2 / degreeMax);
		float num5 = num3 - num4;
		lastStrafeScalar = Mathf.Lerp(lastStrafeScalar, num5, Time.deltaTime * 2f);
	}

	private void ModifyHelicopterAngles()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 zero = Vector3.zero;
		zero.x += lastForwardBackScalar * impactSwayAmount;
		zero.z -= lastStrafeScalar * impactSwayAmount;
		zero.x += Mathf.Sin(smoothedTime) * swayAmount;
		zero.z -= Mathf.Cos(smoothedTime) * swayAmount / 2f;
		Quaternion localRotation = Quaternion.Euler(zero.x, zero.y, zero.z);
		_ai.helicopterBase.rotorPivot.transform.localRotation = localRotation;
	}

	private Vector3 GetCurrentMoveDirection()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position - lastPosition;
		return ((Vector3)(ref val)).normalized;
	}
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class HelicopterDebris : ServerGib
{
	public ItemDefinition metalFragments;

	public ItemDefinition hqMetal;

	public ItemDefinition charcoal;

	[Tooltip("Divide mass by this amount to produce a scalar of resources, default = 5")]
	public float massReductionScalar = 5f;

	private ResourceDispenser resourceDispenser;

	public float tooHotUntil;

	public override void ServerInit()
	{
		base.ServerInit();
		tooHotUntil = Time.realtimeSinceStartup + 480f;
	}

	public override void PhysicsInit(Mesh mesh)
	{
		base.PhysicsInit(mesh);
		if (!base.isServer)
		{
			return;
		}
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		float num = Mathf.Clamp01(((Component)this).GetComponent<Rigidbody>().mass / massReductionScalar);
		resourceDispenser.containedItems = new List<ItemAmount>();
		if (num > 0.75f && (Object)(object)hqMetal != (Object)null)
		{
			resourceDispenser.containedItems.Add(new ItemAmount(hqMetal, Mathf.CeilToInt(7f * num)));
		}
		if (num > 0f)
		{
			if ((Object)(object)metalFragments != (Object)null)
			{
				resourceDispenser.containedItems.Add(new ItemAmount(metalFragments, Mathf.CeilToInt(150f * num)));
			}
			if ((Object)(object)charcoal != (Object)null)
			{
				resourceDispenser.containedItems.Add(new ItemAmount(charcoal, Mathf.CeilToInt(80f * num)));
			}
		}
		resourceDispenser.Initialize();
	}

	public bool IsTooHot()
	{
		return tooHotUntil > Time.realtimeSinceStartup;
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		if (IsTooHot() && info.WeaponPrefab is BaseMelee)
		{
			if (info.Initiator is BasePlayer)
			{
				HitInfo hitInfo = new HitInfo();
				hitInfo.damageTypes.Add(DamageType.Heat, 5f);
				hitInfo.DoHitEffects = true;
				hitInfo.DidHit = true;
				hitInfo.HitBone = 0u;
				hitInfo.Initiator = this;
				hitInfo.PointStart = ((Component)this).transform.position;
				Effect.server.Run("assets/bundled/prefabs/fx/impacts/additive/fire.prefab", info.Initiator, 0u, new Vector3(0f, 1f, 0f), Vector3.up);
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)resourceDispenser))
			{
				resourceDispenser.OnAttacked(info);
			}
			base.OnAttacked(info);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Oxide.Core;
using UnityEngine;

public class HelicopterTurret : MonoBehaviour
{
	public PatrolHelicopterAI _heliAI;

	public float fireRate = 0.125f;

	public float burstLength = 3f;

	public float timeBetweenBursts = 3f;

	public float maxTargetRange = 300f;

	public float loseTargetAfter = 5f;

	public Transform gun_yaw;

	public Transform gun_pitch;

	public Transform muzzleTransform;

	public bool left;

	public BaseCombatEntity _target;

	private float lastBurstTime = float.NegativeInfinity;

	private float lastFireTime = float.NegativeInfinity;

	private float lastSeenTargetTime = float.NegativeInfinity;

	private bool targetVisible;

	public void SetTarget(BaseCombatEntity newTarget)
	{
		if (Interface.CallHook("OnHelicopterTarget", (object)this, (object)newTarget) == null)
		{
			_target = newTarget;
			UpdateTargetVisibility();
		}
	}

	public bool NeedsNewTarget()
	{
		if (HasTarget())
		{
			if (!targetVisible)
			{
				return TimeSinceTargetLastSeen() > loseTargetAfter;
			}
			return false;
		}
		return true;
	}

	public bool UpdateTargetFromList(List<PatrolHelicopterAI.targetinfo> newTargetList)
	{
		int num = Random.Range(0, newTargetList.Count);
		int num2 = newTargetList.Count;
		while (num2 >= 0)
		{
			num2--;
			PatrolHelicopterAI.targetinfo targetinfo = newTargetList[num];
			if (targetinfo != null && (Object)(object)targetinfo.ent != (Object)null && targetinfo.IsVisible() && InFiringArc(targetinfo.ply))
			{
				SetTarget(targetinfo.ply);
				return true;
			}
			num++;
			if (num >= newTargetList.Count)
			{
				num = 0;
			}
		}
		return false;
	}

	public bool TargetVisible()
	{
		UpdateTargetVisibility();
		return targetVisible;
	}

	public float TimeSinceTargetLastSeen()
	{
		return Time.realtimeSinceStartup - lastSeenTargetTime;
	}

	public bool HasTarget()
	{
		return (Object)(object)_target != (Object)null;
	}

	public void ClearTarget()
	{
		_target = null;
		targetVisible = false;
	}

	public void TurretThink()
	{
		if (HasTarget() && TimeSinceTargetLastSeen() > loseTargetAfter * 2f)
		{
			ClearTarget();
		}
		if (HasTarget())
		{
			if (Time.time - lastBurstTime > burstLength + timeBetweenBursts && TargetVisible())
			{
				lastBurstTime = Time.time;
			}
			if (Time.time < lastBurstTime + burstLength && Time.time - lastFireTime >= fireRate && InFiringArc(_target))
			{
				lastFireTime = Time.time;
				FireGun();
			}
		}
	}

	public void FireGun()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		_heliAI.FireGun(((Component)_target).transform.position + new Vector3(0f, 0.25f, 0f), ConVar.PatrolHelicopter.bulletAccuracy, left);
	}

	public Vector3 GetPositionForEntity(BaseCombatEntity potentialtarget)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)potentialtarget).transform.position;
	}

	public float AngleToTarget(BaseCombatEntity potentialtarget)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		Vector3 positionForEntity = GetPositionForEntity(potentialtarget);
		Vector3 position = muzzleTransform.position;
		Vector3 val = positionForEntity - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		return Vector3.Angle(left ? (-((Component)_heliAI).transform.right) : ((Component)_heliAI).transform.right, normalized);
	}

	public bool InFiringArc(BaseCombatEntity potentialtarget)
	{
		object obj = Interface.CallHook("CanBeTargeted", (object)potentialtarget, (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return AngleToTarget(potentialtarget) < 80f;
	}

	public void UpdateTargetVisibility()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (HasTarget())
		{
			Vector3 position = ((Component)_target).transform.position;
			BasePlayer basePlayer = _target as BasePlayer;
			if (Object.op_Implicit((Object)(object)basePlayer))
			{
				position = basePlayer.eyes.position;
			}
			bool flag = false;
			float num = Vector3.Distance(position, muzzleTransform.position);
			Vector3 val = position - muzzleTransform.position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			if (num < maxTargetRange && InFiringArc(_target) && GamePhysics.Trace(new Ray(muzzleTransform.position + normalized * 6f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417, (QueryTriggerInteraction)0) && (Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).gameObject.ToBaseEntity() == (Object)(object)_target)
			{
				flag = true;
			}
			if (flag)
			{
				lastSeenTargetTime = Time.realtimeSinceStartup;
			}
			targetVisible = flag;
		}
	}
}


using System;
using UnityEngine;

public class LockedByEntCrate : LootContainer
{
	public GameObject lockingEnt;

	public void SetLockingEnt(GameObject ent)
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Think);
		SetLocked(isLocked: false);
		lockingEnt = ent;
		if ((Object)(object)lockingEnt != (Object)null)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)Think, Random.Range(0f, 1f), 1f);
			SetLocked(isLocked: true);
		}
	}

	public void SetLocked(bool isLocked)
	{
		SetFlag(Flags.OnFire, isLocked);
		SetFlag(Flags.Locked, isLocked);
	}

	public void Think()
	{
		if ((Object)(object)lockingEnt == (Object)null && IsLocked())
		{
			SetLockingEnt(null);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Text;
using ConVar;
using Facepunch;
using Oxide.Core;
using Rust;
using Rust.Ai;
using UnityEngine;

public class PatrolHelicopterAI : BaseMonoBehaviour
{
	public class targetinfo
	{
		public BasePlayer ply;

		public BaseEntity ent;

		public float lastSeenTime = float.PositiveInfinity;

		public float visibleFor;

		public float nextLOSCheck;

		public targetinfo(BaseEntity initEnt, BasePlayer initPly = null)
		{
			ply = initPly;
			ent = initEnt;
			lastSeenTime = float.PositiveInfinity;
			nextLOSCheck = Time.realtimeSinceStartup + 1.5f;
		}

		public bool IsVisible()
		{
			return TimeSinceSeen() < 1.5f;
		}

		public float TimeSinceSeen()
		{
			return Time.realtimeSinceStartup - lastSeenTime;
		}
	}

	public class DangerZone
	{
		public float Radius;

		private float score;

		private float lastActiveTime = Time.realtimeSinceStartup;

		private const float isStaleTime = 5f;

		private Vector3 centre;

		private BaseEntity parent;

		public Vector3 Centre
		{
			get
			{
				//IL_0021: Unknown result type (might be due to invalid IL or missing references)
				//IL_0026: Unknown result type (might be due to invalid IL or missing references)
				//IL_000f: Unknown result type (might be due to invalid IL or missing references)
				if ((Object)(object)parent == (Object)null)
				{
					return centre;
				}
				return ((Component)parent).transform.TransformPoint(centre);
			}
		}

		public float Score
		{
			get
			{
				return score;
			}
			set
			{
				score = value;
				lastActiveTime = Time.realtimeSinceStartup;
			}
		}

		public float LastActiveTime => lastActiveTime;

		public DangerZone(Vector3 centre, float radius = 20f, BaseEntity parent = null)
		{
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)parent == (Object)null)
			{
				this.centre = centre;
			}
			else
			{
				this.centre = ((Component)parent).transform.InverseTransformPoint(centre);
			}
			this.parent = parent;
			Radius = radius;
		}

		public bool IsPointInside(Vector3 point)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			return Vector3.Distance(point, Centre) <= Radius;
		}

		public bool IsStale()
		{
			return Time.realtimeSinceStartup - lastActiveTime > 5f;
		}

		public Vector3 GetNearestEdge(Vector3 point)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = point - Centre;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			normalized.y = 0f;
			return Centre + normalized * Radius;
		}
	}

	public enum aiState
	{
		IDLE,
		MOVE,
		ORBIT,
		STRAFE,
		PATROL,
		ORBITSTRAFE,
		GUARD,
		FLEE,
		DEATH
	}

	public Vector3 interestZoneOrigin;

	public Vector3 destination;

	public bool hasInterestZone;

	public float moveSpeed;

	public float maxSpeed = 25f;

	public float courseAdjustLerpTime = 2f;

	public Quaternion targetRotation;

	public Vector3 windVec;

	public Vector3 targetWindVec;

	public float windForce = 5f;

	public float windFrequency = 1f;

	public float targetThrottleSpeed;

	public float throttleSpeed;

	public float maxRotationSpeed = 90f;

	public float rotationSpeed;

	public float terrainPushForce = 100f;

	public float obstaclePushForce = 100f;

	public HelicopterTurret leftGun;

	public HelicopterTurret rightGun;

	public static PatrolHelicopterAI heliInstance;

	public PatrolHelicopter helicopterBase;

	public aiState _currentState;

	public float oceanDepthTargetCutoff = 3f;

	public AIHelicopterAnimation anim;

	private Vector3 _aimTarget;

	private bool movementLockingAiming;

	private bool hasAimTarget;

	private bool aimDoorSide;

	private Vector3 pushVec = Vector3.zero;

	private Vector3 _lastPos;

	private Vector3 _lastMoveDir;

	public bool isDead;

	public bool isRetiring;

	public float spawnTime;

	public float lastDamageTime;

	private bool forceTerrainPushback;

	[ServerVar]
	public static float flee_damage_percentage = 0.35f;

	[ServerVar]
	public static bool use_danger_zones = true;

	[ServerVar]
	public static bool monument_crash = true;

	private bool shouldDebug;

	public List<targetinfo> _targetList = new List<targetinfo>();

	private HashSet<BasePlayer> _targetSet = new HashSet<BasePlayer>();

	public List<DangerZone> dangerZones = new List<DangerZone>();

	public List<DangerZone> noGoZones = new List<DangerZone>();

	private const int max_zones = 20;

	private const float no_go_zone_size = 250f;

	private const float danger_zone_size = 20f;

	private DangerZone leastActiveZone;

	private float deathTimeout;

	private bool didImpact;

	private Collider[] collisions;

	private bool reachedSpinoutLocation;

	private float destination_min_dist = 2f;

	private float currentOrbitDistance;

	private float currentOrbitTime;

	private bool hasEnteredOrbit;

	private float orbitStartTime;

	public float maxOrbitDuration = 30f;

	private bool breakingOrbit;

	private float timeBetweenRocketsOrbit = 0.5f;

	private bool didGetToDesination;

	public List<MonumentInfo> _visitedMonuments;

	public float arrivalTime;

	public GameObjectRef rocketProjectile;

	public GameObjectRef rocketProjectile_Napalm;

	public bool leftTubeFiredLast;

	public float lastRocketTime;

	public float timeBetweenRockets = 0.2f;

	public int numRocketsLeft = 12;

	public const int maxRockets = 12;

	public Vector3 strafe_target_position;

	[NonSerialized]
	public BasePlayer strafe_target;

	public bool puttingDistance;

	public const float strafe_approach_range = 175f;

	public const float strafe_firing_range = 150f;

	private float get_out_of_strafe_distance = 15f;

	private bool passNapalm;

	private Vector3 cached_strafe_pos;

	private TimeSince timeSinceRefreshed;

	private bool useNapalm;

	[NonSerialized]
	public float lastNapalmTime = float.NegativeInfinity;

	[NonSerialized]
	public float lastStrafeTime = float.NegativeInfinity;

	private float _lastThinkTime;

	public bool IsDead => isDead;

	[ServerVar]
	private void dumpstate()
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine("[State] " + _currentState);
		stringBuilder.AppendLine($"[Has Interest Zone] {hasInterestZone}");
		stringBuilder.AppendLine($"[Interest Zone] {interestZoneOrigin}");
		stringBuilder.AppendLine($"[Target Count] {_targetList.Count}");
		stringBuilder.AppendLine($"[Retiring] {isRetiring}");
		stringBuilder.AppendLine($"[Has Entered Orbit] {hasEnteredOrbit}");
		stringBuilder.AppendLine($"[Breaking Orbit] {breakingOrbit}");
		stringBuilder.AppendLine($"[Orbit Distance] {currentOrbitDistance}");
		Debug.Log((object)stringBuilder.ToString());
	}

	public void Awake()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.PatrolHelicopter.lifetimeMinutes == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)DestroyMe, 1f);
			return;
		}
		((FacepunchBehaviour)this).InvokeRepeating((Action)UpdateWind, 0f, 1f / windFrequency);
		_lastPos = ((Component)this).transform.position;
		spawnTime = Time.realtimeSinceStartup;
		InitializeAI();
	}

	public void SetInitialDestination(Vector3 dest, float mapScaleDistance = 0.25f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		hasInterestZone = true;
		interestZoneOrigin = dest;
		float x = TerrainMeta.Size.x;
		float y = dest.y + 25f;
		Vector3 val = Vector3Ex.Range(-1f, 1f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * mapScaleDistance;
		val.y = y;
		if (mapScaleDistance == 0f)
		{
			val = interestZoneOrigin + new Vector3(0f, 10f, 0f);
		}
		((Component)this).transform.position = val;
		ExitCurrentState();
		State_Move_Enter(dest);
	}

	public void Retire()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (!isRetiring && Interface.CallHook("OnHelicopterRetire", (object)this) == null)
		{
			((FacepunchBehaviour)this).Invoke((Action)DestroyMe, 240f);
			float x = TerrainMeta.Size.x;
			float y = 200f;
			Vector3 val = Vector3Ex.Range(-1f, 1f);
			val.y = 0f;
			((Vector3)(ref val)).Normalize();
			val *= x * 20f;
			val.y = y;
			ExitCurrentState();
			isRetiring = true;
			State_Move_Enter(val);
		}
	}

	public void SetIdealRotation(Quaternion newTargetRot, float rotationSpeedOverride = -1f)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		float num = ((rotationSpeedOverride == -1f) ? Mathf.Clamp01(moveSpeed / (maxSpeed * 0.5f)) : rotationSpeedOverride);
		rotationSpeed = num * maxRotationSpeed;
		targetRotation = newTargetRot;
	}

	public Quaternion GetYawRotationTo(Vector3 targetDest)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = targetDest;
		val.y = 0f;
		Vector3 position = ((Component)this).transform.position;
		position.y = 0f;
		Vector3 val2 = val - position;
		Vector3 normalized = ((Vector3)(ref val2)).normalized;
		if (!(normalized != Vector3.zero))
		{
			return Quaternion.identity;
		}
		return Quaternion.LookRotation(normalized);
	}

	public void SetTargetDestination(Vector3 targetDest, float minDist = 5f, float minDistForFacingRotation = 30f)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		destination = targetDest;
		destination_min_dist = minDist;
		float num = Vector3.Distance(targetDest, ((Component)this).transform.position);
		if (num > minDistForFacingRotation && !IsTargeting())
		{
			SetIdealRotation(GetYawRotationTo(destination));
		}
		targetThrottleSpeed = GetThrottleForDistance(num);
	}

	public bool AtDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(((Component)this).transform.position, destination) < destination_min_dist;
	}

	public bool AtRotation()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Quaternion.Angle(((Component)this).transform.rotation, targetRotation) <= 8f;
	}

	private void NoGoZoneAdded(DangerZone zone)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (use_danger_zones && Interface.CallHook("OnNoGoZoneAdded", (object)this, (object)zone) == null && zone.IsPointInside(((Component)this).transform.position))
		{
			ClearTargets();
			ExitCurrentState();
			Vector3 nearestEdge = zone.GetNearestEdge(((Component)this).transform.position);
			nearestEdge.y = Random.Range(35f, 45f);
			State_Flee_Enter(nearestEdge);
		}
	}

	public void MoveToDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		Vector3 lastMoveDir = _lastMoveDir;
		Vector3 val = destination - ((Component)this).transform.position;
		Vector3 val2 = (_lastMoveDir = Vector3.Lerp(lastMoveDir, ((Vector3)(ref val)).normalized, Time.deltaTime / courseAdjustLerpTime));
		throttleSpeed = Mathf.Lerp(throttleSpeed, targetThrottleSpeed, Time.deltaTime / 3f);
		float num = throttleSpeed * maxSpeed;
		TerrainPushback();
		Vector3 val3 = windVec * windForce * Time.deltaTime;
		Vector3 val4 = val2 * num * Time.deltaTime;
		Transform transform = ((Component)this).transform;
		transform.position += val4 + val3;
		moveSpeed = Mathf.Lerp(moveSpeed, Vector3.Distance(_lastPos, ((Component)this).transform.position) / Time.deltaTime, Time.deltaTime * 2f);
		_lastPos = ((Component)this).transform.position;
	}

	public void TerrainPushback()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		//IL_015d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		if (_currentState != aiState.DEATH || forceTerrainPushback)
		{
			Vector3 val = ((Component)this).transform.position + new Vector3(0f, 2f, 0f);
			Vector3 val2 = destination - val;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			float num = Vector3.Distance(destination, ((Component)this).transform.position);
			Ray val3 = default(Ray);
			((Ray)(ref val3))..ctor(val, normalized);
			float num2 = 5f;
			float num3 = Mathf.Min(100f, num);
			int mask = LayerMask.GetMask(new string[3] { "Terrain", "World", "Construction" });
			Vector3 val4 = Vector3.zero;
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(val3, num2, ref val5, num3 - num2 * 0.5f, mask))
			{
				float num4 = 1f - ((RaycastHit)(ref val5)).distance / num3;
				float num5 = terrainPushForce * num4;
				val4 = Vector3.up * num5;
			}
			Ray val6 = new Ray(val, _lastMoveDir);
			float num6 = Mathf.Min(10f, num);
			RaycastHit val7 = default(RaycastHit);
			if (Physics.SphereCast(val6, num2, ref val7, num6 - num2 * 0.5f, mask))
			{
				float num7 = 1f - ((RaycastHit)(ref val7)).distance / num6;
				float num8 = obstaclePushForce * num7;
				val4 += _lastMoveDir * num8 * -1f;
				val4 += Vector3.up * num8;
			}
			float num9 = ((Component)this).transform.position.y - WaterSystem.OceanLevel;
			if (num9 < num6)
			{
				float num10 = 1f - num9 / num6;
				float num11 = terrainPushForce * num9 * num10;
				val4 += Vector3.up * num11;
			}
			pushVec = Vector3.Lerp(pushVec, val4, Time.deltaTime);
			Transform transform = ((Component)this).transform;
			transform.position += pushVec * Time.deltaTime;
		}
	}

	public void UpdateRotation()
	{
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		if (hasAimTarget)
		{
			Vector3 position = ((Component)this).transform.position;
			position.y = 0f;
			Vector3 aimTarget = _aimTarget;
			aimTarget.y = 0f;
			Vector3 val = aimTarget - position;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			Vector3 val2 = Vector3.Cross(normalized, Vector3.up);
			float num = Vector3.Angle(normalized, ((Component)this).transform.right);
			float num2 = Vector3.Angle(normalized, -((Component)this).transform.right);
			if (aimDoorSide)
			{
				if (num < num2)
				{
					targetRotation = Quaternion.LookRotation(val2);
				}
				else
				{
					targetRotation = Quaternion.LookRotation(-val2);
				}
			}
			else
			{
				targetRotation = Quaternion.LookRotation(normalized);
			}
		}
		rotationSpeed = Mathf.Lerp(rotationSpeed, maxRotationSpeed, Time.deltaTime / 2f);
		((Component)this).transform.rotation = Quaternion.Lerp(((Component)this).transform.rotation, targetRotation, rotationSpeed * Time.deltaTime);
	}

	public void UpdateSpotlight()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		if (hasInterestZone)
		{
			helicopterBase.spotlightTarget = new Vector3(interestZoneOrigin.x, TerrainMeta.HeightMap.GetHeight(interestZoneOrigin), interestZoneOrigin.z);
		}
		else
		{
			helicopterBase.spotlightTarget = Vector3.zero;
		}
	}

	public void Update()
	{
		if (helicopterBase.isClient)
		{
			return;
		}
		heliInstance = this;
		UpdateTargetList();
		MoveToDestination();
		UpdateRotation();
		UpdateSpotlight();
		anim.UpdateAnimation();
		anim.UpdateLastPosition();
		AIThink();
		DoMachineGuns();
		if (!isRetiring && !isDead)
		{
			float num = Mathf.Max(spawnTime + ConVar.PatrolHelicopter.lifetimeMinutes * 60f, lastDamageTime + 180f);
			if (Time.realtimeSinceStartup > num)
			{
				Retire();
			}
		}
	}

	public void FixedUpdate()
	{
		if (_currentState == aiState.DEATH)
		{
			PhysicsDeathCheck();
		}
	}

	public void OtherDamaged(HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!((Object)(object)basePlayer == (Object)null) && use_danger_zones)
		{
			UpdateDangerZones(((Component)basePlayer).transform.position, info.damageTypes.Total(), basePlayer);
		}
	}

	public void WeakspotDamaged(PatrolHelicopter.weakspot weak, HitInfo info)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!((Object)(object)basePlayer == (Object)null))
		{
			if (use_danger_zones)
			{
				UpdateDangerZones(((Component)basePlayer).transform.position, info.damageTypes.Total(), basePlayer, weak);
			}
			else
			{
				TryStrafePlayer(info, 5f);
			}
		}
	}

	public void TryStrafePlayer(HitInfo info, float timeSinceDamagedThreshold)
	{
		if (!isRetiring && IsAlive() && _currentState != aiState.FLEE)
		{
			BasePlayer basePlayer = info.Initiator as BasePlayer;
			bool num = ValidRocketTarget(basePlayer);
			bool flag = num && CanStrafe();
			bool flag2 = !num && CanUseNapalm();
			float num2 = Time.realtimeSinceStartup - lastDamageTime;
			lastDamageTime = Time.realtimeSinceStartup;
			if (num2 < timeSinceDamagedThreshold && (Object)(object)basePlayer != (Object)null && (flag || flag2))
			{
				ExitCurrentState();
				State_Strafe_Enter(basePlayer, flag2);
			}
		}
	}

	public void CriticalDamage()
	{
		isDead = true;
		ExitCurrentState();
		State_Death_Enter();
	}

	public void DoMachineGuns()
	{
		if (_targetList.Count > 0)
		{
			if (leftGun.NeedsNewTarget())
			{
				leftGun.UpdateTargetFromList(_targetList);
			}
			if (rightGun.NeedsNewTarget())
			{
				rightGun.UpdateTargetFromList(_targetList);
			}
		}
		leftGun.TurretThink();
		rightGun.TurretThink();
	}

	public void FireGun(Vector3 targetPos, float aimCone, bool left)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (ConVar.PatrolHelicopter.guns == 0)
		{
			return;
		}
		Vector3 position = (left ? helicopterBase.left_gun_muzzle.transform : helicopterBase.right_gun_muzzle.transform).position;
		Vector3 val = targetPos - position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		position += normalized * 2f;
		Vector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(aimCone, normalized);
		if (GamePhysics.Trace(new Ray(position, modifiedAimConeDirection), 0f, out var hitInfo, 300f, 1220225809, (QueryTriggerInteraction)0))
		{
			targetPos = ((RaycastHit)(ref hitInfo)).point;
			if (Object.op_Implicit((Object)(object)((RaycastHit)(ref hitInfo)).collider))
			{
				BaseEntity entity = hitInfo.GetEntity();
				if (Object.op_Implicit((Object)(object)entity) && (Object)(object)entity != (Object)(object)helicopterBase)
				{
					BaseCombatEntity baseCombatEntity = entity as BaseCombatEntity;
					HitInfo info = new HitInfo(helicopterBase, entity, DamageType.Bullet, helicopterBase.bulletDamage * ConVar.PatrolHelicopter.bulletDamageScale, ((RaycastHit)(ref hitInfo)).point);
					if (Object.op_Implicit((Object)(object)baseCombatEntity))
					{
						baseCombatEntity.OnAttacked(info);
						if (baseCombatEntity is BasePlayer)
						{
							Effect.server.ImpactEffect(new HitInfo
							{
								HitPositionWorld = ((RaycastHit)(ref hitInfo)).point - modifiedAimConeDirection * 0.25f,
								HitNormalWorld = -modifiedAimConeDirection,
								HitMaterial = StringPool.Get("Flesh")
							});
						}
					}
					else
					{
						entity.OnAttacked(info);
					}
				}
			}
		}
		else
		{
			targetPos = position + modifiedAimConeDirection * 300f;
		}
		helicopterBase.ClientRPC<bool, Vector3>(RpcTarget.NetworkGroup("FireGun"), left, targetPos);
	}

	public bool CanInterruptState()
	{
		aiState currentState = _currentState;
		return currentState == aiState.IDLE || currentState == aiState.MOVE || currentState == aiState.PATROL;
	}

	public bool IsAlive()
	{
		if (!isDead)
		{
			return _currentState != aiState.DEATH;
		}
		return false;
	}

	public void DestroyMe()
	{
		if (dangerZones != null)
		{
			helicopterBase.Kill();
		}
	}

	public Vector3 GetLastMoveDir()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _lastMoveDir;
	}

	public Vector3 GetMoveDirection()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = destination - ((Component)this).transform.position;
		return ((Vector3)(ref val)).normalized;
	}

	public float GetMoveSpeed()
	{
		return moveSpeed;
	}

	public float GetMaxRotationSpeed()
	{
		return maxRotationSpeed;
	}

	public bool IsTargeting()
	{
		return hasAimTarget;
	}

	public void UpdateWind()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		targetWindVec = Random.onUnitSphere;
	}

	public void SetAimTarget(Vector3 aimTarg, bool isDoorSide)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (!movementLockingAiming)
		{
			hasAimTarget = true;
			_aimTarget = aimTarg;
			aimDoorSide = isDoorSide;
		}
	}

	public void ClearAimTarget()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		hasAimTarget = false;
		_aimTarget = Vector3.zero;
	}

	public void UpdateTargetList()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0249: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer strafeTarget = null;
		bool flag = false;
		bool shouldUseNapalm = false;
		float num = 0f;
		targetinfo targetinfo = null;
		for (int num2 = _targetList.Count - 1; num2 >= 0; num2--)
		{
			targetinfo targetinfo2 = _targetList[num2];
			if (targetinfo2 == null || !targetinfo2.ent.IsValid())
			{
				RemoveTargetAt(num2);
			}
			else if (use_danger_zones && IsInNoGoZone(((Component)targetinfo2.ply).transform.position))
			{
				RemoveTargetAt(num2);
			}
			else if (AI.ignoreplayers || SimpleAIMemory.PlayerIgnoreList.Contains(targetinfo2.ply))
			{
				RemoveTargetAt(num2);
			}
			else
			{
				UpdateTargetLineOfSightTime(targetinfo2);
				bool flag2 = (Object.op_Implicit((Object)(object)targetinfo2.ply) ? targetinfo2.ply.IsDead() : (targetinfo2.ent.Health() <= 0f));
				if (targetinfo2.TimeSinceSeen() >= 6f || flag2)
				{
					bool flag3 = Random.Range(0f, 1f) >= 0f;
					if ((CanStrafe() || CanUseNapalm()) && IsAlive() && !flag && !flag2 && ((Object)(object)targetinfo2.ply == (Object)(object)leftGun._target || (Object)(object)targetinfo2.ply == (Object)(object)rightGun._target) && flag3)
					{
						shouldUseNapalm = !ValidRocketTarget(targetinfo2.ply) || Random.Range(0f, 1f) > 0.75f;
						flag = true;
						strafeTarget = targetinfo2.ply;
					}
					RemoveTargetAt(num2);
					if ((Object)(object)leftGun._target == (Object)(object)targetinfo2.ply)
					{
						leftGun._target = null;
					}
					if ((Object)(object)rightGun._target == (Object)(object)targetinfo2.ply)
					{
						rightGun._target = null;
					}
				}
				if (use_danger_zones && !flag && (CanStrafe() || CanUseNapalm()) && IsAlive() && (Time.realtimeSinceStartup - lastNapalmTime > 20f || Time.realtimeSinceStartup - lastStrafeTime > 15f) && IsInDangerZone(((Component)targetinfo2.ply).transform.position, out var dangerZone) && dangerZone != null && dangerZone.Score > num)
				{
					num = dangerZone.Score;
					targetinfo = targetinfo2;
				}
			}
		}
		if (use_danger_zones && !flag && targetinfo != null)
		{
			shouldUseNapalm = !ValidRocketTarget(targetinfo.ply) || Random.Range(0f, 1f) > 0.75f;
			flag = true;
			strafeTarget = targetinfo.ply;
			targetinfo = null;
		}
		AddNewTargetsToList();
		if (flag && !isRetiring && !isDead)
		{
			ExitCurrentState();
			State_Strafe_Enter(strafeTarget, shouldUseNapalm);
		}
	}

	private void UpdateTargetLineOfSightTime(targetinfo targ)
	{
		if (Time.realtimeSinceStartup > targ.nextLOSCheck)
		{
			targ.nextLOSCheck = Time.realtimeSinceStartup + 1f;
			if (PlayerVisible(targ.ply))
			{
				targ.lastSeenTime = Time.realtimeSinceStartup;
				targ.visibleFor += 1f;
			}
			else
			{
				targ.visibleFor = 0f;
			}
		}
	}

	private void AddNewTargetsToList()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.AddNewTargetsToList", 0);
		try
		{
			if (AI.ignoreplayers)
			{
				return;
			}
			PooledList<BasePlayer> val2 = Pool.Get<PooledList<BasePlayer>>();
			try
			{
				BaseEntity.Query.Server.GetPlayersInSphere(((Component)this).transform.position, 150f, (List<BasePlayer>)(object)val2, BaseEntity.Query.DistanceCheckType.None);
				foreach (BasePlayer item in (List<BasePlayer>)(object)val2)
				{
					if ((Object)(object)item == (Object)null || SimpleAIMemory.PlayerIgnoreList.Contains(item))
					{
						continue;
					}
					TimeWarning val3 = TimeWarning.New("PatrolHelicoperAI.SafeZone", 0);
					try
					{
						if (item.InSafeZone())
						{
							continue;
						}
					}
					finally
					{
						((IDisposable)val3)?.Dispose();
					}
					if (item.IsInTutorial)
					{
						continue;
					}
					TimeWarning val4 = TimeWarning.New("PatrolHelicoperAI.NoGoZone", 0);
					try
					{
						if (use_danger_zones && IsInNoGoZone(((Component)item).transform.position))
						{
							continue;
						}
					}
					finally
					{
						((IDisposable)val4)?.Dispose();
					}
					if (!IsAlreadyInTargets(item) && item.GetThreatLevel() > 0.5f && PlayerVisible(item))
					{
						TryAddTarget(item);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private bool TryAddTarget(BasePlayer ply)
	{
		if (IsAlreadyInTargets(ply))
		{
			return false;
		}
		_targetList.Add(new targetinfo(ply, ply));
		_targetSet.Add(ply);
		return true;
	}

	private void RemoveTargetAt(int i)
	{
		BasePlayer ply = _targetList[i].ply;
		_targetSet.Remove(ply);
		_targetList.RemoveAt(i);
	}

	private void ClearTargets()
	{
		_targetList.Clear();
		_targetSet.Clear();
	}

	private bool IsAlreadyInTargets(BasePlayer ply)
	{
		return _targetSet.Contains(ply);
	}

	private Vector3? FindTargetWithZones(bool withOffset = true)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		float num2 = 0f;
		for (int i = 0; i < _targetList.Count; i++)
		{
			if (use_danger_zones)
			{
				Vector3 position = ((Component)_targetList[i].ply).transform.position;
				if (!IsInNoGoZone(position) && IsInDangerZone(position, out var dangerZone) && dangerZone != null && dangerZone.Score > num2)
				{
					num2 = dangerZone.Score;
					num = i;
				}
			}
		}
		if (num == -1)
		{
			return null;
		}
		Vector3 val = Vector3.zero;
		if (withOffset)
		{
			val = GetTargetOffset();
		}
		return ((Component)_targetList[num].ply).transform.position + val;
	}

	private Vector3 FindDefaultTarget(bool withOffset = true)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		if (withOffset)
		{
			val = GetTargetOffset();
		}
		return ((Component)_targetList[0].ply).transform.position + val;
	}

	private Vector3 GetTargetOffset()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(0f, 20f, 0f);
	}

	public bool PlayerVisible(BasePlayer ply)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanHelicopterTarget", (object)this, (object)ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.PlayerVisible", 0);
		try
		{
			Vector3 position = ply.eyes.position;
			if (ply.eyes.position.y < WaterSystem.OceanLevel && Mathf.Abs(WaterSystem.OceanLevel - ply.eyes.position.y) > oceanDepthTargetCutoff)
			{
				return false;
			}
			if (TOD_Sky.Instance.IsNight && Vector3.Distance(position, interestZoneOrigin) > 40f)
			{
				return false;
			}
			Vector3 val2 = ((Component)this).transform.position - Vector3.up * 6f;
			float num = Vector3.Distance(position, val2);
			Vector3 val3 = position - val2;
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			if (GamePhysics.Trace(new Ray(val2 + normalized * 5f, normalized), 0f, out var hitInfo, num * 1.1f, 1218652417, (QueryTriggerInteraction)0) && (Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).gameObject.ToBaseEntity() == (Object)(object)ply)
			{
				return true;
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void WasAttacked(HitInfo info)
	{
		BasePlayer basePlayer = info.Initiator as BasePlayer;
		if (!(basePlayer is ScientistNPC) && basePlayer.IsValid())
		{
			TryAddTarget(basePlayer);
		}
	}

	public void UpdateDangerZones(Vector3 position, float damage, BasePlayer ply, PatrolHelicopter.weakspot weak = null)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		if (!use_danger_zones)
		{
			return;
		}
		if (IsInNoGoZone(position))
		{
			if (shouldDebug)
			{
				Debug.Log((object)"Inside no go zone - ignoring damage");
			}
			return;
		}
		float num = damage;
		if (weak != null)
		{
			if (shouldDebug)
			{
				Debug.Log((object)("Hit weakspot: " + num));
			}
			num = weak.body.MaxHealth() * weak.healthFractionOnDestroyed * (damage / weak.maxHealth);
			if (shouldDebug)
			{
				Debug.Log((object)("Potential Damage: " + num));
			}
		}
		if (dangerZones.Count == 0)
		{
			MakeZone(position, num, ply.GetParentEntity());
			return;
		}
		DangerZone dangerZone = null;
		bool flag = false;
		for (int num2 = dangerZones.Count - 1; num2 >= 0; num2--)
		{
			dangerZone = dangerZones[num2];
			if (dangerZone.IsStale())
			{
				if (shouldDebug)
				{
					Debug.Log((object)"zone is stale");
				}
				dangerZones.RemoveAt(num2);
			}
			else if (dangerZone.IsPointInside(position))
			{
				if (shouldDebug)
				{
					Debug.Log((object)("zone has " + dangerZone.Score + " score"));
				}
				if (leastActiveZone == null || dangerZone.LastActiveTime < leastActiveZone.LastActiveTime)
				{
					leastActiveZone = dangerZone;
				}
				dangerZone.Score += num;
				flag = true;
				UpdateNoGoZones(dangerZone);
				break;
			}
		}
		if (flag && shouldDebug)
		{
			Debug.Log((object)"We found a zone");
		}
		if (flag)
		{
			return;
		}
		if (shouldDebug)
		{
			Debug.Log((object)"making a new zone ");
		}
		if (dangerZones.Count + 1 > 20)
		{
			if (leastActiveZone != null && dangerZones.Contains(leastActiveZone))
			{
				dangerZones.Remove(leastActiveZone);
			}
			else
			{
				dangerZones.RemoveAt(0);
			}
		}
		MakeZone(position, num, ply.GetParentEntity());
	}

	public void MakeZone(Vector3 position, float damage, BaseEntity parent = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		DangerZone dangerZone = new DangerZone(position, 20f, parent);
		dangerZone.Score += damage;
		dangerZones.Add(dangerZone);
	}

	private void UpdateNoGoZones(DangerZone zone)
	{
		if (zone.Score >= helicopterBase.startHealth * flee_damage_percentage)
		{
			dangerZones.Remove(zone);
			zone.Radius = 250f;
			noGoZones.Add(zone);
			NoGoZoneAdded(zone);
		}
	}

	public void ClearStaleZones()
	{
		for (int num = dangerZones.Count - 1; num >= 0; num--)
		{
			if (dangerZones[num].IsStale())
			{
				dangerZones.RemoveAt(num);
			}
		}
	}

	private void RemoveLeastSignificantZone()
	{
		dangerZones.Sort((DangerZone a, DangerZone b) => a.Score.CompareTo(b.Score));
		dangerZones.RemoveAt(0);
	}

	public bool IsInNoGoZone(Vector3 position)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("PatrolHelicoperAI.IsInNoGoZone", 0);
		try
		{
			bool result = false;
			foreach (DangerZone noGoZone in noGoZones)
			{
				if (noGoZone.IsPointInside(position))
				{
					result = true;
				}
			}
			return result;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsInDangerZone(Vector3 position, out DangerZone dangerZone)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		dangerZone = null;
		foreach (DangerZone dangerZone2 in dangerZones)
		{
			if (dangerZone2.IsPointInside(position))
			{
				dangerZone = dangerZone2;
				result = true;
			}
		}
		return result;
	}

	public void State_Death_Think(float timePassed)
	{
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		if (!reachedSpinoutLocation)
		{
			if (AtDestination())
			{
				forceTerrainPushback = false;
				reachedSpinoutLocation = true;
				StartSpinout();
			}
			return;
		}
		float num = Time.realtimeSinceStartup * 0.25f;
		float num2 = Mathf.Sin(MathF.PI * 2f * num) * 10f;
		float num3 = Mathf.Cos(MathF.PI * 2f * num) * 10f;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(num2, 0f, num3);
		SetAimTarget(((Component)this).transform.position + val, isDoorSide: true);
		if (((Component)this).transform.position.y - WaterSystem.OceanLevel <= 0f)
		{
			didImpact = true;
		}
		if (reachedSpinoutLocation && (didImpact || Time.realtimeSinceStartup > deathTimeout))
		{
			KillOfNaturalCauses();
		}
	}

	public void State_Death_Enter()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.DEATH;
		if (collisions == null)
		{
			collisions = (Collider[])(object)new Collider[10];
		}
		MonumentInfo monumentInfo = null;
		if (monument_crash)
		{
			monumentInfo = GetCloseMonument(800f);
		}
		if ((Object)(object)monumentInfo == (Object)null)
		{
			reachedSpinoutLocation = true;
			StartSpinout();
			return;
		}
		forceTerrainPushback = true;
		Vector3 position = ((Component)monumentInfo).transform.position;
		position.y = TerrainMeta.HeightMap.GetHeight(position) + 200f;
		if (TransformUtil.GetGroundInfo(position, out var hitOut, 300f, LayerMask.op_Implicit(1235288065)))
		{
			position.y = ((RaycastHit)(ref hitOut)).point.y;
		}
		position.y += 30f;
		float distToTarget = Vector3.Distance(((Component)this).transform.position, destination);
		targetThrottleSpeed = GetThrottleForDistance(distToTarget);
		SetTargetDestination(position, 15f);
	}

	public void State_Death_Leave()
	{
	}

	private MonumentInfo GetCloseMonument(float maxDistance)
	{
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		MonumentInfo result = null;
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			float num = float.MaxValue;
			foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
			{
				if (monument.IsSafeZone)
				{
					continue;
				}
				MonumentType type = monument.Type;
				if (type == MonumentType.Mountain || type == MonumentType.Lighthouse || type == MonumentType.Lake || type == MonumentType.WaterWell || type == MonumentType.Cave || type == MonumentType.Building || monument.Tier == (MonumentTier)0 || ((Component)monument).transform.position.y < WaterSystem.OceanLevel || !monument.AllowPatrolHeliCrash)
				{
					continue;
				}
				float num2 = Vector3Ex.Distance2D(((Component)this).transform.position, ((Component)monument).transform.position);
				if (num2 < num)
				{
					num = num2;
					if (num <= maxDistance)
					{
						result = monument;
					}
				}
			}
		}
		return result;
	}

	private void PhysicsDeathCheck()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (!reachedSpinoutLocation)
		{
			return;
		}
		int mask = LayerMask.GetMask(new string[4] { "Terrain", "World", "Construction", "Water" });
		didImpact = false;
		Physics.OverlapSphereNonAlloc(((Component)this).transform.position, 5f, collisions, mask);
		Collider[] array = collisions;
		foreach (Collider val in array)
		{
			if (!((Object)(object)val == (Object)null) && !((Object)(object)((Component)val).gameObject == (Object)(object)((Component)this).gameObject))
			{
				didImpact = true;
				break;
			}
		}
	}

	private void KillOfNaturalCauses()
	{
		helicopterBase.Hurt(helicopterBase.health * 2f, DamageType.Generic, null, useProtection: false);
	}

	private void StartSpinout()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		maxRotationSpeed *= 8f;
		Vector3 randomOffset = GetRandomOffset(((Component)this).transform.position, 20f, 60f, 0f, 0f);
		int num = 1237003025;
		TransformUtil.GetGroundInfo(randomOffset - Vector3.up * 2f, out var pos, out var _, 500f, LayerMask.op_Implicit(num));
		SetTargetDestination(pos);
		targetThrottleSpeed = 0.5f;
		deathTimeout = Time.realtimeSinceStartup + 10f;
	}

	public void State_Flee_Think(float timePassed)
	{
		UpdateMove(timePassed);
	}

	public void State_Flee_Enter(Vector3 newPos)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.FLEE;
		helicopterBase.DoFlare();
		TryMove(newPos);
	}

	public void State_Flee_Leave()
	{
	}

	public void State_Idle_Think(float timePassed)
	{
		ExitCurrentState();
		State_Patrol_Enter();
	}

	public void State_Idle_Enter()
	{
		_currentState = aiState.IDLE;
	}

	public void State_Idle_Leave()
	{
	}

	public void State_Move_Think(float timePassed)
	{
		UpdateMove(timePassed);
	}

	public void State_Move_Enter(Vector3 newPos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.MOVE;
		TryMove(newPos);
	}

	public void State_Move_Leave()
	{
	}

	private void TryMove(Vector3 newPos)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		destination_min_dist = 10f;
		SetTargetDestination(newPos);
		float distToTarget = Vector3.Distance(((Component)this).transform.position, destination);
		targetThrottleSpeed = GetThrottleForDistance(distToTarget);
	}

	private void UpdateMove(float timePassed)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float distToTarget = Vector3.Distance(((Component)this).transform.position, destination);
		targetThrottleSpeed = GetThrottleForDistance(distToTarget);
		if (AtDestination())
		{
			ExitCurrentState();
			State_Idle_Enter();
		}
	}

	public void State_Orbit_Think(float timePassed)
	{
		OrbitUpdate(timePassed);
	}

	public Vector3 GetOrbitPosition(float rate)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Sin(rate) * currentOrbitDistance;
		float num2 = Mathf.Cos(rate) * currentOrbitDistance;
		Vector3 val = default(Vector3);
		((Vector3)(ref val))..ctor(num, 20f, num2);
		val = interestZoneOrigin + val;
		return val;
	}

	public void State_Orbit_Enter(float orbitDistance)
	{
		_currentState = aiState.ORBIT;
		OrbitInit(orbitDistance);
	}

	public void State_Orbit_Leave()
	{
		breakingOrbit = false;
		hasEnteredOrbit = false;
		currentOrbitTime = 0f;
		ClearAimTarget();
	}

	private void OrbitInit(float orbitDistance, float minDistForFacingRotation = 0f)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		breakingOrbit = false;
		hasEnteredOrbit = false;
		orbitStartTime = Time.realtimeSinceStartup;
		Vector3 val = ((Component)this).transform.position - interestZoneOrigin;
		currentOrbitTime = Mathf.Atan2(val.x, val.z);
		currentOrbitDistance = orbitDistance;
		ClearAimTarget();
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, interestZoneOrigin);
		if (num > orbitDistance && num < 120f)
		{
			currentOrbitDistance = num;
		}
		SetTargetDestination(GetOrbitPosition(currentOrbitTime), 20f, minDistForFacingRotation);
		if (shouldDebug)
		{
			DebugOrbit();
		}
	}

	private void OrbitUpdate(float timePassed, float minDistForFacingRotation = 1f, bool canBreak = true)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (breakingOrbit)
		{
			if (AtDestination())
			{
				ExitCurrentState();
				State_Idle_Enter();
			}
		}
		else
		{
			if (Vector3Ex.Distance2D(((Component)this).transform.position, destination) > 15f)
			{
				return;
			}
			if (!hasEnteredOrbit)
			{
				hasEnteredOrbit = true;
				orbitStartTime = Time.realtimeSinceStartup;
			}
			if (_targetList.Count == 0 && !isRetiring && canBreak)
			{
				StartBreakOrbit();
				return;
			}
			float num = MathF.PI * 2f * currentOrbitDistance;
			float num2 = 0.5f * maxSpeed;
			float num3 = num / num2;
			currentOrbitTime += timePassed / num3;
			float rate = currentOrbitTime * 30f;
			Vector3 orbitPosition = GetOrbitPosition(rate);
			ClearAimTarget();
			SetTargetDestination(orbitPosition, 2f, minDistForFacingRotation);
			targetThrottleSpeed = 0.5f;
		}
		if (Time.realtimeSinceStartup - orbitStartTime > maxOrbitDuration && !breakingOrbit && canBreak)
		{
			StartBreakOrbit();
		}
	}

	private void StartBreakOrbit()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		breakingOrbit = true;
		Vector3 appropriatePosition = GetAppropriatePosition(((Component)this).transform.position + ((Component)this).transform.forward * 75f, 40f, 50f);
		SetTargetDestination(appropriatePosition, 15f, 0f);
	}

	private void DebugOrbit()
	{
	}

	public void State_OrbitStrafe_Enter()
	{
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.ORBITSTRAFE;
		if ((Object)(object)strafe_target == (Object)null)
		{
			ExitCurrentState();
			State_Patrol_Enter();
		}
		if ((Object)(object)strafe_target.GetParentEntity() != (Object)null)
		{
			ExitCurrentState();
			State_Patrol_Enter();
		}
		interestZoneOrigin = strafe_target_position;
		puttingDistance = true;
		didGetToDesination = false;
		Vector3 targetDest = interestZoneOrigin + ((Component)this).transform.forward * 95f;
		targetDest.y = ((Component)this).transform.position.y;
		SetTargetDestination(targetDest);
		if (strafe_target.IsNearEnemyBase() || Random.Range(0f, 1f) > 0.75f)
		{
			useNapalm = true;
			lastNapalmTime = Time.realtimeSinceStartup;
		}
		numRocketsLeft = 12 + Random.Range(-3, 16);
		lastRocketTime = 0f;
	}

	public void State_OrbitStrafe_Think(float timePassed)
	{
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		if (puttingDistance)
		{
			if (AtDestination())
			{
				didGetToDesination = true;
			}
			if (didGetToDesination)
			{
				SetIdealRotation(Quaternion.LookRotation(interestZoneOrigin - ((Component)this).transform.position), 0.8f);
				if (AtRotation())
				{
					puttingDistance = false;
					float num = Vector3Ex.Distance2D(((Component)this).transform.position, interestZoneOrigin);
					num = Mathf.Max(70f, num);
					OrbitInit(num, 1000f);
				}
			}
			return;
		}
		OrbitUpdate(timePassed, 1000f, canBreak: false);
		if (hasEnteredOrbit && !breakingOrbit)
		{
			SetIdealRotation(Quaternion.LookRotation(interestZoneOrigin - ((Component)this).transform.position), 3.5f);
			if (ClipRocketsLeft() > 0 && Time.realtimeSinceStartup - lastRocketTime > timeBetweenRocketsOrbit && CanSeeForStrafe(interestZoneOrigin))
			{
				FireRocket(interestZoneOrigin);
			}
		}
		if (ClipRocketsLeft() <= 0)
		{
			ExitCurrentState();
			State_Move_Enter(GetAppropriatePosition(strafe_target_position + ((Component)this).transform.forward * 120f));
		}
	}

	public void State_OrbitStrafe_Leave()
	{
		breakingOrbit = false;
		hasEnteredOrbit = false;
		currentOrbitTime = 0f;
		ClearAimTarget();
		lastStrafeTime = Time.realtimeSinceStartup;
		strafe_target = null;
	}

	public Vector3 GetRandomPatrolDestination()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return FindValidDestination();
	}

	private Vector3 FindValidDestination(int maxAttempts = 5)
	{
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (use_danger_zones)
		{
			for (int i = 0; i < maxAttempts; i++)
			{
				Vector3 val = GenerateRandomDestination();
				if (!IsInNoGoZone(val))
				{
					return val;
				}
			}
			Vector3 val2 = GenerateRandomDestination(forceMonument: true);
			if (IsInNoGoZone(val2))
			{
				noGoZones?.Clear();
			}
			return val2;
		}
		return GenerateRandomDestination();
	}

	public Vector3 GenerateRandomDestination(bool forceMonument = false)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_0159: Unknown result type (might be due to invalid IL or missing references)
		//IL_015e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		bool flag = Random.Range(0f, 1f) >= 0.6f;
		if (forceMonument)
		{
			flag = true;
		}
		if (flag)
		{
			if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
			{
				MonumentInfo monumentInfo = null;
				if (_visitedMonuments.Count > 0)
				{
					foreach (MonumentInfo monument in TerrainMeta.Path.Monuments)
					{
						if (monument.IsSafeZone)
						{
							continue;
						}
						bool flag2 = false;
						foreach (MonumentInfo visitedMonument in _visitedMonuments)
						{
							if ((Object)(object)monument == (Object)(object)visitedMonument)
							{
								flag2 = true;
							}
						}
						if (!flag2)
						{
							monumentInfo = monument;
							break;
						}
					}
				}
				if ((Object)(object)monumentInfo == (Object)null)
				{
					_visitedMonuments.Clear();
					for (int i = 0; i < 5; i++)
					{
						monumentInfo = TerrainMeta.Path.Monuments[Random.Range(0, TerrainMeta.Path.Monuments.Count)];
						if (!monumentInfo.IsSafeZone)
						{
							break;
						}
					}
				}
				if (Object.op_Implicit((Object)(object)monumentInfo))
				{
					val = ((Component)monumentInfo).transform.position;
					_visitedMonuments.Add(monumentInfo);
					val.y = TerrainMeta.HeightMap.GetHeight(val) + 200f;
					if (TransformUtil.GetGroundInfo(val, out var hitOut, 300f, LayerMask.op_Implicit(1235288065)))
					{
						val.y = ((RaycastHit)(ref hitOut)).point.y;
					}
					val.y += 30f;
				}
			}
			else
			{
				val = GetRandomMapPosition();
			}
		}
		else
		{
			val = GetRandomMapPosition();
		}
		return val;
	}

	public void State_Patrol_Think(float timePassed)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3Ex.Distance2D(((Component)this).transform.position, destination);
		if (num <= 25f)
		{
			targetThrottleSpeed = GetThrottleForDistance(num);
		}
		else
		{
			targetThrottleSpeed = 0.5f;
		}
		if (AtDestination() && arrivalTime == 0f)
		{
			arrivalTime = Time.realtimeSinceStartup;
			ExitCurrentState();
			maxOrbitDuration = 20f;
			State_Orbit_Enter(75f);
		}
		if (_targetList.Count <= 0)
		{
			return;
		}
		if (use_danger_zones)
		{
			Vector3? val = FindTargetWithZones();
			if (val.HasValue)
			{
				interestZoneOrigin = val.Value;
				OrbitInterestZone();
			}
		}
		else
		{
			interestZoneOrigin = FindDefaultTarget();
			OrbitInterestZone();
		}
	}

	private void OrbitInterestZone()
	{
		ExitCurrentState();
		maxOrbitDuration = 10f;
		State_Orbit_Enter(80f);
	}

	public void State_Patrol_Enter()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		_currentState = aiState.PATROL;
		Vector3 randomPatrolDestination = GetRandomPatrolDestination();
		SetTargetDestination(randomPatrolDestination, 10f);
		interestZoneOrigin = randomPatrolDestination;
		arrivalTime = 0f;
	}

	public void State_Patrol_Leave()
	{
	}

	private Vector3 GetRandomMapPosition()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = 30f;
		Vector3 val = Vector3Ex.Range(-0.7f, 0.7f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * Random.Range(0f, 0.75f);
		val.y = y;
		return val;
	}

	public int ClipRocketsLeft()
	{
		return numRocketsLeft;
	}

	public bool CanStrafe()
	{
		object obj = Interface.CallHook("CanHelicopterStrafe", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (Time.realtimeSinceStartup - lastStrafeTime >= Random.Range(15f, 25f))
		{
			return CanInterruptState();
		}
		return false;
	}

	public bool CanUseNapalm()
	{
		object obj = Interface.CallHook("CanHelicopterUseNapalm", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return Time.realtimeSinceStartup - lastNapalmTime >= Random.Range(25f, 35f);
	}

	public void State_Strafe_Enter(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		StartStrafe(strafeTarget, shouldUseNapalm);
	}

	public void State_Strafe_Think(float timePassed)
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0148: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		if (puttingDistance)
		{
			if (AtDestination())
			{
				RefreshTargetPosition();
				SetIdealRotation(GetYawRotationTo(strafe_target_position), 1.2f);
				if (AtRotation())
				{
					puttingDistance = false;
					cached_strafe_pos = strafe_target_position;
					SetTargetDestination(strafe_target_position + new Vector3(0f, 40f, 0f), 10f);
				}
			}
			return;
		}
		RefreshTargetPosition();
		SetIdealRotation(GetYawRotationTo(strafe_target_position));
		float num = Vector3Ex.Distance2D(cached_strafe_pos, ((Component)this).transform.position);
		if (num <= 150f && ClipRocketsLeft() > 0 && Time.realtimeSinceStartup - lastRocketTime > timeBetweenRockets && CanSeeForStrafe(strafe_target_position))
		{
			FireRocket(strafe_target_position);
		}
		if (num <= get_out_of_strafe_distance || ClipRocketsLeft() <= 0)
		{
			if (Random.value > 0.6f && (Object)(object)strafe_target != (Object)null)
			{
				ExitCurrentState();
				State_OrbitStrafe_Enter();
			}
			else
			{
				ExitCurrentState();
				State_Move_Enter(GetAppropriatePosition(strafe_target_position + ((Component)this).transform.forward * 120f));
			}
		}
	}

	private Vector3 GetPredictedPosition()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = strafe_target_position;
		float num = TimeSince.op_Implicit(timeSinceRefreshed);
		RefreshTargetPosition();
		Vector3 val2 = strafe_target_position;
		return val2 + (val2 - val) * (num / Time.deltaTime);
	}

	private bool CanSeeForStrafe(Vector3 targetPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		float num = Vector3.Distance(targetPos, ((Component)this).transform.position) - 10f;
		if (num < 0f)
		{
			num = 0f;
		}
		Vector3 position = ((Component)this).transform.position;
		Vector3 val = targetPos - ((Component)this).transform.position;
		return !Physics.Raycast(position, ((Vector3)(ref val)).normalized, num, LayerMask.GetMask(new string[2] { "Terrain", "World" }));
	}

	public bool ValidRocketTarget(BasePlayer ply)
	{
		object obj = Interface.CallHook("CanHelicopterStrafeTarget", (object)this, (object)ply);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if ((Object)(object)ply == (Object)null)
		{
			return false;
		}
		return !ply.IsNearEnemyBase();
	}

	public void State_Strafe_Leave()
	{
		lastStrafeTime = Time.realtimeSinceStartup;
		if (useNapalm)
		{
			lastNapalmTime = Time.realtimeSinceStartup;
		}
		useNapalm = false;
		movementLockingAiming = false;
	}

	private void StartStrafe(BasePlayer strafeTarget, bool shouldUseNapalm = false)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnHelicopterStrafeEnter", (object)this, (object)((Component)strafeTarget).transform.position, (object)strafeTarget) == null)
		{
			strafe_target = strafeTarget;
			get_out_of_strafe_distance = Random.Range(13f, 17f);
			if (CanUseNapalm() && shouldUseNapalm)
			{
				passNapalm = shouldUseNapalm;
				useNapalm = true;
				lastNapalmTime = Time.realtimeSinceStartup;
			}
			lastStrafeTime = Time.realtimeSinceStartup;
			_currentState = aiState.STRAFE;
			RefreshTargetPosition();
			numRocketsLeft = 12 + Random.Range(-1, 1);
			lastRocketTime = 0f;
			movementLockingAiming = true;
			Vector3 randomOffset = GetRandomOffset(strafe_target_position, 175f, 192.5f);
			SetTargetDestination(randomOffset, 10f);
			SetIdealRotation(GetYawRotationTo(randomOffset));
			puttingDistance = true;
		}
	}

	public void FireRocket(Vector3 targetPos)
	{
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		numRocketsLeft--;
		lastRocketTime = Time.realtimeSinceStartup;
		float num = Random.Range(3.9f, 4.1f);
		bool flag = leftTubeFiredLast;
		leftTubeFiredLast = !leftTubeFiredLast;
		Transform val = (flag ? helicopterBase.rocket_tube_left.transform : helicopterBase.rocket_tube_right.transform);
		Vector3 val2 = val.position + val.forward * 1f;
		Vector3 val3 = targetPos - val2;
		Vector3 val4 = ((Vector3)(ref val3)).normalized;
		if (num > 0f)
		{
			val4 = AimConeUtil.GetModifiedAimConeDirection(num, val4);
		}
		Effect.server.Run(helicopterBase.rocket_fire_effect.resourcePath, helicopterBase, StringPool.Get(flag ? "rocket_tube_left" : "rocket_tube_right"), Vector3.zero, Vector3.forward, null, broadcast: true);
		BaseEntity baseEntity = GameManager.server.CreateEntity(useNapalm ? rocketProjectile_Napalm.resourcePath : rocketProjectile.resourcePath, val2);
		if (!((Object)(object)baseEntity == (Object)null))
		{
			ServerProjectile component = ((Component)baseEntity).GetComponent<ServerProjectile>();
			if (Object.op_Implicit((Object)(object)component))
			{
				component.InitializeVelocity(val4 * component.speed);
			}
			baseEntity.Spawn();
		}
	}

	private void RefreshTargetPosition()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)strafe_target == (Object)null))
		{
			timeSinceRefreshed = TimeSince.op_Implicit(0f);
			int mask = LayerMask.GetMask(new string[5] { "Terrain", "World", "Construction", "Water", "Vehicle Large" });
			if (TransformUtil.GetGroundInfo(((Component)strafe_target).transform.position, out var pos, out var _, 100f, LayerMask.op_Implicit(mask), ((Component)this).transform))
			{
				strafe_target_position = pos;
			}
			else
			{
				strafe_target_position = ((Component)strafe_target).transform.position;
			}
		}
	}

	public void InitializeAI()
	{
		_lastThinkTime = Time.realtimeSinceStartup;
	}

	public void OnCurrentStateExit()
	{
		switch (_currentState)
		{
		default:
			State_Idle_Leave();
			break;
		case aiState.MOVE:
			State_Move_Leave();
			break;
		case aiState.STRAFE:
			State_Strafe_Leave();
			break;
		case aiState.ORBIT:
			State_Orbit_Leave();
			break;
		case aiState.ORBITSTRAFE:
			State_OrbitStrafe_Leave();
			break;
		case aiState.FLEE:
			State_Flee_Leave();
			break;
		case aiState.PATROL:
			State_Patrol_Leave();
			break;
		}
	}

	public void ExitCurrentState()
	{
		if (isRetiring || isDead)
		{
			if (shouldDebug)
			{
				Debug.Log((object)"Patrol Helicopter attempting to exit state whilst retiring/dying.");
			}
		}
		else
		{
			OnCurrentStateExit();
			_currentState = aiState.IDLE;
		}
	}

	public float GetTime()
	{
		return Time.realtimeSinceStartup;
	}

	public void AIThink()
	{
		float time = GetTime();
		float timePassed = time - _lastThinkTime;
		_lastThinkTime = time;
		switch (_currentState)
		{
		default:
			State_Idle_Think(timePassed);
			break;
		case aiState.MOVE:
			State_Move_Think(timePassed);
			break;
		case aiState.STRAFE:
			State_Strafe_Think(timePassed);
			break;
		case aiState.ORBIT:
			State_Orbit_Think(timePassed);
			break;
		case aiState.PATROL:
			State_Patrol_Think(timePassed);
			break;
		case aiState.ORBITSTRAFE:
			State_OrbitStrafe_Think(timePassed);
			break;
		case aiState.FLEE:
			State_Flee_Think(timePassed);
			break;
		case aiState.DEATH:
			State_Death_Think(timePassed);
			break;
		}
	}

	public Vector3 GetRandomOffset(Vector3 origin, float minRange, float maxRange = 0f, float minHeight = 20f, float maxHeight = 30f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 onUnitSphere = Random.onUnitSphere;
		onUnitSphere.y = 0f;
		((Vector3)(ref onUnitSphere)).Normalize();
		maxRange = Mathf.Max(minRange, maxRange);
		Vector3 origin2 = origin + onUnitSphere * Random.Range(minRange, maxRange);
		return GetAppropriatePosition(origin2, minHeight, maxHeight);
	}

	public Vector3 GetAppropriatePosition(Vector3 origin, float minHeight = 20f, float maxHeight = 30f)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		float num = 100f;
		Ray val = default(Ray);
		((Ray)(ref val))..ctor(origin + new Vector3(0f, num, 0f), Vector3.down);
		float num2 = 5f;
		int mask = LayerMask.GetMask(new string[4] { "Terrain", "World", "Construction", "Water" });
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val, num2, ref val2, num * 2f - num2, mask))
		{
			origin = ((RaycastHit)(ref val2)).point;
		}
		origin.y += Random.Range(minHeight, maxHeight);
		return origin;
	}

	public float GetThrottleForDistance(float distToTarget)
	{
		float num = 0f;
		if (distToTarget >= 75f)
		{
			return 1f;
		}
		if (distToTarget >= 50f)
		{
			return 0.75f;
		}
		if (distToTarget >= 25f)
		{
			return 0.33f;
		}
		if (distToTarget >= 5f)
		{
			return 0.05f;
		}
		return 0.05f * (1f - distToTarget / 5f);
	}
}


using UnityEngine;

public class targetinfo
{
	public BasePlayer ply;

	public BaseEntity ent;

	public float lastSeenTime = float.PositiveInfinity;

	public float visibleFor;

	public float nextLOSCheck;

	public targetinfo(BaseEntity initEnt, BasePlayer initPly = null)
	{
		ply = initPly;
		ent = initEnt;
		lastSeenTime = float.PositiveInfinity;
		nextLOSCheck = Time.realtimeSinceStartup + 1.5f;
	}

	public bool IsVisible()
	{
		return TimeSinceSeen() < 1.5f;
	}

	public float TimeSinceSeen()
	{
		return Time.realtimeSinceStartup - lastSeenTime;
	}
}


using UnityEngine;

public class DangerZone
{
	public float Radius;

	private float score;

	private float lastActiveTime = Time.realtimeSinceStartup;

	private const float isStaleTime = 5f;

	private Vector3 centre;

	private BaseEntity parent;

	public Vector3 Centre
	{
		get
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			if ((Object)(object)parent == (Object)null)
			{
				return centre;
			}
			return ((Component)parent).transform.TransformPoint(centre);
		}
	}

	public float Score
	{
		get
		{
			return score;
		}
		set
		{
			score = value;
			lastActiveTime = Time.realtimeSinceStartup;
		}
	}

	public float LastActiveTime => lastActiveTime;

	public DangerZone(Vector3 centre, float radius = 20f, BaseEntity parent = null)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)parent == (Object)null)
		{
			this.centre = centre;
		}
		else
		{
			this.centre = ((Component)parent).transform.InverseTransformPoint(centre);
		}
		this.parent = parent;
		Radius = radius;
	}

	public bool IsPointInside(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Distance(point, Centre) <= Radius;
	}

	public bool IsStale()
	{
		return Time.realtimeSinceStartup - lastActiveTime > 5f;
	}

	public Vector3 GetNearestEdge(Vector3 point)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = point - Centre;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		normalized.y = 0f;
		return Centre + normalized * Radius;
	}
}


public enum aiState
{
	IDLE,
	MOVE,
	ORBIT,
	STRAFE,
	PATROL,
	ORBITSTRAFE,
	GUARD,
	FLEE,
	DEATH
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ServerGib : BaseCombatEntity
{
	public GameObject _gibSource;

	public string _gibName;

	public PhysicMaterial physicsMaterial;

	public bool useContinuousCollision;

	private MeshCollider meshCollider;

	private Rigidbody rigidBody;

	public override float BoundsPadding()
	{
		return 3f;
	}

	public static List<ServerGib> CreateGibs(string entityToCreatePath, GameObject creator, GameObject gibSource, Vector3 inheritVelocity, float spreadVelocity)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		List<ServerGib> list = new List<ServerGib>();
		MeshRenderer[] componentsInChildren = gibSource.GetComponentsInChildren<MeshRenderer>(true);
		foreach (MeshRenderer val in componentsInChildren)
		{
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			Vector3 val2 = ((Component)val).transform.localPosition;
			Vector3 normalized = ((Vector3)(ref val2)).normalized;
			Matrix4x4 localToWorldMatrix = creator.transform.localToWorldMatrix;
			Vector3 val3 = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint(((Component)val).transform.localPosition) + normalized * 0.5f;
			Quaternion val4 = creator.transform.rotation * ((Component)val).transform.localRotation;
			BaseEntity baseEntity = GameManager.server.CreateEntity(entityToCreatePath, val3, val4);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				ServerGib component2 = ((Component)baseEntity).GetComponent<ServerGib>();
				((Component)component2).transform.SetPositionAndRotation(val3, val4);
				component2._gibName = ((Object)val).name;
				MeshCollider component3 = ((Component)val).GetComponent<MeshCollider>();
				Mesh physicsMesh = (((Object)(object)component3 != (Object)null) ? component3.sharedMesh : component.sharedMesh);
				component2.PhysicsInit(physicsMesh);
				val2 = ((Component)val).transform.localPosition;
				Vector3 val5 = ((Vector3)(ref val2)).normalized * spreadVelocity;
				component2.rigidBody.velocity = inheritVelocity + val5;
				Rigidbody obj = component2.rigidBody;
				val2 = Vector3Ex.Range(-1f, 1f);
				obj.angularVelocity = ((Vector3)(ref val2)).normalized * 1f;
				component2.rigidBody.WakeUp();
				component2.Spawn();
				list.Add(component2);
			}
		}
		foreach (ServerGib item in list)
		{
			foreach (ServerGib item2 in list)
			{
				if (!((Object)(object)item == (Object)(object)item2))
				{
					Physics.IgnoreCollision((Collider)(object)item2.GetCollider(), (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		return list;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk && _gibName != "")
		{
			info.msg.servergib = Pool.Get<ServerGib>();
			info.msg.servergib.gibName = _gibName;
		}
	}

	public MeshCollider GetCollider()
	{
		if ((Object)(object)meshCollider == (Object)null)
		{
			meshCollider = ((Component)this).GetComponent<MeshCollider>();
		}
		if ((Object)(object)meshCollider == (Object)null)
		{
			meshCollider = ((Component)this).GetComponentInChildren<MeshCollider>();
		}
		return meshCollider;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)RemoveMe, 1800f);
	}

	public void RemoveMe()
	{
		Kill();
	}

	public virtual void PhysicsInit(Mesh physicsMesh)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		Mesh sharedMesh = null;
		MeshFilter component = ((Component)this).gameObject.GetComponent<MeshFilter>();
		if ((Object)(object)component != (Object)null)
		{
			sharedMesh = component.sharedMesh;
			component.sharedMesh = physicsMesh;
		}
		meshCollider = ((Component)this).gameObject.AddComponent<MeshCollider>();
		meshCollider.sharedMesh = physicsMesh;
		meshCollider.convex = true;
		((Collider)meshCollider).material = physicsMaterial;
		if ((Object)(object)component != (Object)null)
		{
			component.sharedMesh = sharedMesh;
		}
		Rigidbody val = ((Component)this).gameObject.AddComponent<Rigidbody>();
		val.useGravity = true;
		Bounds val2 = ((Collider)meshCollider).bounds;
		Vector3 size = ((Bounds)(ref val2)).size;
		float magnitude = ((Vector3)(ref size)).magnitude;
		val2 = ((Collider)meshCollider).bounds;
		size = ((Bounds)(ref val2)).size;
		val.mass = Mathf.Clamp(magnitude * ((Vector3)(ref size)).magnitude * 20f, 10f, 2000f);
		val.interpolation = (RigidbodyInterpolation)1;
		val.collisionDetectionMode = (CollisionDetectionMode)(useContinuousCollision ? 2 : 0);
		if (base.isServer)
		{
			val.drag = 0.1f;
			val.angularDrag = 0.1f;
		}
		rigidBody = val;
		((Component)this).gameObject.layer = LayerMask.NameToLayer("Default");
		if (base.isClient)
		{
			val.isKinematic = true;
		}
	}
}


using System;

public class TimedUnlootableCrate : LootContainer
{
	public bool unlootableOnSpawn = true;

	public float unlootableDuration = 300f;

	public override void ServerInit()
	{
		base.ServerInit();
		if (unlootableOnSpawn)
		{
			SetUnlootableFor(unlootableDuration);
		}
	}

	public void SetUnlootableFor(float duration)
	{
		SetFlag(Flags.OnFire, b: true);
		SetFlag(Flags.Locked, b: true);
		unlootableDuration = duration;
		((FacepunchBehaviour)this).Invoke((Action)MakeLootable, duration);
	}

	public void MakeLootable()
	{
		SetFlag(Flags.OnFire, b: false);
		SetFlag(Flags.Locked, b: false);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PlanterBoxStatic : PlanterBox
{
	[ServerVar(Help = "Chance of a favourable gene being picked [0-1]. Setting this to 0 does not ensure no favourable genes are picked up, but it greatly reduces the chances.")]
	public static float FavourableGeneChance = 0.5f;

	public List<GameObjectRef> staticPlantsSpawnlist;

	public bool randomPerSlot;

	public float respawnCheckTimer = 30f;

	public override void SetupTimeCaches()
	{
	}

	public override void RefreshGrowables(GrowableEntity ignoreEntity = null)
	{
	}

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)CreateStaticPlants, 1f, respawnCheckTimer);
	}

	public void CreateStaticPlants()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		soilSaturation = soilSaturationMax;
		GameObjectRef randomStaticPlant = GetRandomStaticPlant();
		Socket_Base[] array = PrefabAttribute.server.FindAll<Socket_Base>(prefabID);
		foreach (Socket_Base socket_Base in array)
		{
			if (socket_Base is Socket_Specific_Female && IsSpawnPointFreeSearch(socket_Base.localPosition))
			{
				if (randomPerSlot)
				{
					randomStaticPlant = GetRandomStaticPlant();
				}
				Vector3 pos = ((Component)this).transform.TransformPoint(socket_Base.localPosition);
				BaseEntity baseEntity = GameManager.server.CreateEntity(randomStaticPlant.resourcePath, pos, Quaternion.identity);
				baseEntity.SetParent(this, worldPositionStays: true);
				baseEntity.Spawn();
				GrowableEntity growableEntity = baseEntity as GrowableEntity;
				if ((Object)(object)growableEntity != (Object)null)
				{
					growableEntity.Fertilize();
					growableEntity.SetGodQuality(qual: true);
					growableEntity.SetMaxGrowingConditions();
					growableEntity.Genes.GenerateFavourableGenes(growableEntity);
					growableEntity.SendNetworkUpdate();
					OnPlantInserted(growableEntity, null);
				}
			}
		}
	}

	private GameObjectRef GetRandomStaticPlant()
	{
		if (staticPlantsSpawnlist == null || staticPlantsSpawnlist.Count == 0)
		{
			return null;
		}
		int index = Random.Range(0, staticPlantsSpawnlist.Count);
		return staticPlantsSpawnlist[index];
	}

	private bool IsSpawnPointFreeSearch(Vector3 localPos)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		foreach (BaseEntity child in children)
		{
			if (child is GrowableEntity && Vector3.Distance(((Component)child).transform.localPosition, localPos) < 0.05f)
			{
				return false;
			}
		}
		return true;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SeekerTarget
{
	public enum SeekerStrength
	{
		OFF = 0,
		LOW = 100,
		MEDIUM = 200,
		HIGH = 1000,
		HIGHEST = 1000
	}

	public interface ISeekerTargetOwner
	{
		Vector3 CenterPoint();

		bool InSafeZone();

		bool IsValidHomingTarget();

		bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

		void OnEntityMessage(BaseEntity from, string msg);
	}

	[NonSerialized]
	public SeekerStrength strength;

	public ISeekerTargetOwner owner;

	private static Dictionary<ISeekerTargetOwner, SeekerTarget> seekerTargets = new Dictionary<ISeekerTargetOwner, SeekerTarget>();

	public bool IsValidTarget()
	{
		if (owner.IsUnityNull())
		{
			return false;
		}
		if (!owner.InSafeZone())
		{
			return owner.IsValidHomingTarget();
		}
		return false;
	}

	public bool TryGetPosition(out Vector3 result)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		if (owner.IsUnityNull())
		{
			result = Vector3.zero;
			return false;
		}
		result = owner.CenterPoint();
		return true;
	}

	public void SendOwnerMessage(BaseEntity from, string message)
	{
		if (!owner.IsUnityNull())
		{
			owner.OnEntityMessage(from, message);
		}
	}

	public static SeekerTarget GetBestForPoint(Vector3 from, Vector3 forward, float maxCone, float maxDist, SeekerStrength minStrength = SeekerStrength.LOW)
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		SeekerTarget result = null;
		float num = 0f;
		foreach (KeyValuePair<ISeekerTargetOwner, SeekerTarget> seekerTarget in seekerTargets)
		{
			ISeekerTargetOwner key = seekerTarget.Key;
			SeekerTarget value = seekerTarget.Value;
			if (value.strength < minStrength || !value.IsValidTarget() || !value.TryGetPosition(out var result2))
			{
				continue;
			}
			Vector3 val = Vector3Ex.Direction(result2, from);
			float num2 = Vector3.Dot(forward, val);
			float num3 = Vector3.Distance(result2, from);
			if (num3 < maxDist && num2 > maxCone)
			{
				float num4 = 1f - num3 / maxDist * 0.3f;
				float num5 = num2 / maxCone * 1f;
				float num6 = (float)value.strength / 1000f * 0.5f;
				float num7 = num4 + num5 + num6;
				if (num7 > num && key.IsVisible(from, maxDist))
				{
					result = value;
					num = num7;
				}
			}
		}
		return result;
	}

	public static void SetSeekerTarget(ISeekerTargetOwner toAdd, SeekerStrength strength)
	{
		if (strength == SeekerStrength.OFF)
		{
			if (seekerTargets.ContainsKey(toAdd))
			{
				seekerTargets.Remove(toAdd);
			}
		}
		else if (!seekerTargets.ContainsKey(toAdd))
		{
			SeekerTarget value = new SeekerTarget
			{
				strength = strength,
				owner = toAdd
			};
			seekerTargets.Add(toAdd, value);
		}
	}
}


public enum SeekerStrength
{
	OFF = 0,
	LOW = 100,
	MEDIUM = 200,
	HIGH = 1000,
	HIGHEST = 1000
}


using UnityEngine;

public interface ISeekerTargetOwner
{
	Vector3 CenterPoint();

	bool InSafeZone();

	bool IsValidHomingTarget();

	bool IsVisible(Vector3 position, float maxDistance = float.PositiveInfinity);

	void OnEntityMessage(BaseEntity from, string msg);
}


using System;
using UnityEngine;

public class SeekingServerProjectile : ServerProjectile
{
	public float courseAdjustRate = 1f;

	public float maxTrackDistance = 500f;

	public float minLockDot;

	public float flareLockDot = 0.6f;

	public bool autoSeek;

	public float swimAfter = 6f;

	public float launchingDuration = 0.15f;

	public float armingDuration = 0.75f;

	public float velocityRampUpTime = 6f;

	public Vector3 armingFinalDir;

	public AnimationCurve airmingDirCurve;

	public AnimationCurve armingVelocityCurve;

	public float armingVelocity;

	public AnimationCurve velocityCurve;

	public float orphanedVectorChangeRate = 30f;

	public SeekerTarget lockedTarget;

	private float nextTargetUpdateTime = float.NegativeInfinity;

	private Vector3 seekingDestination;

	private float launchTime;

	private Vector3 initialDir = Vector3.forward;

	private bool orphanedProjectile;

	private Vector3 orphanedTargetVector;

	private Vector3 orphanedRotationAxis;

	public float totalArmingPhaseDuration => launchingDuration + armingDuration;

	public void NotifyOrphaned()
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		orphanedProjectile = true;
		orphanedTargetVector = Random.onUnitSphere;
	}

	public virtual void UpdateTarget()
	{
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		if (orphanedProjectile)
		{
			lockedTarget = null;
			return;
		}
		if (Time.realtimeSinceStartup >= nextTargetUpdateTime)
		{
			if (autoSeek)
			{
				lockedTarget = SeekerTarget.GetBestForPoint(((Component)this).transform.position, ((Component)this).transform.forward, minLockDot, maxTrackDistance);
			}
			else
			{
				SeekerTarget bestForPoint = SeekerTarget.GetBestForPoint(((Component)this).transform.position, ((Component)this).transform.forward, flareLockDot, maxTrackDistance, SeekerTarget.SeekerStrength.HIGH);
				if (bestForPoint != null)
				{
					lockedTarget = bestForPoint;
				}
			}
			nextTargetUpdateTime = Time.realtimeSinceStartup + 0.1f;
		}
		if (lockedTarget != null && lockedTarget.TryGetPosition(out var result))
		{
			seekingDestination = result;
		}
		else
		{
			seekingDestination = ((Component)this).transform.position + ((Component)this).transform.forward * 1000f;
		}
		if (lockedTarget != null)
		{
			lockedTarget.SendOwnerMessage(base.baseEntity, "RadarLock");
		}
	}

	public Vector3 GetSeekingDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return seekingDestination;
	}

	public override bool DoMovement()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		float num = TimeSinceLaunch();
		if (!(num < launchingDuration))
		{
			if (num < totalArmingPhaseDuration)
			{
				float num2 = num - launchingDuration;
				Vector3 val = Vector3.Lerp(initialDir, armingFinalDir, Mathf.Clamp01(num2 / armingDuration));
				base.CurrentVelocity = val * armingVelocity * armingVelocityCurve.Evaluate(num);
			}
			else
			{
				UpdateTarget();
				Vector3 val2 = base.CurrentVelocity;
				Vector3 normalized = ((Vector3)(ref val2)).normalized;
				Vector3 normalized2;
				if (orphanedProjectile)
				{
					normalized2 = orphanedTargetVector;
					orphanedTargetVector = Quaternion.AngleAxis(orphanedVectorChangeRate * Time.deltaTime, orphanedRotationAxis) * orphanedTargetVector;
					if (Random.value < 0.02f)
					{
						PickNewRotationAxis();
					}
				}
				else
				{
					val2 = GetSeekingDestination() - ((Component)this).transform.position;
					normalized2 = ((Vector3)(ref val2)).normalized;
				}
				Vector3 val3 = Vector3.MoveTowards(normalized, normalized2, Time.fixedDeltaTime * courseAdjustRate);
				((Vector3)(ref val3)).Normalize();
				float num3 = armingVelocity + velocityCurve.Evaluate(TimeSinceArmed() / velocityRampUpTime) * speed;
				base.CurrentVelocity = val3 * num3;
			}
		}
		return base.DoMovement();
	}

	public float TimeSinceArmed()
	{
		return TimeSinceLaunch() - totalArmingPhaseDuration;
	}

	public float TimeSinceLaunch()
	{
		return Mathf.Max(Time.time - launchTime, 0f);
	}

	public void EnableBoosters()
	{
		base.baseEntity.SetFlag(BaseEntity.Flags.On, b: true);
		((FacepunchBehaviour)this).Invoke((Action)DisableBoosters, 1f);
	}

	public void DisableBoosters()
	{
		base.baseEntity.SetFlag(BaseEntity.Flags.On, b: false);
	}

	public override void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		Vector3 normalized = ((Vector3)(ref overrideVel)).normalized;
		launchTime = Time.time;
		initialDir = normalized;
		((FacepunchBehaviour)this).Invoke((Action)EnableBoosters, 0.5f);
		base.InitializeVelocity(overrideVel);
	}

	private void PickNewRotationAxis()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.Cross(orphanedTargetVector, Random.onUnitSphere);
		orphanedRotationAxis = ((Vector3)(ref val)).normalized;
	}
}


using System;
using System.Linq;
using Rust.Workshop;
using UnityEngine;

public static class SkinHelpers
{
	public static void SetSkin(GameObject itemModel, ItemDefinition itemDef, ulong skinID)
	{
		ItemSkinDirectory.Skin skin = itemDef.skins.FirstOrDefault((ItemSkinDirectory.Skin x) => (ulong)x.id == skinID);
		if ((ulong)skin.id == skinID)
		{
			ItemSkin itemSkin = skin.invItem as ItemSkin;
			if ((Object)(object)itemSkin != (Object)null)
			{
				itemSkin.ApplySkin(itemModel);
			}
		}
		else if (skinID != 0L)
		{
			WorkshopSkin.Apply(itemModel, skinID, (Action<Skin>)null, (Action)null);
		}
	}
}


public class SmokeBomb : TimedExplosive
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SmokeGrenade : TimedExplosive
{
	public float smokeDuration = 45f;

	public GameObjectRef smokeEffectPrefab;

	public GameObjectRef igniteSound;

	public SoundPlayer soundLoop;

	private GameObject smokeEffectInstance;

	public static List<SmokeGrenade> activeGrenades = new List<SmokeGrenade>();

	public float fieldMin = 5f;

	public float fieldMax = 8f;

	protected bool killing;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckForWater, 1f, 1f);
	}

	public override void Explode()
	{
		if (WaterFactor() >= 0.5f)
		{
			FinishUp();
		}
		else if (!IsOn())
		{
			((FacepunchBehaviour)this).Invoke((Action)FinishUp, smokeDuration);
			SetFlag(Flags.On, b: true);
			SetFlag(Flags.Open, b: true);
			InvalidateNetworkCache();
			SendNetworkUpdateImmediate();
			activeGrenades.Add(this);
			SingletonComponent<SmokeGrenadeManager>.Instance.Add(this);
		}
	}

	public void CheckForWater()
	{
		if (WaterFactor() >= 0.5f)
		{
			FinishUp();
		}
	}

	public void FinishUp()
	{
		if (!killing)
		{
			Kill();
			killing = true;
		}
	}

	public override void DestroyShared()
	{
		SingletonComponent<SmokeGrenadeManager>.Instance.Remove(this);
		activeGrenades.Remove(this);
		base.DestroyShared();
	}
}


using System;
using System.Collections.Generic;
using Spatial;
using UnityEngine;

public class SmokeGrenadeManager : SingletonComponent<SmokeGrenadeManager>
{
	private const float worldSize = 8096f;

	private const int cellSize = 32;

	private Grid<BaseEntity> smokeGrid = new Grid<BaseEntity>(32, 8096f);

	public void Add(BaseEntity smoke)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		if (IsSmokeGrenade(smoke))
		{
			smokeGrid.Add(smoke, ((Component)smoke).transform.position.x, ((Component)smoke).transform.position.z);
		}
	}

	public void Move(BaseEntity smoke)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SmokeGrenadeManager.Move", 0);
		try
		{
			if (IsSmokeGrenade(smoke))
			{
				Vector3 position = ((Component)smoke).transform.position;
				smokeGrid.Move(smoke, position.x, position.z);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Remove(BaseEntity smoke)
	{
		if (IsSmokeGrenade(smoke))
		{
			smokeGrid.Remove(smoke);
		}
	}

	public void GetSmokeAround(Vector3 position, float range, List<BaseEntity> results)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SmokeGrenadeManager.GetSmokeAround", 0);
		try
		{
			if (smokeGrid != null)
			{
				smokeGrid.Query<BaseEntity>(position.x, position.z, range, results);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static bool IsSmokeGrenade(BaseEntity entity)
	{
		if (entity is SmokeGrenade)
		{
			return true;
		}
		return false;
	}
}


using Facepunch;
using ProtoBuf;
using UnityEngine;

public class SphereEntity : BaseEntity
{
	public float currentRadius = 1f;

	public float lerpRadius = 1f;

	public float lerpSpeed = 1f;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.sphereEntity = Pool.Get<SphereEntity>();
		info.msg.sphereEntity.radius = currentRadius;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer)
		{
			if (info.msg.sphereEntity != null)
			{
				currentRadius = (lerpRadius = info.msg.sphereEntity.radius);
			}
			UpdateScale();
		}
	}

	public void LerpRadiusTo(float radius, float speed)
	{
		lerpRadius = radius;
		lerpSpeed = speed;
	}

	public void UpdateScale()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = new Vector3(currentRadius, currentRadius, currentRadius);
	}

	public void Update()
	{
		if (currentRadius != lerpRadius && base.isServer)
		{
			currentRadius = Mathf.MoveTowards(currentRadius, lerpRadius, Time.deltaTime * lerpSpeed);
			UpdateScale();
			SendNetworkUpdate();
		}
	}
}


using UnityEngine;

public class StaticRespawnArea : SleepingBag
{
	public Transform[] spawnAreas;

	public bool allowHostileSpawns;

	public override bool ValidForPlayer(ulong playerID, bool ignoreTimers)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(playerID);
		if ((Object)(object)basePlayer != (Object)null && basePlayer.IsInTutorial)
		{
			return false;
		}
		if (ignoreTimers || allowHostileSpawns)
		{
			return true;
		}
		return basePlayer.GetHostileDuration() <= 0f;
	}

	public override void GetSpawnPos(out Vector3 pos, out Quaternion rot)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		Transform val = spawnAreas[Random.Range(0, spawnAreas.Length)];
		pos = ((Component)val).transform.position + spawnOffset;
		Quaternion rotation = ((Component)val).transform.rotation;
		rot = Quaternion.Euler(0f, ((Quaternion)(ref rotation)).eulerAngles.y, 0f);
	}

	public override void SetUnlockTime(float newTime)
	{
		unlockTime = 0f;
	}

	public override float GetUnlockSeconds(ulong playerID)
	{
		BasePlayer basePlayer = BasePlayer.FindByID(playerID);
		if ((Object)(object)basePlayer == (Object)null || allowHostileSpawns)
		{
			return base.unlockSeconds;
		}
		return Mathf.Max(basePlayer.GetHostileDuration(), base.unlockSeconds);
	}
}


using System;
using ConVar;
using Oxide.Core;
using Rust;
using UnityEngine;

public class SupplyDrop : LootContainer
{
	public const Flags FlagNightLight = Flags.Reserved1;

	private const Flags ShowParachute = Flags.Reserved2;

	public GameObject ParachuteRoot;

	public override void ServerInit()
	{
		base.ServerInit();
		if (!Application.isLoadingSave)
		{
			SetFlag(Flags.Reserved2, b: true);
		}
		isLootable = false;
		((FacepunchBehaviour)this).Invoke((Action)MakeLootable, 300f);
		((FacepunchBehaviour)this).InvokeRepeating((Action)CheckNightLight, 0f, 30f);
	}

	public void RemoveParachute()
	{
		SetFlag(Flags.Reserved2, b: false);
	}

	public void MakeLootable()
	{
		isLootable = true;
	}

	private void OnCollisionEnter(Collision collision)
	{
		bool flag = ((1 << ((Component)collision.collider).gameObject.layer) & 0x40A10111) > 0;
		if (((1 << ((Component)collision.collider).gameObject.layer) & 0x8000000) > 0 && collision.GetEntity() is Tugboat)
		{
			flag = true;
		}
		if (flag)
		{
			RemoveParachute();
			MakeLootable();
		}
		Interface.CallHook("OnSupplyDropLanded", (object)this);
	}

	public void CheckNightLight()
	{
		SetFlag(Flags.Reserved1, Env.time > 20f || Env.time < 7f);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if ((Object)(object)ParachuteRoot != (Object)null)
		{
			ParachuteRoot.SetActive(next.HasFlag(Flags.Reserved2));
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class SupplySignal : TimedExplosive
{
	public GameObjectRef smokeEffectPrefab;

	public GameObjectRef EntityToCreate;

	[NonSerialized]
	public GameObject smokeEffect;

	public override void Explode()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(EntityToCreate.resourcePath);
		if (Object.op_Implicit((Object)(object)baseEntity))
		{
			Vector3 val = default(Vector3);
			((Vector3)(ref val))..ctor(Random.Range(-20f, 20f), 0f, Random.Range(-20f, 20f));
			((Component)baseEntity).SendMessage("InitDropPosition", (object)(((Component)this).transform.position + val), (SendMessageOptions)1);
			baseEntity.Spawn();
			Interface.CallHook("OnCargoPlaneSignaled", (object)baseEntity, (object)this);
		}
		((FacepunchBehaviour)this).Invoke((Action)FinishUp, 210f);
		SetFlag(Flags.On, b: true);
		SendNetworkUpdateImmediate();
	}

	public void FinishUp()
	{
		Kill();
	}
}


using UnityEngine;

public class TorpedoServerProjectile : ServerProjectile
{
	[SerializeField]
	[Tooltip("Make sure to leave some allowance for waves, which affect the true depth.")]
	private float minWaterDepth = 0.5f;

	[SerializeField]
	private float shallowWaterInaccuracy;

	[SerializeField]
	private float deepWaterInaccuracy;

	[SerializeField]
	private float shallowWaterCutoff = 2f;

	public override bool HasRangeLimit => false;

	protected override int mask => 1237003009;

	public override bool DoMovement()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		if (!base.DoMovement())
		{
			return false;
		}
		float num = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: false).surfaceLevel - ((Component)this).transform.position.y;
		if (num < -1f)
		{
			gravityModifier = 1f;
		}
		else if (num <= minWaterDepth)
		{
			Vector3 currentVelocity = base.CurrentVelocity;
			currentVelocity.y = 0f;
			base.CurrentVelocity = currentVelocity;
			gravityModifier = 0.1f;
		}
		else if (num > minWaterDepth + 0.3f && num <= minWaterDepth + 0.7f)
		{
			gravityModifier = -0.1f;
		}
		else
		{
			gravityModifier = Mathf.Clamp(base.CurrentVelocity.y, -0.1f, 0.1f);
		}
		return true;
	}

	public override void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		base.InitializeVelocity(overrideVel);
		float num = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: false).surfaceLevel - ((Component)this).transform.position.y;
		float num2 = Mathf.InverseLerp(shallowWaterCutoff, shallowWaterCutoff + 2f, num);
		float num3 = Mathf.Lerp(shallowWaterInaccuracy, deepWaterInaccuracy, num2);
		initialVelocity = Vector3Ex.GetWithInaccuracy(initialVelocity, num3);
		base.CurrentVelocity = initialVelocity;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class TrainSignal : BaseEntity
{
	public enum LightState
	{
		None,
		Green,
		Yellow,
		Red
	}

	private class SplineSection
	{
		public readonly TrainTrackSpline spline;

		public readonly float startDist;

		public readonly float endDist;

		public SplineSection(TrainTrackSpline spline, float startDist, float endDist)
		{
			this.spline = spline;
			this.startDist = startDist;
			this.endDist = endDist;
		}
	}

	[SerializeField]
	private bool testFX;

	[SerializeField]
	private VehicleLight redLight;

	[SerializeField]
	private VehicleLight yellowLight;

	[SerializeField]
	private VehicleLight greenLight;

	private const Flags Flag_Red = Flags.Reserved1;

	private const Flags Flag_Yellow = Flags.Reserved2;

	private const Flags Flag_Green = Flags.Reserved3;

	private LightState lightState;

	[NonSerialized]
	public TrainSignal nextSignal;

	private TrainTrackSpline ourSpline;

	private float ourSplineDist;

	private readonly List<SplineSection> ourSplines = new List<SplineSection>();

	private LightState prevTargetLightState;

	public float SplineDist => ourSplineDist;

	public bool HasNextSignal => (Object)(object)nextSignal != (Object)null;

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (base.isClient)
		{
			if ((next & Flags.Reserved1) == Flags.Reserved1)
			{
				SetLightState(LightState.Red);
			}
			else if ((next & Flags.Reserved2) == Flags.Reserved2)
			{
				SetLightState(LightState.Yellow);
			}
			else if ((next & Flags.Reserved3) == Flags.Reserved3)
			{
				SetLightState(LightState.Green);
			}
		}
	}

	private void SetLightState(LightState newState)
	{
		if (lightState != newState)
		{
			lightState = newState;
			if (base.isServer)
			{
				SetFlag(Flags.Reserved1, newState == LightState.Red, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved2, newState == LightState.Yellow, recursive: false, networkupdate: false);
				SetFlag(Flags.Reserved3, newState == LightState.Green, recursive: false, networkupdate: false);
				SendNetworkUpdate_Flags();
			}
		}
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (TrainTrackSpline.TryFindTrackNear(((Component)this).transform.position, 10f, out ourSpline, out ourSplineDist))
		{
			ourSpline.RegisterSignal(this);
			((FacepunchBehaviour)this).Invoke((Action)SetUpSignal, 0f);
		}
		else
		{
			Debug.LogWarning((object)"TrainSignal found no nearby track. Disabling lights.");
			SetLightState(LightState.None);
		}
	}

	private void SetUpSignal()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ourSpline != (Object)null)
		{
			TrainTrackSpline trainTrackSpline = ourSpline;
			float prevSplineDist = ourSplineDist;
			Vector3 askerForward = -((Component)this).transform.forward;
			TrainTrackSpline.MoveRequest.SplineAction onSpline = ProcessSplineSection;
			TrainTrackSpline.MoveResult moveResult = trainTrackSpline.MoveAlongSpline(prevSplineDist, askerForward, 500f, default(TrainTrackSpline.TrackRequest), onSpline);
			if (!testFX)
			{
				RefreshLightState();
				((FacepunchBehaviour)this).InvokeRandomized((Action)RefreshLightState, 1f, 1f, 0.1f);
			}
			Debug.DrawLine(((Component)this).transform.position, moveResult.spline.GetPosition(moveResult.distAlongSpline), IsForward() ? Color.blue : Color.cyan, 1000f);
		}
		if (testFX)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TestLights, 1f, 1f);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (ourSplines.Count > 0)
		{
			ourSplines[0].spline.DeregisterSignal(this);
		}
	}

	public void RefreshLightState()
	{
		LightState lightState = (HasOccupant() ? LightState.Red : ((!HasNextSignal) ? LightState.Green : ((nextSignal.lightState != LightState.Red) ? LightState.Green : LightState.Yellow)));
		if (lightState == LightState.Green)
		{
			if (prevTargetLightState == LightState.Green)
			{
				SetLightState(lightState);
			}
		}
		else
		{
			SetLightState(lightState);
		}
		prevTargetLightState = lightState;
	}

	private bool HasOccupant()
	{
		foreach (SplineSection ourSpline in ourSplines)
		{
			foreach (TrainTrackSpline.ITrainTrackUser trackUser in ourSpline.spline.trackUsers)
			{
				float frontWheelSplineDist = trackUser.FrontWheelSplineDist;
				if (frontWheelSplineDist >= ourSpline.startDist && frontWheelSplineDist <= ourSpline.endDist)
				{
					return true;
				}
			}
		}
		return false;
	}

	public bool IsForward()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return ourSpline.IsForward(-((Component)this).transform.forward, ourSplineDist);
	}

	private void TestLights()
	{
		SetLightState((LightState)Random.Range(1, 4));
	}

	private TrainTrackSpline.MoveResult ProcessSplineSection(TrainTrackSpline.MoveResult result, TrainTrackSpline.MoveRequest request, TrainTrackSpline spline, float splineLength)
	{
		float num = request.distAlongSpline;
		float num2 = result.distAlongSpline;
		bool flag = true;
		float num3 = num;
		if (num2 < num)
		{
			flag = false;
			num = num2;
			num2 = num3;
		}
		TrainSignal trainSignal = null;
		float num4 = float.MaxValue;
		foreach (TrainSignal signal in spline.signals)
		{
			if (!((Object)(object)signal == (Object)(object)this) && signal.IsValid() && signal.IsForward() == flag && signal.SplineDist >= num && signal.SplineDist <= num2)
			{
				float num5 = Mathf.Abs(signal.SplineDist - num3);
				if (result.totalDistMoved + num5 >= 5f && num5 < num4)
				{
					trainSignal = signal;
					num4 = num5;
				}
			}
		}
		if ((Object)(object)trainSignal != (Object)null)
		{
			result.distAlongSpline = trainSignal.SplineDist;
			if ((Object)(object)trainSignal != (Object)null)
			{
				nextSignal = trainSignal;
			}
		}
		float num6 = Mathf.Clamp(request.distAlongSpline, 0f, splineLength);
		float num7 = Mathf.Clamp(result.distAlongSpline, 0f, splineLength);
		if (num7 < num6)
		{
			SplineSection item = new SplineSection(spline, num7, num6);
			ourSplines.Add(item);
		}
		else if (num7 > num6)
		{
			SplineSection item2 = new SplineSection(spline, num6, num7);
			ourSplines.Add(item2);
		}
		return result;
	}
}


public enum LightState
{
	None,
	Green,
	Yellow,
	Red
}


private class SplineSection
{
	public readonly TrainTrackSpline spline;

	public readonly float startDist;

	public readonly float endDist;

	public SplineSection(TrainTrackSpline spline, float startDist, float endDist)
	{
		this.spline = spline;
		this.startDist = startDist;
		this.endDist = endDist;
	}
}


using UnityEngine;

public class TravellingVendorSounds : MonoBehaviour
{
	[Header("Engine")]
	[SerializeField]
	private EngineAudioSet EngineAudioSet;

	[SerializeField]
	private BlendedLoopEngineSound blendedEngineLoops;

	[SerializeField]
	private float engineRPMThrottleWeight = 0.75f;

	[SerializeField]
	private float engineRPMThrottleSpeedWeight = 0.25f;

	[SerializeField]
	private float engineRPMSpeedWeight = 0.25f;

	[SerializeField]
	private float wheelRatioMultiplier = 600f;

	[SerializeField]
	private SoundDefinition missGearSoundDef;

	[SerializeField]
	private float gearMissCooldown = 5f;

	[Header("Suspension")]
	[SerializeField]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	private float suspensionUpAngleDeltaThreshold = 0.05f;

	[SerializeField]
	private AnimationCurve suspensionDeltaSpeedGain;

	[SerializeField]
	private AnimationCurve suspensionUpAngleDeltaGain;

	[Header("Tires")]
	[SerializeField]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[Header("Movement")]
	[SerializeField]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementLoopGainCurve;

	[Header("Brakes")]
	[SerializeField]
	private SoundDefinition brakeLoopDef;

	[SerializeField]
	private SoundDefinition brakeHissDef;

	[SerializeField]
	private float brakeHissCooldown = 2f;

	[Header("Misc")]
	[SerializeField]
	private SoundDefinition angryHornSoundDef;

	[SerializeField]
	private SoundDefinition musicLoopSoundDef;
}


using UnityEngine;

public class TravellingVendorVisuals : VehicleChassisVisuals<TravellingVendor>, IClientComponent
{
	[Header("References")]
	public Transform frontAxle;

	public ModularCarChassisVisuals.Steering steering;

	public ModularCarChassisVisuals.LookAtTarget transmission;

	[Header("Settings")]
	public float wheelTurnLerpSpeed = 5f;
}


using System;

public class TutorialContainer : StorageContainer
{
	private bool acceptingItems;

	public void LoadStorage(ItemAmount[] toLoad)
	{
		base.inventory.Clear();
		acceptingItems = true;
		foreach (ItemAmount itemAmount in toLoad)
		{
			base.inventory.GiveItem(ItemManager.Create(itemAmount.itemDef, (int)itemAmount.amount, 0uL));
		}
		acceptingItems = false;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	private bool CanAcceptItem(Item item, int targetSlot)
	{
		return acceptingItems;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VendingMachineMapMarker : MapMarker
{
	public string markerShopName;

	public VendingMachine server_vendingMachine;

	public VendingMachine client_vendingMachine;

	[NonSerialized]
	public NetworkableId client_vendingMachineNetworkID;

	public GameObjectRef clusterMarkerObj;

	private UIMapVendingMachineMarker myUIMarker;

	private RectTransform markerTransform;

	public void SetVendingMachine(VendingMachine vm, string shopName)
	{
		_ = (Object)(object)vm == (Object)null;
		server_vendingMachine = vm;
		markerShopName = shopName;
		if (!((FacepunchBehaviour)this).IsInvoking((Action)TryUpdatePosition))
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)TryUpdatePosition, 30f, 30f, 10f);
		}
	}

	public void TryUpdatePosition()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)server_vendingMachine != (Object)null && (Object)(object)server_vendingMachine.GetParentEntity() != (Object)null)
		{
			((Component)this).transform.position = ((Component)server_vendingMachine).transform.position;
			try
			{
				syncPosition = true;
				NetworkPositionTick();
			}
			finally
			{
				syncPosition = false;
			}
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vendingMachine = Pool.Get<VendingMachine>();
		info.msg.vendingMachine.shopName = markerShopName;
		if ((Object)(object)server_vendingMachine != (Object)null)
		{
			if (server_vendingMachine is NPCVendingMachine { IsLocalized: not false } nPCVendingMachine)
			{
				info.msg.vendingMachine.translationToken = nPCVendingMachine.GetTranslationToken();
			}
			info.msg.vendingMachine.networkID = server_vendingMachine.net.ID;
			info.msg.vendingMachine.sellOrderContainer = server_vendingMachine.sellOrders.Copy();
			info.msg.vendingMachine.sellOrderContainer.sellOrders.RemoveAll(delegate(SellOrder x)
			{
				//IL_001d: Unknown result type (might be due to invalid IL or missing references)
				//IL_0030: Unknown result type (might be due to invalid IL or missing references)
				ItemDefinition itemDefinition = ItemManager.FindItemDefinition(x.itemToSellID);
				return !ItemManager.FindItemDefinition(x.currencyID).IsAllowedInEra(server_vendingMachine.CurrentEraRestriction) || !itemDefinition.IsAllowedInEra(server_vendingMachine.CurrentEraRestriction);
			});
		}
	}

	public override AppMarker GetAppMarkerData()
	{
		AppMarker appMarkerData = base.GetAppMarkerData();
		appMarkerData.name = markerShopName ?? "";
		appMarkerData.outOfStock = !HasFlag(Flags.Busy);
		if ((Object)(object)server_vendingMachine != (Object)null)
		{
			appMarkerData.sellOrders = Pool.Get<List<SellOrder>>();
			foreach (SellOrder sellOrder in server_vendingMachine.sellOrders.sellOrders)
			{
				if (server_vendingMachine.CanSellOrBuyItem(sellOrder.itemToSellID, sellOrder.currencyID))
				{
					SellOrder val = Pool.Get<SellOrder>();
					val.itemId = sellOrder.itemToSellID;
					val.quantity = sellOrder.itemToSellAmount;
					val.currencyId = sellOrder.currencyID;
					val.costPerItem = sellOrder.currencyAmountPerItem;
					val.amountInStock = sellOrder.inStock;
					val.itemIsBlueprint = sellOrder.itemToSellIsBP;
					val.currencyIsBlueprint = sellOrder.currencyIsBP;
					val.itemCondition = sellOrder.itemCondition;
					val.itemConditionMax = sellOrder.itemConditionMax;
					val.priceMultiplier = sellOrder.priceMultiplier;
					appMarkerData.sellOrders.Add(val);
				}
			}
		}
		return appMarkerData;
	}
}


using System;
using ProtoBuf;
using UnityEngine;

public class VisualStorageContainer : LootContainer
{
	[Serializable]
	public class DisplayModel
	{
		public GameObject displayModel;

		public ItemDefinition def;

		public int slot;
	}

	public VisualStorageContainerNode[] displayNodes;

	public DisplayModel[] displayModels;

	public Transform nodeParent;

	public GameObject defaultDisplayModel;

	public override void ServerInit()
	{
		base.ServerInit();
	}

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
	}

	public override void PopulateLoot()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		base.PopulateLoot();
		for (int i = 0; i < inventorySlots; i++)
		{
			Item slot = base.inventory.GetSlot(i);
			if (slot == null)
			{
				continue;
			}
			DroppedItem component = ((Component)slot.Drop(((Component)displayNodes[i]).transform.position + new Vector3(0f, 0.25f, 0f), Vector3.zero, ((Component)displayNodes[i]).transform.rotation)).GetComponent<DroppedItem>();
			if (Object.op_Implicit((Object)(object)component))
			{
				ReceiveCollisionMessages(b: false);
				((FacepunchBehaviour)this).CancelInvoke((Action)component.IdleDestroy);
				Rigidbody componentInChildren = ((Component)component).GetComponentInChildren<Rigidbody>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					componentInChildren.constraints = (RigidbodyConstraints)10;
				}
			}
		}
	}

	public void ClearRigidBodies()
	{
		if (displayModels == null)
		{
			return;
		}
		DisplayModel[] array = displayModels;
		foreach (DisplayModel displayModel in array)
		{
			if (displayModel != null)
			{
				Object.Destroy((Object)(object)displayModel.displayModel.GetComponentInChildren<Rigidbody>());
			}
		}
	}

	public void SetItemsVisible(bool vis)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (displayModels == null)
		{
			return;
		}
		DisplayModel[] array = displayModels;
		foreach (DisplayModel displayModel in array)
		{
			if (displayModel != null)
			{
				LODGroup componentInChildren = displayModel.displayModel.GetComponentInChildren<LODGroup>();
				if (Object.op_Implicit((Object)(object)componentInChildren))
				{
					componentInChildren.localReferencePoint = (Vector3)(vis ? Vector3.zero : new Vector3(10000f, 10000f, 10000f));
				}
				else
				{
					Debug.Log((object)("VisualStorageContainer item missing LODGroup" + ((Object)displayModel.displayModel.gameObject).name));
				}
			}
		}
	}

	public void ItemUpdateComplete()
	{
		ClearRigidBodies();
		SetItemsVisible(vis: true);
	}

	public void UpdateVisibleItems(ItemContainer msg)
	{
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < displayModels.Length; i++)
		{
			DisplayModel displayModel = displayModels[i];
			if (displayModel != null)
			{
				Object.Destroy((Object)(object)displayModel.displayModel);
				displayModels[i] = null;
			}
		}
		if (msg == null)
		{
			return;
		}
		foreach (Item content in msg.contents)
		{
			ItemDefinition itemDefinition = ItemManager.FindItemDefinition(content.itemid);
			GameObject val = null;
			val = ((itemDefinition.GetWorldModel(content.amount) == null || !itemDefinition.GetWorldModel(content.amount).isValid) ? Object.Instantiate<GameObject>(defaultDisplayModel) : itemDefinition.GetWorldModel(content.amount).Instantiate());
			if (Object.op_Implicit((Object)(object)val))
			{
				val.transform.SetPositionAndRotation(((Component)displayNodes[content.slot]).transform.position + new Vector3(0f, 0.25f, 0f), ((Component)displayNodes[content.slot]).transform.rotation);
				Rigidbody obj = val.AddComponent<Rigidbody>();
				obj.mass = 1f;
				obj.drag = 0.1f;
				obj.angularDrag = 0.1f;
				obj.interpolation = (RigidbodyInterpolation)1;
				obj.constraints = (RigidbodyConstraints)10;
				displayModels[content.slot].displayModel = val;
				displayModels[content.slot].slot = content.slot;
				displayModels[content.slot].def = itemDefinition;
				val.SetActive(true);
			}
		}
		SetItemsVisible(vis: false);
		((FacepunchBehaviour)this).CancelInvoke((Action)ItemUpdateComplete);
		((FacepunchBehaviour)this).Invoke((Action)ItemUpdateComplete, 1f);
	}
}


using System;
using UnityEngine;

[Serializable]
public class DisplayModel
{
	public GameObject displayModel;

	public ItemDefinition def;

	public int slot;
}


using UnityEngine;

public class VisualStorageContainerNode : MonoBehaviour
{
	private void Start()
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using UnityEngine;

public class WaterBall : BaseEntity
{
	public ItemDefinition liquidType;

	public int waterAmount;

	public GameObjectRef waterExplosion;

	public Collider waterCollider;

	public Rigidbody myRigidBody;

	public override void ServerInit()
	{
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)Extinguish, 10f);
	}

	public void Extinguish()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)Extinguish);
		if (!base.IsDestroyed)
		{
			Kill();
		}
	}

	public void FixedUpdate()
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		if (base.isServer && (Object)(object)myRigidBody != (Object)null)
		{
			myRigidBody.AddForce(Physics.gravity, (ForceMode)5);
		}
	}

	public static bool DoSplash(Vector3 position, float radius, ItemDefinition liquidDef, int amount)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("CanWaterBallSplash", (object)liquidDef, (object)position, (object)radius, (object)amount);
		if (obj is bool)
		{
			return (bool)obj;
		}
		List<BaseEntity> list = Pool.Get<List<BaseEntity>>();
		Vis.Entities(position, radius, list, 1220225811, (QueryTriggerInteraction)2);
		int num = 0;
		int num2 = amount;
		bool flag = false;
		while (amount > 0 && num < 3)
		{
			List<ISplashable> list2 = Pool.Get<List<ISplashable>>();
			foreach (BaseEntity item in list)
			{
				if (item.isClient || !(item is ISplashable splashable) || list2.Contains(splashable) || !splashable.WantsSplash(liquidDef, amount))
				{
					continue;
				}
				bool flag2 = true;
				bool flag3 = item is PlanterBox;
				bool flag4 = item is TimedExplosive;
				if (flag3 || flag4)
				{
					Vector3 val = Vector3.zero;
					if (flag3)
					{
						val = Vector3.up;
					}
					if (!GamePhysics.LineOfSight(((Component)item).transform.position + val, position, 2097152))
					{
						flag2 = false;
					}
					if (flag2)
					{
						flag = true;
					}
				}
				if (flag2)
				{
					list2.Add(splashable);
				}
			}
			if (list2.Count == 0)
			{
				break;
			}
			int num3 = Mathf.CeilToInt((float)(amount / list2.Count));
			foreach (ISplashable item2 in list2)
			{
				if (!flag || !(item2 is BasePlayer))
				{
					int num4 = item2.DoSplash(liquidDef, Mathf.Min(amount, num3));
					amount -= num4;
					if (amount <= 0)
					{
						break;
					}
				}
			}
			Pool.FreeUnmanaged<ISplashable>(ref list2);
			num++;
		}
		Pool.FreeUnmanaged<BaseEntity>(ref list);
		return amount < num2;
	}

	private void OnCollisionEnter(Collision collision)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !myRigidBody.isKinematic)
		{
			float num = 2.5f;
			Vector3 position = ((Component)this).transform.position;
			float num2 = num * 0.75f;
			if (GamePhysics.Trace(new Ray(position, Vector3.up), 0.05f, out var hitInfo, num2, 1084293377, (QueryTriggerInteraction)0))
			{
				num2 = ((RaycastHit)(ref hitInfo)).distance;
			}
			DoSplash(position + new Vector3(0f, num2, 0f), num, liquidType, waterAmount);
			Effect.server.Run(waterExplosion.resourcePath, position, Vector3.up);
			myRigidBody.isKinematic = true;
			waterCollider.enabled = false;
			((FacepunchBehaviour)this).Invoke((Action)Extinguish, 2f);
		}
	}
}


using UnityEngine;

public class WeaponRackBatchAutoSet : MonoBehaviour
{
	public Transform Anchor;

	public Object MountConfigScript;
}


public static class WeaponRackGhost
{
}


using ProtoBuf;
using Rust;
using UnityEngine;

public class WeaponRackSlot
{
	[InspectorFlags]
	public AmmoTypes AmmoTypes;

	public bool Used { get; private set; }

	public ItemDefinition ItemDef { get; private set; }

	public int ClientItemID { get; private set; }

	public ulong ClientItemSkinID { get; private set; }

	public ItemDefinition AmmoItemDef { get; private set; }

	public int AmmoItemID { get; private set; }

	public int AmmoCount { get; private set; }

	public int AmmoMax { get; private set; }

	public float Condition { get; private set; }

	public int InventoryIndex { get; private set; }

	public int GridSlotIndex { get; private set; }

	public int Rotation { get; private set; }

	public float ReloadTime { get; private set; }

	public void SetUsed(bool flag)
	{
		Used = flag;
	}

	public WeaponRackItem SaveToProto(Item item, WeaponRackItem proto)
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Expected I4, but got Unknown
		proto.itemID = item?.info.itemid ?? 0;
		proto.skinid = item?.skin ?? 0;
		proto.inventorySlot = InventoryIndex;
		proto.gridSlotIndex = GridSlotIndex;
		proto.rotation = Rotation;
		proto.ammoCount = AmmoCount;
		proto.ammoMax = AmmoMax;
		proto.ammoID = AmmoItemID;
		proto.condition = Condition;
		proto.ammoTypes = (int)AmmoTypes;
		proto.reloadTime = ReloadTime;
		return proto;
	}

	public void InitFromProto(WeaponRackItem item)
	{
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		ClientItemID = item.itemID;
		ClientItemSkinID = item.skinid;
		ItemDef = ItemManager.FindItemDefinition(ClientItemID);
		InventoryIndex = item.inventorySlot;
		GridSlotIndex = item.gridSlotIndex;
		AmmoCount = item.ammoCount;
		AmmoMax = item.ammoMax;
		AmmoItemID = item.ammoID;
		AmmoItemDef = ((AmmoItemID != 0) ? ItemManager.FindItemDefinition(AmmoItemID) : null);
		Condition = item.condition;
		Rotation = item.rotation;
		AmmoTypes = (AmmoTypes)item.ammoTypes;
		ReloadTime = item.reloadTime;
	}

	public void SetItem(Item item, ItemDefinition updatedItemDef, int gridCellIndex, int rotation)
	{
		InventoryIndex = item.position;
		GridSlotIndex = gridCellIndex;
		Condition = item.conditionNormalized;
		Rotation = rotation;
		SetAmmoDetails(item);
		ItemDef = updatedItemDef;
	}

	public void SetAmmoDetails(Item item)
	{
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		ClearAmmoDetails();
		BaseEntity heldEntity = item.GetHeldEntity();
		if (!((Object)(object)heldEntity == (Object)null))
		{
			BaseProjectile component = ((Component)heldEntity).GetComponent<BaseProjectile>();
			if (!((Object)(object)component == (Object)null))
			{
				AmmoItemDef = component.primaryMagazine.ammoType;
				AmmoItemID = (((Object)(object)AmmoItemDef != (Object)null) ? AmmoItemDef.itemid : 0);
				AmmoCount = component.primaryMagazine.contents;
				AmmoMax = component.primaryMagazine.capacity;
				AmmoTypes = component.primaryMagazine.definition.ammoTypes;
				ReloadTime = component.GetReloadDuration();
			}
		}
	}

	private void ClearAmmoDetails()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		AmmoItemDef = null;
		AmmoTypes = (AmmoTypes)0;
		AmmoItemID = 0;
		AmmoCount = 0;
		AmmoMax = 0;
		ReloadTime = 0f;
	}

	public bool CanBeReloadedAtWeaponRack()
	{
		if ((Object)(object)ItemDef == (Object)null)
		{
			return false;
		}
		WorldModelRackMountConfig forItemDef = WorldModelRackMountConfig.GetForItemDef(ItemDef);
		if ((Object)(object)forItemDef == (Object)null)
		{
			return false;
		}
		return forItemDef.CanReloadOnWeaponRack;
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class WhitelistLootContainer : LootContainer
{
	public static readonly Phrase CantLootToast = new Phrase("whitelistcontainer.noloot", "You are not authorized to access this box");

	[NonSerialized]
	public List<ulong> whitelist = new List<ulong>();

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk)
		{
			return;
		}
		info.msg.whitelist = Pool.Get<Whitelist>();
		info.msg.whitelist.users = Pool.Get<List<ulong>>();
		foreach (ulong item in whitelist)
		{
			info.msg.whitelist.users.Add(item);
			Debug.Log((object)("Whitelistcontainer saving user " + item));
		}
	}

	public override void Load(LoadInfo info)
	{
		if (info.fromDisk && info.msg.whitelist != null)
		{
			foreach (ulong user in info.msg.whitelist.users)
			{
				whitelist.Add(user);
			}
		}
		base.Load(info);
	}

	public void MissionSetupPlayer(BasePlayer player)
	{
		AddToWhitelist(player.userID);
	}

	public void AddToWhitelist(ulong userid)
	{
		if (!whitelist.Contains(userid))
		{
			whitelist.Add(userid);
		}
	}

	public void RemoveFromWhitelist(ulong userid)
	{
		if (whitelist.Contains(userid))
		{
			whitelist.Remove(userid);
		}
	}

	public override bool PlayerOpenLoot(BasePlayer player, string panelToOpen = "", bool doPositionChecks = true)
	{
		ulong item = player.userID.Get();
		if (!whitelist.Contains(item))
		{
			player.ShowToast(GameTip.Styles.Red_Normal, CantLootToast, false);
			return false;
		}
		return base.PlayerOpenLoot(player, panelToOpen, doPositionChecks);
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ConVar;
using Cronos;
using Facepunch;
using Facepunch.Math;
using Newtonsoft.Json;
using ProtoBuf;
using TimeZoneConverter;
using UnityEngine;

public class WipeTimer : BaseEntity
{
	public enum WipeFrequency
	{
		Monthly,
		Weekly,
		BiWeekly
	}

	[ServerVar(Help = "0=sun,1=mon,2=tues,3=wed,4=thur,5=fri,6=sat")]
	public static int wipeDayOfWeek = 4;

	[ServerVar(Help = "Which hour to wipe? 14.5 = 2:30pm")]
	public static float wipeHourOfDay = 19f;

	[ServerVar(Help = "The timezone to use for wipes. Defaults to the server's time zone if not set or invalid. Value should be a TZ identifier as seen here: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones")]
	public static string wipeTimezone = "Europe/London";

	[ServerVar(Help = "Unix timestamp (seconds) for the upcoming wipe. Overrides all other convars if set to a time in the future.")]
	public static long wipeUnixTimestampOverride = 0L;

	[ServerVar(Help = "Custom cron expression for the wipe schedule. Overrides all other convars (except wipeUnixTimestampOverride) if set. Uses Cronos as a parser: https://github.com/HangfireIO/Cronos/")]
	public static string wipeCronOverride = "";

	public bool useWipeDayOverride;

	public DayOfWeek wipeDayOfWeekOverride = DayOfWeek.Thursday;

	public WipeFrequency wipeFrequency;

	[ServerVar(Name = "days_to_add_test")]
	public static int daysToAddTest = 0;

	[ServerVar(Name = "hours_to_add_test")]
	public static float hoursToAddTest = 0f;

	public static WipeTimer serverinstance;

	public static WipeTimer clientinstance;

	private string oldTags = "";

	private static string cronExprCacheKey = null;

	private static CronExpression cronExprCache = null;

	private static (WipeFrequency, int, float)? cronCacheKey = null;

	private static string cronCache = null;

	private static string timezoneCacheKey = null;

	private static TimeZoneInfo timezoneCache = null;

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			serverinstance = this;
		}
		if (base.isClient)
		{
			clientinstance = this;
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			serverinstance = null;
		}
		if (base.isClient)
		{
			clientinstance = null;
		}
		base.DestroyShared();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		RecalculateWipeFrequency();
		((FacepunchBehaviour)this).InvokeRepeating((Action)TryAndUpdate, 1f, 4f);
	}

	public void RecalculateWipeFrequency()
	{
		string tags = Server.tags;
		if (tags.Contains("monthly"))
		{
			wipeFrequency = WipeFrequency.Monthly;
		}
		else if (tags.Contains("biweekly"))
		{
			wipeFrequency = WipeFrequency.BiWeekly;
		}
		else if (tags.Contains("weekly"))
		{
			wipeFrequency = WipeFrequency.Weekly;
		}
		else
		{
			wipeFrequency = WipeFrequency.Monthly;
		}
	}

	public void TryAndUpdate()
	{
		if (Server.tags != oldTags)
		{
			RecalculateWipeFrequency();
			oldTags = Server.tags;
		}
		SendNetworkUpdate();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (!info.forDisk && info.msg.landmine == null)
		{
			info.msg.landmine = Pool.Get<Landmine>();
			info.msg.landmine.triggeredID = (ulong)GetTicksUntilWipe();
		}
	}

	public TimeSpan GetTimeSpanUntilWipe()
	{
		DateTimeOffset dateTimeOffset = DateTimeOffset.UtcNow.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		return GetWipeTime(dateTimeOffset) - dateTimeOffset;
	}

	public long GetTicksUntilWipe()
	{
		return GetTimeSpanUntilWipe().Ticks;
	}

	[ServerVar]
	public static void PrintWipe(Arg arg)
	{
		if ((Object)(object)serverinstance == (Object)null)
		{
			arg.ReplyWith("WipeTimer not found!");
			return;
		}
		serverinstance.RecalculateWipeFrequency();
		serverinstance.TryAndUpdate();
		TimeZoneInfo timeZone = GetTimeZone();
		string text = default(string);
		string text2 = (TZConvert.TryWindowsToIana(timeZone.Id, ref text) ? text : timeZone.Id);
		DateTimeOffset dateTimeOffset = DateTimeOffset.UtcNow.AddDays(daysToAddTest).AddHours(hoursToAddTest);
		DateTimeOffset wipeTime = serverinstance.GetWipeTime(dateTimeOffset);
		TimeSpan timeSpan = wipeTime - dateTimeOffset;
		string cronString = GetCronString(serverinstance.wipeFrequency, serverinstance.useWipeDayOverride ? ((int)serverinstance.wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay);
		CronExpression cronExpression = GetCronExpression(serverinstance.wipeFrequency, serverinstance.useWipeDayOverride ? ((int)serverinstance.wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay);
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.AppendLine($"Frequency: {serverinstance.wipeFrequency}");
		stringBuilder.AppendLine("Timezone: " + timeZone.StandardName + " (ID=" + timeZone.Id + ", IANA=" + text2 + ")");
		stringBuilder.AppendLine($"Wipe day of week: {(DayOfWeek)wipeDayOfWeek}");
		stringBuilder.AppendLine($"Wipe hour: {wipeHourOfDay}");
		stringBuilder.AppendLine($"Test time: {dateTimeOffset:O}");
		stringBuilder.AppendLine($"Wipe time: {wipeTime:O}");
		stringBuilder.AppendLine($"Time until wipe: {timeSpan:g}");
		stringBuilder.AppendLine($"Ticks until wipe: {timeSpan.Ticks}");
		stringBuilder.AppendLine();
		stringBuilder.AppendLine("Cron: " + cronString);
		stringBuilder.AppendLine("Next 10 occurrences:");
		int num = 0;
		foreach (DateTimeOffset item in cronExpression.GetOccurrences(dateTimeOffset, dateTimeOffset.AddYears(2), timeZone, true, false).Take(10))
		{
			stringBuilder.AppendLine($"  {num}. {item:O}");
			num++;
		}
		arg.ReplyWith(stringBuilder.ToString());
	}

	[ServerVar]
	public static void PrintTimeZones(Arg arg)
	{
		List<string> systemTzs = (from z in TimeZoneInfo.GetSystemTimeZones()
			select z.Id).ToList();
		IReadOnlyCollection<string> knownWindowsTimeZoneIds = TZConvert.KnownWindowsTimeZoneIds;
		IReadOnlyCollection<string> knownIanaTimeZoneNames = TZConvert.KnownIanaTimeZoneNames;
		arg.ReplyWith(JsonConvert.SerializeObject((object)new
		{
			systemTzs = systemTzs,
			windowsTzs = knownWindowsTimeZoneIds,
			ianaTzs = knownIanaTimeZoneNames
		}));
	}

	public DateTimeOffset GetWipeTime(DateTimeOffset nowTime)
	{
		if (wipeUnixTimestampOverride > 0 && wipeUnixTimestampOverride > Epoch.Current)
		{
			return Epoch.ToDateTime(wipeUnixTimestampOverride);
		}
		try
		{
			return GetCronExpression(wipeFrequency, useWipeDayOverride ? ((int)wipeDayOfWeekOverride) : wipeDayOfWeek, wipeHourOfDay).GetNextOccurrence(nowTime, GetTimeZone(), false) ?? DateTimeOffset.MaxValue;
		}
		catch (Exception ex)
		{
			Debug.LogException(ex);
			return DateTimeOffset.MaxValue;
		}
	}

	private bool HoursUntilWipe(float hours)
	{
		if (serverinstance.GetTimeSpanUntilWipe().TotalHours < (double)hours)
		{
			return true;
		}
		return false;
	}

	private static CronExpression GetCronExpression(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		string cronString = GetCronString(frequency, dayOfWeek, hourOfDay);
		if (cronString == cronExprCacheKey && cronExprCache != (CronExpression)null)
		{
			return cronExprCache;
		}
		cronExprCache = CronExpression.Parse(cronString);
		cronExprCacheKey = cronString;
		return cronExprCache;
	}

	private static string GetCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		if (!string.IsNullOrWhiteSpace(wipeCronOverride))
		{
			return wipeCronOverride;
		}
		(WipeFrequency, int, float) tuple = (frequency, dayOfWeek, hourOfDay);
		(WipeFrequency, int, float) tuple2 = tuple;
		(WipeFrequency, int, float)? tuple3 = cronCacheKey;
		if (tuple3.HasValue)
		{
			(WipeFrequency, int, float) valueOrDefault = tuple3.GetValueOrDefault();
			if (tuple2.Item1 == valueOrDefault.Item1 && tuple2.Item2 == valueOrDefault.Item2 && tuple2.Item3 == valueOrDefault.Item3 && cronCache != null)
			{
				return cronCache;
			}
		}
		cronCache = BuildCronString(frequency, dayOfWeek, hourOfDay);
		cronCacheKey = tuple;
		return cronCache;
	}

	private static string BuildCronString(WipeFrequency frequency, int dayOfWeek, float hourOfDay)
	{
		int num = Mathf.FloorToInt(hourOfDay);
		int num2 = Mathf.FloorToInt((hourOfDay - (float)num) * 60f);
		return frequency switch
		{
			WipeFrequency.Weekly => $"{num2} {num} * * {dayOfWeek}", 
			WipeFrequency.BiWeekly => $"{num2} {num} 1-7,15-21,29-31 * {dayOfWeek}", 
			WipeFrequency.Monthly => $"{num2} {num} * * {dayOfWeek}#1", 
			_ => throw new NotSupportedException($"WipeFrequency {frequency}"), 
		};
	}

	private static TimeZoneInfo GetTimeZone()
	{
		if (string.IsNullOrWhiteSpace(wipeTimezone))
		{
			return TimeZoneInfo.Local;
		}
		if (wipeTimezone == timezoneCacheKey && timezoneCache != null)
		{
			return timezoneCache;
		}
		if (TZConvert.TryGetTimeZoneInfo(wipeTimezone, ref timezoneCache))
		{
			timezoneCacheKey = wipeTimezone;
			return timezoneCache;
		}
		return TimeZoneInfo.Local;
	}
}


public enum WipeFrequency
{
	Monthly,
	Weekly,
	BiWeekly
}


using UnityEngine;
using UnityEngine.UI;

public class WipeTimerScreen : MonoBehaviour
{
	public Text timerText;
}


using System.Collections.Generic;
using ConVar;
using Rust;
using UnityEngine;

public abstract class BaseModifiers<T> : EntityComponent<T> where T : BaseCombatEntity
{
	public List<Modifier> All = new List<Modifier>();

	protected Dictionary<Modifier.ModifierType, float> totalValues = new Dictionary<Modifier.ModifierType, float>();

	protected Dictionary<Modifier.ModifierType, float> modifierVariables = new Dictionary<Modifier.ModifierType, float>();

	protected Dictionary<Modifier.ModifierSource, int> sourceCounts = new Dictionary<Modifier.ModifierSource, int>();

	protected T owner;

	protected bool dirty = true;

	protected float timeSinceLastTick;

	protected float lastTickTime;

	public int ActiveModifierCount => All.Count;

	public int ActiveTeaCount
	{
		get
		{
			int num = 0;
			foreach (Modifier item in All)
			{
				if (item != null && item.Source == Modifier.ModifierSource.Tea)
				{
					num++;
				}
			}
			return num;
		}
	}

	public void Add(List<ModifierDefintion> modDefs, float effectScale = 1f, float durationScale = 1f)
	{
		foreach (ModifierDefintion modDef in modDefs)
		{
			if (IsCompatible(modDef.type))
			{
				Add(modDef, effectScale, durationScale);
			}
		}
	}

	protected virtual bool IsCompatible(Modifier.ModifierType modType)
	{
		return true;
	}

	protected void Add(ModifierDefintion def, float effectScale = 1f, float durationScale = 1f)
	{
		Modifier modifier = new Modifier();
		modifier.Init(def.type, def.source, def.value * effectScale, def.duration * durationScale, def.duration * durationScale);
		Add(modifier);
	}

	protected void Add(Modifier modifier)
	{
		if (!CanAdd(modifier))
		{
			return;
		}
		int maxModifierCount = GetMaxModifierCount(modifier);
		if (GetActiveCount(modifier.Type, modifier.Source) >= maxModifierCount)
		{
			Modifier shortestLifeModifier = GetShortestLifeModifier(modifier.Type, modifier.Source);
			if (shortestLifeModifier == null)
			{
				return;
			}
			Remove(shortestLifeModifier);
		}
		All.Add(modifier);
		AdjustSourceCount(modifier.Source, 1);
		ApplyModifierValue(modifier);
		SetDirty(flag: true);
	}

	private void AdjustSourceCount(Modifier.ModifierSource source, int adjustBy)
	{
		sourceCounts.TryGetValue(source, out var value);
		sourceCounts[source] = value + 1;
	}

	public int GetSourceCount(Modifier.ModifierSource source)
	{
		return sourceCounts.GetValueOrDefault(source, 0);
	}

	private void ApplyModifierValue(Modifier modifier)
	{
		float value = modifier.Value;
		if (!totalValues.ContainsKey(modifier.Type))
		{
			totalValues.Add(modifier.Type, value);
		}
		else
		{
			totalValues[modifier.Type] += value;
		}
		totalValues[modifier.Type] = GetClampedValue(modifier, totalValues[modifier.Type]);
	}

	private bool CanAdd(Modifier modifier)
	{
		if (All.Contains(modifier))
		{
			return false;
		}
		return true;
	}

	private int GetMaxModifiersForSourceType(Modifier.ModifierSource source)
	{
		if (source == Modifier.ModifierSource.Tea || source == Modifier.ModifierSource.Interaction)
		{
			return 1;
		}
		return int.MaxValue;
	}

	protected virtual int GetMaxModifierCount(Modifier modifier)
	{
		if (modifier == null)
		{
			return 0;
		}
		Modifier.ModifierSource source = modifier.Source;
		if (source == Modifier.ModifierSource.Tea || source == Modifier.ModifierSource.Interaction)
		{
			return 1;
		}
		return int.MaxValue;
	}

	protected virtual float GetClampedValue(Modifier modifier, float value)
	{
		return value;
	}

	private int GetActiveCount(Modifier.ModifierType type, Modifier.ModifierSource source)
	{
		int num = 0;
		foreach (Modifier item in All)
		{
			if (item.Type == type && item.Source == source)
			{
				num++;
			}
		}
		return num;
	}

	private Modifier GetShortestLifeModifier(Modifier.ModifierType type, Modifier.ModifierSource source)
	{
		Modifier modifier = null;
		foreach (Modifier item in All)
		{
			if (item.Type == type && item.Source == source)
			{
				if (modifier == null)
				{
					modifier = item;
				}
				else if (item.TimeRemaining < modifier.TimeRemaining)
				{
					modifier = item;
				}
			}
		}
		return modifier;
	}

	private void Remove(Modifier toRemove)
	{
		bool flag = false;
		bool flag2 = false;
		Modifier.ModifierType type = toRemove.Type;
		foreach (Modifier item in All)
		{
			if (toRemove == item)
			{
				flag = true;
			}
			else if (item.Type == type)
			{
				flag2 = true;
			}
		}
		if (flag)
		{
			All.Remove(toRemove);
			AdjustSourceCount(toRemove.Source, -1);
			if (!flag2)
			{
				totalValues.Remove(toRemove.Type);
			}
			SetDirty(flag: true);
		}
	}

	public void RemoveAll()
	{
		All.Clear();
		totalValues.Clear();
		sourceCounts.Clear();
		SetDirty(flag: true);
	}

	public void RemoveFromSource(Modifier.ModifierSource source)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			if (modifier != null && modifier.Source == source)
			{
				Remove(modifier);
			}
		}
	}

	public float GetValue(Modifier.ModifierType type, float defaultValue = 0f)
	{
		float num = 1f;
		if (IsModifierCompatibleWithDigestionBoost(type))
		{
			num = GetValue(Modifier.ModifierType.DigestionBoost, 1f);
		}
		if (totalValues.TryGetValue(type, out var value))
		{
			return value * num;
		}
		return defaultValue * num;
	}

	public void SetValue(Modifier.ModifierSource source, Modifier.ModifierType type, float value)
	{
		Modifier modifier = new Modifier();
		bool flag = false;
		foreach (Modifier item in All)
		{
			if (item != null && item.Source == source && item.Type == type)
			{
				modifier.Init(item.Type, item.Source, value, item.Duration, item.TimeRemaining);
				flag = true;
				break;
			}
		}
		if (flag)
		{
			Add(modifier);
		}
	}

	public float GetVariableValue(Modifier.ModifierType type, float defaultValue)
	{
		if (modifierVariables.TryGetValue(type, out var value))
		{
			return value;
		}
		return defaultValue;
	}

	public void SetVariableValue(Modifier.ModifierType type, float value)
	{
		if (modifierVariables.TryGetValue(type, out var _))
		{
			modifierVariables[type] = value;
		}
		else
		{
			modifierVariables.Add(type, value);
		}
	}

	public void RemoveVariable(Modifier.ModifierType type)
	{
		modifierVariables.Remove(type);
	}

	protected virtual void OnDisable()
	{
		if (!Application.isQuitting)
		{
			owner = null;
		}
	}

	public void SetDirty(bool flag)
	{
		dirty = flag;
	}

	public virtual void ServerInit(T owner)
	{
		this.owner = owner;
		ResetTicking();
		RemoveAll();
	}

	public void ResetTicking()
	{
		lastTickTime = Time.realtimeSinceStartup;
		timeSinceLastTick = 0f;
	}

	public virtual void ServerUpdate(BaseCombatEntity ownerEntity)
	{
		float num = Time.realtimeSinceStartup - lastTickTime;
		lastTickTime = Time.realtimeSinceStartup;
		timeSinceLastTick += num;
		if (!(timeSinceLastTick <= ConVar.Server.modifierTickRate))
		{
			if ((Object)(object)owner != (Object)null && !owner.IsDead())
			{
				TickModifiers(ownerEntity, timeSinceLastTick);
			}
			timeSinceLastTick = 0f;
		}
	}

	protected virtual void TickModifiers(BaseCombatEntity ownerEntity, float delta)
	{
		for (int num = All.Count - 1; num >= 0; num--)
		{
			Modifier modifier = All[num];
			float num2 = (IsModifierCompatibleWithDigestionBoost(modifier.Type) ? GetValue(Modifier.ModifierType.DigestionBoost, 1f) : 1f);
			modifier.Tick(ownerEntity, delta * num2);
			if (modifier.Expired)
			{
				Remove(modifier);
			}
		}
	}

	protected bool IsModifierCompatibleWithDigestionBoost(Modifier.ModifierType modifierType)
	{
		if ((uint)modifierType <= 1u || modifierType == Modifier.ModifierType.Scrap_Yield || modifierType == Modifier.ModifierType.Harvesting)
		{
			return true;
		}
		return false;
	}
}


using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class HorseModifiers : BaseModifiers<RidableHorse>
{
	public static void AddToHorse(RidableHorse horse, List<ModifierDefintion> modifiers)
	{
		if (!((Object)(object)horse == (Object)null) && !((Object)(object)horse.modifiers == (Object)null) && modifiers != null)
		{
			horse.modifiers.Add(modifiers);
		}
	}

	protected override bool IsCompatible(Modifier.ModifierType modType)
	{
		if ((uint)(modType - 20) <= 1u)
		{
			return true;
		}
		return false;
	}

	public HorseModifiers Save(bool forDisk)
	{
		HorseModifiers val = Pool.Get<HorseModifiers>();
		val.modifiers = Pool.Get<List<Modifier>>();
		foreach (Modifier item2 in All)
		{
			if (item2 != null && (!forDisk || item2.Source != Modifier.ModifierSource.Interaction))
			{
				Modifier item = item2.Save();
				val.modifiers.Add(item);
			}
		}
		return val;
	}

	public void Load(HorseModifiers m, bool fromDisk)
	{
		RemoveAll();
		if (m == null || m.modifiers == null)
		{
			return;
		}
		foreach (Modifier modifier2 in m.modifiers)
		{
			if (modifier2 != null && (!fromDisk || modifier2.source != 2))
			{
				Modifier modifier = new Modifier();
				modifier.Init((Modifier.ModifierType)modifier2.type, (Modifier.ModifierSource)modifier2.source, modifier2.value, modifier2.duration, modifier2.timeRemaing);
				Add(modifier);
			}
		}
	}
}


using System;

[Serializable]
public class ModifierDefintion
{
	public Modifier.ModifierType type;

	public Modifier.ModifierSource source;

	public float value;

	public float duration;
}


using System;

[Serializable]
public class ModifierLimit
{
	public Modifier.ModifierSource source;

	public int MaxApplications;

	public float minValue;

	public float maxValue;
}


using System;
using System.Collections.Generic;

[Serializable]
public class ModifierLimits
{
	public Modifier.ModifierType type;

	public float minValue;

	public float maxValue;

	public List<ModifierLimit> limits;
}


using System;
using Facepunch;
using ProtoBuf;

public class Modifier
{
	public enum ModifierType
	{
		Wood_Yield,
		Ore_Yield,
		Radiation_Resistance,
		Radiation_Exposure_Resistance,
		Max_Health,
		Scrap_Yield,
		MoveSpeed,
		ObscureVision,
		Warming,
		Cooling,
		CoreTemperatureMinAdjustment,
		CoreTemperatureMaxAdjustment,
		Crafting_Quality,
		VisionCare,
		MetabolismBooster,
		Harvesting,
		DigestionBoost,
		FishingBoost,
		Collectible_DoubleYield,
		Farming_BetterGenes,
		HorseGallopSpeed,
		HorseDungProductionBoost,
		Comfort,
		Clotting,
		HunterVision,
		Radiation
	}

	public enum ModifierSource
	{
		Tea,
		Dart,
		Interaction,
		NegativeEffect
	}

	public static Phrase WoodYieldPhrase = new Phrase("mod.woodyield", "Wood Yield");

	public static Phrase OreYieldPhrase = new Phrase("mod.oreyield", "Ore Yield");

	public static Phrase RadiationResistancePhrase = new Phrase("mod.radiationresistance", "Radiation Resistance");

	public static Phrase RadiationExposureResistancePhrase = new Phrase("mod.radiationexposureresistance", "Radiation Exposure Resistance");

	public static Phrase MaxHealthPhrase = new Phrase("mod.maxhealth", "Max Health");

	public static Phrase ScrapYieldPhrase = new Phrase("mod.scrapyield", "Scrap Yield");

	public static Phrase MoveSpeedPhrase = new Phrase("mod.movespeed", "Movement Speed");

	public static Phrase ObscureVisionPhrase = new Phrase("mod.ObscureVision", "Obscure Vision");

	public static Phrase RadiationPhrase = new Phrase("mod.radiation", "Radiation");

	public static Phrase CraftingQualityPhrase = new Phrase("mod.craftingquality", "Crafting Quality");

	public static Phrase WarmingPhrase = new Phrase("mod.warming", "Warming");

	public static Phrase CoolingPhrase = new Phrase("mod.cooling", "Cooling");

	public static Phrase CoreTempMinPhrase = new Phrase("mod.coretempmin", "Min Temp");

	public static Phrase CoreTempMaxPhrase = new Phrase("mod.coretempmax", "Max Temp");

	public static Phrase VisionCarePhrase = new Phrase("mod.VisionCare", "Vision Care");

	public static Phrase MetabolismBoosterPhrase = new Phrase("mod.MetabolismBooster", "Metabolism Booster");

	public static Phrase HarvestingPhrase = new Phrase("mod.Harvesting", "Harvesting");

	public static Phrase DigestionBoostPhrase = new Phrase("mod.DigestionBoost", "Digestion Boost");

	public static Phrase FishingBoostPhrase = new Phrase("mod.FishingBoost", "Fishing Boost");

	public static Phrase CollectibleYieldPhrase = new Phrase("mod.CollectibleDoubleYield", "Double Yield Chance");

	public static Phrase Farming_BetterGenesPhrase = new Phrase("mod.Farming_BetterGenes", "Better Genes Chance");

	public static Phrase HorseGallopSpeedPhrase = new Phrase("mod.HorseGallopSpeed", "Horse Gallop Speed");

	public static Phrase ComfortPhrase = new Phrase("mod.Comfort", "Comfort");

	public static Phrase ClottingPhrase = new Phrase("mod.Clotting", "Clotting");

	public static Phrase Temperature = new Phrase("mod.temperature", "Temperature: ");

	public static Phrase MinTemp = new Phrase("mod.mintemp", "Min temperature: ");

	public static Phrase MaxTemp = new Phrase("mod.maxtemp", "Max temperature: ");

	public static Phrase HunterVisionPhrase = new Phrase("mod.huntervision", "Hunter Vision");

	public ModifierType Type { get; private set; }

	public ModifierSource Source { get; private set; }

	public float Value { get; private set; } = 1f;

	public float Duration { get; private set; } = 10f;

	public float TimeRemaining { get; private set; }

	public bool Expired { get; private set; }

	public void Init(ModifierType type, ModifierSource source, float value, float duration, float remaining)
	{
		Type = type;
		Source = source;
		Value = value;
		Duration = duration;
		Expired = false;
		TimeRemaining = remaining;
	}

	public void Tick(BaseCombatEntity ownerEntity, float delta)
	{
		TimeRemaining -= delta;
		Expired = Duration > 0f && TimeRemaining <= 0f;
	}

	public Modifier Save()
	{
		Modifier obj = Pool.Get<Modifier>();
		obj.type = (int)Type;
		obj.source = (int)Source;
		obj.value = Value;
		obj.timeRemaing = TimeRemaining;
		obj.duration = Duration;
		return obj;
	}

	public void Load(Modifier m)
	{
		Type = (ModifierType)m.type;
		Source = (ModifierSource)m.source;
		Value = m.value;
		TimeRemaining = m.timeRemaing;
		Duration = m.duration;
	}

	public static Phrase GetPhraseForModType(ModifierType type)
	{
		switch (type)
		{
		case ModifierType.Wood_Yield:
			return WoodYieldPhrase;
		case ModifierType.Ore_Yield:
			return OreYieldPhrase;
		case ModifierType.Radiation_Resistance:
			return RadiationResistancePhrase;
		case ModifierType.Radiation_Exposure_Resistance:
			return RadiationExposureResistancePhrase;
		case ModifierType.Max_Health:
			return MaxHealthPhrase;
		case ModifierType.Scrap_Yield:
			return ScrapYieldPhrase;
		case ModifierType.MoveSpeed:
			return MoveSpeedPhrase;
		case ModifierType.ObscureVision:
			return ObscureVisionPhrase;
		case ModifierType.Crafting_Quality:
			return CraftingQualityPhrase;
		case ModifierType.Warming:
			return WarmingPhrase;
		case ModifierType.Cooling:
			return CoolingPhrase;
		case ModifierType.CoreTemperatureMinAdjustment:
			return CoreTempMinPhrase;
		case ModifierType.CoreTemperatureMaxAdjustment:
			return CoreTempMaxPhrase;
		case ModifierType.VisionCare:
			return VisionCarePhrase;
		case ModifierType.MetabolismBooster:
			return MetabolismBoosterPhrase;
		case ModifierType.Harvesting:
			return HarvestingPhrase;
		case ModifierType.DigestionBoost:
		case ModifierType.HorseDungProductionBoost:
			return DigestionBoostPhrase;
		case ModifierType.FishingBoost:
			return FishingBoostPhrase;
		case ModifierType.Collectible_DoubleYield:
			return CollectibleYieldPhrase;
		case ModifierType.Farming_BetterGenes:
			return Farming_BetterGenesPhrase;
		case ModifierType.HorseGallopSpeed:
			return HorseGallopSpeedPhrase;
		case ModifierType.Comfort:
			return ComfortPhrase;
		case ModifierType.Clotting:
			return ClottingPhrase;
		case ModifierType.HunterVision:
			return HunterVisionPhrase;
		case ModifierType.Radiation:
			return RadiationPhrase;
		default:
			throw new ArgumentOutOfRangeException("type", type, $"Couldn't find a phrase for this modifier! {type}");
		}
	}
}


public enum ModifierType
{
	Wood_Yield,
	Ore_Yield,
	Radiation_Resistance,
	Radiation_Exposure_Resistance,
	Max_Health,
	Scrap_Yield,
	MoveSpeed,
	ObscureVision,
	Warming,
	Cooling,
	CoreTemperatureMinAdjustment,
	CoreTemperatureMaxAdjustment,
	Crafting_Quality,
	VisionCare,
	MetabolismBooster,
	Harvesting,
	DigestionBoost,
	FishingBoost,
	Collectible_DoubleYield,
	Farming_BetterGenes,
	HorseGallopSpeed,
	HorseDungProductionBoost,
	Comfort,
	Clotting,
	HunterVision,
	Radiation
}


public enum ModifierSource
{
	Tea,
	Dart,
	Interaction,
	NegativeEffect
}


using UnityEngine;

public class ExcavatorEffects : MonoBehaviour
{
	public static ExcavatorEffects instance;

	public ParticleSystemContainer[] miningParticles;

	public SoundPlayer[] miningSounds;

	public SoundFollowCollider[] beltSounds;

	public SoundPlayer[] miningStartSounds;

	public GameObject[] ambientMetalRattles;

	public bool wasMining;
}


using UnityEngine;

public class ExcavatorEngineSounds : MonoBehaviour, IClientComponent
{
	public SoundPlayer[] engineStartClunks;

	public void PlayStartClunks()
	{
	}
}


public class ExcavatorOutputPile : StorageContainer
{
}


using UnityEngine;

public class ExcavatorServerEffects : MonoBehaviour
{
	public static ExcavatorServerEffects instance;

	public TriggerBase[] miningTriggers;

	public void Awake()
	{
		instance = this;
		SetMining(isMining: false, force: true);
	}

	public void OnDestroy()
	{
		instance = null;
	}

	public static void SetMining(bool isMining, bool force = false)
	{
		if ((Object)(object)instance == (Object)null)
		{
			return;
		}
		TriggerBase[] array = instance.miningTriggers;
		foreach (TriggerBase triggerBase in array)
		{
			if (!((Object)(object)triggerBase == (Object)null))
			{
				((Component)triggerBase).gameObject.SetActive(isMining);
			}
		}
	}
}


using UnityEngine;

public class ExcavatorYawSounds : MonoBehaviour, IClientComponent
{
	public SoundPlayer[] miningStartClunks;

	public void PlayStartClunks()
	{
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Rust;
using Rust;
using UnityEngine;

public class LargeShredder : BaseEntity
{
	public Transform shredRail;

	public Transform shredRailStartPos;

	public Transform shredRailEndPos;

	public Vector3 shredRailStartRotation;

	public Vector3 shredRailEndRotation;

	public LargeShredderTrigger trigger;

	public float shredDurationRotation = 2f;

	public float shredDurationPosition = 5f;

	public float shredSwayAmount = 1f;

	public float shredSwaySpeed = 3f;

	public BaseEntity currentlyShredding;

	public GameObject[] shreddingWheels;

	public float shredRotorSpeed = 1f;

	public GameObjectRef shredSoundEffect;

	public Transform resourceSpawnPoint;

	private Quaternion entryRotation;

	public const string SHRED_STAT = "cars_shredded";

	public const Flags IsShreddingFlag = Flags.Reserved10;

	public bool isShredding;

	private float shreddingEntityNormalizedHealth = 1f;

	public float shredStartTime;

	private float prevDelta;

	public virtual void OnEntityEnteredTrigger(BaseEntity ent)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		if (ent.IsDestroyed)
		{
			return;
		}
		Rigidbody component = ((Component)ent).GetComponent<Rigidbody>();
		if (isShredding || (Object)(object)currentlyShredding != (Object)null)
		{
			if (!component.isKinematic)
			{
				component.velocity = -component.velocity * 3f;
			}
			return;
		}
		shreddingEntityNormalizedHealth = 1f;
		MagnetLiftable magnetLiftable = default(MagnetLiftable);
		if (((Component)ent).TryGetComponent<MagnetLiftable>(ref magnetLiftable))
		{
			if (magnetLiftable.requireObjectOff && ent.IsOn())
			{
				return;
			}
			if (magnetLiftable.scaleScrapResourcesByHealth && ent is BaseCombatEntity baseCombatEntity)
			{
				shreddingEntityNormalizedHealth = baseCombatEntity.healthFraction;
			}
		}
		((Component)shredRail).transform.position = shredRailStartPos.position;
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(shredRailStartRotation);
		entryRotation = ((Component)ent).transform.rotation;
		Quaternion rotation = ((Component)ent).transform.rotation;
		PooledList<Collider> val = Pool.Get<PooledList<Collider>>();
		try
		{
			((Component)ent).GetComponentsInChildren<Collider>((List<Collider>)(object)val);
			foreach (Collider item in (List<Collider>)(object)val)
			{
				item.enabled = false;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
		component.isKinematic = true;
		currentlyShredding = ent;
		((Component)ent).transform.rotation = rotation;
		isShredding = true;
		SetShredding(isShredding: true);
		prevDelta = 0f;
		shredStartTime = Time.realtimeSinceStartup;
	}

	public void CreateShredResources()
	{
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0259: Unknown result type (might be due to invalid IL or missing references)
		//IL_0277: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)currentlyShredding == (Object)null)
		{
			return;
		}
		MagnetLiftable component = ((Component)currentlyShredding).GetComponent<MagnetLiftable>();
		if ((Object)(object)component == (Object)null)
		{
			return;
		}
		if ((Object)(object)component.associatedPlayer != (Object)null && GameInfo.HasAchievements)
		{
			component.associatedPlayer.stats.Add("cars_shredded", 1);
			component.associatedPlayer.stats.Save(forceSteamSave: true);
		}
		List<Item> list = Pool.Get<List<Item>>();
		if (component.shredResources.Length > list.Capacity)
		{
			list.Capacity = component.shredResources.Length;
		}
		ItemAmount[] shredResources = component.shredResources;
		foreach (ItemAmount itemAmount in shredResources)
		{
			int num = Mathf.RoundToInt(itemAmount.amount * shreddingEntityNormalizedHealth);
			if (num > 0)
			{
				Item item = ItemManager.Create(itemAmount.itemDef, num, 0uL);
				if ((Object)(object)component.associatedPlayer != (Object)null)
				{
					item.SetItemOwnership(component.associatedPlayer, ItemOwnershipPhrases.Shredded);
				}
				float num2 = 0.5f;
				if ((Object)(object)item.CreateWorldObject(((Component)resourceSpawnPoint).transform.position + new Vector3(Random.Range(0f - num2, num2), 1f, Random.Range(0f - num2, num2))) == (Object)null)
				{
					item.Remove();
					continue;
				}
				list.Add(item);
				Analytics.Azure.AddPendingItems(currentlyShredding, item.info.shortname, item.amount, "car_shred", consumed: false);
			}
		}
		Analytics.Azure.OnCarShredded(component, list);
		Pool.Free<Item>(ref list, false);
		BaseModularVehicle component2 = ((Component)currentlyShredding).GetComponent<BaseModularVehicle>();
		if (!Object.op_Implicit((Object)(object)component2))
		{
			return;
		}
		foreach (BaseVehicleModule attachedModuleEntity in component2.AttachedModuleEntities)
		{
			if (!Object.op_Implicit((Object)(object)attachedModuleEntity.AssociatedItemDef) || !Object.op_Implicit((Object)(object)attachedModuleEntity.AssociatedItemDef.Blueprint))
			{
				continue;
			}
			foreach (ItemAmount ingredient in attachedModuleEntity.AssociatedItemDef.Blueprint.GetIngredients())
			{
				int num3 = Mathf.FloorToInt(ingredient.amount * 0.5f);
				if (num3 != 0)
				{
					Item item2 = ItemManager.Create(ingredient.itemDef, num3, 0uL);
					float num4 = 0.5f;
					if ((Object)(object)item2.CreateWorldObject(((Component)resourceSpawnPoint).transform.position + new Vector3(Random.Range(0f - num4, num4), 1f, Random.Range(0f - num4, num4))) == (Object)null)
					{
						item2.Remove();
					}
				}
			}
		}
	}

	public void UpdateBonePosition(float delta)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		float num = delta / shredDurationPosition;
		float num2 = delta / shredDurationRotation;
		((Component)shredRail).transform.localPosition = Vector3.Lerp(shredRailStartPos.localPosition, shredRailEndPos.localPosition, num);
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(Vector3.Lerp(shredRailStartRotation, shredRailEndRotation, num2));
	}

	public void SetShredding(bool isShredding)
	{
		if (isShredding)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)FireShredEffect, 0.25f, 0.75f, 0.25f);
		}
		else
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)FireShredEffect);
		}
	}

	public void FireShredEffect()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		Effect.server.Run(shredSoundEffect.resourcePath, ((Component)this).transform.position + Vector3.up * 3f, Vector3.up);
	}

	public void ServerUpdate()
	{
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			return;
		}
		SetFlag(Flags.Reserved10, isShredding);
		if (!isShredding)
		{
			return;
		}
		float num = Time.realtimeSinceStartup - shredStartTime;
		float num2 = num / shredDurationPosition;
		float num3 = num / shredDurationRotation;
		((Component)shredRail).transform.localPosition = Vector3.Lerp(shredRailStartPos.localPosition, shredRailEndPos.localPosition, num2);
		((Component)shredRail).transform.rotation = Quaternion.LookRotation(Vector3.Lerp(shredRailStartRotation, shredRailEndRotation, num3));
		MagnetLiftable component = ((Component)currentlyShredding).GetComponent<MagnetLiftable>();
		((Component)currentlyShredding).transform.position = ((Component)shredRail).transform.position;
		Vector3 val = ((Component)this).transform.TransformDirection(component.shredDirection);
		if (Vector3.Dot(-val, ((Component)currentlyShredding).transform.forward) > Vector3.Dot(val, ((Component)currentlyShredding).transform.forward))
		{
			val = ((Component)this).transform.TransformDirection(-component.shredDirection);
		}
		bool flag = Vector3.Dot(((Component)component).transform.up, Vector3.up) >= -0.95f;
		Quaternion val2 = QuaternionEx.LookRotationForcedUp(val, flag ? (-((Component)this).transform.right) : ((Component)this).transform.right);
		float num4 = Time.time * shredSwaySpeed;
		float num5 = Mathf.PerlinNoise(num4, 0f);
		float num6 = Mathf.PerlinNoise(0f, num4 + 150f);
		val2 *= Quaternion.Euler(num5 * shredSwayAmount, 0f, num6 * shredSwayAmount);
		((Component)currentlyShredding).transform.rotation = Quaternion.Lerp(entryRotation, val2, num3);
		if (prevDelta < 1.5f && num > 1.5f)
		{
			if (currentlyShredding is BaseVehicle baseVehicle)
			{
				foreach (BaseVehicle.MountPointInfo mountPoint in baseVehicle.mountPoints)
				{
					if ((Object)(object)mountPoint.mountable != (Object)null && (Object)(object)mountPoint.mountable.GetMounted() != (Object)null)
					{
						mountPoint.mountable.GetMounted().Hurt(999f, DamageType.Blunt, this, useProtection: false);
					}
				}
			}
			if (currentlyShredding is ScrapTransportHelicopter)
			{
				PooledList<BasePlayer> val3 = Pool.Get<PooledList<BasePlayer>>();
				try
				{
					foreach (BaseEntity child in currentlyShredding.children)
					{
						if (child is BasePlayer { isMounted: false } basePlayer)
						{
							((List<BasePlayer>)(object)val3).Add(basePlayer);
						}
					}
					foreach (BasePlayer item in (List<BasePlayer>)(object)val3)
					{
						item.Hurt(999f, DamageType.Blunt, this, useProtection: false);
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
		}
		prevDelta = num;
		if (num > 5f)
		{
			CreateShredResources();
			currentlyShredding.Kill();
			currentlyShredding = null;
			isShredding = false;
			SetShredding(isShredding: false);
		}
	}

	private void Update()
	{
		ServerUpdate();
	}
}


using UnityEngine;

public class LargeShredderTrigger : TriggerBase
{
	public LargeShredder shredder;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!baseEntity.syncPosition)
		{
			return null;
		}
		if (!Object.op_Implicit((Object)(object)((Component)baseEntity).GetComponent<MagnetLiftable>()))
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnEntityEnter(BaseEntity ent)
	{
		base.OnEntityEnter(ent);
		shredder.OnEntityEnteredTrigger(ent);
	}
}


using UnityEngine;

public class LightListener : BaseEntity
{
	public string onMessage = "";

	public string offMessage = "";

	[Tooltip("Must be part of this prefab")]
	public LightGroupAtTime onLights;

	[Tooltip("Must be part of this prefab")]
	public LightGroupAtTime offLights;

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		base.OnEntityMessage(from, msg);
		if (msg == onMessage)
		{
			SetFlag(Flags.On, b: true);
		}
		else if (msg == offMessage)
		{
			SetFlag(Flags.On, b: false);
		}
	}
}


using UnityEngine;

public class FruitScale : MonoBehaviour, IClientComponent
{
	public void SetProgress(float progress)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = Vector3.one * progress;
	}
}


using System;
using UnityEngine;

public class LifeScale : BaseMonoBehaviour
{
	[NonSerialized]
	private bool initialized;

	[NonSerialized]
	private Vector3 initialScale;

	public Vector3 finalScale = Vector3.one;

	private Vector3 targetLerpScale = Vector3.zero;

	private Action updateScaleAction;

	protected void Awake()
	{
		updateScaleAction = UpdateScale;
	}

	public void OnEnable()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Init();
		((Component)this).transform.localScale = initialScale;
	}

	public void SetProgress(float progress)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		Init();
		targetLerpScale = Vector3.Lerp(initialScale, finalScale, progress);
		((FacepunchBehaviour)this).InvokeRepeating(updateScaleAction, 0f, 0.015f);
	}

	public void Init()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			initialScale = ((Component)this).transform.localScale;
			initialized = true;
		}
	}

	public void UpdateScale()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).transform.localScale = Vector3.Lerp(((Component)this).transform.localScale, targetLerpScale, Time.deltaTime);
		if (((Component)this).transform.localScale == targetLerpScale)
		{
			targetLerpScale = Vector3.zero;
			((FacepunchBehaviour)this).CancelInvoke(updateScaleAction);
		}
	}
}


using UnityEngine;

public class MaterialColorLerp : MonoBehaviour, IClientComponent
{
	public Color startColor;

	public Color endColor;

	public Color currentColor;

	public float delta;
}


using System;
using UnityEngine;

[CreateAssetMenu(menuName = "Rust/Plant Properties")]
public class PlantProperties : ScriptableObject
{
	public enum State
	{
		Seed,
		Seedling,
		Sapling,
		Crossbreed,
		Mature,
		Fruiting,
		Ripe,
		Dying
	}

	[Serializable]
	public struct Stage
	{
		public State nextState;

		public float lifeLength;

		public float health;

		public float resources;

		public float yield;

		public GameObjectRef skinObject;

		public bool IgnoreConditions;

		public float lifeLengthSeconds => lifeLength * 60f;
	}

	public Phrase Description;

	public GrowableGeneProperties Genes;

	[ArrayIndexIsEnum(enumType = typeof(State))]
	public Stage[] stages = new Stage[8];

	[Header("Metabolism")]
	public AnimationCurve timeOfDayHappiness = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(12f, 1f),
		new Keyframe(24f, 0f)
	});

	public AnimationCurve temperatureHappiness = new AnimationCurve((Keyframe[])(object)new Keyframe[5]
	{
		new Keyframe(-10f, -1f),
		new Keyframe(1f, 0f),
		new Keyframe(30f, 1f),
		new Keyframe(50f, 0f),
		new Keyframe(80f, -1f)
	});

	public AnimationCurve temperatureWaterRequirementMultiplier = new AnimationCurve((Keyframe[])(object)new Keyframe[5]
	{
		new Keyframe(-10f, 1f),
		new Keyframe(0f, 1f),
		new Keyframe(30f, 1f),
		new Keyframe(50f, 1f),
		new Keyframe(80f, 1f)
	});

	public AnimationCurve fruitVisualScaleCurve = new AnimationCurve((Keyframe[])(object)new Keyframe[3]
	{
		new Keyframe(0f, 0f),
		new Keyframe(0.75f, 1f),
		new Keyframe(1f, 0f)
	});

	public int MaxSeasons = 1;

	public float WaterIntake = 20f;

	public float OptimalLightQuality = 1f;

	public float OptimalWaterQuality = 1f;

	public float OptimalGroundQuality = 1f;

	public float OptimalTemperatureQuality = 1f;

	[Header("Harvesting")]
	public BaseEntity.Menu.Option pickOption;

	public BaseEntity.Menu.Option pickAllOption;

	public BaseEntity.Menu.Option eatOption;

	public ItemDefinition pickupItem;

	public BaseEntity.Menu.Option cloneOption;

	public BaseEntity.Menu.Option cloneAllOption;

	public BaseEntity.Menu.Option removeDyingOption;

	public BaseEntity.Menu.Option removeDyingAllOption;

	public ItemDefinition removeDyingItem;

	public GameObjectRef removeDyingEffect;

	public int pickupMultiplier = 1;

	public GameObjectRef pickEffect;

	public int maxHarvests = 1;

	public bool disappearAfterHarvest;

	[Header("Seeds")]
	public GameObjectRef CrossBreedEffect;

	public ItemDefinition SeedItem;

	public ItemDefinition CloneItem;

	public int BaseCloneCount = 1;

	[Header("Market")]
	public int BaseMarketValue = 10;
}


public enum State
{
	Seed,
	Seedling,
	Sapling,
	Crossbreed,
	Mature,
	Fruiting,
	Ripe,
	Dying
}


using System;

[Serializable]
public struct Stage
{
	public State nextState;

	public float lifeLength;

	public float health;

	public float resources;

	public float yield;

	public GameObjectRef skinObject;

	public bool IgnoreConditions;

	public float lifeLengthSeconds => lifeLength * 60f;
}


using UnityEngine;

public class PlantSkin : MonoBehaviour, IClientComponent
{
}


using UnityEngine;

public class PlatformEntity : BaseEntity
{
	private const float movementSpeed = 1f;

	private const float rotationSpeed = 10f;

	private const float radius = 10f;

	private Vector3 targetPosition = Vector3.zero;

	private Quaternion targetRotation = Quaternion.identity;

	protected void FixedUpdate()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			if (targetPosition == Vector3.zero || Vector3.Distance(((Component)this).transform.position, targetPosition) < 0.01f)
			{
				Vector2 val = Random.insideUnitCircle * 10f;
				targetPosition = ((Component)this).transform.position + new Vector3(val.x, 0f, val.y);
				targetPosition.y = WaterLevel.GetWaterOrTerrainSurface(targetPosition, waves: false, volumes: false) + 1f;
				targetRotation = Quaternion.LookRotation(targetPosition - ((Component)this).transform.position);
			}
			((Component)this).transform.SetPositionAndRotation(Vector3.MoveTowards(((Component)this).transform.position, targetPosition, Time.fixedDeltaTime * 1f), Quaternion.RotateTowards(((Component)this).transform.rotation, targetRotation, Time.fixedDeltaTime * 10f));
		}
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}
}


using ProtoBuf;

public interface IEntityPingSource
{
	bool IsPingValid(MapNote note);
}


using UnityEngine;

public class PlayerAnimationEvents : MonoBehaviour
{
	private static readonly int Up = Animator.StringToHash("up");

	private static readonly int Right = Animator.StringToHash("right");
}


using System;
using Facepunch.Rust;
using Oxide.Core;
using UnityEngine;

public class PlayerBelt
{
	public static int ClientAutoSelectSlot = -1;

	public static uint ClientAutoSeletItemUID = 0u;

	public static EncryptedValue<int> SelectedSlot = -1;

	protected BasePlayer player;

	public static int MaxBeltSlots => 6;

	public PlayerBelt(BasePlayer player)
	{
		this.player = player;
	}

	public void DropActive(Vector3 position, Vector3 velocity)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		if (player.GetActiveShield(out var foundShield))
		{
			if (Interface.CallHook("OnPlayerActiveShieldDrop", (object)player, (object)foundShield) != null)
			{
				return;
			}
			DroppedItem droppedItem = foundShield.GetItem().Drop(position, velocity) as DroppedItem;
			if ((Object)(object)droppedItem != (Object)null)
			{
				droppedItem.DropReason = DroppedItem.DropReasonEnum.Death;
				droppedItem.DroppedBy = player.userID;
				droppedItem.DroppedTime = DateTime.UtcNow;
				Analytics.Azure.OnItemDropped(player, droppedItem, DroppedItem.DropReasonEnum.Death);
			}
		}
		Item activeItem = player.GetActiveItem();
		if (activeItem == null || Interface.CallHook("OnPlayerDropActiveItem", (object)player, (object)activeItem) != null)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerBelt.DropActive", 0);
		try
		{
			DroppedItem droppedItem2 = activeItem.Drop(position, velocity) as DroppedItem;
			if ((Object)(object)droppedItem2 != (Object)null)
			{
				droppedItem2.DropReason = DroppedItem.DropReasonEnum.Death;
				droppedItem2.DroppedBy = player.userID;
				droppedItem2.DroppedTime = DateTime.UtcNow;
				Analytics.Azure.OnItemDropped(player, droppedItem2, DroppedItem.DropReasonEnum.Death);
			}
			player.svActiveItemID = default(ItemId);
			player.SendNetworkUpdate();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Item GetItemInSlot(int slot)
	{
		if ((Object)(object)player == (Object)null)
		{
			return null;
		}
		if ((Object)(object)player.inventory == (Object)null)
		{
			return null;
		}
		if (player.inventory.containerBelt == null)
		{
			return null;
		}
		return player.inventory.containerBelt.GetSlot(slot);
	}

	public Handcuffs GetRestraintItem()
	{
		if ((Object)(object)player == (Object)null)
		{
			return null;
		}
		if ((Object)(object)player.inventory == (Object)null)
		{
			return null;
		}
		if (player.inventory.containerBelt == null)
		{
			return null;
		}
		foreach (Item item in player.inventory.containerBelt.itemList)
		{
			if (item != null)
			{
				Handcuffs handcuffs = item.GetHeldEntity() as Handcuffs;
				if (!((Object)(object)handcuffs == (Object)null) && handcuffs.Locked)
				{
					return handcuffs;
				}
			}
		}
		return null;
	}

	public bool CanHoldItem()
	{
		if ((Object)(object)player == (Object)null)
		{
			return false;
		}
		if (player.IsWounded())
		{
			return false;
		}
		if (player.IsSleeping())
		{
			return false;
		}
		if (player.isMounted && !player.GetMounted().CanHoldItems())
		{
			return false;
		}
		return true;
	}
}


using System.Collections.Generic;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;

public class PlayerBlueprints : EntityComponent<BasePlayer>
{
	public SteamInventory steamInventory;

	public void Reset()
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (persistantPlayerInfo.unlockedItems != null)
		{
			persistantPlayerInfo.unlockedItems.Clear();
		}
		else
		{
			persistantPlayerInfo.unlockedItems = Pool.Get<List<int>>();
		}
		base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
		base.baseEntity.SendNetworkUpdate();
	}

	public void UnlockAll()
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		foreach (ItemBlueprint bp in ItemManager.bpList)
		{
			if (bp.userCraftable && !bp.defaultBlueprint && !persistantPlayerInfo.unlockedItems.Contains(bp.targetItem.itemid))
			{
				persistantPlayerInfo.unlockedItems.Add(bp.targetItem.itemid);
			}
		}
		base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
		base.baseEntity.SendNetworkUpdateImmediate();
		base.baseEntity.ClientRPC(RpcTarget.Player("UnlockedBlueprint", base.baseEntity), 0);
	}

	public bool IsUnlocked(ItemDefinition itemDef)
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (persistantPlayerInfo.unlockedItems != null)
		{
			return persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid);
		}
		return false;
	}

	public void Unlock(ItemDefinition itemDef)
	{
		PersistantPlayer persistantPlayerInfo = base.baseEntity.PersistantPlayerInfo;
		if (!persistantPlayerInfo.unlockedItems.Contains(itemDef.itemid))
		{
			persistantPlayerInfo.unlockedItems.Add(itemDef.itemid);
			base.baseEntity.PersistantPlayerInfo = persistantPlayerInfo;
			base.baseEntity.SendNetworkUpdateImmediate();
			base.baseEntity.ClientRPC(RpcTarget.Player("UnlockedBlueprint", base.baseEntity), itemDef.itemid);
			base.baseEntity.stats.Add("blueprint_studied", 1, (Stats)5);
		}
	}

	public bool HasUnlocked(ItemDefinition targetItem)
	{
		if (base.baseEntity.IsCraftingTutorialBlocked(targetItem, out var forceUnlock))
		{
			return false;
		}
		if (forceUnlock)
		{
			return true;
		}
		if (Object.op_Implicit((Object)(object)targetItem.Blueprint))
		{
			if ((Object)(object)targetItem.Blueprint.RequireUnlockedItem != (Object)null && !HasUnlocked(targetItem.Blueprint.RequireUnlockedItem))
			{
				return false;
			}
			if (targetItem.Blueprint.NeedsSteamItem)
			{
				if ((Object)(object)targetItem.steamItem != (Object)null)
				{
					if ((Object)(object)targetItem.steamItem.UnlockedViaSteamItem != (Object)null)
					{
						if (!steamInventory.HasItem(targetItem.steamItem.UnlockedViaSteamItem.id))
						{
							return false;
						}
					}
					else if (!steamInventory.HasItem(targetItem.steamItem.id))
					{
						return false;
					}
				}
				if (base.baseEntity.UnlockAllSkins)
				{
					return true;
				}
				if ((Object)(object)targetItem.steamItem == (Object)null)
				{
					bool flag = false;
					ItemSkinDirectory.Skin[] skins = targetItem.skins;
					for (int i = 0; i < skins.Length; i++)
					{
						ItemSkinDirectory.Skin skin = skins[i];
						if (steamInventory.HasItem(skin.id))
						{
							flag = true;
							break;
						}
					}
					if (!flag && targetItem.skins2 != null)
					{
						IPlayerItemDefinition[] skins2 = targetItem.skins2;
						foreach (IPlayerItemDefinition val in skins2)
						{
							if (steamInventory.HasItem(val.DefinitionId))
							{
								flag = true;
								break;
							}
						}
					}
					if (!flag)
					{
						return false;
					}
				}
				return true;
			}
			if (targetItem.Blueprint.NeedsSteamDLC)
			{
				if (base.baseEntity.UnlockAllSkins)
				{
					return true;
				}
				if ((Object)(object)targetItem.steamDlc != (Object)null && targetItem.steamDlc.HasLicense(base.baseEntity.userID))
				{
					return true;
				}
			}
		}
		int[] defaultBlueprints = ItemManager.defaultBlueprints;
		for (int i = 0; i < defaultBlueprints.Length; i++)
		{
			if (defaultBlueprints[i] == targetItem.itemid)
			{
				return true;
			}
		}
		if (base.baseEntity.isServer)
		{
			return IsUnlocked(targetItem);
		}
		return false;
	}

	public bool CanCraft(int itemid, int skinItemId, ulong playerId)
	{
		ItemDefinition itemDefinition = ItemManager.FindItemDefinition(itemid);
		if ((Object)(object)itemDefinition == (Object)null)
		{
			return false;
		}
		object obj = Interface.CallHook("CanCraft", (object)this, (object)itemDefinition, (object)skinItemId);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (skinItemId != 0 && !base.baseEntity.UnlockAllSkins && !CheckSkinOwnership(skinItemId, playerId))
		{
			return false;
		}
		if (base.baseEntity.currentCraftLevel < (float)itemDefinition.Blueprint.GetWorkbenchLevel())
		{
			return false;
		}
		if (HasUnlocked(itemDefinition))
		{
			return true;
		}
		return false;
	}

	public bool CheckSkinOwnership(int skinItemId, ulong playerId)
	{
		ItemSkinDirectory.Skin skin = ItemSkinDirectory.FindByInventoryDefinitionId(skinItemId);
		if ((Object)(object)skin.invItem != (Object)null && skin.invItem.HasUnlocked(playerId))
		{
			return true;
		}
		return steamInventory.HasItem(skinItemId);
	}
}


using UnityEngine;

public class PlayerEyes : EntityComponent<BasePlayer>
{
	public static readonly Vector3 EyeOffset = new Vector3(0f, 1.5f, 0f);

	public static readonly Vector3 DuckOffset = new Vector3(0f, -0.6f, 0f);

	public static readonly Vector3 CrawlOffset = new Vector3(0f, -1.15f, 0.175f);

	public static readonly Vector3 ParachuteOffset = new Vector3(0f, -1.45f, 0.3f);

	public Vector3 thirdPersonSleepingOffset = new Vector3(0.43f, 1.25f, 0.7f);

	public LazyAimProperties defaultLazyAim;

	private EncryptedValue<Vector3> viewOffset = Vector3.zero;

	public Vector3 worldMountedPosition
	{
		get
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyePositionForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
			}
			return worldStandingPosition;
		}
	}

	public Vector3 worldStandingPosition => ((Component)this).transform.position + EyeOffset;

	public Vector3 worldCrouchedPosition => worldStandingPosition + DuckOffset;

	public Vector3 worldCrawlingPosition => worldStandingPosition + CrawlOffset;

	public Vector3 position
	{
		get
		{
			//IL_0096: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0034: Unknown result type (might be due to invalid IL or missing references)
			//IL_0039: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_006f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_007f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_008a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyePositionForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
				return ((Component)this).transform.position + ((Component)this).transform.up * (EyeOffset.y + viewOffset.Get().y) + BodyLeanOffset;
			}
			return ((Component)this).transform.position + ((Component)this).transform.rotation * (EyeOffset + (Vector3)viewOffset) + BodyLeanOffset;
		}
	}

	private Vector3 BodyLeanOffset => Vector3.zero;

	public Vector3 center
	{
		get
		{
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0071: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0031: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			if (Object.op_Implicit((Object)(object)base.baseEntity) && base.baseEntity.isMounted)
			{
				Vector3 val = base.baseEntity.GetMounted().EyeCenterForPlayer(base.baseEntity, GetLookRotation());
				if (val != Vector3.zero)
				{
					return val;
				}
			}
			return ((Component)this).transform.position + ((Component)this).transform.up * (EyeOffset.y + DuckOffset.y);
		}
	}

	public Vector3 offset => ((Component)this).transform.up * (EyeOffset.y + viewOffset.Get().y);

	public Quaternion rotation
	{
		get
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			return parentRotation * bodyRotation;
		}
		set
		{
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			bodyRotation = Quaternion.Inverse(parentRotation) * value;
		}
	}

	public Quaternion bodyRotation { get; set; }

	public Quaternion parentRotation
	{
		get
		{
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_003e: Unknown result type (might be due to invalid IL or missing references)
			//IL_004d: Unknown result type (might be due to invalid IL or missing references)
			if (base.baseEntity.isMounted || !((Object)(object)((Component)this).transform.parent != (Object)null))
			{
				return Quaternion.identity;
			}
			Quaternion val = ((Component)this).transform.parent.rotation;
			return Quaternion.Euler(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f);
		}
	}

	public void NetworkUpdate(Quaternion rot)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.IsCrawling())
		{
			viewOffset = CrawlOffset;
		}
		else
		{
			viewOffset = Vector3.zero;
			viewOffset = Vector3.Lerp((Vector3)viewOffset, DuckOffset, base.baseEntity.modelState.ducking);
		}
		bodyRotation = rot;
	}

	public Vector3 MovementForward()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = rotation;
		return Quaternion.Euler(new Vector3(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f)) * Vector3.forward;
	}

	public Vector3 MovementRight()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = rotation;
		return Quaternion.Euler(new Vector3(0f, ((Quaternion)(ref val)).eulerAngles.y, 0f)) * Vector3.right;
	}

	public Ray BodyRay()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Ray(position, BodyForward());
	}

	public Vector3 BodyForward()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.forward;
	}

	public Vector3 BodyRight()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.right;
	}

	public Vector3 BodyUp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return rotation * Vector3.up;
	}

	public Ray HeadRay()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return new Ray(position, HeadForward());
	}

	public Vector3 HeadForward()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.forward;
	}

	public Vector3 HeadRight()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.right;
	}

	public Vector3 HeadUp()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		return GetLookRotation() * Vector3.up;
	}

	public Quaternion GetLookRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return rotation;
	}

	public Quaternion GetAimRotation()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return rotation;
	}
}


using System;
using Rust;

public class PlayerInput : EntityComponent<BasePlayer>
{
	public InputState state = new InputState();

	[NonSerialized]
	public bool hadInputBuffer = true;

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			state.Clear();
		}
	}
}


public static class PlayerInventoryErrors
{
	public static readonly Phrase InvalidItem = new Phrase("error_activeitembroken", "Invalid item");

	public static readonly Phrase CannotMoveItem = new Phrase("error_cannotmoveitem", "Cannot move item!");

	public static readonly Phrase ContainerLocked = new Phrase("error_containerlocked", "Container locked");

	public static readonly Phrase InvalidContainer = new Phrase("error_invalidcontainer", "Invalid container");

	public static readonly Phrase DoesntAcceptPlayerItems = new Phrase("error_doesntacceptplayeritems", "Container does not accept player items!");

	public static readonly Phrase CannotEquipBroken = new Phrase("error_cannotequipbroken", "Cannot equip a broken item");

	public static readonly Phrase ActiveItemBroken = new Phrase("error_activeitembroken", "Your active item was broken!");

	public static readonly Phrase LootableDoesntExist = new Phrase("error_lootabledoesntexist", "Lootable doesn't exist!");
}


using System;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class PlayerModel : ListComponent<PlayerModel>
{
	public enum MountPoses
	{
		Chair = 0,
		Driving = 1,
		Horseback = 2,
		HeliUnarmed = 3,
		HeliArmed = 4,
		HandMotorBoat = 5,
		MotorBoatPassenger = 6,
		SitGeneric = 7,
		SitRaft = 8,
		StandDrive = 9,
		SitShootingGeneric = 10,
		SitMinicopter_Pilot = 11,
		SitMinicopter_Passenger = 12,
		ArcadeLeft = 13,
		ArcadeRight = 14,
		SitSummer_Ring = 15,
		SitSummer_BoogieBoard = 16,
		SitCarPassenger = 17,
		SitSummer_Chair = 18,
		SitRaft_NoPaddle = 19,
		Sit_SecretLab = 20,
		Sit_Workcart = 21,
		Sit_Cardgame = 22,
		Sit_Crane = 23,
		Sit_Snowmobile_Shooting = 24,
		Sit_RetroSnowmobile_Shooting = 25,
		Driving_Snowmobile = 26,
		ZiplineHold = 27,
		Sit_Locomotive = 28,
		Sit_Throne = 29,
		Parachute = 30,
		Sit_DPV = 31,
		Standing_Ballista = 32,
		Sit_BatteringRam = 33,
		VineSwinging = 34,
		Standing = 128
	}

	protected static int speed = Animator.StringToHash("speed");

	protected static int acceleration = Animator.StringToHash("acceleration");

	protected static int rotationYaw = Animator.StringToHash("rotationYaw");

	protected static int forward = Animator.StringToHash("forward");

	protected static int right = Animator.StringToHash("right");

	protected static int up = Animator.StringToHash("up");

	protected static int ducked = Animator.StringToHash("ducked");

	protected static int grounded = Animator.StringToHash("grounded");

	protected static int crawling = Animator.StringToHash("crawling");

	protected static int waterlevel = Animator.StringToHash("waterlevel");

	protected static int attack = Animator.StringToHash("attack");

	protected static int attack_alt = Animator.StringToHash("attack_alt");

	protected static int deploy = Animator.StringToHash("deploy");

	protected static int turnOn = Animator.StringToHash("turnOn");

	protected static int turnOff = Animator.StringToHash("turnOff");

	protected static int reload = Animator.StringToHash("reload");

	protected static int throwWeapon = Animator.StringToHash("throw");

	protected static int holster = Animator.StringToHash("holster");

	protected static int aiming = Animator.StringToHash("aiming");

	protected static int onLadder = Animator.StringToHash("onLadder");

	protected static int posing = Animator.StringToHash("posing");

	protected static int poseType = Animator.StringToHash("poseType");

	protected static int relaxGunPose = Animator.StringToHash("relaxGunPose");

	protected static int vehicle_aim_yaw = Animator.StringToHash("vehicleAimYaw");

	protected static int vehicle_aim_speed = Animator.StringToHash("vehicleAimYawSpeed");

	protected static int usePoseTransition = Animator.StringToHash("usePoseTransition");

	protected static int onPhone = Animator.StringToHash("onPhone");

	protected static int leftFootIK = Animator.StringToHash("leftFootIK");

	protected static int rightFootIK = Animator.StringToHash("rightFootIK");

	protected static int vehicleSteering = Animator.StringToHash("vehicleSteering");

	protected static int sitReaction = Animator.StringToHash("sitReaction");

	protected static int forwardReaction = Animator.StringToHash("forwardReaction");

	protected static int rightReaction = Animator.StringToHash("rightReaction");

	protected static int ladderType = Animator.StringToHash("ladderType");

	protected static int hasParachute = Animator.StringToHash("hasParachute");

	protected static int nonGroundedTime = Animator.StringToHash("nonGroundedTime");

	protected static int deployParachuteTrigger = Animator.StringToHash("deployParachute");

	protected static int shieldBlockingParam = Animator.StringToHash("shieldBlocking");

	protected static int shieldDeploy = Animator.StringToHash("ShieldDeploy");

	protected static int shieldMeleeAttackParam = Animator.StringToHash("shieldMeleeAttack");

	public BoxCollider collision;

	public GameObject censorshipCube;

	public GameObject censorshipCubeBreasts;

	public GameObject jawBone;

	public GameObject neckBone;

	public GameObject headBone;

	public EyeController eyeController;

	public EyeBlink blinkController;

	public Transform[] SpineBones;

	public Transform leftFootBone;

	public Transform rightFootBone;

	public Transform leftHandPropBone;

	public Transform rightHandPropBone;

	public Vector3 rightHandTarget;

	public bool isPreview;

	[Header("IK")]
	public Vector3 leftHandTargetPosition;

	public Quaternion leftHandTargetRotation;

	public Vector3 rightHandTargetPosition;

	public Quaternion rightHandTargetRotation;

	public float steeringTargetDegrees;

	public Vector3 rightFootTargetPosition;

	public Quaternion rightFootTargetRotation;

	public Vector3 leftFootTargetPosition;

	public Quaternion leftFootTargetRotation;

	public LegsAnimator legsAnimator;

	public RuntimeAnimatorController CinematicAnimationController;

	public Avatar DefaultAvatar;

	public Avatar CinematicAvatar;

	public RuntimeAnimatorController DefaultHoldType;

	public RuntimeAnimatorController SleepGesture;

	public RuntimeAnimatorController CrawlToIncapacitatedGesture;

	public RuntimeAnimatorController CrawlToIncapacitatedGestureHandcuff;

	public RuntimeAnimatorController StandToIncapacitatedGesture;

	[NonSerialized]
	public RuntimeAnimatorController CurrentGesture;

	[Header("Skin")]
	public SkinSetCollection MaleSkin;

	public SkinSetCollection FemaleSkin;

	public SubsurfaceProfile subsurfaceProfile;

	[Header("Parameters")]
	[Range(0f, 1f)]
	public float voiceVolume;

	[Range(0f, 1f)]
	public float skinColor = 1f;

	[Range(0f, 1f)]
	public float skinNumber = 1f;

	[Range(0f, 1f)]
	public float meshNumber;

	[Range(0f, 1f)]
	public float hairNumber;

	[Range(0f, 1f)]
	public int skinType;

	public MovementSounds movementSounds;

	public bool showSash;

	public int tempPoseType;

	public uint underwearSkin;

	public Transform[] Shoulders;

	public Transform[] AdditionalSpineBones;

	public ulong overrideSkinSeed { get; private set; }

	public bool IsFemale => skinType == 1;

	public SkinSetCollection SkinSet
	{
		get
		{
			if (!IsFemale)
			{
				return MaleSkin;
			}
			return FemaleSkin;
		}
	}

	public Quaternion AimAngles { get; set; }

	public Quaternion LookAngles { get; set; }

	private static Vector3 GetFlat(Vector3 dir)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		dir.y = 0f;
		return ((Vector3)(ref dir)).normalized;
	}

	public static void RebuildAll()
	{
	}
}


public enum MountPoses
{
	Chair = 0,
	Driving = 1,
	Horseback = 2,
	HeliUnarmed = 3,
	HeliArmed = 4,
	HandMotorBoat = 5,
	MotorBoatPassenger = 6,
	SitGeneric = 7,
	SitRaft = 8,
	StandDrive = 9,
	SitShootingGeneric = 10,
	SitMinicopter_Pilot = 11,
	SitMinicopter_Passenger = 12,
	ArcadeLeft = 13,
	ArcadeRight = 14,
	SitSummer_Ring = 15,
	SitSummer_BoogieBoard = 16,
	SitCarPassenger = 17,
	SitSummer_Chair = 18,
	SitRaft_NoPaddle = 19,
	Sit_SecretLab = 20,
	Sit_Workcart = 21,
	Sit_Cardgame = 22,
	Sit_Crane = 23,
	Sit_Snowmobile_Shooting = 24,
	Sit_RetroSnowmobile_Shooting = 25,
	Driving_Snowmobile = 26,
	ZiplineHold = 27,
	Sit_Locomotive = 28,
	Sit_Throne = 29,
	Parachute = 30,
	Sit_DPV = 31,
	Standing_Ballista = 32,
	Sit_BatteringRam = 33,
	VineSwinging = 34,
	Standing = 128
}


using System;
using UnityEngine;

public class PlayerModelCinematicList : PrefabAttribute, IClientComponent
{
	[Serializable]
	public struct PlayerModelCinematicAnimation
	{
		public string StateName;

		public string ClipName;

		public float Length;
	}

	public PlayerModelCinematicAnimation[] Animations;

	protected override Type GetIndexedType()
	{
		return typeof(PlayerModelCinematicList);
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
	}
}


using System;

[Serializable]
public struct PlayerModelCinematicAnimation
{
	public string StateName;

	public string ClipName;

	public float Length;
}


using UnityEngine;

public class PlayerModelReactionEnded : StateMachineBehaviour
{
}


using UnityEngine;
using UnityEngine.UI;

public class PlayerNameTag : MonoBehaviour
{
	public CanvasGroup canvasGroup;

	public Text text;

	public Gradient color;

	public float minDistance = 3f;

	public float maxDistance = 10f;

	public Vector3 positionOffset;

	public Transform parentBone;
}


[Factory("nametags")]
public class nametags : ConsoleSystem
{
	[ClientVar(Saved = true)]
	public static bool enabled = true;
}


public class PlayerVoiceRecorder : EntityComponent<BasePlayer>
{
}


public class PlayerVoiceSpeaker : EntityComponent<BasePlayer>
{
	public VoiceProcessor voiceProcessor;
}


using UnityEngine;

public class VoiceProcessor : EntityComponentBase
{
	public AudioSource mouthSpeaker;

	public PlayerVoiceSpeaker playerSpeaker;

	public float volumeMultiplier = 1f;
}


public static class LocalPlayer
{
}


using System;
using UnityEngine;

public class BaseMovement : MonoBehaviour
{
	[NonSerialized]
	public bool adminCheat;

	[NonSerialized]
	public float adminSpeed = 1f;
}


using UnityEngine;

public class PlayerWalkMovement : BaseMovement
{
	public const float WaterLevelHead = 0.75f;

	public const float WaterLevelNeck = 0.65f;

	public PhysicMaterial zeroFrictionMaterial;

	public PhysicMaterial highFrictionMaterial;
}


using System;
using System.Collections;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class PlayerCache
{
	public struct ValidEnumerator : IEnumerator<BasePlayer>, IEnumerator, IDisposable
	{
		private PlayerCache cache;

		private int index;

		private int found;

		public BasePlayer Current => cache.players[index];

		BasePlayer IEnumerator<BasePlayer>.Current => Current;

		object IEnumerator.Current => Current;

		public ValidEnumerator(PlayerCache cache)
		{
			this.cache = cache;
			index = -1;
			found = 0;
		}

		public void Dispose()
		{
			cache = null;
		}

		void IDisposable.Dispose()
		{
			Dispose();
		}

		public bool MoveNext()
		{
			if (found >= cache.playerCount || index >= cache.players.Length)
			{
				return false;
			}
			while (++index < cache.players.Length && (Object)(object)cache.players[index] == (Object)null)
			{
			}
			found++;
			return index < cache.players.Length;
		}

		bool IEnumerator.MoveNext()
		{
			return MoveNext();
		}

		public void Reset()
		{
			index = -1;
			found = 0;
		}

		void IEnumerator.Reset()
		{
			Reset();
		}
	}

	public struct ValidView : IEnumerable<BasePlayer>, IEnumerable
	{
		private PlayerCache cache;

		public ValidView(PlayerCache cache)
		{
			this.cache = cache;
		}

		public ValidEnumerator GetEnumerator()
		{
			return new ValidEnumerator(cache);
		}

		IEnumerator<BasePlayer> IEnumerable<BasePlayer>.GetEnumerator()
		{
			return GetEnumerator();
		}

		IEnumerator IEnumerable.GetEnumerator()
		{
			return GetEnumerator();
		}
	}

	public const int NotInCache = -1;

	private BasePlayer[] players;

	private int playerCount;

	private int[] nextIndices;

	private int firstFreeIndex;

	private int lastFreeIndex;

	private const int Occupied = -1;

	private BufferList<int> changes = new BufferList<int>();

	public ValidView ValidPlayers => new ValidView(this);

	public ReadOnlySpan<BasePlayer> Players => players;

	public ReadOnlySpan<BaseEntity> AsEntities
	{
		get
		{
			BaseEntity[] array = players;
			return array;
		}
	}

	public int PlayerCount => playerCount;

	public PlayerCache(int initialCapacity)
	{
		players = new BasePlayer[initialCapacity];
		nextIndices = new int[initialCapacity];
		SetupFreeList(0, initialCapacity);
	}

	public void Add(BasePlayer player)
	{
		Debug.Assert((Object)(object)player != (Object)null, "Player is dead!");
		Debug.Assert(player.StableIndex == -1, "Player is already in the cache!");
		bool num = firstFreeIndex == lastFreeIndex;
		int num2 = firstFreeIndex;
		players[num2] = player;
		player.StableIndex = num2;
		firstFreeIndex = nextIndices[num2];
		nextIndices[num2] = -1;
		if (num)
		{
			Grow();
		}
		playerCount++;
		changes.Add(num2);
	}

	public void Remove(BasePlayer player)
	{
		Debug.Assert(player.StableIndex != -1, "Player is not in the cache!");
		int stableIndex = player.StableIndex;
		player.StableIndex = -1;
		players[stableIndex] = null;
		if (stableIndex < firstFreeIndex)
		{
			nextIndices[stableIndex] = firstFreeIndex;
			firstFreeIndex = stableIndex;
		}
		else
		{
			nextIndices[lastFreeIndex] = stableIndex;
			lastFreeIndex = stableIndex;
		}
		playerCount--;
		changes.Add(stableIndex);
	}

	public void Clear()
	{
		if (playerCount > 0)
		{
			for (int i = 0; i < players.Length; i++)
			{
				BasePlayer basePlayer = players[i];
				if (Object.op_Implicit((Object)(object)basePlayer))
				{
					basePlayer.StableIndex = -1;
					changes.Add(i);
				}
			}
			playerCount = 0;
		}
		SetupFreeList(0, players.Length);
	}

	public void ResetDirtyTracking()
	{
		changes.Clear();
	}

	public void GetDirtyIndices(BufferList<int> indices)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		indices.Clear();
		HashSet<int> hashSet = Pool.Get<HashSet<int>>();
		Enumerator<int> enumerator = changes.GetEnumerator();
		try
		{
			while (enumerator.MoveNext())
			{
				int current = enumerator.Current;
				if (hashSet.Add(current))
				{
					indices.Add(current);
				}
			}
		}
		finally
		{
			((IDisposable)enumerator/*cast due to .constrained prefix*/).Dispose();
		}
		Pool.FreeUnmanaged<int>(ref hashSet);
	}

	private void SetupFreeList(int from, int to)
	{
		for (int i = from; i < to; i++)
		{
			nextIndices[i] = i + 1;
		}
		firstFreeIndex = from;
		lastFreeIndex = to - 1;
	}

	private void Grow()
	{
		int num = players.Length;
		int num2 = num * 2;
		Array.Resize(ref players, num2);
		Array.Resize(ref nextIndices, num2);
		SetupFreeList(num, num2);
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public struct ValidEnumerator : IEnumerator<BasePlayer>, IEnumerator, IDisposable
{
	private PlayerCache cache;

	private int index;

	private int found;

	public BasePlayer Current => cache.players[index];

	BasePlayer IEnumerator<BasePlayer>.Current => Current;

	object IEnumerator.Current => Current;

	public ValidEnumerator(PlayerCache cache)
	{
		this.cache = cache;
		index = -1;
		found = 0;
	}

	public void Dispose()
	{
		cache = null;
	}

	void IDisposable.Dispose()
	{
		Dispose();
	}

	public bool MoveNext()
	{
		if (found >= cache.playerCount || index >= cache.players.Length)
		{
			return false;
		}
		while (++index < cache.players.Length && (Object)(object)cache.players[index] == (Object)null)
		{
		}
		found++;
		return index < cache.players.Length;
	}

	bool IEnumerator.MoveNext()
	{
		return MoveNext();
	}

	public void Reset()
	{
		index = -1;
		found = 0;
	}

	void IEnumerator.Reset()
	{
		Reset();
	}
}


using System.Collections;
using System.Collections.Generic;

public struct ValidView : IEnumerable<BasePlayer>, IEnumerable
{
	private PlayerCache cache;

	public ValidView(PlayerCache cache)
	{
		this.cache = cache;
	}

	public ValidEnumerator GetEnumerator()
	{
		return new ValidEnumerator(cache);
	}

	IEnumerator<BasePlayer> IEnumerable<BasePlayer>.GetEnumerator()
	{
		return GetEnumerator();
	}

	IEnumerator IEnumerable.GetEnumerator()
	{
		return GetEnumerator();
	}
}


using System.Collections.Generic;
using System.Linq;
using ConVar;
using UnityEngine;

public class CombatLog
{
	public struct Event
	{
		public float time;

		public ulong attacker_id;

		public ulong target_id;

		public string attacker;

		public string target;

		public string weapon;

		public string ammo;

		public string bone;

		public HitArea area;

		public float distance;

		public float health_old;

		public float health_new;

		public string info;

		public int proj_hits;

		public float proj_integrity;

		public float proj_travel;

		public float proj_mismatch;

		public int desync;

		public bool attacker_dead;
	}

	private const string selfname = "you";

	private const string noname = "N/A";

	private BasePlayer player;

	private Queue<Event> storage;

	private static Dictionary<ulong, Queue<Event>> players = new Dictionary<ulong, Queue<Event>>();

	public float LastActive { get; private set; }

	public CombatLog(BasePlayer player)
	{
		this.player = player;
	}

	public void Init()
	{
		storage = Get(player.userID);
		LastActive = storage.LastOrDefault().time;
	}

	public void Save()
	{
	}

	public void LogInvalid(BasePlayer player, AttackEntity weapon, string description)
	{
		Log(player, weapon, null, description);
	}

	public void LogInvalid(HitInfo info, string description)
	{
		Log(info.Initiator, info.Weapon, info.HitEntity as BaseCombatEntity, description, info.ProjectilePrefab, info.ProjectileID, -1f, info);
	}

	public void LogAttack(HitInfo info, string description, float oldHealth = -1f)
	{
		Log(info.Initiator, info.Weapon, info.HitEntity as BaseCombatEntity, description, info.ProjectilePrefab, info.ProjectileID, oldHealth, info);
	}

	public void Log(BaseEntity attacker, AttackEntity weapon, BaseCombatEntity hitEntity, string description, Projectile projectilePrefab = null, int projectileId = -1, float healthOld = -1f, HitInfo hitInfo = null)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		Event val = default(Event);
		float distance = 0f;
		if (hitInfo != null)
		{
			distance = (hitInfo.IsProjectile() ? hitInfo.ProjectileDistance : Vector3.Distance(hitInfo.PointStart, hitInfo.HitPositionWorld));
			if (hitInfo.Initiator is BasePlayer basePlayer && (Object)(object)hitInfo.HitEntity != (Object)(object)hitInfo.Initiator)
			{
				val.attacker_dead = basePlayer.IsDead() || basePlayer.IsWounded();
			}
		}
		float health_new = (((Object)(object)hitEntity != (Object)null) ? hitEntity.Health() : 0f);
		val.time = Time.realtimeSinceStartup;
		val.attacker_id = ((NetworkableId)(((Object)(object)attacker != (Object)null && attacker.net != null) ? attacker.net.ID : default(NetworkableId))).Value;
		val.target_id = ((NetworkableId)(((Object)(object)hitEntity != (Object)null && hitEntity.net != null) ? hitEntity.net.ID : default(NetworkableId))).Value;
		val.attacker = (((Object)(object)player == (Object)(object)attacker) ? "you" : (attacker?.ShortPrefabName ?? "N/A"));
		val.target = (((Object)(object)player == (Object)(object)hitEntity) ? "you" : (hitEntity?.ShortPrefabName ?? "N/A"));
		val.weapon = (((Object)(object)weapon != (Object)null) ? ((Object)weapon).name : "N/A");
		val.ammo = ((!((Object)(object)projectilePrefab != (Object)null)) ? "N/A" : ((projectilePrefab != null) ? ((Object)projectilePrefab).name : null));
		val.bone = hitInfo?.boneName ?? "N/A";
		val.area = hitInfo?.boneArea ?? ((HitArea)0);
		val.distance = distance;
		val.health_old = ((healthOld == -1f) ? 0f : healthOld);
		val.health_new = health_new;
		val.info = description ?? string.Empty;
		val.proj_hits = hitInfo?.ProjectileHits ?? 0;
		val.proj_integrity = hitInfo?.ProjectileIntegrity ?? 0f;
		val.proj_travel = hitInfo?.ProjectileTravelTime ?? 0f;
		val.proj_mismatch = hitInfo?.ProjectileTrajectoryMismatch ?? 0f;
		BasePlayer basePlayer2 = attacker as BasePlayer;
		if ((Object)(object)basePlayer2 != (Object)null && (Object)(object)projectilePrefab != (Object)null && basePlayer2.firedProjectiles.TryGetValue(projectileId, out var value))
		{
			val.desync = (int)(value.desyncLifeTime * 1000f);
		}
		Log(val);
	}

	private void Log(Event val)
	{
		LastActive = Time.realtimeSinceStartup;
		if (storage != null)
		{
			storage.Enqueue(val);
			int num = Mathf.Max(0, Server.combatlogsize);
			while (storage.Count > num)
			{
				storage.Dequeue();
			}
		}
	}

	public string Get(int count, NetworkableId filterByAttacker = default(NetworkableId), bool json = false, bool isAdmin = false, ulong requestingUser = 0uL)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		//IL_0158: Unknown result type (might be due to invalid IL or missing references)
		if (storage == null)
		{
			return string.Empty;
		}
		if (storage.Count == 0 && !json)
		{
			return "Combat log empty.";
		}
		TextTable val = new TextTable();
		val.AddColumn("time");
		val.AddColumn("attacker");
		val.AddColumn("id");
		val.AddColumn("target");
		val.AddColumn("id");
		val.AddColumn("weapon");
		val.AddColumn("ammo");
		val.AddColumn("area");
		val.AddColumn("distance");
		val.AddColumn("old_hp");
		val.AddColumn("new_hp");
		val.AddColumn("info");
		val.AddColumn("hits");
		val.AddColumn("integrity");
		val.AddColumn("travel");
		val.AddColumn("mismatch");
		val.AddColumn("desync");
		int num = storage.Count - count;
		int num2 = ((!player.IsAdmin && !player.IsDeveloper) ? Server.combatlogdelay : 0);
		int num3 = 0;
		BaseGameMode activeGameMode = BaseGameMode.GetActiveGameMode(serverside: true);
		foreach (Event item in storage)
		{
			if (num > 0)
			{
				num--;
			}
			else
			{
				if ((((NetworkableId)(ref filterByAttacker)).IsValid && item.attacker_id != filterByAttacker.Value) || ((Object)(object)activeGameMode != (Object)null && !activeGameMode.returnValidCombatlog && !isAdmin && item.proj_hits > 0))
				{
					continue;
				}
				float num4 = Time.realtimeSinceStartup - item.time;
				if (num4 >= (float)num2)
				{
					string text = num4.ToString("0.00s");
					string attacker = item.attacker;
					ulong attacker_id = item.attacker_id;
					string text2 = attacker_id.ToString();
					string target = item.target;
					attacker_id = item.target_id;
					string text3 = attacker_id.ToString();
					string weapon = item.weapon;
					string ammo = item.ammo;
					string text4 = HitAreaUtil.Format(item.area).ToLower();
					float distance = item.distance;
					string text5 = distance.ToString("0.0m");
					distance = item.health_old;
					string text6 = distance.ToString("0.0");
					distance = item.health_new;
					string text7 = distance.ToString("0.0");
					string text8 = item.info;
					if (!player.IsDestroyed && (ulong)player.userID == requestingUser && item.attacker_dead)
					{
						text8 = "you died first (" + text8 + ")";
					}
					int proj_hits = item.proj_hits;
					string text9 = proj_hits.ToString();
					distance = item.proj_integrity;
					string text10 = distance.ToString("0.00");
					distance = item.proj_travel;
					string text11 = distance.ToString("0.00s");
					distance = item.proj_mismatch;
					string text12 = distance.ToString("0.00m");
					proj_hits = item.desync;
					string text13 = proj_hits.ToString();
					val.AddRow(new string[17]
					{
						text, attacker, text2, target, text3, weapon, ammo, text4, text5, text6,
						text7, text8, text9, text10, text11, text12, text13
					});
				}
				else
				{
					num3++;
				}
			}
		}
		string text14;
		if (json)
		{
			text14 = val.ToJson(true);
		}
		else
		{
			text14 = ((object)val).ToString();
			if (num3 > 0)
			{
				text14 = text14 + "+ " + num3 + " " + ((num3 > 1) ? "events" : "event");
				text14 = text14 + " in the last " + num2 + " " + ((num2 > 1) ? "seconds" : "second");
			}
		}
		return text14;
	}

	public static Queue<Event> Get(ulong id)
	{
		if (players.TryGetValue(id, out var value))
		{
			return value;
		}
		value = new Queue<Event>();
		players.Add(id, value);
		return value;
	}
}


public struct Event
{
	public float time;

	public ulong attacker_id;

	public ulong target_id;

	public string attacker;

	public string target;

	public string weapon;

	public string ammo;

	public string bone;

	public HitArea area;

	public float distance;

	public float health_old;

	public float health_new;

	public string info;

	public int proj_hits;

	public float proj_integrity;

	public float proj_travel;

	public float proj_mismatch;

	public int desync;

	public bool attacker_dead;
}


public enum Stats
{
	Steam = 1,
	Server = 2,
	Life = 4,
	All = -1
}


using ConVar;

public class PlayerStatistics
{
	public SteamStatistics steam;

	public ServerStatistics server;

	public CombatLog combat;

	public BasePlayer forPlayer;

	private TimeSince lastSteamSave;

	public PlayerStatistics(BasePlayer player)
	{
		steam = new SteamStatistics(player);
		server = new ServerStatistics(player);
		combat = new CombatLog(player);
		forPlayer = player;
	}

	public void Init()
	{
		steam.Init();
		server.Init();
		combat.Init();
	}

	public void Save(bool forceSteamSave = false)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		if (Server.official && (forceSteamSave || TimeSince.op_Implicit(lastSteamSave) > 60f))
		{
			lastSteamSave = TimeSince.op_Implicit(0f);
			steam.Save();
		}
		server.Save();
		combat.Save();
	}

	public void Add(string name, int val, Stats stats = Stats.Steam)
	{
		if ((stats & Stats.Steam) != 0)
		{
			steam.Add(name, val);
		}
		if ((stats & Stats.Server) != 0)
		{
			server.Add(name, val);
		}
		if ((stats & Stats.Life) != 0)
		{
			forPlayer.LifeStoryGenericStat(name, val);
		}
	}
}


using System.Collections.Generic;

public class ServerStatistics
{
	public class Storage
	{
		private Dictionary<string, int> dict = new Dictionary<string, int>();

		public int Get(string name)
		{
			dict.TryGetValue(name, out var value);
			return value;
		}

		public void Add(string name, int val)
		{
			if (dict.ContainsKey(name))
			{
				dict[name] += val;
			}
			else
			{
				dict.Add(name, val);
			}
		}
	}

	private BasePlayer player;

	private Storage storage;

	private static Dictionary<ulong, Storage> players = new Dictionary<ulong, Storage>();

	public ServerStatistics(BasePlayer player)
	{
		this.player = player;
	}

	public void Init()
	{
		storage = Get(player.userID);
	}

	public void Save()
	{
	}

	public void Add(string name, int val)
	{
		if (storage != null)
		{
			storage.Add(name, val);
		}
	}

	public static Storage Get(ulong id)
	{
		if (players.TryGetValue(id, out var value))
		{
			return value;
		}
		value = new Storage();
		players.Add(id, value);
		return value;
	}
}


using System.Collections.Generic;

public class Storage
{
	private Dictionary<string, int> dict = new Dictionary<string, int>();

	public int Get(string name)
	{
		dict.TryGetValue(name, out var value);
		return value;
	}

	public void Add(string name, int val)
	{
		if (dict.ContainsKey(name))
		{
			dict[name] += val;
		}
		else
		{
			dict.Add(name, val);
		}
	}
}


using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using ConVar;
using UnityEngine;

public class SteamStatistics
{
	private BasePlayer player;

	public Dictionary<string, int> intStats = new Dictionary<string, int>();

	private Task refresh;

	public SteamStatistics(BasePlayer p)
	{
		player = p;
	}

	public void Init()
	{
		if (PlatformService.Instance.IsValid)
		{
			refresh = PlatformService.Instance.LoadPlayerStats((ulong)player.userID);
			intStats.Clear();
		}
	}

	public void Save()
	{
		if (PlatformService.Instance.IsValid)
		{
			PlatformService.Instance.SavePlayerStats((ulong)player.userID);
		}
	}

	public void Add(string name, int var)
	{
		if (!PlatformService.Instance.IsValid || refresh == null || !refresh.IsCompleted)
		{
			return;
		}
		TimeWarning val = TimeWarning.New("PlayerStats.Add", 0);
		try
		{
			int value = 0;
			if (intStats.TryGetValue(name, out value))
			{
				intStats[name] += var;
				PlatformService.Instance.SetPlayerStatInt((ulong)player.userID, name, (long)intStats[name]);
				return;
			}
			value = (int)PlatformService.Instance.GetPlayerStatInt((ulong)player.userID, name, 0L);
			if (!PlatformService.Instance.SetPlayerStatInt((ulong)player.userID, name, (long)(value + var)))
			{
				if (Global.developer > 0)
				{
					Debug.LogWarning((object)("[STEAMWORKS] Couldn't SetUserStat: " + name));
				}
			}
			else
			{
				intStats.Add(name, value + var);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public int Get(string name)
	{
		if (!PlatformService.Instance.IsValid)
		{
			return 0;
		}
		if (refresh == null || !refresh.IsCompleted)
		{
			return 0;
		}
		TimeWarning val = TimeWarning.New("PlayerStats.Get", 0);
		try
		{
			if (intStats.TryGetValue(name, out var value))
			{
				return value;
			}
			return (int)PlatformService.Instance.GetPlayerStatInt((ulong)player.userID, name, 0L);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using System;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class PlayerCorpse : LootableCorpse
{
	public Buoyancy buoyancy;

	public const Flags Flag_Buoyant = Flags.Reserved6;

	public uint underwearSkin;

	public PlayerBonePosData bonePosData;

	public const Flags BlockClothingRebuild = Flags.Reserved2;

	private Vector3 prevLocalPos;

	private const float SLEEP_CHECK_FREQUENCY = 10f;

	public Ragdoll CorpseRagdollScript { get; private set; }

	public override bool CorpseIsRagdoll => (Object)(object)CorpseRagdollScript != (Object)null;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	public bool IsBuoyant()
	{
		return HasFlag(Flags.Reserved6);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		if ((baseEntity.InSafeZone() || InSafeZone()) && (ulong)baseEntity.userID != playerSteamID)
		{
			return false;
		}
		return base.OnStartBeingLooted(baseEntity);
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if ((Object)(object)buoyancy == (Object)null)
		{
			Debug.LogWarning((object)("Player corpse has no buoyancy assigned, searching at runtime :" + ((Object)this).name));
			buoyancy = ((Component)this).GetComponent<Buoyancy>();
		}
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.SubmergedChanged = BuoyancyChanged;
			buoyancy.forEntity = this;
		}
		if (Application.isLoadingSave)
		{
			CorpseRagdollScript = ((Component)this).GetComponent<Ragdoll>();
		}
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.simOnServer = true;
			CorpseRagdollScript.ServerInit();
			((FacepunchBehaviour)this).InvokeRandomized((Action)SleepCheck, 5f, 10f, Random.Range(-1f, 1f));
		}
	}

	public override void ServerInitCorpse(BaseEntity pr, Vector3 posOnDeah, Quaternion rotOnDeath, BasePlayer.PlayerFlags playerFlagsOnDeath, ModelState modelState)
	{
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		parentEnt = pr;
		BasePlayer basePlayer = (BasePlayer)pr;
		CorpseRagdollScript = ((Component)this).GetComponent<Ragdoll>();
		SpawnPointInstance component = ((Component)this).GetComponent<SpawnPointInstance>();
		if ((Object)(object)component != (Object)null)
		{
			spawnGroup = component.parentSpawnPointUser as SpawnGroup;
		}
		Skeleton component2 = ((Component)this).GetComponent<Skeleton>();
		if ((Object)(object)component2 != (Object)null)
		{
			PlayerBonePosData.BonePosData bonePositionData = bonePosData.GetBonePositionData(playerFlagsOnDeath, modelState);
			if (bonePositionData != null)
			{
				component2.CopyFrom(bonePositionData.bonePositions, bonePositionData.boneRotations, true);
				Transform transform = component2.Bones[0].transform;
				transform.localEulerAngles += bonePositionData.rootRotationOffset;
			}
		}
		if (CorpseIsRagdoll)
		{
			Quaternion val = (((playerFlagsOnDeath & BasePlayer.PlayerFlags.Sleeping) != 0) ? Quaternion.identity : rotOnDeath);
			((Component)this).transform.SetPositionAndRotation(posOnDeah, val);
		}
		else
		{
			((Component)this).transform.SetPositionAndRotation(parentEnt.CenterPoint(), basePlayer.eyes.bodyRotation);
		}
	}

	public void BuoyancyChanged(bool isSubmerged)
	{
		if (!IsBuoyant())
		{
			SetFlag(Flags.Reserved6, isSubmerged, recursive: false, networkupdate: false);
			SendNetworkUpdate_Flags();
		}
	}

	public void BecomeActive()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.BecomeActive();
			prevLocalPos = ((Component)this).transform.localPosition;
		}
	}

	public void BecomeInactive()
	{
		if (CorpseIsRagdoll)
		{
			CorpseRagdollScript.BecomeInactive();
		}
	}

	protected override void PushRagdoll(HitInfo info)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if (CorpseIsRagdoll)
		{
			BecomeActive();
			PushRigidbodies(CorpseRagdollScript.rigidbodies, info.HitPositionWorld, info.attackNormal);
		}
		else
		{
			base.PushRagdoll(info);
		}
	}

	private void SleepCheck()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (!CorpseIsRagdoll)
		{
			return;
		}
		if (CorpseRagdollScript.IsKinematic)
		{
			if (!GamePhysics.Trace(new Ray(CenterPoint(), Vector3.down), 0f, out var _, 0.25f, -928830701, (QueryTriggerInteraction)1, this))
			{
				BecomeActive();
			}
		}
		else if (!rigidBody.IsSleeping() && !buoyancy.ShouldWake() && Vector3.SqrMagnitude(((Component)this).transform.localPosition - prevLocalPos) < 0.1f)
		{
			BecomeInactive();
		}
		prevLocalPos = ((Component)this).transform.localPosition;
	}

	public override bool BuoyancySleep(bool inWater)
	{
		if (CorpseIsRagdoll)
		{
			if (!rigidBody.IsSleeping())
			{
				BecomeInactive();
			}
			return true;
		}
		return base.BuoyancySleep(inWater);
	}

	public override bool BuoyancyWake()
	{
		if (CorpseIsRagdoll)
		{
			BecomeActive();
			return true;
		}
		return base.BuoyancyWake();
	}

	private void OnPhysicsNeighbourChanged()
	{
		BecomeActive();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.msg.lootableCorpse != null)
		{
			info.msg.lootableCorpse.underwearSkin = underwearSkin;
		}
		if (base.isServer && containers != null && containers.Length > 1 && !info.forDisk)
		{
			info.msg.storageBox = Pool.Get<StorageBox>();
			info.msg.storageBox.contents = containers[1].Save();
		}
	}

	public override string Categorize()
	{
		return "playercorpse";
	}
}


public class PointEntity : BaseEntity
{
}


using UnityEngine;

public class PropSway : MonoBehaviour
{
	public Transform pivotRotator;

	public float swaySpeed = 1f;

	public float swayDistance = 0.25f;

	public float lerpSpeed = 2f;
}


using ConVar;
using UnityEngine;

public class BushEntity : BaseEntity, IPrefabPreProcess
{
	public GameObjectRef prefab;

	public bool globalBillboard = true;

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefabID);
			((Component)this).transform.ApplyDecorComponentsScaleOnly(components);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		if (globalBillboard)
		{
			TreeManager.OnTreeSpawned(this);
		}
	}

	internal override void DoServerDestroy()
	{
		base.DoServerDestroy();
		if (globalBillboard)
		{
			TreeManager.OnTreeDestroyed(this);
		}
	}

	public override void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		base.PreProcess(preProcess, rootObj, name, serverside, clientside, bundling);
		if (serverside)
		{
			globalBroadcast = Tree.global_broadcast;
		}
	}
}


using System;
using Oxide.Core;
using UnityEngine;

public class RandomItemDispenser : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct RandomItemChance
	{
		public ItemDefinition Item;

		public int Amount;

		[Range(0f, 1f)]
		public float Chance;

		public bool IgnoreInTutorial;
	}

	public RandomItemChance[] Chances;

	public bool OnlyAwardOne = true;

	protected override Type GetIndexedType()
	{
		return typeof(RandomItemDispenser);
	}

	public void DistributeItems(BasePlayer forPlayer, Vector3 distributorPosition)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		RandomItemChance[] chances = Chances;
		for (int i = 0; i < chances.Length; i++)
		{
			RandomItemChance itemChance = chances[i];
			if (!((Object)(object)forPlayer != (Object)null) || !forPlayer.IsInTutorial || !itemChance.IgnoreInTutorial)
			{
				bool flag = TryAward(itemChance, forPlayer, distributorPosition);
				if (OnlyAwardOne && flag)
				{
					break;
				}
			}
		}
	}

	private bool TryAward(RandomItemChance itemChance, BasePlayer forPlayer, Vector3 distributorPosition)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (Interface.CallHook("OnRandomItemAward", (object)this, (object)itemChance, (object)forPlayer, (object)distributorPosition) != null)
		{
			return false;
		}
		float num = Random.Range(0f, 1f);
		if (itemChance.Chance >= num)
		{
			Item item = ItemManager.Create(itemChance.Item, itemChance.Amount, 0uL);
			if (item != null)
			{
				item.SetItemOwnership(forPlayer, ItemOwnershipPhrases.GatheredPhrase);
				if (Object.op_Implicit((Object)(object)forPlayer))
				{
					forPlayer.GiveItem(item, BaseEntity.GiveItemReason.ResourceHarvested);
				}
				else
				{
					item.Drop(distributorPosition + Vector3.up * 0.5f, Vector3.up);
				}
			}
			return true;
		}
		return false;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct RandomItemChance
{
	public ItemDefinition Item;

	public int Amount;

	[Range(0f, 1f)]
	public float Chance;

	public bool IgnoreInTutorial;
}


using System;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using UnityEngine;
using UnityEngine.Serialization;

public class ResourceEntity : BaseEntity
{
	[FormerlySerializedAs("health")]
	public float startHealth;

	[FormerlySerializedAs("protection")]
	public ProtectionProperties baseProtection;

	public float health;

	public ResourceDispenser resourceDispenser;

	[NonSerialized]
	protected bool isKilled;

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.resource != null)
		{
			health = info.msg.resource.health;
		}
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			DecorComponent[] components = PrefabAttribute.server.FindAll<DecorComponent>(prefabID);
			((Component)this).transform.ApplyDecorComponentsScaleOnly(components);
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		resourceDispenser = ((Component)this).GetComponent<ResourceDispenser>();
		if (health == 0f)
		{
			health = startHealth;
		}
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.resource = Pool.Get<BaseResource>();
			info.msg.resource.health = Health();
		}
	}

	public override float MaxHealth()
	{
		return startHealth;
	}

	public override float Health()
	{
		return health;
	}

	protected virtual void OnHealthChanged()
	{
	}

	public override void OnAttacked(HitInfo info)
	{
		if (!base.isServer || isKilled || Interface.CallHook("OnEntityTakeDamage", (object)this, (object)info) != null)
		{
			return;
		}
		if ((Object)(object)resourceDispenser != (Object)null)
		{
			resourceDispenser.OnAttacked(info);
		}
		if (!info.DidGather)
		{
			if (Object.op_Implicit((Object)(object)baseProtection))
			{
				baseProtection.Scale(info.damageTypes);
			}
			float num = info.damageTypes.Total();
			health -= num;
			if (health <= 0f)
			{
				OnDied(info);
			}
			else
			{
				OnHealthChanged();
			}
		}
	}

	public virtual void OnDied(HitInfo info)
	{
		isKilled = true;
		Interface.CallHook("OnEntityDeath", (object)this, (object)info);
		Kill();
	}

	public override float BoundsPadding()
	{
		return 1f;
	}
}


using UnityEngine;

public class StagedResourceBreakEffect : MonoBehaviour, IEffect
{
}


using System;
using UnityEngine;

public class StagedResourceEntityInfo : PrefabAttribute
{
	[Serializable]
	public class ResourceStage
	{
		public float Health;

		public Mesh CollisionMesh;

		public Mesh[] VisualMeshLods;
	}

	public ResourceStage[] Stages;

	public Mesh GetCollisionMesh(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].CollisionMesh;
	}

	public Mesh[] GetVisualMeshLods(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].VisualMeshLods;
	}

	public float GetHealth(int index)
	{
		index = Mathf.Clamp(index, 0, Stages.Length);
		return Stages[index].Health;
	}

	protected override Type GetIndexedType()
	{
		return typeof(StagedResourceEntityInfo);
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceStage
{
	public float Health;

	public Mesh CollisionMesh;

	public Mesh[] VisualMeshLods;
}


using System;
using UnityEngine;

public class TreeMarkerData : PrefabAttribute, IServerComponent
{
	[Serializable]
	public struct MarkerLocation
	{
		public Vector3 LocalPosition;

		public Vector3 LocalNormal;
	}

	[Serializable]
	public struct GenerationArc
	{
		public Vector3 CentrePoint;

		public float Radius;

		public Vector3 Rotation;

		public int OverrideCount;
	}

	public GenerationArc[] GenerationArcs;

	public MarkerLocation[] Markers;

	public Vector3 GenerationStartPoint = Vector3.up * 2f;

	public float GenerationRadius = 2f;

	public float MaxY = 1.7f;

	public float MinY = 0.2f;

	public bool ProcessAngleChecks;

	protected override Type GetIndexedType()
	{
		return typeof(TreeMarkerData);
	}

	public Vector3 GetNearbyPoint(Vector3 point, ref int ignoreIndex, out Vector3 normal)
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		int num = Markers.Length;
		if (ignoreIndex != -1 && ProcessAngleChecks)
		{
			ignoreIndex++;
			if (ignoreIndex >= num)
			{
				ignoreIndex = 0;
			}
			normal = Markers[ignoreIndex].LocalNormal;
			return Markers[ignoreIndex].LocalPosition;
		}
		int num2 = Random.Range(0, num);
		float num3 = float.MaxValue;
		int num4 = -1;
		for (int i = 0; i < num; i++)
		{
			if (ignoreIndex == num2)
			{
				continue;
			}
			MarkerLocation markerLocation = Markers[num2];
			if (!(markerLocation.LocalPosition.y < MinY))
			{
				Vector3 val = markerLocation.LocalPosition;
				val.y = Mathf.Lerp(val.y, point.y, 0.5f);
				Vector3 val2 = val - point;
				float sqrMagnitude = ((Vector3)(ref val2)).sqrMagnitude;
				sqrMagnitude *= Random.Range(0.95f, 1.05f);
				if (sqrMagnitude < num3)
				{
					num3 = sqrMagnitude;
					num4 = num2;
				}
				num2++;
				if (num2 >= num)
				{
					num2 = 0;
				}
			}
		}
		if (num4 > -1)
		{
			normal = Markers[num4].LocalNormal;
			ignoreIndex = num4;
			return Markers[num4].LocalPosition;
		}
		normal = Markers[0].LocalNormal;
		return Markers[0].LocalPosition;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct MarkerLocation
{
	public Vector3 LocalPosition;

	public Vector3 LocalNormal;
}


using System;
using UnityEngine;

[Serializable]
public struct GenerationArc
{
	public Vector3 CentrePoint;

	public float Radius;

	public Vector3 Rotation;

	public int OverrideCount;
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using Rust;
using UnityEngine;

public class VineSwingingTree : TreeEntity
{
	public GameObjectRef StumpPrefab;

	public MeshRenderer[] BranchRenderers;

	public GameObject[] BranchRoots;

	public MeshRenderer BranchHighlightRenderer;

	public float VineSpawnHeight = 15f;

	public float VineSpawnRadius = 5f;

	public VineLaunchPoint[] LaunchPoints;

	public Collider[] ClimbColliders;

	public List<EntityRef<VineMountable>> SpawnedVines = new List<EntityRef<VineMountable>>();

	public VineMountable GetSpawnedVine(VineLaunchPoint point)
	{
		int index = point.Index();
		EnsureVineArrayLength(index);
		return SpawnedVines[index].Get(base.isServer);
	}

	private void EnsureVineArrayLength(int index)
	{
		if (SpawnedVines.Count <= index)
		{
			while (SpawnedVines.Count <= index)
			{
				SpawnedVines.Add(default(EntityRef<VineMountable>));
			}
		}
	}

	public void SetSpawnedVine(VineLaunchPoint point, VineMountable vine)
	{
		int index = point.Index();
		EnsureVineArrayLength(index);
		EntityRef<VineMountable> value = default(EntityRef<VineMountable>);
		value.Set(vine);
		SpawnedVines[index] = value;
	}

	public Vector3 GetVineSpawnPos(List<VineLaunchPoint> possibleDestinations)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		if (possibleDestinations.Count == 0)
		{
			return Vector3.zero;
		}
		Vector3 val = Vector3.zero;
		foreach (VineLaunchPoint possibleDestination in possibleDestinations)
		{
			val += ((Component)possibleDestination).transform.position;
		}
		val /= (float)possibleDestinations.Count;
		Vector3 val2 = ((Component)this).transform.position + ((Component)this).transform.up * VineSpawnHeight;
		val = Vector3Ex.WithY(val, val2.y);
		Vector3 val3 = val - val2;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		return val2 + normalized * VineSpawnRadius;
	}

	public void RefreshVineState()
	{
		if (Application.isLoading)
		{
			((FacepunchBehaviour)this).Invoke((Action)RefreshVineState, 0.25f);
			return;
		}
		VineLaunchPoint[] launchPoints = LaunchPoints;
		for (int i = 0; i < launchPoints.Length; i++)
		{
			launchPoints[i].SpawnVineIfPossible(this);
		}
	}

	public override void PostMapEntitySpawn()
	{
		base.PostMapEntitySpawn();
		RefreshVineState();
	}

	public override void ServerInit()
	{
		base.ServerInit();
		VineLaunchPoint[] launchPoints = LaunchPoints;
		for (int i = 0; i < launchPoints.Length; i++)
		{
			launchPoints[i].ServerInit();
		}
		((FacepunchBehaviour)this).Invoke((Action)RefreshVineState, 0.25f);
	}

	internal override void DoServerDestroy()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		base.DoServerDestroy();
		VineLaunchPoint[] launchPoints = LaunchPoints;
		for (int i = 0; i < launchPoints.Length; i++)
		{
			launchPoints[i].DoServerDestroy();
		}
		if (StumpPrefab.isValid)
		{
			VineSwingingTreeStump obj = base.gameManager.CreateEntity(StumpPrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as VineSwingingTreeStump;
			obj.InitializeTree();
			obj.Spawn();
		}
	}

	public void NotifyNearbyTreesSpawned()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		PooledList<VineSwingingTree> val = Pool.Get<PooledList<VineSwingingTree>>();
		try
		{
			Vis.Entities(((Component)this).transform.position, 64f, (List<VineSwingingTree>)(object)val, 1073741824, (QueryTriggerInteraction)2);
			foreach (VineSwingingTree item in (List<VineSwingingTree>)(object)val)
			{
				if (!item.isClient && !((Object)(object)item == (Object)(object)this))
				{
					item.RefreshVineState();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.vineTree = Pool.Get<VineTree>();
		info.msg.vineTree.spawnedVines = Pool.Get<List<NetworkableId>>();
		foreach (EntityRef<VineMountable> spawnedVine in SpawnedVines)
		{
			info.msg.vineTree.spawnedVines.Add(spawnedVine.uid);
		}
	}

	protected override void OnFallServer()
	{
		base.OnFallServer();
		ToggleClimbColliders(state: false);
		GameObject[] branchRoots = BranchRoots;
		foreach (GameObject val in branchRoots)
		{
			if ((Object)(object)val != (Object)null)
			{
				val.SetActive(false);
			}
		}
		PooledList<Collider> val2 = Pool.Get<PooledList<Collider>>();
		((Component)this).GetComponentsInChildren<Collider>((List<Collider>)(object)val2);
		foreach (Collider item in (List<Collider>)(object)val2)
		{
			if (!item.isTrigger)
			{
				item.enabled = false;
			}
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		base.OnAttacked(info);
		if ((Object)(object)info.InitiatorPlayer == (Object)null || base.isClient)
		{
			return;
		}
		PooledList<VineMountable> val = Pool.Get<PooledList<VineMountable>>();
		try
		{
			VineMountable.pointGrid.Query<VineMountable>(((Component)this).transform.position.x, ((Component)this).transform.position.z, 10f, (List<VineMountable>)(object)val);
			foreach (VineMountable item in (List<VineMountable>)(object)val)
			{
				if (!item.IsOn())
				{
					VineLaunchPoint vineLaunchPoint = item.currentLocation.Get(isServer: true);
					if ((Object)(object)vineLaunchPoint != (Object)null && (Object)(object)vineLaunchPoint.ParentTree == (Object)(object)this && item.AttackedByPlayer(info.InitiatorPlayer))
					{
						break;
					}
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.vineTree == null || info.msg.vineTree.spawnedVines == null)
		{
			return;
		}
		SpawnedVines.Clear();
		foreach (NetworkableId spawnedVine in info.msg.vineTree.spawnedVines)
		{
			SpawnedVines.Add(new EntityRef<VineMountable>(spawnedVine));
		}
	}

	private void ToggleClimbColliders(bool state)
	{
		Collider[] climbColliders = ClimbColliders;
		foreach (Collider val in climbColliders)
		{
			if ((Object)(object)val != (Object)null)
			{
				((Component)val).gameObject.SetActive(state);
			}
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class VineSwingingTreeStump : BaseEntity
{
	public GameObjectRef TreePrefab;

	public float MaxTreeRespawnTime = 5f;

	public float MinTreeRespawnTime = 10f;

	public GameObject PreventBuildingVolume;

	private TimeUntil treeRespawnTime;

	public void InitializeTree()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		treeRespawnTime = TimeUntil.op_Implicit(Random.Range(MinTreeRespawnTime, MaxTreeRespawnTime));
		((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, TimeUntil.op_Implicit(treeRespawnTime));
	}

	private void RespawnTreeInvoke()
	{
		RespawnTree();
	}

	public bool RespawnTree()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (TreePrefab.isValid)
		{
			if (!IsTreeRespawnClear())
			{
				((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, 10f);
				return false;
			}
			VineSwingingTree obj = base.gameManager.CreateEntity(TreePrefab.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation) as VineSwingingTree;
			obj.Spawn();
			obj.NotifyNearbyTreesSpawned();
			Kill();
			return true;
		}
		return false;
	}

	private bool IsTreeRespawnClear()
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		PooledList<BoxCollider> val = Pool.Get<PooledList<BoxCollider>>();
		try
		{
			PreventBuildingVolume.GetComponents<BoxCollider>((List<BoxCollider>)(object)val);
			foreach (BoxCollider item in (List<BoxCollider>)(object)val)
			{
				if (GamePhysics.CheckOBB(new OBB(PreventBuildingVolume.transform, new Bounds(item.center, item.size)), 131072, (QueryTriggerInteraction)0))
				{
					return false;
				}
			}
			return true;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		if (info.forDisk)
		{
			info.msg.treeRespawn = Pool.Get<TreeRespawn>();
			info.msg.treeRespawn.timeToRespawn = TimeUntil.op_Implicit(treeRespawnTime);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.fromDisk && info.msg.treeRespawn != null)
		{
			treeRespawnTime = TimeUntil.op_Implicit(info.msg.treeRespawn.timeToRespawn);
			((FacepunchBehaviour)this).Invoke((Action)RespawnTreeInvoke, TimeUntil.op_Implicit(treeRespawnTime));
		}
	}
}


using Oxide.Core;
using UnityEngine;

public class RoadFlare : TimedExplosive, SeekerTarget.ISeekerTargetOwner
{
	public override void ServerInit()
	{
		base.ServerInit();
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.HIGH);
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.OnCollision(collision, hitEntity);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	internal override void DoServerDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}
}


using Facepunch;
using ProtoBuf;

public class AssociatedSculptureStorage : BaseEntity
{
	public uint Crc;

	public void InitFromSculpture(uint crc, NetworkableId id)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		Crc = crc;
		FileStorage.server.ReassignEntityId(id, net.ID);
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.baseSculpture = Pool.Get<BaseSculpture>();
		info.msg.baseSculpture.crc = Crc;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		Crc = (uint)(((int?)info.msg.baseSculpture?.crc) ?? (-1));
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct AddAndBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (!(math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num) && Grid.InBoundsNotTouching(val2))
					{
						Grid[val2] = true;
					}
				}
			}
		}
		int3 val3 = default(int3);
		for (int l = -R; l <= R; l++)
		{
			for (int m = -R; m <= R; m++)
			{
				for (int n = -R; n <= R; n++)
				{
					((int3)(ref val3))..ctor(l, m, n);
					int3 val4 = Origin + val3;
					if (math.distancesq(float3.op_Implicit(val4), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val4))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int num4 = -1; num4 <= 1; num4++)
					{
						for (int num5 = -1; num5 <= 1; num5++)
						{
							for (int num6 = -1; num6 <= 1; num6++)
							{
								if (num4 != 0 || num5 != 0 || num6 != 0)
								{
									int3 val5 = val4 + new int3(num4, num5, num6);
									if (Grid.InBounds(val5))
									{
										num2 += Grid.Sample(val5);
										num3++;
									}
								}
							}
						}
					}
					Grid[val4] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct BoxBlur3DJob : IJobFor
{
	[ReadOnly]
	public Point3DGrid InputGrid;

	public NativeBitArray OutputGrid;

	public int Width;

	public int WidthHeight;

	public void Execute(int index)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		int3 val = default(int3);
		((int3)(ref val))..ctor(index % Width, index % WidthHeight / Width, index / WidthHeight);
		bool flag = InputGrid[index];
		if (!InputGrid.InBoundsNotTouching(val))
		{
			((NativeBitArray)(ref OutputGrid)).Set(index, false);
			return;
		}
		float num = 0f;
		for (int i = -1; i <= 1; i++)
		{
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					if (i != 0 || j != 0 || k != 0)
					{
						num += InputGrid.Sample(val + new int3(i, j, k));
					}
				}
			}
		}
		bool flag2 = num / 26f >= (flag ? 0.33f : 0.66f);
		if (flag2 != flag)
		{
			flag2 = flag2 || flag2;
		}
		((NativeBitArray)(ref OutputGrid)).Set(index, flag2);
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct BoxBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0153: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float r = R * R;
		for (float num = val2.x; num <= val3.x; num += 1f)
		{
			for (float num2 = val2.y; num2 <= val3.y; num2 += 1f)
			{
				for (float num3 = val2.z; num3 <= val3.z; num3 += 1f)
				{
					float3 val5 = math.float3(num, num2, num3);
					int3 val6 = math.int3(val5);
					if (!Grid.InBoundsNotTouching(val6) || !SculptMathUtil.InFlatEndedCapsule(P0, val4, v, r, val5))
					{
						continue;
					}
					float num4 = 0f;
					int num5 = 0;
					for (int i = -1; i <= 1; i++)
					{
						for (int j = -1; j <= 1; j++)
						{
							for (int k = -1; k <= 1; k++)
							{
								if (i != 0 || j != 0 || k != 0)
								{
									int3 val7 = val6 + new int3(i, j, k);
									if (Grid.InBounds(val7))
									{
										num4 += Grid.Sample(val7);
										num5++;
									}
								}
							}
						}
					}
					Grid[val6] = num4 / (float)num5 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct BoxBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0105: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val2))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int l = -1; l <= 1; l++)
					{
						for (int m = -1; m <= 1; m++)
						{
							for (int n = -1; n <= 1; n++)
							{
								if (l != 0 || m != 0 || n != 0)
								{
									int3 val3 = val2 + new int3(l, m, n);
									if (Grid.InBounds(val3))
									{
										num2 += Grid.Sample(val3);
										num3++;
									}
								}
							}
						}
					}
					Grid[val2] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
public struct CarveAndBlurCylinderJob : IJob
{
	public Point3DGrid Grid;

	public float3 P0;

	public float3 P1;

	public float R;

	public void Execute()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		float3 val = math.float3(R);
		float3 val2 = math.min(P0, P1) - val;
		float3 val3 = math.max(P0, P1) + val;
		float3 val4 = P1 - P0;
		float v = math.dot(val4, val4);
		float num = R * R;
		NativeList<int3> val5 = default(NativeList<int3>);
		val5..ctor((int)num, AllocatorHandle.op_Implicit((Allocator)2));
		for (float num2 = val2.x; num2 <= val3.x; num2 += 1f)
		{
			for (float num3 = val2.y; num3 <= val3.y; num3 += 1f)
			{
				for (float num4 = val2.z; num4 <= val3.z; num4 += 1f)
				{
					float3 val6 = math.float3(num2, num3, num4);
					int3 p = math.int3(val6);
					if (Grid.InBounds(p) && SculptMathUtil.InFlatEndedCapsule(P0, val4, v, num, val6))
					{
						Grid[p] = false;
						val5.Add(ref p);
					}
				}
			}
		}
		NativeArray<int3> val7 = val5.AsArray();
		int length = val5.Length;
		for (int i = 0; i < length; i++)
		{
			int3 val8 = val7[i];
			if (!Grid.InBoundsNotTouching(val8))
			{
				continue;
			}
			float num5 = 0f;
			int num6 = 0;
			for (int j = -1; j <= 1; j++)
			{
				for (int k = -1; k <= 1; k++)
				{
					for (int l = -1; l <= 1; l++)
					{
						if (j != 0 || k != 0 || l != 0)
						{
							int3 val9 = val8 + new int3(j, k, l);
							if (Grid.InBounds(val9))
							{
								num5 += Grid.Sample(val9);
								num6++;
							}
						}
					}
				}
			}
			Grid[val8] = num5 / (float)num6 > 0.5f;
		}
	}
}


using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Jobs;
using Unity.Mathematics;

[BurstCompile]
internal struct CarveAndBlurSphereJob : IJob
{
	public Point3DGrid Grid;

	public int3 Origin;

	public int R;

	public void Execute()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0152: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0170: Unknown result type (might be due to invalid IL or missing references)
		int num = R * R;
		int3 val = default(int3);
		for (int i = -R; i <= R; i++)
		{
			for (int j = -R; j <= R; j++)
			{
				for (int k = -R; k <= R; k++)
				{
					((int3)(ref val))..ctor(i, j, k);
					int3 val2 = Origin + val;
					if (!(math.distancesq(float3.op_Implicit(val2), float3.op_Implicit(Origin)) > (float)num) && Grid.InBounds(val2))
					{
						Grid[val2] = false;
					}
				}
			}
		}
		int3 val3 = default(int3);
		for (int l = -R; l <= R; l++)
		{
			for (int m = -R; m <= R; m++)
			{
				for (int n = -R; n <= R; n++)
				{
					((int3)(ref val3))..ctor(l, m, n);
					int3 val4 = Origin + val3;
					if (math.distancesq(float3.op_Implicit(val4), float3.op_Implicit(Origin)) > (float)num || !Grid.InBoundsNotTouching(val4))
					{
						continue;
					}
					float num2 = 0f;
					int num3 = 0;
					for (int num4 = -1; num4 <= 1; num4++)
					{
						for (int num5 = -1; num5 <= 1; num5++)
						{
							for (int num6 = -1; num6 <= 1; num6++)
							{
								if (num4 != 0 || num5 != 0 || num6 != 0)
								{
									int3 val5 = val4 + new int3(num4, num5, num6);
									if (Grid.InBounds(val5))
									{
										num2 += Grid.Sample(val5);
										num3++;
									}
								}
							}
						}
					}
					Grid[val4] = num2 / (float)num3 > 0.5f;
				}
			}
		}
	}
}


using System;
using Facepunch.MarchingCubes;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using Unity.Profiling;

[BurstCompile]
internal struct CleanFloatingIslandsJob : IJob
{
	private struct NativeStack : IDisposable
	{
		public NativeList<int3> arr;

		public NativeStack(Allocator allocator)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
		}

		public void Dispose()
		{
			arr.Dispose();
		}

		public void Push(int3 v)
		{
			arr.Add(ref v);
		}

		public bool TryPop(out int3 v)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			v = default(int3);
			if (arr.Length == 0)
			{
				return false;
			}
			v = arr[arr.Length - 1];
			arr.RemoveAtSwapBack(arr.Length - 1);
			return true;
		}
	}

	public Point3DGrid Sampler;

	public static readonly ProfilerMarker k_Init = new ProfilerMarker("Init");

	public static readonly ProfilerMarker k_Flood = new ProfilerMarker("Flood");

	public static readonly ProfilerMarker k_Copy = new ProfilerMarker("CopyBack");

	public void Execute()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0171: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0242: Unknown result type (might be due to invalid IL or missing references)
		//IL_0257: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_028b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		NativeBitArray other = default(NativeBitArray);
		((NativeBitArray)(ref other))..ctor(Sampler.Length, AllocatorHandle.op_Implicit((Allocator)2), (NativeArrayOptions)1);
		NativeStack nativeStack = new NativeStack((Allocator)2);
		int width = Sampler.Width;
		int depth = Sampler.Depth;
		int3 val = default(int3);
		for (int i = 0; i < width; i++)
		{
			for (int j = 0; j < depth; j++)
			{
				((int3)(ref val))..ctor(i, 1, j);
				int num = Sampler.ToIndex(val);
				if (Sampler[num])
				{
					nativeStack.Push(val);
					((NativeBitArray)(ref other)).Set(num, true);
				}
			}
		}
		int3 v;
		int3 val2 = default(int3);
		while (nativeStack.TryPop(out v))
		{
			int num2 = v.x - 1;
			((int3)(ref val2))..ctor(num2, ((int3)(ref v)).yz);
			int num3 = 0;
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(--num2, ((int3)(ref v)).yz);
			}
			int num4 = v.x + 1;
			((int3)(ref val2))..ctor(num4, ((int3)(ref v)).yz);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(++num4, ((int3)(ref v)).yz);
			}
			int num5 = v.z - 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num5);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, --num5);
			}
			int num6 = v.z + 1;
			((int3)(ref val2))..ctor(((int3)(ref v)).xy, num6);
			while (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
			{
				((NativeBitArray)(ref other)).Set(num3, true);
				((int3)(ref val2))..ctor(((int3)(ref v)).xy, ++num6);
			}
			for (int k = num2; k < num4; k++)
			{
				for (int l = num5; l < num6; l++)
				{
					for (int m = -1; m <= 1; m += 2)
					{
						((int3)(ref val2))..ctor(k, v.y + m, l);
						if (Sampler.InBounds(val2) && Sampler[num3 = Sampler.ToIndex(val2)] && !((NativeBitArray)(ref other)).IsSet(num3))
						{
							nativeStack.Push(val2);
							((NativeBitArray)(ref other)).Set(num3, true);
						}
					}
				}
			}
		}
		Sampler.CopyFromNativeBitArray(ref other);
	}
}


using System;
using Unity.Collections;
using Unity.Mathematics;

private struct NativeStack : IDisposable
{
	public NativeList<int3> arr;

	public NativeStack(Allocator allocator)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		arr = new NativeList<int3>(AllocatorHandle.op_Implicit(allocator));
	}

	public void Dispose()
	{
		arr.Dispose();
	}

	public void Push(int3 v)
	{
		arr.Add(ref v);
	}

	public bool TryPop(out int3 v)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		v = default(int3);
		if (arr.Length == 0)
		{
			return false;
		}
		v = arr[arr.Length - 1];
		arr.RemoveAtSwapBack(arr.Length - 1);
		return true;
	}
}


using Unity.Mathematics;

public static class SculptMathUtil
{
	public static bool InFlatEndedCapsule(float3 p0, float3 v, float v2, float r2, float3 check)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		float3 val = check - p0;
		if (math.dot(val, v) > v2)
		{
			return false;
		}
		return math.lengthsq(math.cross(val, v)) * math.rcp(v2) <= r2;
	}
}


using System;
using UnityEngine;

public class SculptingToolData : PrefabAttribute
{
	public enum CarvingShapeType
	{
		Cylinder,
		Sphere,
		Rectangle
	}

	[Flags]
	public enum CarvingMode
	{
		Carve = 1,
		Smooth = 2,
		Additive = 4
	}

	public CarvingShapeType CarvingShape;

	public CarvingMode CarvingModes = CarvingMode.Carve | CarvingMode.Smooth | CarvingMode.Additive;

	public Vector2Int CarvingSizeLimits = new Vector2Int(2, 5);

	public bool AllowCarve => (CarvingModes & CarvingMode.Carve) != 0;

	public bool AllowSmooth => (CarvingModes & CarvingMode.Smooth) != 0;

	public bool AllowAdditive => (CarvingModes & CarvingMode.Additive) != 0;

	public int MinCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).x;

	public int MaxCarvingSize => ((Vector2Int)(ref CarvingSizeLimits)).y;

	protected override Type GetIndexedType()
	{
		return typeof(SculptingToolData);
	}
}


public enum CarvingShapeType
{
	Cylinder,
	Sphere,
	Rectangle
}


using System;

[Flags]
public enum CarvingMode
{
	Carve = 1,
	Smooth = 2,
	Additive = 4
}


public class SeasonalTimedExplosive : TimedExplosive
{
	public RandomRendererEnable randomRenderer;
}


using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public class ServerProjectile : EntityComponent<BaseEntity>, IServerComponent
{
	public interface IProjectileImpact
	{
		void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
	}

	public Vector3 initialVelocity;

	public float drag;

	public float gravityModifier = 1f;

	public float speed = 15f;

	public float scanRange;

	public Vector3 swimScale;

	public Vector3 swimSpeed;

	public float radius;

	public bool IgnoreAI;

	[HideInInspector]
	public BaseEntity ignoreEntity;

	protected bool shouldMoveProjectile = true;

	public bool impacted;

	public float swimRandom;

	public virtual bool HasRangeLimit => true;

	protected virtual int mask => 1237003025;

	public Vector3 CurrentVelocity { get; set; }

	public bool Impacted => impacted;

	public float GetMaxRange(float maxFuseTime)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		if (gravityModifier == 0f)
		{
			return float.PositiveInfinity;
		}
		float num = Mathf.Sin(MathF.PI / 2f) * speed * speed / (0f - Physics.gravity.y * gravityModifier);
		float num2 = speed * maxFuseTime;
		return Mathf.Min(num, num2);
	}

	protected void FixedUpdate()
	{
		if ((Object)(object)base.baseEntity != (Object)null && base.baseEntity.isServer)
		{
			DoMovement();
		}
	}

	public void AdjustVelocity(Vector3 adjustment)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		CurrentVelocity += adjustment;
	}

	public virtual Vector3 GetVelocityStep()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		return Physics.gravity * gravityModifier * Time.fixedDeltaTime * Time.timeScale;
	}

	public virtual void InitializeVelocity(Vector3 overrideVel)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate())
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		initialVelocity = overrideVel;
		CurrentVelocity = overrideVel;
	}

	public void SetVelocity(Vector3 overrideVel)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (AutomaticallyRotate() && overrideVel != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref overrideVel)).normalized);
		}
		CurrentVelocity = overrideVel;
	}

	public virtual bool DoMovement()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		if (base.baseEntity.isClient)
		{
			return false;
		}
		if (impacted)
		{
			return false;
		}
		CurrentVelocity += GetVelocityStep();
		Vector3 val = AddSwim(CurrentVelocity);
		float num = ((Vector3)(ref val)).magnitude * Time.fixedDeltaTime;
		if (DoHitDetection(val, num))
		{
			return false;
		}
		if (shouldMoveProjectile)
		{
			Transform transform = ((Component)this).transform;
			transform.position += ((Component)this).transform.forward * num;
		}
		if (AutomaticallyRotate() && val != Vector3.zero)
		{
			((Component)this).transform.rotation = Quaternion.LookRotation(((Vector3)(ref val)).normalized);
		}
		PostDoMove();
		return true;
	}

	protected virtual bool DoHitDetection(Vector3 velocityToUse, float distance)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		Vector3 position = ((Component)this).transform.position;
		GamePhysics.TraceAll(new Ray(position, ((Vector3)(ref velocityToUse)).normalized), radius, list, distance + scanRange, mask, (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			BaseEntity entity = item.GetEntity();
			if ((!((Object)(object)entity != (Object)null) || !entity.isClient) && (!IgnoreAI || !IsAnIgnoredAI(entity)) && IsAValidHit(entity) && IsShootable(item))
			{
				ProcessHit(item, entity, position);
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return true;
			}
		}
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	private Vector3 AddSwim(Vector3 currentVelocity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = currentVelocity;
		if (swimScale != Vector3.zero)
		{
			if (swimRandom == 0f)
			{
				swimRandom = Random.Range(0f, 20f);
			}
			float num = Time.time + swimRandom;
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(Mathf.Sin(num * swimSpeed.x) * swimScale.x, Mathf.Cos(num * swimSpeed.y) * swimScale.y, Mathf.Sin(num * swimSpeed.z) * swimScale.z);
			val2 = ((Component)this).transform.InverseTransformDirection(val2);
			val += val2;
		}
		return val;
	}

	protected void ProcessHit(RaycastHit hitInfo, BaseEntity hitEnt, Vector3 rayOrigin)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		Transform transform = ((Component)this).transform;
		transform.position += ((Component)this).transform.forward * Mathf.Max(0f, ((RaycastHit)(ref hitInfo)).distance - 0.1f);
		((Component)this).GetComponent<IProjectileImpact>()?.ProjectileImpact(hitInfo, rayOrigin);
		SingletonComponent<NpcNoiseManager>.Instance.OnServerProjectileHit(base.baseEntity, this, hitInfo);
		impacted = true;
		OnHit(hitInfo, hitEnt);
		PostDoMove();
	}

	protected bool IsShootable(RaycastHit hitInfo)
	{
		ColliderInfo colliderInfo = (((Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null) ? ((Component)((RaycastHit)(ref hitInfo)).collider).GetComponent<ColliderInfo>() : null);
		if (!((Object)(object)colliderInfo == (Object)null))
		{
			return colliderInfo.HasFlag(ColliderInfo.Flags.Shootable);
		}
		return true;
	}

	protected virtual void OnHit(RaycastHit rayHit, BaseEntity hitEntity)
	{
	}

	protected virtual void PostDoMove()
	{
	}

	protected virtual bool IsAValidHit(BaseEntity hitEnt)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (!hitEnt.IsValid())
		{
			return true;
		}
		if (base.baseEntity.creatorEntity.IsValid() && hitEnt.net.ID == base.baseEntity.creatorEntity.net.ID)
		{
			return false;
		}
		if (ignoreEntity.IsValid() && hitEnt.net.ID == ignoreEntity.net.ID)
		{
			return false;
		}
		return true;
	}

	protected virtual bool IsAnIgnoredAI(BaseEntity hitEnt)
	{
		return hitEnt is ScientistNPC;
	}

	protected virtual bool AutomaticallyRotate()
	{
		return true;
	}
}


using UnityEngine;

public interface IProjectileImpact
{
	void ProjectileImpact(RaycastHit hitInfo, Vector3 rayOrigin);
}


using System;
using UnityEngine;

public class Ballista : BaseSiegeWeapon
{
	[Header("Ballista")]
	public GameObjectRef ballistaGunPrefab;

	public EntityRef<BallistaGun> ballistaGunRef;

	public Transform dismountPositionsParent;

	[SerializeField]
	[Header("Effects")]
	private GameObjectRef fireEffectPrefab;

	public override float DriveWheelVelocity { get; }

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (child.prefabID == ballistaGunPrefab.GetEntity().prefabID)
		{
			BallistaGun ballistaGun = (BallistaGun)child;
			ballistaGunRef.Set(ballistaGun);
			ballistaGun.ballistaOwner = this;
		}
	}

	private BallistaGun GetBallistaGun()
	{
		BallistaGun ballistaGun = ballistaGunRef.Get(base.isServer);
		if (ballistaGun.IsValid())
		{
			return ballistaGun;
		}
		return null;
	}

	protected override bool CanPullNow(BasePlayer puller)
	{
		if (base.CanPullNow(puller))
		{
			return !IsGunMounted();
		}
		return false;
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (base.CanPushNow(pusher))
		{
			return !IsGunMounted();
		}
		return false;
	}

	public bool IsGunMounted()
	{
		BallistaGun ballistaGun = GetBallistaGun();
		if ((Object)(object)ballistaGun != (Object)null)
		{
			return ballistaGun.IsMounted();
		}
		return false;
	}

	protected override void CreateEngineController()
	{
	}

	private void RotateDismountPositions()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ballistaGunRef.Get(base.isServer) != (Object)null)
		{
			dismountPositionsParent.rotation = ((Component)ballistaGunRef.Get(base.isServer)).transform.rotation;
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		mountPose = PlayerModel.MountPoses.StandDrive;
		DisablePhysics();
		((FacepunchBehaviour)this).Invoke((Action)base.EnablePhysics, 1f);
	}

	public override BasePlayer GetMounted()
	{
		return GetDriver();
	}

	public override void OnTowAttach()
	{
		base.OnTowAttach();
		DismountAllPlayers();
	}

	public void OnFired()
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (fireEffectPrefab != null && fireEffectPrefab.isValid)
		{
			Effect.server.Run(fireEffectPrefab.resourcePath, this, 0u, Vector3.zero, Vector3.up, null, broadcast: true);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		base.VehicleFixedUpdate();
		Vector3 worldVelocity = GetWorldVelocity();
		if (((Vector3)(ref worldVelocity)).magnitude > 5f || IsFlipping())
		{
			DismountAllPlayers();
		}
		RotateDismountPositions();
	}

	protected override void DoPushAction(BasePlayer player)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)rigidBody == (Object)null))
		{
			Vector3 val = Vector3.ProjectOnPlane(((Component)this).transform.position - player.eyes.position, ((Component)this).transform.up);
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			float num = rigidBody.mass * 2.4f;
			rigidBody.AddForce(normalized * num, (ForceMode)1);
		}
	}

	public override void OnEngineStartFailed()
	{
	}

	public override bool MeetsEngineRequirements()
	{
		return false;
	}

	public override void LightToggle(BasePlayer player)
	{
	}
}


public class BallistaAnimationEvents : FacepunchBehaviour
{
	public BallistaGun ballista;

	public SoundDefinition reloadClickSoundDef;

	public SoundDefinition reloadWrenchForwardDef;

	public SoundDefinition reloadCompleteDef;
}


public class BaseSiegeWeaponVisuals : VehicleChassisVisuals<BaseSiegeWeapon>, IClientComponent
{
}


public class SiegeWeaponVehicleAudio : GroundVehicleAudio
{
}


using Rust;
using UnityEngine;

public class BatteringRamHead : BaseCombatEntity
{
	public float damagedHealthThreshold = 100f;

	public float brokenHealthThreshold = 20f;

	public Collider serverCollider;

	[HideInInspector]
	public BatteringRam batteringRamOwner;

	[HideInInspector]
	public DamageRenderer damageRenderer;

	public const Flags Flags_DamagedLow = Flags.Reserved6;

	public const Flags Flags_DamagedMid = Flags.Reserved7;

	public const Flags Flags_DamagedHeavy = Flags.Reserved8;

	public bool CanBeUsed()
	{
		return base.health > brokenHealthThreshold;
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateBrokenFlag();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateBrokenFlag();
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		base.OnHealthChanged(oldvalue, newvalue);
		UpdateDamageFlags();
	}

	private void UpdateDamageFlags()
	{
		float num = base.healthFraction;
		SetFlag(Flags.Reserved6, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved7, b: false, recursive: false, networkupdate: false);
		SetFlag(Flags.Reserved8, b: false);
		if (num <= 0.1f)
		{
			SetFlag(Flags.Reserved8, b: true);
		}
		else if (num <= 0.5f)
		{
			SetFlag(Flags.Reserved7, b: true);
		}
		else if (num <= 0.75f)
		{
			SetFlag(Flags.Reserved6, b: true);
		}
	}

	private void UpdateBrokenFlag()
	{
		if (CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: false);
			SetFlag(Flags.Broken, b: false);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 0f;
	}

	public void TakeDamage(float damage)
	{
		damage = Mathf.Min(damage, base.health - 10f);
		Hurt(damage, DamageType.Blunt, this, useProtection: false);
		if (!CanBeUsed())
		{
			batteringRamOwner.SetFlag(Flags.Broken, b: true);
			SetFlag(Flags.Broken, b: true);
		}
	}

	[ServerVar]
	public static void hurt(Arg arg)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		BasePlayer basePlayer = arg.Player();
		if ((Object)(object)basePlayer == (Object)null || !basePlayer.IsAdmin)
		{
			return;
		}
		float @float = arg.GetFloat(0, 0f);
		BatteringRamHead[] array = Util.FindAll<BatteringRamHead>();
		foreach (BatteringRamHead batteringRamHead in array)
		{
			if (batteringRamHead.isServer && Vector3.Distance(((Component)batteringRamHead).transform.position, ((Component)basePlayer).transform.position) <= 10f)
			{
				batteringRamHead.TakeDamage(@float);
			}
		}
	}
}


public class BatteringRamSeat : BaseVehicleSeat
{
}


using UnityEngine;

public class BatteringRamVehicleAudio : SiegeWeaponVehicleAudio
{
	public Transform lightToggleSoundPos;
}


public class BatteringRamVisuals : BaseSiegeWeaponVisuals, IClientComponent
{
}


using System;

public class CatapultAmmoContainer : StorageContainer
{
	[NonSerialized]
	public Catapult catapult;

	public override void OnItemAddedOrRemoved(Item item, bool added)
	{
		base.OnItemAddedOrRemoved(item, added);
		catapult.UpdateLoadedAmmo(item, added);
	}
}


public class CatapultAnimationEvents : FacepunchBehaviour
{
	public Catapult catapult;

	public SoundDefinition reloadClickSoundDef;

	public void PlayReloadClick()
	{
	}

	public void PlaySound(SoundDefinition def)
	{
	}
}


using UnityEngine;

public class CatapultSounds : GroundVehicleAudio
{
	[Header("Reload")]
	public SoundDefinition reloadLoopDef;

	public SoundDefinition reloadStartDef;

	public SoundDefinition reloadStopDef;

	[Header("Suspension")]
	[SerializeField]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	[Header("Tires")]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[SerializeField]
	[Header("Movement")]
	private SoundDefinition movementLoopDef;

	[SerializeField]
	private AnimationCurve movementGainCurve;

	[SerializeField]
	private float movementGainAdjustmentSpeed = 5f;
}


using System.Collections.Generic;
using System.Linq;
using ConVar;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class ConstructableEntity : StorageContainer
{
	[Header("Constructable Entity")]
	public List<ItemAmount> ingredients = new List<ItemAmount>();

	private int[] currentMaterials;

	public GameObjectRef entityToSpawn;

	public PlayerDetectionTrigger trigger;

	public bool onlyRunTriggerCheckOnLastHit;

	public bool onlyBlockWhenStanding;

	public GameObject[] states;

	public SoundDefinition[] stateSounds;

	public GameObjectRef spawnEffect;

	public bool additiveMode;

	private int currentState;

	private void SetState(int index)
	{
		if (index < 0 || index >= states.Length)
		{
			return;
		}
		if (additiveMode)
		{
			for (int i = 0; i < states.Length; i++)
			{
				states[i].SetActive(i <= index);
			}
		}
		else
		{
			GameObject[] array = states;
			for (int j = 0; j < array.Length; j++)
			{
				array[j].SetActive(false);
			}
			states[index].SetActive(true);
		}
		currentState = index;
	}

	private void UpdateState()
	{
		int num = Mathf.FloorToInt(GetTotalMaterialFraction() * (float)states.Length);
		num = Mathf.Clamp(num, 0, states.Length - 1);
		if (num != currentState)
		{
			if (base.isServer)
			{
				timePlaced = GetNetworkTime();
			}
			SetState(num);
		}
	}

	private float GetTotalMaterialFraction()
	{
		float num = 0f;
		float num2 = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += Mathf.Min((float)currentMaterials[i], ingredients[i].amount);
			num2 += ingredients[i].amount;
		}
		if (!(num2 > 0f))
		{
			return 0f;
		}
		return num / num2;
	}

	public bool IsNearlyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			float num = Mathf.Max(0f, ingredients[i].amount - (float)currentMaterials[i]);
			if (!(num <= 0f))
			{
				int num2 = Mathf.CeilToInt(ingredients[i].amount / 10f);
				if (num > (float)num2)
				{
					return false;
				}
			}
		}
		return true;
	}

	public override void ServerInit()
	{
		SetState(0);
		base.ServerInit();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		base.OnRepairFinished(player);
		ulong ownerID = base.OwnerID;
		Kill();
		BaseEntity baseEntity = GameManager.server.CreateEntity(entityToSpawn.resourcePath, ((Component)this).transform.position, ((Component)this).transform.rotation);
		baseEntity.OwnerID = ownerID;
		baseEntity.Spawn();
		if (spawnEffect.isValid)
		{
			Effect.server.Run(spawnEffect.resourcePath, ((Component)this).transform.position, Vector3.up);
		}
	}

	public override float GetDamageRepairCooldown()
	{
		return 5f;
	}

	public override void DoRepair(BasePlayer player)
	{
		if (!CanRepair(player))
		{
			return;
		}
		bool flag = false;
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			ItemAmount itemAmount = ingredients[i];
			float num2 = Mathf.Max(0f, itemAmount.amount - (float)currentMaterials[i]);
			if (num2 != 0f)
			{
				int num3 = Mathf.CeilToInt(itemAmount.amount / 10f);
				int num4 = player.inventory.GetAmount(itemAmount.itemid);
				if (player.IsInCreativeMode && Creative.freeRepair)
				{
					num4 = int.MaxValue;
				}
				int num5 = Mathf.Min(new int[3]
				{
					num3,
					num4,
					Mathf.FloorToInt(num2)
				});
				if (num5 > 0)
				{
					currentMaterials[i] += num5;
					player.inventory.Take(null, itemAmount.itemid, num5);
					player.Command("note.inv", itemAmount.itemid, num5 * -1);
					flag = true;
					float num6 = MaxHealth() * (itemAmount.amount / GetTotalRequiredMaterials());
					num += num6 * ((float)num5 / itemAmount.amount);
				}
				else
				{
					OnBuildFailedResources(player, itemAmount.itemDef.itemid);
				}
			}
		}
		if (num != 0f)
		{
			SetHealth(Mathf.Min(Health() + num, MaxHealth()));
		}
		if (flag)
		{
			SendNetworkUpdate();
			UpdateState();
			if (IsFullyBuilt())
			{
				OnRepairFinished(player);
			}
			else
			{
				OnRepair();
			}
		}
	}

	public void OnBuildFailedResources(BasePlayer player, int itemID)
	{
		if ((Object)(object)player != (Object)null)
		{
			player.ClientRPC(RpcTarget.Player("Client_OnConstructableBuildFailed", player), itemID);
		}
	}

	private bool IsFullyBuilt()
	{
		for (int i = 0; i < ingredients.Count; i++)
		{
			if ((float)currentMaterials[i] < ingredients[i].amount)
			{
				return false;
			}
		}
		return true;
	}

	private float GetTotalRequiredMaterials()
	{
		float num = 0f;
		for (int i = 0; i < ingredients.Count; i++)
		{
			num += ingredients[i].amount;
		}
		return num;
	}

	protected virtual bool CanRepair(BasePlayer player)
	{
		if ((Object)(object)trigger != (Object)null && trigger.entityContents != null)
		{
			if (onlyRunTriggerCheckOnLastHit && !IsNearlyBuilt())
			{
				return true;
			}
			foreach (BaseEntity entityContent in trigger.entityContents)
			{
				if (entityContent is BaseVehicle baseVehicle)
				{
					if (!baseVehicle.IsDead() && !baseVehicle.isClient && !((Object)(object)((Component)baseVehicle).transform.root == (Object)(object)((Component)this).transform))
					{
						player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByVehicle, false);
						return false;
					}
				}
				else if (entityContent is BasePlayer { isClient: false } basePlayer && !basePlayer.IsDead() && (!onlyBlockWhenStanding || basePlayer.IsStandingOnEntity(this, 134226176)))
				{
					player.ShowToast(GameTip.Styles.Error, ConstructionErrors.BlockedByPlayer, overlay: false, (string[])null);
					return false;
				}
			}
		}
		return true;
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.constructableEntity = Pool.Get<ConstructableEntity>();
		if (currentMaterials == null || currentMaterials.IsEmpty())
		{
			currentMaterials = new int[ingredients.Count];
			for (int i = 0; i < ingredients.Count; i++)
			{
				currentMaterials[i] = 0;
			}
		}
		info.msg.constructableEntity.addedResources = currentMaterials.ToList();
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.constructableEntity != null)
		{
			currentMaterials = info.msg.constructableEntity.addedResources.ToArray();
		}
		UpdateState();
	}
}


using UnityEngine;

public class SiegeTowerDoor : Door
{
	private SiegeTower tower;

	protected override bool OnlyCheckForVehicles()
	{
		return false;
	}

	protected override bool InverseDotCheck()
	{
		return true;
	}

	protected override bool CheckOnClose()
	{
		return false;
	}

	public void SetupDoor(SiegeTower tower)
	{
		this.tower = tower;
	}

	private void UpdateTowerHP()
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedSetHealth(base.health);
		}
	}

	public override void OnRepair()
	{
		base.OnRepair();
		UpdateTowerHP();
	}

	public override void OnRepairFinished(BasePlayer player)
	{
		base.OnRepairFinished(player);
		UpdateTowerHP();
	}

	public override void Hurt(HitInfo info)
	{
		if (HasParent() && (Object)(object)tower != (Object)null)
		{
			tower.ProtectedHurt(info);
		}
	}

	public override void OnDied(HitInfo info)
	{
		base.OnDied(info);
		if ((Object)(object)tower != (Object)null && !tower.IsDead())
		{
			tower.Die();
		}
	}

	public void ProtectedHurt(HitInfo info)
	{
		info.HitEntity = this;
		base.Hurt(info);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if ((Object)(object)tower != (Object)null && old != next)
		{
			tower.RefreshLastUseTime();
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Facepunch.Rust;
using Oxide.Core;
using Rust;
using UnityEngine;

public class TimedExplosive : BaseEntity, ServerProjectile.IProjectileImpact
{
	public enum ExplosionEffectOffsetMode
	{
		Local,
		World
	}

	[Header("General")]
	public float timerAmountMin = 10f;

	public float timerAmountMax = 20f;

	public float minExplosionRadius;

	public float explosionRadius = 10f;

	public bool explodeOnContact;

	public bool canStick;

	public bool onlyDamageParent;

	[Header("AI")]
	public bool IgnoreAI;

	public bool BlindAI;

	public float aiBlindDuration = 2.5f;

	public float aiBlindRange = 4f;

	[Header("Offsets")]
	public ExplosionEffectOffsetMode explosionOffsetMode;

	public Vector3 explosionEffectOffset = Vector3.zero;

	[Header("Normals")]
	public bool explosionMatchesNormal;

	public bool explosionUsesForward;

	public bool explosionMatchesOrientation;

	public bool explosionMatchesVelocity;

	public bool explosionMatchesInverseVelocity;

	[Header("Effects")]
	public GameObjectRef explosionEffect;

	[Tooltip("Optional: Will fall back to watersurfaceExplosionEffect or explosionEffect if not assigned.")]
	public GameObjectRef underwaterExplosionEffect;

	public GameObjectRef stickEffect;

	public GameObjectRef bounceEffect;

	public GameObjectRef watersurfaceExplosionEffect;

	[Header("Water")]
	[Min(0f)]
	public float underwaterExplosionDepth = 1f;

	[Tooltip("Optional: Will fall back to underwaterExplosionEffect or explosionEffect if not assigned.")]
	[MinMax(0f, 100f)]
	public MinMax watersurfaceExplosionDepth = new MinMax(0.5f, 10f);

	public bool waterCausesExplosion;

	[Header("Other")]
	public int vibrationLevel = 3;

	public List<DamageTypeEntry> damageTypes = new List<DamageTypeEntry>();

	public List<DamageTypeEntry> playerDamage = new List<DamageTypeEntry>();

	[NonSerialized]
	private float lastBounceTime;

	private bool hadRB;

	private float rbMass;

	private float rbDrag;

	private float rbAngularDrag;

	private Vector3 rbVelocityBeforeCollision;

	private CollisionDetectionMode rbCollisionMode;

	[NonSerialized]
	public ItemOwnershipShare ItemOwnership;

	protected BasePlayer creatorPlayer;

	private const int parentOnlySplashDamage = 166144;

	private const int fullSplashDamage = 1210222849;

	protected Vector3? hitNormal;

	private static BaseEntity[] queryResults = new BaseEntity[64];

	private Vector3 lastPosition = Vector3.zero;

	public override bool PositionTickFixedTime
	{
		protected get
		{
			return true;
		}
	}

	protected virtual bool AlwaysRunWaterCheck => false;

	public List<DamageTypeEntry> GetDamageList(BaseEntity entity)
	{
		if (entity is BasePlayer && playerDamage != null && playerDamage.Count > 0)
		{
			return playerDamage;
		}
		return damageTypes;
	}

	public void SetDamageScale(float scale)
	{
		foreach (DamageTypeEntry damageType in damageTypes)
		{
			damageType.amount *= scale;
		}
	}

	public void SetCreator(BasePlayer ply)
	{
		creatorPlayer = ply;
	}

	public override float GetNetworkTime()
	{
		return Time.fixedTime;
	}

	public override void ServerInit()
	{
		lastBounceTime = Time.time;
		base.ServerInit();
		SetFuse(GetRandomTimerTime());
		if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
		{
			ReceiveCollisionMessages(b: true);
		}
		if (waterCausesExplosion || AlwaysRunWaterCheck)
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)WaterCheck, 0f, 0.5f);
		}
	}

	public virtual void WaterCheck()
	{
		if (waterCausesExplosion && WaterFactor() >= 0.5f)
		{
			Explode();
			Debug.Log((object)"water explode");
		}
	}

	public virtual void SetFuse(float fuseLength)
	{
		if (base.isServer)
		{
			object obj = Interface.CallHook("OnExplosiveFuseSet", (object)this, (object)fuseLength);
			if (obj is float)
			{
				fuseLength = (float)obj;
			}
			((FacepunchBehaviour)this).Invoke((Action)Explode, fuseLength);
			SetFlag(Flags.Reserved2, b: true);
		}
	}

	public virtual float GetRandomTimerTime()
	{
		return Random.Range(timerAmountMin, timerAmountMax);
	}

	public virtual void ProjectileImpact(RaycastHit info, Vector3 rayOrigin)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		hitNormal = ((RaycastHit)(ref info)).normal;
		Explode();
	}

	public void ForceExplode()
	{
		if (this is DudTimedExplosive dudTimedExplosive)
		{
			dudTimedExplosive.dudChance = 0f;
		}
		if (this is RFTimedExplosive rFTimedExplosive)
		{
			rFTimedExplosive.DisarmRF();
		}
		Explode();
	}

	public virtual void Explode()
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Explode(PivotPoint());
	}

	private Vector3 GetExplosionNormal()
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		Vector3 result;
		if (explosionUsesForward)
		{
			result = ((Component)this).transform.forward;
		}
		else if (!explosionMatchesOrientation)
		{
			result = (explosionMatchesVelocity ? ((Vector3)(ref rbVelocityBeforeCollision)).normalized : ((!explosionMatchesInverseVelocity) ? Vector3.up : (-((Vector3)(ref rbVelocityBeforeCollision)).normalized)));
		}
		else
		{
			Quaternion rotation = ((Component)this).transform.rotation;
			Vector3 forward = Vector3.forward;
			result = rotation * forward;
		}
		if (explosionMatchesNormal && hitNormal.HasValue)
		{
			result = hitNormal.Value;
		}
		return result;
	}

	public virtual void Explode(Vector3 explosionFxPos)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0176: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0424: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0451: Unknown result type (might be due to invalid IL or missing references)
		//IL_0227: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_03f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0403: Unknown result type (might be due to invalid IL or missing references)
		//IL_0408: Unknown result type (might be due to invalid IL or missing references)
		//IL_0307: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0317: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0294: Unknown result type (might be due to invalid IL or missing references)
		Analytics.Azure.OnExplosion(this);
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component))
		{
			component.enabled = false;
		}
		WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(explosionFxPos - new Vector3(0f, 0.25f, 0f), waves: true, volumes: true);
		if (underwaterExplosionEffect.isValid && waterInfo.isValid && waterInfo.currentDepth >= underwaterExplosionDepth)
		{
			Effect.server.Run(underwaterExplosionEffect.resourcePath, explosionFxPos, GetExplosionNormal(), null, broadcast: true);
		}
		else if (explosionEffect.isValid)
		{
			Vector3 val = explosionFxPos;
			if (explosionOffsetMode == ExplosionEffectOffsetMode.Local)
			{
				Vector3 val2 = ((Component)this).transform.TransformPoint(explosionEffectOffset) - ((Component)this).transform.position;
				val += val2;
			}
			if (explosionOffsetMode == ExplosionEffectOffsetMode.World)
			{
				val += explosionEffectOffset;
			}
			Effect.server.Run(explosionEffect.resourcePath, val, GetExplosionNormal(), null, broadcast: true);
		}
		if (watersurfaceExplosionEffect.isValid && waterInfo.isValid && waterInfo.overallDepth >= watersurfaceExplosionDepth.x && waterInfo.currentDepth <= watersurfaceExplosionDepth.y)
		{
			Effect.server.Run(watersurfaceExplosionEffect.resourcePath, Vector3Ex.WithY(explosionFxPos, waterInfo.surfaceLevel), GetExplosionNormal(), null, broadcast: true);
		}
		if (damageTypes.Count > 0)
		{
			if (Interface.CallHook("OnTimedExplosiveExplode", (object)this, (object)explosionFxPos) != null)
			{
				return;
			}
			Vector3 val3 = ExplosionCenter();
			if (onlyDamageParent)
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, damageTypes, 166144, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage);
				BaseEntity baseEntity = GetParentEntity();
				BaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;
				while ((Object)(object)baseCombatEntity == (Object)null && (Object)(object)baseEntity != (Object)null && baseEntity.HasParent())
				{
					baseEntity = baseEntity.GetParentEntity();
					baseCombatEntity = baseEntity as BaseCombatEntity;
				}
				if ((Object)(object)baseEntity == (Object)null || !((Component)baseEntity).gameObject.IsOnLayer((Layer)21))
				{
					List<BuildingBlock> list = Pool.Get<List<BuildingBlock>>();
					Vis.Entities(val3, explosionRadius, list, 2097152, (QueryTriggerInteraction)1);
					BuildingBlock buildingBlock = null;
					float num = float.PositiveInfinity;
					foreach (BuildingBlock item in list)
					{
						if (!item.isClient && !item.IsDestroyed && !(item.healthFraction <= 0f))
						{
							float num2 = Vector3.Distance(item.ClosestPoint(val3), val3);
							if (num2 < num && item.IsVisible(val3, explosionRadius))
							{
								buildingBlock = item;
								num = num2;
							}
						}
					}
					if (Object.op_Implicit((Object)(object)buildingBlock))
					{
						HitInfo hitInfo = new HitInfo();
						hitInfo.Initiator = creatorEntity;
						hitInfo.WeaponPrefab = LookupPrefab();
						hitInfo.damageTypes.Add(GetDamageList(buildingBlock));
						hitInfo.PointStart = val3;
						hitInfo.PointEnd = ((Component)buildingBlock).transform.position;
						float amount = 1f - Mathf.Clamp01((num - minExplosionRadius) / (explosionRadius - minExplosionRadius));
						hitInfo.damageTypes.ScaleAll(amount);
						buildingBlock.Hurt(hitInfo);
					}
					Pool.FreeUnmanaged<BuildingBlock>(ref list);
				}
				if (Object.op_Implicit((Object)(object)baseCombatEntity))
				{
					HitInfo hitInfo2 = new HitInfo();
					hitInfo2.Initiator = creatorEntity;
					hitInfo2.WeaponPrefab = LookupPrefab();
					hitInfo2.damageTypes.Add(GetDamageList(baseEntity));
					baseCombatEntity.Hurt(hitInfo2);
				}
				else if ((Object)(object)baseEntity != (Object)null)
				{
					HitInfo hitInfo3 = new HitInfo();
					hitInfo3.Initiator = creatorEntity;
					hitInfo3.WeaponPrefab = LookupPrefab();
					hitInfo3.damageTypes.Add(GetDamageList(baseEntity));
					hitInfo3.PointStart = val3;
					hitInfo3.PointEnd = ((Component)baseEntity).transform.position;
					baseEntity.OnAttacked(hitInfo3);
				}
			}
			else
			{
				DamageUtil.RadiusDamage(creatorEntity, LookupPrefab(), val3, minExplosionRadius, explosionRadius, damageTypes, 1210222849, useLineOfSight: true, IgnoreAI, ignoreAttackingPlayer: false, extendedLineOfSight: false, playerDamage);
			}
			SeismicSensor.Notify(val3, vibrationLevel);
			BlindAnyAI();
		}
		if (!base.IsDestroyed && !HasFlag(Flags.Broken))
		{
			Kill(DestroyMode.Gib);
		}
	}

	private Vector3 ExplosionCenter()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStuck() && parentEntity.Get(base.isServer) is BaseVehicle)
		{
			OBB val = WorldSpaceBounds();
			return CenterPoint() - val.forward * (val.extents.z + 0.1f);
		}
		return CenterPoint();
	}

	private void BlindAnyAI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		if (!BlindAI)
		{
			return;
		}
		int brainsInSphereFast = Query.Server.GetBrainsInSphereFast(((Component)this).transform.position, 10f, queryResults);
		for (int i = 0; i < brainsInSphereFast; i++)
		{
			BaseEntity baseEntity = queryResults[i];
			if (Vector3.Distance(((Component)this).transform.position, ((Component)baseEntity).transform.position) > aiBlindRange)
			{
				continue;
			}
			BaseAIBrain component = ((Component)baseEntity).GetComponent<BaseAIBrain>();
			if (!((Object)(object)component == (Object)null))
			{
				BaseEntity brainBaseEntity = component.GetBrainBaseEntity();
				if (!((Object)(object)brainBaseEntity == (Object)null) && brainBaseEntity.IsVisible(CenterPoint()))
				{
					float blinded = aiBlindDuration * component.BlindDurationMultiplier * Random.Range(0.6f, 1.4f);
					component.SetBlinded(blinded);
					queryResults[i] = null;
				}
			}
		}
	}

	public void FixedUpdate()
	{
		CheckClippingThroughWalls();
	}

	private void CheckClippingThroughWalls()
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		if (!canStick)
		{
			return;
		}
		if (lastPosition == default(Vector3) || !parentEntity.IsValid(serverside: true))
		{
			lastPosition = CenterPoint();
			return;
		}
		Vector3 val = lastPosition;
		Vector3 val2 = CenterPoint();
		Vector3 val3 = val2 - val;
		lastPosition = val2;
		if (val == val2 || !IsStuck(bypassColliderCheck: true))
		{
			return;
		}
		Ray ray = new Ray(val, val2 - val);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(ray, 0f, list, Vector3.Distance(val2, val), 2097152, (QueryTriggerInteraction)0);
		foreach (RaycastHit item in list)
		{
			if ((Object)(object)(item.GetEntity() as BuildingBlock) != (Object)null)
			{
				Transform transform = ((Component)this).transform;
				transform.position -= val3;
				ForceExplode();
				break;
			}
		}
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		if (canStick && !IsStuck())
		{
			bool flag = true;
			if (Object.op_Implicit((Object)(object)hitEntity))
			{
				flag = CanStickTo(hitEntity);
				if (!flag)
				{
					Collider component = ((Component)this).GetComponent<Collider>();
					if ((Object)(object)collision.collider != (Object)null && (Object)(object)component != (Object)null)
					{
						Physics.IgnoreCollision(collision.collider, component);
					}
				}
			}
			if (flag)
			{
				DoCollisionStick(collision, hitEntity);
			}
		}
		if (explodeOnContact && !IsBusy())
		{
			hitNormal = ((ContactPoint)(ref collision.contacts[0])).normal;
			SetMotionEnabled(wantsMotion: false);
			SetFlag(Flags.Busy, b: true, recursive: false, networkupdate: false);
			((FacepunchBehaviour)this).Invoke((Action)Explode, 0.015f);
		}
		else
		{
			DoBounceEffect();
		}
	}

	public virtual bool CanStickTo(BaseEntity entity)
	{
		object obj = Interface.CallHook("CanExplosiveStick", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		DecorDeployable decorDeployable = default(DecorDeployable);
		if (((Component)entity).TryGetComponent<DecorDeployable>(ref decorDeployable))
		{
			return false;
		}
		if (entity is Drone)
		{
			return false;
		}
		if (entity is TravellingVendor)
		{
			return false;
		}
		return true;
	}

	private void DoBounceEffect()
	{
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		if (!bounceEffect.isValid || Time.time - lastBounceTime < 0.2f)
		{
			return;
		}
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component))
		{
			Vector3 velocity = component.velocity;
			if (((Vector3)(ref velocity)).magnitude < 1f)
			{
				return;
			}
		}
		if (bounceEffect.isValid)
		{
			Effect.server.Run(bounceEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		lastBounceTime = Time.time;
	}

	private void DoCollisionStick(Collision collision, BaseEntity ent)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		ContactPoint contact = collision.GetContact(0);
		DoStick(((ContactPoint)(ref contact)).point, ((ContactPoint)(ref contact)).normal, ent, collision.collider);
	}

	public virtual void SetMotionEnabled(bool wantsMotion)
	{
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (wantsMotion)
		{
			if ((Object)(object)component == (Object)null && hadRB)
			{
				component = ((Component)this).gameObject.AddComponent<Rigidbody>();
				component.mass = rbMass;
				component.drag = rbDrag;
				component.angularDrag = rbAngularDrag;
				component.collisionDetectionMode = rbCollisionMode;
				component.useGravity = true;
				component.isKinematic = false;
			}
		}
		else if ((Object)(object)component != (Object)null)
		{
			hadRB = true;
			rbMass = component.mass;
			rbDrag = component.drag;
			rbAngularDrag = component.angularDrag;
			rbCollisionMode = component.collisionDetectionMode;
			rbVelocityBeforeCollision = component.velocity;
			Object.Destroy((Object)(object)component);
		}
	}

	public bool IsStuck(bool bypassColliderCheck = false)
	{
		Rigidbody component = ((Component)this).GetComponent<Rigidbody>();
		if (Object.op_Implicit((Object)(object)component) && !component.isKinematic)
		{
			return false;
		}
		if (!bypassColliderCheck)
		{
			Collider component2 = ((Component)this).GetComponent<Collider>();
			if (Object.op_Implicit((Object)(object)component2) && component2.enabled)
			{
				return false;
			}
		}
		return parentEntity.IsValid(serverside: true);
	}

	public void DoStick(Vector3 position, Vector3 normal, BaseEntity ent, Collider collider)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ent == (Object)null)
		{
			return;
		}
		if (ent is TimedExplosive)
		{
			if (!ent.HasParent())
			{
				return;
			}
			position = ((Component)ent).transform.position;
			ent = ent.parentEntity.Get(serverside: true);
		}
		SetMotionEnabled(wantsMotion: false);
		if (!HasChild(ent))
		{
			((Component)this).transform.position = position;
			((Component)this).transform.rotation = Quaternion.LookRotation(normal, ((Component)this).transform.up);
			if ((Object)(object)collider != (Object)null)
			{
				SetParent(ent, ent.FindBoneID(((Component)collider).transform), worldPositionStays: true);
			}
			else
			{
				SetParent(ent, StringPool.closest, worldPositionStays: true);
			}
			if (ent is BaseCombatEntity baseCombatEntity)
			{
				baseCombatEntity.SetJustAttacked();
			}
			if (stickEffect.isValid)
			{
				Effect.server.Run(stickEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
			}
			ReceiveCollisionMessages(b: false);
		}
	}

	public void UnStick()
	{
		if (Object.op_Implicit((Object)(object)GetParentEntity()))
		{
			SetParent(null, worldPositionStays: true, sendImmediate: true);
			SetMotionEnabled(wantsMotion: true);
			if (((Component)(object)((Component)this).transform).HasComponent<Collider>())
			{
				ReceiveCollisionMessages(b: true);
			}
		}
	}

	internal override void OnParentRemoved()
	{
		UnStick();
	}

	public override void Save(SaveInfo info)
	{
		base.Save(info);
	}

	public override void PostServerLoad()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		base.PostServerLoad();
		if (parentEntity.IsValid(serverside: true))
		{
			DoStick(((Component)this).transform.position, ((Component)this).transform.forward, parentEntity.Get(serverside: true), null);
		}
	}

	public override void Load(LoadInfo info)
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.explosive != null)
		{
			parentEntity.uid = info.msg.explosive.parentid;
		}
	}

	public virtual void SetCollisionEnabled(bool wantsCollision)
	{
		Collider component = ((Component)this).GetComponent<Collider>();
		if (Object.op_Implicit((Object)(object)component) && component.enabled != wantsCollision)
		{
			component.enabled = wantsCollision;
		}
	}
}


public enum ExplosionEffectOffsetMode
{
	Local,
	World
}


using UnityEngine;

public class BaseTrap : DecayEntity
{
	public virtual void ObjectEntered(GameObject obj)
	{
	}

	public virtual void Arm()
	{
		SetFlag(Flags.On, b: true);
		SendNetworkUpdate();
	}

	public virtual void OnEmpty()
	{
	}
}


using Oxide.Core;
using UnityEngine;

public class BaseTrapTrigger : TriggerBase
{
	public BaseTrap _trap;

	public override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	internal override void OnObjectAdded(GameObject obj, Collider col)
	{
		Interface.CallHook("OnTrapSnapped", (object)this, (object)obj, (object)col);
		base.OnObjectAdded(obj, col);
		_trap.ObjectEntered(obj);
	}

	public override void OnEmpty()
	{
		base.OnEmpty();
		_trap.OnEmpty();
	}
}


public class BearTrapTrigger : BaseTrapTrigger
{
}


using System.Collections.Generic;
using Oxide.Core;
using UnityEngine;

public class SurvivalFishTrap : WildlifeTrap
{
	private WaterBody cachedWaterBody;

	private bool bypassItemFilter;

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		if (GamePhysics.Trace(new Ray(((Component)this).transform.position + Vector3.up, Vector3.down), 0f, out var hitInfo, 1.5f, 16, (QueryTriggerInteraction)0))
		{
			cachedWaterBody = hitInfo.GetWaterBody();
		}
	}

	public override bool HasBait()
	{
		ItemModCompostable itemModCompostable = default(ItemModCompostable);
		foreach (Item item in base.inventory.itemList)
		{
			if (item != null && ((Component)item.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) && itemModCompostable.BaitValue > 0f)
			{
				return true;
			}
		}
		return false;
	}

	public override void TrapThink()
	{
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0130: Unknown result type (might be due to invalid IL or missing references)
		ItemDefinition itemDefinition = null;
		Item item = null;
		int usedLureAmount = 0;
		using (List<Item>.Enumerator enumerator = base.inventory.itemList.GetEnumerator())
		{
			if (enumerator.MoveNext())
			{
				Item current = enumerator.Current;
				ItemModCompostable itemModCompostable = default(ItemModCompostable);
				if ((((Component)current.info).TryGetComponent<ItemModCompostable>(ref itemModCompostable) ? itemModCompostable.BaitValue : 0f) > 0f)
				{
					item = current;
					itemDefinition = FishLookup.Instance.GetFish(((Component)this).transform.position, cachedWaterBody, current, out var _, ((Component)current.info).GetComponent<ItemModFishable>(), out usedLureAmount, 5f);
				}
			}
		}
		item?.UseItem(usedLureAmount);
		if (Random.Range(0f, 1f) <= trapSuccessRate || !((Object)(object)itemDefinition != (Object)null))
		{
			return;
		}
		try
		{
			bypassItemFilter = true;
			if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)itemDefinition) == null)
			{
				Item item2 = ItemManager.Create(itemDefinition, 1, 0uL);
				if ((Object)(object)base.LastLootedByPlayer != (Object)null)
				{
					item2.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
				}
				if (!item2.MoveToContainer(base.inventory))
				{
					item2.Drop(((Component)this).transform.position, Vector3.zero, Quaternion.identity);
				}
				OnTrappedWildlife(setFlag: true);
			}
		}
		finally
		{
			bypassItemFilter = false;
		}
	}

	public override bool ItemFilter(Item item, int targetSlot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool flag = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				flag = true;
				break;
			}
		}
		return base.ItemFilter(item, targetSlot) && flag;
	}

	protected override bool CanAcceptItem(Item item, int slot)
	{
		if (FishLookup.Instance == null || item == null)
		{
			return false;
		}
		FishLookup.LoadFish();
		if (bypassItemFilter)
		{
			return true;
		}
		bool result = false;
		ItemDefinition[] baitItems = FishLookup.BaitItems;
		for (int i = 0; i < baitItems.Length; i++)
		{
			if ((Object)(object)baitItems[i] == (Object)(object)item.info)
			{
				result = true;
				break;
			}
		}
		return result;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
[CreateAssetMenu(menuName = "Rust/TrappableWildlife")]
public class TrappableWildlife : ScriptableObject
{
	[Serializable]
	public class BaitType
	{
		public float successRate = 1f;

		public ItemDefinition bait;

		public int minForInterest = 1;

		public int maxToConsume = 1;
	}

	public GameObjectRef worldObject;

	public ItemDefinition inventoryObject;

	public int minToCatch;

	public int maxToCatch;

	public List<BaitType> baitTypes;

	public int caloriesForInterest = 20;

	public float successRate = 1f;

	public float xpScale = 1f;
}


using System;

[Serializable]
public class BaitType
{
	public float successRate = 1f;

	public ItemDefinition bait;

	public int minForInterest = 1;

	public int maxToConsume = 1;
}


using System;
using System.Collections.Generic;
using System.Linq;
using Oxide.Core;
using Rust;
using UnityEngine;

public class WildlifeTrap : StorageContainer
{
	[Serializable]
	public class WildlifeWeight
	{
		public TrappableWildlife wildlife;

		public int weight;
	}

	public static class WildlifeTrapFlags
	{
		public const Flags Occupied = Flags.Reserved1;
	}

	public float tickRate = 60f;

	public GameObjectRef trappedEffect;

	public float trappedEffectRepeatRate = 30f;

	public float trapSuccessRate = 0.5f;

	public List<ItemDefinition> ignoreBait;

	public List<WildlifeWeight> targetWildlife;

	public override void ResetState()
	{
		base.ResetState();
	}

	public void SetTrapActive(bool trapOn)
	{
		if (trapOn != IsTrapActive())
		{
			((FacepunchBehaviour)this).CancelInvoke((Action)TrapThink);
			SetFlag(Flags.On, trapOn);
			if (trapOn)
			{
				((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
			}
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (base.isServer && IsOn())
		{
			((FacepunchBehaviour)this).InvokeRepeating((Action)TrapThink, tickRate * 0.8f + tickRate * Random.Range(0f, 0.4f), tickRate);
		}
	}

	[ContextMenu("DebugPrintout")]
	public void DebugPrintout()
	{
		bool flag = ((FacepunchBehaviour)this).IsInvoking((Action)TrapThink);
		Debug.Log((object)$"is invoking: {flag}");
	}

	private int CalculateBaitCalories(Item bait)
	{
		ItemModConsumable component = ((Component)bait.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		if (ignoreBait.Contains(bait.info))
		{
			return 0;
		}
		int num = 0;
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				num += Mathf.CeilToInt(effect.amount * (float)bait.amount);
			}
		}
		return num;
	}

	public int GetBaitCalories()
	{
		int num = 0;
		foreach (Item item in base.inventory.itemList)
		{
			num += CalculateBaitCalories(item);
		}
		return num;
	}

	public void DestroyRandomFoodItem()
	{
		int count = base.inventory.itemList.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = num + i;
			if (num2 >= count)
			{
				num2 -= count;
			}
			Item item = base.inventory.itemList[num2];
			if (item != null && !((Object)(object)((Component)item.info).GetComponent<ItemModConsumable>() == (Object)null))
			{
				item.UseItem();
				break;
			}
		}
	}

	public void UseBaitCalories(int numToUse)
	{
		foreach (Item item in base.inventory.itemList)
		{
			int itemCalories = GetItemCalories(item);
			if (itemCalories > 0)
			{
				numToUse -= itemCalories;
				item.UseItem();
				if (numToUse <= 0)
				{
					break;
				}
			}
		}
	}

	public int GetItemCalories(Item item)
	{
		ItemModConsumable component = ((Component)item.info).GetComponent<ItemModConsumable>();
		if ((Object)(object)component == (Object)null)
		{
			return 0;
		}
		foreach (ItemModConsumable.ConsumableEffect effect in component.effects)
		{
			if (effect.type == MetabolismAttribute.Type.Calories && effect.amount > 0f)
			{
				return Mathf.CeilToInt(effect.amount);
			}
		}
		return 0;
	}

	public virtual void TrapThink()
	{
		int baitCalories = GetBaitCalories();
		if (baitCalories <= 0)
		{
			return;
		}
		TrappableWildlife randomWildlife = GetRandomWildlife();
		if (baitCalories >= randomWildlife.caloriesForInterest && Random.Range(0f, 1f) <= randomWildlife.successRate)
		{
			UseBaitCalories(randomWildlife.caloriesForInterest);
			if (Random.Range(0f, 1f) <= trapSuccessRate)
			{
				TrapWildlife(randomWildlife);
			}
		}
	}

	public void TrapWildlife(TrappableWildlife trapped)
	{
		if (Interface.CallHook("OnWildlifeTrap", (object)this, (object)trapped) == null)
		{
			Item item = ItemManager.Create(trapped.inventoryObject, Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL);
			if ((Object)(object)base.LastLootedByPlayer != (Object)null)
			{
				item.SetItemOwnership(base.LastLootedByPlayer, ItemOwnershipPhrases.SurvivalTrap);
			}
			if (!item.MoveToContainer(base.inventory))
			{
				item.Remove();
				OnTrappedWildlife(setFlag: false);
			}
			else
			{
				OnTrappedWildlife(setFlag: true);
			}
		}
	}

	protected void OnTrappedWildlife(bool setFlag)
	{
		if (setFlag)
		{
			SetFlag(Flags.Reserved1, b: true);
		}
		SetTrapActive(trapOn: false);
		Hurt(StartMaxHealth() * 0.1f, DamageType.Decay, null, useProtection: false);
	}

	public void ClearTrap()
	{
		SetFlag(Flags.Reserved1, b: false);
	}

	public virtual bool HasBait()
	{
		return GetBaitCalories() > 0;
	}

	public override void PlayerStoppedLooting(BasePlayer player)
	{
		SetTrapActive(HasBait());
		ClearTrap();
		base.PlayerStoppedLooting(player);
	}

	public override bool OnStartBeingLooted(BasePlayer baseEntity)
	{
		ClearTrap();
		return base.OnStartBeingLooted(baseEntity);
	}

	public TrappableWildlife GetRandomWildlife()
	{
		int num = targetWildlife.Sum((WildlifeWeight x) => x.weight);
		int num2 = Random.Range(0, num);
		for (int i = 0; i < targetWildlife.Count; i++)
		{
			num -= targetWildlife[i].weight;
			if (num2 >= num)
			{
				return targetWildlife[i].wildlife;
			}
		}
		return null;
	}

	public override void ServerInit()
	{
		base.ServerInit();
		ItemContainer itemContainer = base.inventory;
		itemContainer.canAcceptItem = (Func<Item, int, bool>)Delegate.Combine(itemContainer.canAcceptItem, new Func<Item, int, bool>(CanAcceptItem));
	}

	protected virtual bool CanAcceptItem(Item item, int slot)
	{
		if (CalculateBaitCalories(item) > 0)
		{
			return true;
		}
		foreach (WildlifeWeight item2 in targetWildlife)
		{
			if ((Object)(object)item2.wildlife?.inventoryObject == (Object)(object)item.info)
			{
				return true;
			}
		}
		return false;
	}

	public bool HasCatch()
	{
		return HasFlag(Flags.Reserved1);
	}

	public bool IsTrapActive()
	{
		return HasFlag(Flags.On);
	}
}


using System;

[Serializable]
public class WildlifeWeight
{
	public TrappableWildlife wildlife;

	public int weight;
}


public static class WildlifeTrapFlags
{
	public const Flags Occupied = Flags.Reserved1;
}


using UnityEngine;

public class BaseAimable : BaseVehicleMountPoint
{
	public Transform aimBase;
}


public class BaseChair : BaseMountable
{
	public override float GetComfort()
	{
		return 1f;
	}
}


using UnityEngine;

public class BaseVehicleMountPoint : BaseMountable
{
	[Header("BaseVehicleMountPoint")]
	[Tooltip("Only Set this if you definitely need a VehicleFixedUpdate tick on the seat for some reason")]
	public bool RequiresVehicleFixedUpdateOnSeat;

	public override bool DirectlyMountable()
	{
		return false;
	}

	public override BaseVehicle VehicleParent()
	{
		BaseVehicle baseVehicle = GetParentEntity() as BaseVehicle;
		while ((Object)(object)baseVehicle != (Object)null && !baseVehicle.IsVehicleRoot())
		{
			BaseVehicle baseVehicle2 = baseVehicle.GetParentEntity() as BaseVehicle;
			if ((Object)(object)baseVehicle2 == (Object)null)
			{
				return baseVehicle;
			}
			baseVehicle = baseVehicle2;
		}
		return baseVehicle;
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			info = default(WaterLevel.WaterInfo);
			return 0f;
		}
		return baseVehicle.WaterFactorForPlayer(player, out info);
	}

	public override float AirFactor()
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle == (Object)null)
		{
			return 0f;
		}
		return baseVehicle.AirFactor();
	}
}


using UnityEngine;

public class BaseVehicleSeat : BaseVehicleMountPoint
{
	[Header("Vehicle Seat")]
	public float mountedAnimationSpeed;

	public bool sendClientInputToVehicleParent;

	public bool forcePlayerModelUpdate;

	public bool giveCrosshair;

	public bool canTeamInteract = true;

	public override void ScaleDamageForPlayer(BasePlayer player, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.ScaleDamageForPlayer(player, info);
		}
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.MounteeTookDamage(mountee, info);
		}
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			baseVehicle.PlayerServerInput(inputState, player);
		}
		base.PlayerServerInput(inputState, player);
	}

	public override void LightToggle(BasePlayer player)
	{
		BaseVehicle baseVehicle = VehicleParent();
		if (!((Object)(object)baseVehicle == (Object)null))
		{
			baseVehicle.LightToggle(player);
		}
	}

	public override void SwitchParent(BaseEntity ent)
	{
	}

	public override Vector3 GetMountRagdollVelocity(BasePlayer player)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		BaseVehicle baseVehicle = VehicleParent();
		if ((Object)(object)baseVehicle != (Object)null)
		{
			return baseVehicle.GetMountRagdollVelocity(player);
		}
		return base.GetMountRagdollVelocity(player);
	}
}


using System;
using UnityEngine;

public class BasicCar : BaseVehicle
{
	[Serializable]
	public class VehicleWheel
	{
		public Transform shock;

		public WheelCollider wheelCollider;

		public Transform wheel;

		public Transform axle;

		public bool steerWheel;

		public bool brakeWheel = true;

		public bool powerWheel = true;
	}

	public VehicleWheel[] wheels;

	public float brakePedal;

	public float gasPedal;

	public float steering;

	public Transform centerOfMass;

	public Transform steeringWheel;

	public float motorForceConstant = 150f;

	public float brakeForceConstant = 500f;

	public float GasLerpTime = 20f;

	public float SteeringLerpTime = 20f;

	public Transform driverEye;

	public GameObjectRef chairRef;

	public Transform chairAnchorTest;

	public SoundPlayer idleLoopPlayer;

	public Transform engineOffset;

	public SoundDefinition engineSoundDef;

	private static bool chairtest;

	public float throttle;

	public float brake;

	public bool lightsOn = true;

	public override float MaxVelocity()
	{
		return 50f;
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion viewRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (PlayerIsMounted(player))
		{
			return ((Component)driverEye).transform.position;
		}
		return Vector3.zero;
	}

	public override void ServerInit()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient)
		{
			base.ServerInit();
			rigidBody = ((Component)this).GetComponent<Rigidbody>();
			rigidBody.centerOfMass = centerOfMass.localPosition;
			rigidBody.isKinematic = false;
			if (chairtest)
			{
				SpawnChairTest();
			}
		}
	}

	public void SpawnChairTest()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity baseEntity = GameManager.server.CreateEntity(chairRef.resourcePath, ((Component)chairAnchorTest).transform.localPosition);
		baseEntity.Spawn();
		DestroyOnGroundMissing component = ((Component)baseEntity).GetComponent<DestroyOnGroundMissing>();
		if ((Object)(object)component != (Object)null)
		{
			((Behaviour)component).enabled = false;
		}
		MeshCollider component2 = ((Component)baseEntity).GetComponent<MeshCollider>();
		if (Object.op_Implicit((Object)(object)component2))
		{
			component2.convex = true;
		}
		baseEntity.SetParent(this);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("BasicCar.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (!HasDriver())
			{
				NoDriverInput();
			}
			ConvertInputToThrottle();
			DoSteering();
			ApplyForceAtWheels();
			SetFlag(Flags.Reserved1, HasDriver());
			SetFlag(Flags.Reserved2, HasDriver() && lightsOn);
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void DoSteering()
	{
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.steerWheel)
			{
				vehicleWheel.wheelCollider.steerAngle = steering;
			}
		}
		SetFlag(Flags.Reserved4, steering < -2f);
		SetFlag(Flags.Reserved5, steering > 2f);
	}

	public void ConvertInputToThrottle()
	{
	}

	public void ApplyForceAtWheels()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		Vector3 velocity = rigidBody.velocity;
		float num = ((Vector3)(ref velocity)).magnitude * Vector3.Dot(((Vector3)(ref velocity)).normalized, ((Component)this).transform.forward);
		float num2 = brakePedal;
		float num3 = gasPedal;
		if (num > 0f && num3 < 0f)
		{
			num2 = 100f;
		}
		else if (num < 0f && num3 > 0f)
		{
			num2 = 100f;
		}
		VehicleWheel[] array = wheels;
		foreach (VehicleWheel vehicleWheel in array)
		{
			if (vehicleWheel.wheelCollider.isGrounded)
			{
				if (vehicleWheel.powerWheel)
				{
					vehicleWheel.wheelCollider.motorTorque = num3 * motorForceConstant;
				}
				if (vehicleWheel.brakeWheel)
				{
					vehicleWheel.wheelCollider.brakeTorque = num2 * brakeForceConstant;
				}
			}
		}
		SetFlag(Flags.Reserved3, num2 >= 100f && AnyMounted());
	}

	public void NoDriverInput()
	{
		if (chairtest)
		{
			gasPedal = Mathf.Sin(Time.time) * 50f;
			return;
		}
		gasPedal = 0f;
		brakePedal = Mathf.Lerp(brakePedal, 100f, Time.deltaTime * GasLerpTime / 5f);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 100f;
			brakePedal = 0f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -30f;
			brakePedal = 0f;
		}
		else
		{
			gasPedal = 0f;
			brakePedal = 30f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = -60f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = 60f;
		}
		else
		{
			steering = 0f;
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			lightsOn = !lightsOn;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class VehicleWheel
{
	public Transform shock;

	public WheelCollider wheelCollider;

	public Transform wheel;

	public Transform axle;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using UnityEngine;

public class BicycleAudio : BikeVehicleAudio
{
	[SerializeField]
	[Header("Bicycle")]
	private SoundDefinition pedalActiveSoundDef;

	[SerializeField]
	private SoundDefinition pedalCoastSoundDef;

	[SerializeField]
	private SoundDefinition pedalStartDef;

	[SerializeField]
	private SoundDefinition pedalStopDef;

	[SerializeField]
	private SoundDefinition bellSoundDef;

	[SerializeField]
	private AnimationCurve pedalGainCurve;

	[SerializeField]
	private AnimationCurve pedalPitchCurve;

	[SerializeField]
	private SlicedGranularAudioClip pedalClicks;

	[SerializeField]
	private AnimationCurve pedalClickFrequencyCurve;
}


using System;
using UnityEngine;

public class BikeChassisVisuals : VehicleChassisVisuals<Bike>, IClientComponent
{
	[Serializable]
	private class SuspensionSettings
	{
		public bool enabled;

		public Transform front;

		public float frontMinZ = 0.3f;

		public float frontMaxZ = 0.55f;

		public Transform rearTop;

		public Transform rearBottom;

		public Transform rearSwingArm;

		public float swingArmMinAngle = 5f;

		public float swingArmMaxAngle = 25f;
	}

	[Serializable]
	private class PedalBikeSettings
	{
		public bool enabled;

		public Transform axle;

		public float ratio = 0.5f;

		public Transform left;

		public Transform right;

		public Transform[] clockwiseCogs;

		public Transform[] anticlockwiseCogs;

		public float cogRatio = 1f;
	}

	[Serializable]
	private class KickstandSettiongs
	{
		public bool enabled;

		public Transform pivot;

		public Transform spring;

		public Transform springTarget;

		public float kickstandZ;

		public float upX = 180f;

		public float downX = 80f;
	}

	[Serializable]
	private class ChainRenderer
	{
		public Renderer renderer;

		public int materialIndex;
	}

	[SerializeField]
	private SuspensionSettings suspension;

	[SerializeField]
	private PedalBikeSettings pedals;

	[SerializeField]
	private KickstandSettiongs kickstand;

	[SerializeField]
	private BikeVehicleAudio audioScript;

	[SerializeField]
	private ChainRenderer[] chainRenderers;

	[SerializeField]
	private float chainSpeedMultiplier = 1f;

	[SerializeField]
	private Animator animator;

	[SerializeField]
	private float minGroundFXSpeed = 3f;
}


using System;
using UnityEngine;

[Serializable]
private class SuspensionSettings
{
	public bool enabled;

	public Transform front;

	public float frontMinZ = 0.3f;

	public float frontMaxZ = 0.55f;

	public Transform rearTop;

	public Transform rearBottom;

	public Transform rearSwingArm;

	public float swingArmMinAngle = 5f;

	public float swingArmMaxAngle = 25f;
}


using System;
using UnityEngine;

[Serializable]
private class PedalBikeSettings
{
	public bool enabled;

	public Transform axle;

	public float ratio = 0.5f;

	public Transform left;

	public Transform right;

	public Transform[] clockwiseCogs;

	public Transform[] anticlockwiseCogs;

	public float cogRatio = 1f;
}


using System;
using UnityEngine;

[Serializable]
private class KickstandSettiongs
{
	public bool enabled;

	public Transform pivot;

	public Transform spring;

	public Transform springTarget;

	public float kickstandZ;

	public float upX = 180f;

	public float downX = 80f;
}


using System;
using UnityEngine;

[Serializable]
private class ChainRenderer
{
	public Renderer renderer;

	public int materialIndex;
}


using UnityEngine;

public class BikeDriverSeat : BikeSeat
{
	[SerializeField]
	private Vector3 sprintPosOffset;
}


using UnityEngine;

public class BikeSeat : MouseSteerableSeat
{
	[SerializeField]
	private Transform eyePosRef;
}


using UnityEngine;

public class BikeVehicleAudio : GroundVehicleAudio
{
	[SerializeField]
	[Header("Engine")]
	private EngineAudioSet engineAudioSet;

	[SerializeField]
	[Header("Suspension")]
	private SoundDefinition suspensionDef;

	[SerializeField]
	private float suspensionMinExtensionDelta = 0.4f;

	[SerializeField]
	private float suspensionMinTimeBetweenSounds = 0.25f;

	[SerializeField]
	[Header("Tires")]
	private SoundDefinition tireDirtSoundDef;

	[SerializeField]
	private SoundDefinition tireGrassSoundDef;

	[SerializeField]
	private SoundDefinition tireSnowSoundDef;

	[SerializeField]
	private SoundDefinition tireWaterSoundDef;

	[SerializeField]
	private AnimationCurve tireGainCurve;

	[SerializeField]
	[Header("Skid")]
	private SoundDefinition skidSoundLoop;

	[SerializeField]
	private SoundDefinition skidSoundDirtLoop;

	[SerializeField]
	private SoundDefinition skidSoundSnowLoop;

	[SerializeField]
	private float skidMinSlip = 10f;

	[SerializeField]
	private float skidMaxSlip = 25f;
}


public class MotorbikeAudio : BikeVehicleAudio
{
}


using System;
using UnityEngine;

public class SidecarBikeChassisVisuals : BikeChassisVisuals
{
	[Serializable]
	private class SidecarSuspensionSettings
	{
		public Transform sidecarVisualHinge;

		public Transform sidecarTop;

		public Transform sidecarBottom;

		public Transform sidecarSwingArm;

		public float scSwingArmMinAngle = -10f;

		public float scSwingArmMaxAngle = 10f;
	}

	[SerializeField]
	private SidecarSuspensionSettings sidecarSuspension;
}


using System;
using UnityEngine;

[Serializable]
private class SidecarSuspensionSettings
{
	public Transform sidecarVisualHinge;

	public Transform sidecarTop;

	public Transform sidecarBottom;

	public Transform sidecarSwingArm;

	public float scSwingArmMinAngle = -10f;

	public float scSwingArmMaxAngle = 10f;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust;
using UnityEngine;
using VacuumBreather;

public class BaseBoat : BaseVehicle
{
	[Header("Boat")]
	public float engineThrust = 10f;

	public float steeringScale = 0.1f;

	public Transform thrustPoint;

	public Transform centerOfMass;

	public Buoyancy buoyancy;

	public bool preventDecayIndoors = true;

	[Header("Correction Forces")]
	public bool applyCorrectionForces = true;

	public Transform[] planeFitPoints;

	public Vector3 inAirPID;

	public float inAirDesiredPitch = -15f;

	public Vector3 wavePID;

	public MinMax correctionRange;

	public float correctionSpringForce;

	public float correctionSpringDamping;

	private Vector3[] worldAnchors;

	private PidQuaternionController pidController;

	[ServerVar]
	public static bool generate_paths = true;

	[ServerVar]
	public static bool do_shore_drift = true;

	public static int secondsUntilShoreDrift = 7200;

	public static int secondsBetweenShoreDrift = 120;

	[ServerVar]
	[Help("Shore drift speed in metres per second")]
	public static float drift_speed = 1f;

	[NonSerialized]
	public float gasPedal;

	[NonSerialized]
	public float steering;

	private TimeSince shoreDriftTimer;

	private string lastDriftCheckStatus = "Never checked";

	protected virtual bool AllowKinematicDrift => false;

	protected virtual bool SkipBoatForcedUpdate => false;

	[ServerVar]
	[Help("Seconds until boat starts drifting to shore if there's nobody around")]
	public static int seconds_until_shore_drift(Arg arg)
	{
		secondsUntilShoreDrift = arg.GetInt(0, secondsUntilShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsUntilShoreDrift;
	}

	[Help("Seconds between shore drift teleport ticks")]
	[ServerVar]
	public static int seconds_between_shore_drift(Arg arg)
	{
		secondsBetweenShoreDrift = arg.GetInt(0, secondsBetweenShoreDrift);
		UpdateShoreDriftInvokeOnAll();
		return secondsBetweenShoreDrift;
	}

	public bool InDryDock()
	{
		return (Object)(object)GetParentEntity() != (Object)null;
	}

	public override float MaxVelocity()
	{
		return 25f;
	}

	public override void ServerInit()
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.isKinematic = false;
		if ((Object)(object)rigidBody == (Object)null)
		{
			Debug.LogWarning((object)"Boat rigidbody null");
			return;
		}
		if ((Object)(object)centerOfMass == (Object)null)
		{
			Debug.LogWarning((object)"boat COM null");
			return;
		}
		rigidBody.centerOfMass = centerOfMass.localPosition;
		if (planeFitPoints == null || planeFitPoints.Length != 3)
		{
			Debug.LogWarning((object)"Boats require 3 plane fit points");
			return;
		}
		worldAnchors = (Vector3[])(object)new Vector3[3];
		pidController = new PidQuaternionController(wavePID.x, wavePID.y, wavePID.z);
		if (Application.isLoadingSave)
		{
			((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
			return;
		}
		shoreDriftTimer = TimeSince.op_Implicit(0f);
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, (float)secondsUntilShoreDrift, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			DriverInput(inputState, player);
		}
	}

	public virtual void DriverInput(InputState inputState, BasePlayer player)
	{
		if (inputState.IsDown(BUTTON.FORWARD))
		{
			gasPedal = 1f;
		}
		else if (inputState.IsDown(BUTTON.BACKWARD))
		{
			gasPedal = -0.5f;
		}
		else
		{
			gasPedal = 0f;
		}
		if (inputState.IsDown(BUTTON.LEFT))
		{
			steering = 1f;
		}
		else if (inputState.IsDown(BUTTON.RIGHT))
		{
			steering = -1f;
		}
		else
		{
			steering = 0f;
		}
	}

	public void OnPoolDestroyed()
	{
		Kill(DestroyMode.Gib);
	}

	public void WakeUp()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
			rigidBody.AddForce(Vector3.up * 0.1f, (ForceMode)1);
		}
	}

	protected override void OnServerWake()
	{
		if ((Object)(object)buoyancy != (Object)null)
		{
			buoyancy.Wake();
		}
	}

	public virtual bool EngineOn()
	{
		if (HasDriver())
		{
			return !IsFlipped();
		}
		return false;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseBoat.VehicleFixedUpdate", 0);
		try
		{
			if (!EngineOn())
			{
				gasPedal = 0f;
				steering = 0f;
			}
			base.VehicleFixedUpdate();
			if (!SkipBoatForcedUpdate)
			{
				ApplyCorrectionForces();
				bool flag = WaterLevel.Test(thrustPoint.position, waves: true, volumes: true, this);
				if (gasPedal != 0f && flag && buoyancy.submergedFraction > 0.3f)
				{
					Vector3 val2 = ((Component)this).transform.forward + ((Component)this).transform.right * steering * steeringScale;
					Vector3 val3 = ((Vector3)(ref val2)).normalized * gasPedal * engineThrust;
					rigidBody.AddForceAtPosition(val3, thrustPoint.position, (ForceMode)0);
				}
				if (AnyMounted() && IsFlipped())
				{
					DismountAllPlayers();
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	protected void ApplyCorrectionForces()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0119: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_017b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_022b: Unknown result type (might be due to invalid IL or missing references)
		//IL_027b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0280: Unknown result type (might be due to invalid IL or missing references)
		//IL_0288: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0297: Unknown result type (might be due to invalid IL or missing references)
		//IL_029f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_030b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0310: Unknown result type (might be due to invalid IL or missing references)
		//IL_0318: Unknown result type (might be due to invalid IL or missing references)
		//IL_0322: Unknown result type (might be due to invalid IL or missing references)
		//IL_0327: Unknown result type (might be due to invalid IL or missing references)
		//IL_033b: Unknown result type (might be due to invalid IL or missing references)
		if (applyCorrectionForces && planeFitPoints != null && planeFitPoints.Length == 3 && HasDriver() && !(buoyancy.submergedFraction < 0.5f))
		{
			Matrix4x4 val = Matrix4x4.TRS(((Component)this).transform.position, Quaternion.Euler(0f, ((Component)this).transform.eulerAngles.y, 0f), Vector3.one);
			for (int i = 0; i < planeFitPoints.Length; i++)
			{
				Vector3 val2 = ((Matrix4x4)(ref val)).MultiplyPoint(planeFitPoints[i].localPosition);
				val2.y = WaterLevel.GetWaterSurface(val2, waves: true, volumes: false);
				worldAnchors[i] = val2;
			}
			Plane val3 = default(Plane);
			((Plane)(ref val3))..ctor(worldAnchors[0], worldAnchors[1], worldAnchors[2]);
			Vector3 normal = ((Plane)(ref val3)).normal;
			Vector3 val4 = Vector3.Normalize(worldAnchors[2] - worldAnchors[1]);
			Quaternion desiredOrientation = Quaternion.LookRotation(Vector3.Cross(normal, val4), normal);
			float y = planeFitPoints[0].localPosition.y;
			float num = (worldAnchors[0].y + worldAnchors[1].y + worldAnchors[2].y) / 3f - y;
			float y2 = ((Component)this).transform.position.y;
			float num2 = num - y2;
			Vector3 velocity = rigidBody.velocity;
			if (y2 > num + correctionRange.x && y2 < num + correctionRange.y)
			{
				float num3 = num2 * correctionSpringForce;
				float num4 = (0f - velocity.y) * correctionSpringDamping;
				rigidBody.AddForce(0f, num3 + num4, 0f, (ForceMode)0);
			}
			if (y2 > num + correctionRange.y)
			{
				desiredOrientation = Quaternion.Euler(inAirDesiredPitch, ((Component)this).transform.eulerAngles.y, 0f);
				pidController.Kp = inAirPID.x;
				pidController.Ki = inAirPID.y;
				pidController.Kd = inAirPID.z;
				Vector3 val5 = pidController.ComputeRequiredAngularAcceleration(((Component)this).transform.rotation, desiredOrientation, rigidBody.angularVelocity, Time.fixedDeltaTime);
				rigidBody.AddTorque(val5, (ForceMode)5);
			}
			else if (y2 > num + correctionRange.x)
			{
				pidController.Kp = wavePID.x;
				pidController.Ki = wavePID.y;
				pidController.Kd = wavePID.z;
				Vector3 val6 = pidController.ComputeRequiredAngularAcceleration(((Component)this).transform.rotation, desiredOrientation, rigidBody.angularVelocity, Time.fixedDeltaTime);
				val6.y = 0f;
				rigidBody.AddTorque(val6, (ForceMode)5);
			}
		}
	}

	public static void WaterVehicleDecay(BaseCombatEntity entity, float decayTickRate, float timeSinceLastUsed, float outsideDecayMinutes, float deepWaterDecayMinutes, float decayStartDelayMinutes, bool preventDecayIndoors)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		if (entity.healthFraction != 0f && !(timeSinceLastUsed < 60f * decayStartDelayMinutes))
		{
			float overallWaterDepth = WaterLevel.GetOverallWaterDepth(((Component)entity).transform.position, waves: true, volumes: false);
			float num = outsideDecayMinutes;
			if (preventDecayIndoors && !entity.IsOutside())
			{
				num = float.PositiveInfinity;
			}
			if (overallWaterDepth > 12f)
			{
				float num2 = Mathf.InverseLerp(12f, 16f, overallWaterDepth);
				float num3 = Mathf.Lerp(0.1f, 1f, num2);
				num = Mathf.Min(num, deepWaterDecayMinutes / num3);
			}
			if (!float.IsPositiveInfinity(num))
			{
				float num4 = decayTickRate / 60f / num;
				entity.Hurt(entity.MaxHealth() * num4, DamageType.Decay, entity, useProtection: false);
			}
		}
	}

	private void CheckDriftToShore()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_0125: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_0188: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0204: Unknown result type (might be due to invalid IL or missing references)
		//IL_0206: Unknown result type (might be due to invalid IL or missing references)
		//IL_020b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0210: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_032f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0334: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0344: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0359: Unknown result type (might be due to invalid IL or missing references)
		//IL_0369: Unknown result type (might be due to invalid IL or missing references)
		//IL_0379: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0254: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_02eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		if (!do_shore_drift)
		{
			return;
		}
		if (TimeSince.op_Implicit(shoreDriftTimer) < (float)secondsUntilShoreDrift - 1f)
		{
			lastDriftCheckStatus = "Was too soon";
			return;
		}
		if (!AllowKinematicDrift && rigidBody.isKinematic)
		{
			lastDriftCheckStatus = "Was kinematic";
			return;
		}
		if (IsOn())
		{
			lastDriftCheckStatus = "Was on";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (AnyPlayersOnBoat())
		{
			lastDriftCheckStatus = "Players were on boat";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (HasParent())
		{
			lastDriftCheckStatus = "Was parented";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (IsDead())
		{
			lastDriftCheckStatus = "Is dead";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (WaterFactor() < 0.1f)
		{
			lastDriftCheckStatus = "Not in water";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if ((Object)(object)TerrainTexturing.Instance == (Object)null)
		{
			lastDriftCheckStatus = "No terrain tex";
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			return;
		}
		if (BaseNetworkable.HasConnections(((Component)this).transform.position))
		{
			lastDriftCheckStatus = "Players were nearby";
			return;
		}
		float num = bounds.MaxExtent() + 2f;
		float num2 = drift_speed * (float)secondsBetweenShoreDrift;
		(Vector3 shoreDir, float shoreDist) coarseVectorToShore = TerrainTexturing.Instance.GetCoarseVectorToShore(((Component)this).transform.position);
		Vector3 item = coarseVectorToShore.shoreDir;
		float item2 = coarseVectorToShore.shoreDist;
		float num3 = 2f * num;
		if (item2 < num3)
		{
			shoreDriftTimer = TimeSince.op_Implicit(0f);
			lastDriftCheckStatus = "Was near shore already";
			return;
		}
		float maxDistance = num2 - num;
		Vector3 val = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * (num + 1f);
		Vector3 val2 = ((Component)this).transform.position + ((Bounds)(ref bounds)).center + item * num2;
		Ray ray = new Ray(val, item);
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(ray, num, list, maxDistance, 1235583233, (QueryTriggerInteraction)1, this);
		if (list.Count > 0)
		{
			foreach (RaycastHit item3 in list)
			{
				RaycastHit current = item3;
				if ((Object)(object)((RaycastHit)(ref current)).collider != (Object)null)
				{
					BaseEntity baseEntity = ((RaycastHit)(ref current)).collider.ToBaseEntity();
					if ((Object)(object)baseEntity != (Object)null && baseEntity.HasEntityInParents(this))
					{
						continue;
					}
				}
				if (((RaycastHit)(ref current)).distance <= num3)
				{
					lastDriftCheckStatus = $"Was blocked by {((Object)((RaycastHit)(ref current)).transform).name} at {((RaycastHit)(ref current)).transform.position}";
					Pool.FreeUnmanaged<RaycastHit>(ref list);
					return;
				}
				val2 = ((RaycastHit)(ref current)).point - item * num3;
				val2.y = ((Component)this).transform.position.y + ((Bounds)(ref bounds)).center.y;
				break;
			}
		}
		Vector3 position = ((Component)this).transform.position;
		((Component)this).transform.position = val2 - ((Bounds)(ref bounds)).center;
		rigidBody.velocity = Vector3.zero;
		rigidBody.angularVelocity = Vector3.zero;
		lastDriftCheckStatus = $"Drifted {Vector3.Distance(position, ((Component)this).transform.position):F0}m";
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		((FacepunchBehaviour)this).Invoke((Action)GoToSleep, 0f);
	}

	private void GoToSleep()
	{
		rigidBody.Sleep();
	}

	public virtual bool AnyPlayersOnBoat()
	{
		return AnyMounted();
	}

	public string GetDriftStatus()
	{
		return lastDriftCheckStatus;
	}

	public static void UpdateShoreDriftInvokeOnAll()
	{
		BaseBoat[] array = Util.FindAll<BaseBoat>();
		foreach (BaseBoat baseBoat in array)
		{
			if (baseBoat.IsValid())
			{
				baseBoat.UpdateShoreDriftInvoke();
			}
		}
	}

	private void UpdateShoreDriftInvoke()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = Mathf.Max(0f, (float)secondsUntilShoreDrift - TimeSince.op_Implicit(shoreDriftTimer));
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckDriftToShore, num, (float)secondsBetweenShoreDrift, (float)secondsBetweenShoreDrift * 0.1f);
	}

	public override void Save(SaveInfo info)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.baseBoat = Pool.Get<BaseBoat>();
		info.msg.baseBoat.shoreDriftTimerValue = TimeSince.op_Implicit(shoreDriftTimer);
	}

	public override void Load(LoadInfo info)
	{
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		base.Load(info);
		if (info.msg.baseBoat != null && base.isServer)
		{
			shoreDriftTimer = TimeSince.op_Implicit(info.msg.baseBoat.shoreDriftTimerValue);
		}
	}

	public override float WaterFactorForPlayer(BasePlayer player, out WaterLevel.WaterInfo info)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		info = WaterLevel.GetWaterInfo(player.eyes.position, waves: true, volumes: true);
		if (!info.isValid)
		{
			return 0f;
		}
		return 1f;
	}

	public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_0275: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0114: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0192: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		object obj = Interface.CallHook("OnBoatPathGenerate");
		if (obj is List<Vector3>)
		{
			return (List<Vector3>)obj;
		}
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		List<Vector3> list = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			list.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 4f;
		float num8 = 200f;
		bool flag = true;
		RaycastHit val9 = default(RaycastHit);
		for (int j = 0; j < AI.ocean_patrol_path_iterations && flag; j++)
		{
			flag = false;
			for (int k = 0; k < num3; k++)
			{
				Vector3 val = list[k];
				int index = ((k == 0) ? (num3 - 1) : (k - 1));
				int index2 = ((k != num3 - 1) ? (k + 1) : 0);
				Vector3 val2 = list[index2];
				Vector3 val3 = list[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				int num9 = 16;
				for (int l = 0; l < num9; l++)
				{
					float num10 = (float)l / (float)num9 * 360f;
					val5 = new Vector3(Mathf.Sin(num10 * (MathF.PI / 180f)), num5, Mathf.Cos(num10 * (MathF.PI / 180f)));
					Vector3 normalized2 = ((Vector3)(ref val5)).normalized;
					Vector3 val7 = val6 + normalized2 * 1f;
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val6;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (Physics.SphereCast(val4, 3f, val8, ref val9, minDistanceFromShore, 1084293377))
					{
						flag2 = false;
						break;
					}
				}
				if (flag2)
				{
					flag = true;
					list[k] = val6;
				}
			}
		}
		if (flag)
		{
			Debug.LogWarning((object)"Failed to generate ocean patrol path");
			return null;
		}
		List<int> list2 = new List<int>();
		LineUtility.Simplify(list, 5f, list2);
		List<Vector3> list3 = list;
		list = new List<Vector3>();
		foreach (int item in list2)
		{
			list.Add(list3[item]);
		}
		Debug.Log((object)("Generated ocean patrol path with node count: " + list.Count));
		return list;
	}
}


using System;
using ConVar;
using UnityEngine;
using UnityEngine.Serialization;

public class Buoyancy : ListComponent<Buoyancy>, IServerComponent, IPrefabPreProcess
{
	public enum Priority
	{
		High,
		Low
	}

	[Serializable]
	private struct BuoyancyPointData
	{
		[ReadOnly]
		public Vector3 localPosition;

		[ReadOnly]
		public Vector3 rootToPoint;

		[NonSerialized]
		public Vector3 position;
	}

	public BuoyancyPoint[] points;

	public GameObjectRef[] waterImpacts;

	public Rigidbody rigidBody;

	public float buoyancyScale = 1f;

	public bool scaleForceWithMass;

	public bool doEffects = true;

	public float flowMovementScale = 1f;

	public float requiredSubmergedFraction = 0.5f;

	public bool useUnderwaterDrag;

	[Range(0f, 3f)]
	public float underwaterDrag = 2f;

	[Range(0f, 1f)]
	[FormerlySerializedAs("flatWaterLerp")]
	[Tooltip("How much this object will pay attention to the wave system, 0 = flat water, 1 = full waves (default 1)")]
	public float wavesEffect = 1f;

	public Action<bool> SubmergedChanged;

	public BaseEntity forEntity;

	[NonSerialized]
	public float submergedFraction;

	[ReadOnly]
	[SerializeField]
	private BuoyancyPointData[] pointData;

	private bool initedPointArrays;

	private Vector2[] pointPositionArray;

	private Vector2[] pointPositionUVArray;

	private float[] pointShoreDistanceArray;

	private float[] pointTerrainHeightArray;

	private float[] pointWaterHeightArray;

	private float defaultDrag;

	private float defaultAngularDrag;

	private float timeInWater;

	[NonSerialized]
	public float? ArtificialHeight;

	private BaseVehicle forVehicle;

	private bool hasLocalPlayers;

	private bool hadLocalPlayers;

	public float timeOutOfWater { get; private set; }

	public bool InWater => submergedFraction > requiredSubmergedFraction;

	public Priority BuoyancyPriority { get; set; }

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!Application.isPlaying || serverside)
		{
			SavePointData(forced: false);
		}
	}

	public void SavePointData(bool forced)
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		if (points == null || points.Length == 0)
		{
			Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
			if ((Object)(object)val == (Object)null)
			{
				val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			}
			GameObject val2 = new GameObject("BuoyancyPoint");
			val2.transform.parent = ((Component)val).gameObject.transform;
			val2.transform.localPosition = val.centerOfMass;
			BuoyancyPoint buoyancyPoint = val2.AddComponent<BuoyancyPoint>();
			buoyancyPoint.buoyancyForce = val.mass * (0f - Physics.gravity.y);
			buoyancyPoint.buoyancyForce *= 1.32f;
			buoyancyPoint.size = 0.2f;
			points = new BuoyancyPoint[1];
			points[0] = buoyancyPoint;
		}
		if (pointData == null || pointData.Length != points.Length || forced)
		{
			pointData = new BuoyancyPointData[points.Length];
			for (int i = 0; i < points.Length; i++)
			{
				Transform transform = ((Component)points[i]).transform;
				pointData[i].localPosition = transform.localPosition;
				pointData[i].rootToPoint = ((Component)this).transform.InverseTransformPoint(transform.position);
			}
		}
	}

	public static string DefaultWaterImpact()
	{
		return "assets/bundled/prefabs/fx/impacts/physics/water-enter-exit.prefab";
	}

	private void Awake()
	{
		forVehicle = forEntity as BaseVehicle;
		((FacepunchBehaviour)this).InvokeRandomized((Action)CheckSleepState, 0.5f, 5f, 1f);
	}

	public void Sleep()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancySleep(InWater)) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.Sleep();
		}
		((Behaviour)this).enabled = false;
	}

	public void Wake()
	{
		if (((Object)(object)forEntity == (Object)null || !forEntity.BuoyancyWake()) && (Object)(object)rigidBody != (Object)null)
		{
			rigidBody.WakeUp();
		}
		((Behaviour)this).enabled = true;
	}

	public void CheckSleepState()
	{
		if ((Object)(object)((Component)this).transform == (Object)null || (Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		hasLocalPlayers = HasLocalPlayers();
		bool flag = rigidBody.IsSleeping() || rigidBody.isKinematic;
		bool flag2 = flag || (!hasLocalPlayers && timeInWater > 6f);
		if ((Object)(object)forVehicle != (Object)null && forVehicle.IsOn())
		{
			flag2 = false;
		}
		if (((Behaviour)this).enabled && flag2)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (!((Behaviour)this).enabled && hasLocalPlayers && !hadLocalPlayers)
		{
			DoCycle(forced: true);
		}
		bool flag3 = !flag || ShouldWake(hasLocalPlayers);
		if (!((Behaviour)this).enabled && flag3)
		{
			((FacepunchBehaviour)this).Invoke((Action)Wake, 0f);
		}
		hadLocalPlayers = hasLocalPlayers;
	}

	public void LowPriorityCheck(bool forceHighPriority)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Priority buoyancyPriority = BuoyancyPriority;
		Priority priority = buoyancyPriority;
		if (forceHighPriority)
		{
			priority = Priority.High;
		}
		else
		{
			Vector3 position = ((Component)this).transform.position;
			priority = ((!BaseNetworkable.HasCloseConnections(position, Server.lowPriorityBuoyancyRange)) ? Priority.Low : Priority.High);
			if (priority == Priority.Low && priority != buoyancyPriority)
			{
				Vector3 val = Vector3Ex.WithY(((Component)this).transform.TransformPoint(Vector3.forward * 2f), position.y);
				Rigidbody obj = rigidBody;
				Vector3 val2 = val - rigidBody.position;
				obj.rotation = Quaternion.LookRotation(((Vector3)(ref val2)).normalized, Vector3.up);
			}
		}
		if (priority != buoyancyPriority)
		{
			rigidBody.velocity = Vector3.zero;
			rigidBody.angularVelocity = Vector3.zero;
			BuoyancyPriority = priority;
		}
	}

	public bool ShouldWake()
	{
		return ShouldWake(HasLocalPlayers());
	}

	public bool ShouldWake(bool hasLocalPlayers)
	{
		if (hasLocalPlayers)
		{
			return submergedFraction > 0f;
		}
		return false;
	}

	private bool HasLocalPlayers()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return BaseNetworkable.HasCloseConnections(((Component)this).transform.position, 100f);
	}

	protected void DoCycle(bool forced = false)
	{
		if (!((Behaviour)this).enabled && !forced)
		{
			return;
		}
		bool num = submergedFraction > 0f;
		BuoyancyFixedUpdate();
		bool flag = submergedFraction > 0f;
		if (num == flag)
		{
			return;
		}
		if (useUnderwaterDrag && (Object)(object)rigidBody != (Object)null)
		{
			if (flag)
			{
				defaultDrag = rigidBody.drag;
				defaultAngularDrag = rigidBody.angularDrag;
				rigidBody.drag = underwaterDrag;
				rigidBody.angularDrag = underwaterDrag;
			}
			else
			{
				rigidBody.drag = defaultDrag;
				rigidBody.angularDrag = defaultAngularDrag;
			}
		}
		if (SubmergedChanged != null)
		{
			SubmergedChanged(flag);
		}
	}

	public static void Cycle()
	{
		bool autoSyncTransforms = Physics.autoSyncTransforms;
		try
		{
			Physics.autoSyncTransforms = false;
			Buoyancy[] buffer = ListComponent<Buoyancy>.InstanceList.Values.Buffer;
			int count = ListComponent<Buoyancy>.InstanceList.Count;
			for (int i = 0; i < count; i++)
			{
				buffer[i].DoCycle();
			}
		}
		finally
		{
			if (autoSyncTransforms)
			{
				Physics.SyncTransforms();
			}
			Physics.autoSyncTransforms = autoSyncTransforms;
		}
	}

	private Vector3 GetFlowDirection(Vector3 worldPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return WaterLevel.GetWaterFlowDirection(worldPos);
	}

	public void BuoyancyFixedUpdate()
	{
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_025e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_0292: Unknown result type (might be due to invalid IL or missing references)
		//IL_0381: Unknown result type (might be due to invalid IL or missing references)
		//IL_0383: Unknown result type (might be due to invalid IL or missing references)
		//IL_03ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_03d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0442: Unknown result type (might be due to invalid IL or missing references)
		//IL_0444: Unknown result type (might be due to invalid IL or missing references)
		//IL_0446: Unknown result type (might be due to invalid IL or missing references)
		//IL_044b: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)rigidBody == (Object)null)
		{
			return;
		}
		if (buoyancyScale == 0f)
		{
			((FacepunchBehaviour)this).Invoke((Action)Sleep, 0f);
			return;
		}
		if (BuoyancyPriority == Priority.Low)
		{
			WaterLevel.WaterInfo waterInfo = WaterLevel.GetWaterInfo(((Component)this).transform.position, waves: true, volumes: true, forEntity);
			Vector3 position = rigidBody.position;
			if (position.y < waterInfo.surfaceLevel)
			{
				rigidBody.position = new Vector3(position.x, waterInfo.surfaceLevel, position.z);
			}
			return;
		}
		if (!initedPointArrays)
		{
			InitPointArrays();
		}
		float time = Time.time;
		float x = TerrainMeta.Position.x;
		float z = TerrainMeta.Position.z;
		float x2 = TerrainMeta.OneOverSize.x;
		float z2 = TerrainMeta.OneOverSize.z;
		Matrix4x4 localToWorldMatrix = ((Component)this).transform.localToWorldMatrix;
		for (int i = 0; i < pointData.Length; i++)
		{
			Vector3 val = ((Matrix4x4)(ref localToWorldMatrix)).MultiplyPoint3x4(pointData[i].rootToPoint);
			pointData[i].position = val;
			float num = (val.x - x) * x2;
			float num2 = (val.z - z) * z2;
			pointPositionArray[i] = new Vector2(val.x, val.z);
			pointPositionUVArray[i] = new Vector2(num, num2);
		}
		WaterSystem.GetHeightArray(pointPositionArray, pointPositionUVArray, pointShoreDistanceArray, pointTerrainHeightArray, pointWaterHeightArray);
		bool flag = wavesEffect < 1f;
		int num3 = 0;
		Vector3 accumForce = default(Vector3);
		Vector3 val2 = default(Vector3);
		for (int j = 0; j < points.Length; j++)
		{
			BuoyancyPoint buoyancyPoint = points[j];
			Vector3 pos = pointData[j].position;
			Vector3 localPosition = pointData[j].localPosition;
			Vector2 posUV = pointPositionUVArray[j];
			float terrainHeight = pointTerrainHeightArray[j];
			float num4 = pointWaterHeightArray[j];
			if (ArtificialHeight.HasValue)
			{
				num4 = ArtificialHeight.Value;
			}
			else if (flag)
			{
				num4 = Mathf.Lerp(0f, num4, wavesEffect);
			}
			bool doDeepwaterChecks = !ArtificialHeight.HasValue;
			WaterLevel.WaterInfo waterInfo2 = WaterLevel.GetBuoyancyWaterInfo(pos, posUV, terrainHeight, num4, doDeepwaterChecks, forEntity);
			if (flag && waterInfo2.isValid)
			{
				waterInfo2.currentDepth = Mathf.Lerp(waterInfo2.currentDepth, waterInfo2.surfaceLevel - pos.y, wavesEffect);
			}
			bool flag2 = false;
			if (pos.y < waterInfo2.surfaceLevel && waterInfo2.isValid)
			{
				flag2 = true;
				num3++;
				float currentDepth = waterInfo2.currentDepth;
				float num5 = Mathf.InverseLerp(0f, buoyancyPoint.size, currentDepth);
				float num6 = 1f + Mathf.PerlinNoise(buoyancyPoint.randomOffset + time * buoyancyPoint.waveFrequency, 0f) * buoyancyPoint.waveScale;
				float num7 = buoyancyPoint.buoyancyForce * buoyancyScale;
				if (scaleForceWithMass)
				{
					num7 *= rigidBody.mass;
				}
				((Vector3)(ref accumForce))..ctor(0f, num6 * num5 * num7, 0f);
				AccumulateFlowForce(ref accumForce, in pos, in waterInfo2, Mathf.Abs(pointShoreDistanceArray[j]), num7);
				rigidBody.AddForceAtPosition(accumForce, pos, (ForceMode)0);
			}
			if (buoyancyPoint.doSplashEffects && ((!buoyancyPoint.wasSubmergedLastFrame && flag2) || (!flag2 && buoyancyPoint.wasSubmergedLastFrame)) && doEffects)
			{
				Vector3 relativePointVelocity = rigidBody.GetRelativePointVelocity(localPosition);
				if (((Vector3)(ref relativePointVelocity)).magnitude > 1f)
				{
					string strName = ((waterImpacts != null && waterImpacts.Length != 0 && waterImpacts[0].isValid) ? waterImpacts[0].resourcePath : DefaultWaterImpact());
					((Vector3)(ref val2))..ctor(Random.Range(-0.25f, 0.25f), 0f, Random.Range(-0.25f, 0.25f));
					Effect.server.Run(strName, pos + val2, Vector3.up);
					buoyancyPoint.nexSplashTime = Time.time + 0.25f;
				}
			}
			buoyancyPoint.wasSubmergedLastFrame = flag2;
		}
		if (points.Length != 0)
		{
			submergedFraction = (float)num3 / (float)points.Length;
		}
		if (InWater)
		{
			timeInWater += Time.fixedDeltaTime;
			timeOutOfWater = 0f;
		}
		else
		{
			timeOutOfWater += Time.fixedDeltaTime;
			timeInWater = 0f;
		}
	}

	public void AccumulateFlowForce(ref Vector3 accumForce, in Vector3 pos, in WaterLevel.WaterInfo waterInfo, float shoreDistance, float scaledBuoyancyForce)
	{
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		if ((waterInfo.topology & 0x10000) == 0)
		{
			float num = Mathf.Clamp01(Mathf.InverseLerp(60f, 0f, shoreDistance));
			if (!(num <= Mathf.Epsilon))
			{
				num = Mathf.Pow(num, 0.5f);
				Vector3 flowDirection = GetFlowDirection(pos);
				scaledBuoyancyForce *= 0.025f * num;
				accumForce.x += flowDirection.x * scaledBuoyancyForce * flowMovementScale;
				accumForce.z += flowDirection.z * scaledBuoyancyForce * flowMovementScale;
			}
		}
	}

	private void InitPointArrays()
	{
		pointPositionArray = (Vector2[])(object)new Vector2[points.Length];
		pointPositionUVArray = (Vector2[])(object)new Vector2[points.Length];
		pointShoreDistanceArray = new float[points.Length];
		pointTerrainHeightArray = new float[points.Length];
		pointWaterHeightArray = new float[points.Length];
		initedPointArrays = true;
	}
}


public enum Priority
{
	High,
	Low
}


using System;
using UnityEngine;

[Serializable]
private struct BuoyancyPointData
{
	[ReadOnly]
	public Vector3 localPosition;

	[ReadOnly]
	public Vector3 rootToPoint;

	[NonSerialized]
	public Vector3 position;
}


using System;
using UnityEngine;

public class BuoyancyPoint : MonoBehaviour
{
	public float buoyancyForce = 10f;

	public float size = 0.1f;

	public float waveScale = 0.2f;

	public float waveFrequency = 1f;

	public bool doSplashEffects = true;

	[NonSerialized]
	public float randomOffset;

	[NonSerialized]
	public bool wasSubmergedLastFrame;

	[NonSerialized]
	public float nexSplashTime;

	private static readonly Color gizmoColour = new Color(1f, 0f, 0f, 0.25f);

	public void Start()
	{
		randomOffset = Random.Range(0f, 20f);
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = gizmoColour;
		Gizmos.DrawSphere(((Component)this).transform.position, size * 0.5f);
	}
}


using UnityEngine;

public class KayakSeat : BaseVehicleSeat
{
	public ItemDefinition PaddleItem;

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerMounted();
		}
	}

	public override void OnPlayerDismounted(BasePlayer player)
	{
		base.OnPlayerDismounted(player);
		if ((Object)(object)VehicleParent() != (Object)null)
		{
			VehicleParent().OnPlayerDismounted(player);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class RHIBAIController : FacepunchBehaviour
{
	public List<Vector3> nodes = new List<Vector3>();

	[ContextMenu("Calculate Path")]
	public void SetupPatrolPath()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0194: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0205: Unknown result type (might be due to invalid IL or missing references)
		//IL_020a: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		//IL_0222: Unknown result type (might be due to invalid IL or missing references)
		//IL_0224: Unknown result type (might be due to invalid IL or missing references)
		//IL_0226: Unknown result type (might be due to invalid IL or missing references)
		//IL_027a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0246: Unknown result type (might be due to invalid IL or missing references)
		//IL_0248: Unknown result type (might be due to invalid IL or missing references)
		//IL_0232: Unknown result type (might be due to invalid IL or missing references)
		//IL_0234: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_023f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0244: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float num = x * 2f * MathF.PI;
		float num2 = 30f;
		int num3 = Mathf.CeilToInt(num / num2);
		nodes = new List<Vector3>();
		float num4 = x;
		float num5 = 0f;
		for (int i = 0; i < num3; i++)
		{
			float num6 = (float)i / (float)num3 * 360f;
			nodes.Add(new Vector3(Mathf.Sin(num6 * (MathF.PI / 180f)) * num4, num5, Mathf.Cos(num6 * (MathF.PI / 180f)) * num4));
		}
		float num7 = 2f;
		float num8 = 200f;
		float num9 = 150f;
		float num10 = 8f;
		bool flag = true;
		int num11 = 1;
		float num12 = 20f;
		Vector3[] array = (Vector3[])(object)new Vector3[5]
		{
			new Vector3(0f, 0f, 0f),
			new Vector3(num12, 0f, 0f),
			new Vector3(0f - num12, 0f, 0f),
			new Vector3(0f, 0f, num12),
			new Vector3(0f, 0f, 0f - num12)
		};
		RaycastHit val9 = default(RaycastHit);
		while (flag)
		{
			Debug.Log((object)("Loop # :" + num11));
			num11++;
			flag = false;
			for (int j = 0; j < num3; j++)
			{
				Vector3 val = nodes[j];
				int index = ((j == 0) ? (num3 - 1) : (j - 1));
				int index2 = ((j != num3 - 1) ? (j + 1) : 0);
				Vector3 val2 = nodes[index2];
				Vector3 val3 = nodes[index];
				Vector3 val4 = val;
				Vector3 val5 = Vector3.zero - val;
				Vector3 normalized = ((Vector3)(ref val5)).normalized;
				Vector3 val6 = val + normalized * num7;
				if (Vector3.Distance(val6, val2) > num8 || Vector3.Distance(val6, val3) > num8)
				{
					continue;
				}
				bool flag2 = true;
				for (int k = 0; k < array.Length; k++)
				{
					Vector3 val7 = val6 + array[k];
					if (GetWaterDepth(val7) < num10)
					{
						flag2 = false;
					}
					Vector3 val8 = normalized;
					if (val7 != Vector3.zero)
					{
						val5 = val7 - val4;
						val8 = ((Vector3)(ref val5)).normalized;
					}
					if (Physics.Raycast(val4, val8, ref val9, num9, 1218511105))
					{
						flag2 = false;
					}
				}
				if (flag2)
				{
					flag = true;
					nodes[j] = val6;
				}
			}
		}
		List<int> list = new List<int>();
		LineUtility.Simplify(nodes, 15f, list);
		List<Vector3> list2 = nodes;
		nodes = new List<Vector3>();
		foreach (int item in list)
		{
			nodes.Add(list2[item]);
		}
	}

	public float GetWaterDepth(Vector3 pos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (!Physics.Raycast(pos, Vector3.down, ref val, 100f, 8388608))
		{
			return 100f;
		}
		return ((RaycastHit)(ref val)).distance;
	}

	public void OnDrawGizmosSelected()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		if (TerrainMeta.Path.OceanPatrolClose != null)
		{
			for (int i = 0; i < TerrainMeta.Path.OceanPatrolClose.Count; i++)
			{
				Vector3 val = TerrainMeta.Path.OceanPatrolClose[i];
				Gizmos.color = Color.green;
				Gizmos.DrawSphere(val, 3f);
				Vector3 val2 = ((i + 1 == TerrainMeta.Path.OceanPatrolClose.Count) ? TerrainMeta.Path.OceanPatrolClose[0] : TerrainMeta.Path.OceanPatrolClose[i + 1]);
				Gizmos.DrawLine(val, val2);
			}
		}
	}
}


using UnityEngine;

public class TugboatInteriorSoundTrigger : MonoBehaviour, IClientComponent
{
	public TugboatSounds tugboatSounds;

	public bool bridge;
}


using UnityEngine;

public class TugboatSounds : MonoBehaviour, IClientComponent
{
	[SerializeField]
	private Tugboat tugboat;

	[SerializeField]
	private float roughHalfWidth = 5f;

	[SerializeField]
	private float roughHalfLength = 10f;

	private float soundCullDistanceSq;

	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineLoopDef;

	private Sound engineLoop;

	private SoundModulation.Modulator engineGainMod;

	private SoundModulation.Modulator enginePitchMod;

	[SerializeField]
	private SoundDefinition engineStartDef;

	[SerializeField]
	private SoundDefinition engineStartBridgeDef;

	[SerializeField]
	private SoundDefinition engineStopDef;

	[SerializeField]
	private SoundDefinition engineStopBridgeDef;

	[SerializeField]
	private float engineGainChangeRate = 1f;

	[SerializeField]
	private float enginePitchChangeRate = 0.5f;

	[SerializeField]
	private Transform engineTransform;

	[SerializeField]
	private Transform bridgeControlsTransform;

	[Header("Water")]
	[SerializeField]
	private SoundDefinition waterIdleDef;

	[SerializeField]
	private SoundDefinition waterSideMovementSlowDef;

	[SerializeField]
	private SoundDefinition waterSideMovementFastDef;

	[SerializeField]
	private SoundDefinition waterSternMovementDef;

	[SerializeField]
	private SoundDefinition waterInteriorIdleDef;

	[SerializeField]
	private SoundDefinition waterInteriorDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private float waterMovementGainChangeRate = 0.5f;

	[SerializeField]
	private AnimationCurve waterDistanceGainCurve;

	private Sound leftWaterSound;

	private SoundModulation.Modulator leftWaterGainMod;

	private Sound rightWaterSound;

	private SoundModulation.Modulator rightWaterGainMod;

	private Sound sternWaterSound;

	private SoundModulation.Modulator sternWaterGainMod;

	[SerializeField]
	private Transform wakeTransform;

	[SerializeField]
	private Vector3 sideSoundLineStern;

	[SerializeField]
	private Vector3 sideSoundLineBow;

	[Header("Ambient")]
	private Sound ambientIdleSound;

	[SerializeField]
	private SoundDefinition ambientActiveLoopDef;

	private Sound ambientActiveSound;

	[SerializeField]
	private SoundDefinition hullGroanDef;

	[SerializeField]
	private float hullGroanCooldown = 1f;

	private float lastHullGroan;

	[SerializeField]
	private SoundDefinition chainRattleDef;

	[SerializeField]
	private float chainRattleCooldown = 1f;

	[SerializeField]
	private Transform[] chainRattleLocations;

	[SerializeField]
	private float chainRattleAngleDeltaThreshold = 1f;

	private float lastChainRattle;

	private Line leftSoundLine;

	private Line rightSoundLine;

	[Header("Runtime")]
	public bool engineOn;

	public bool throttleOn;

	public bool inWater = true;
}


using System;
using UnityEngine;

[Serializable]
public class CarSettings
{
	[Header("Vehicle Setup")]
	[Range(0f, 1f)]
	public float rollingResistance = 0.05f;

	[Range(0f, 1f)]
	public float antiRoll;

	public bool canSleep = true;

	[Header("Wheels")]
	public bool tankSteering;

	[Range(0f, 50f)]
	public float maxSteerAngle = 35f;

	public bool steeringAssist = true;

	[Range(0f, 1f)]
	public float steeringAssistRatio = 0.5f;

	public bool steeringLimit;

	[Range(0f, 50f)]
	public float minSteerLimitAngle = 6f;

	[Range(10f, 50f)]
	public float minSteerLimitSpeed = 30f;

	[Range(0f, 1f)]
	public float rearWheelSteer = 1f;

	public float steerMinLerpSpeed = 75f;

	public float steerMaxLerpSpeed = 150f;

	public float steerReturnLerpSpeed = 200f;

	public bool retainLerpSpeed;

	[Header("Motor")]
	public float maxDriveSlip = 4f;

	public float driveForceToMaxSlip = 1000f;

	public float reversePercentSpeed = 0.3f;

	[Header("Brakes")]
	public float brakeForceMultiplier = 1000f;

	public bool disableHandbrakes;

	[Header("Front/Rear Vehicle Balance")]
	[Range(0f, 1f)]
	public float handlingBias = 0.5f;
}


using System;
using UnityEngine;

[Serializable]
public class CarWheel
{
	public WheelCollider wheelCollider;

	[Range(0.0001f, 3f)]
	public float tyreFriction = 1f;

	public bool steerWheel;

	public bool brakeWheel = true;

	public bool powerWheel = true;
}


using System;
using ConVar;
using UnityEngine;

public class CarPhysics<TCar> where TCar : BaseVehicle, CarPhysics<TCar>.ICar
{
	public interface ICar
	{
		VehicleTerrainHandler.Surface OnSurface { get; }

		float GetThrottleInput();

		float GetBrakeInput();

		float GetSteerInput();

		bool GetSteerSpeedMod(float speed);

		float GetSteerMaxMult(float speed);

		float GetMaxForwardSpeed();

		float GetMaxDriveForce();

		float GetAdjustedDriveForce(float absSpeed, float topSpeed);

		float GetModifiedDrag();

		CarWheel[] GetWheels();

		float GetWheelsMidPos();
	}

	private class ServerWheelData
	{
		public CarWheel wheel;

		public Transform wheelColliderTransform;

		public WheelCollider wheelCollider;

		public bool isGrounded;

		public float downforce;

		public float forceDistance;

		public WheelHit hit;

		public Vector2 localRigForce;

		public Vector2 localVelocity;

		public float angularVelocity;

		public Vector3 origin;

		public Vector2 tyreForce;

		public Vector2 tyreSlip;

		public Vector3 velocity;

		public bool isBraking;

		public bool hasThrottleInput;

		public bool isFrontWheel;

		public bool isLeftWheel;
	}

	private readonly ServerWheelData[] wheelData;

	private readonly TCar car;

	private readonly Transform transform;

	private readonly Rigidbody rBody;

	private readonly CarSettings vehicleSettings;

	private float speedAngle;

	private bool wasSleeping = true;

	private bool hasDriver;

	private bool hadDriver;

	private float steerLerpSpeed;

	public float lastMovingTime = float.MinValue;

	private WheelFrictionCurve zeroFriction;

	private Vector3 prevLocalCOM;

	private readonly float midWheelPos;

	private const bool WHEEL_HIT_CORRECTION = true;

	private const float SLEEP_SPEED = 0.25f;

	private const float SLEEP_DELAY = 10f;

	private const float AIR_DRAG = 0.25f;

	private const float DEFAULT_GROUND_GRIP = 0.75f;

	private const float ROAD_GROUND_GRIP = 1f;

	private const float ICE_GROUND_GRIP = 0.25f;

	private bool slowSpeedExitFlag;

	private const float SLOW_SPEED_EXIT_SPEED = 4f;

	public TimeSince timeSinceWaterCheck;

	public float DriveWheelVelocity { get; private set; }

	public float DriveWheelSlip { get; private set; }

	public float SteerAngle { get; private set; }

	public float TankThrottleLeft { get; private set; }

	public float TankThrottleRight { get; private set; }

	private bool InSlowSpeedExitMode
	{
		get
		{
			if (!hasDriver)
			{
				return slowSpeedExitFlag;
			}
			return false;
		}
	}

	public CarPhysics(TCar car, Transform transform, Rigidbody rBody, CarSettings vehicleSettings)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		WheelFrictionCurve val = default(WheelFrictionCurve);
		((WheelFrictionCurve)(ref val)).stiffness = 0f;
		zeroFriction = val;
		Transform transform2 = transform;
		base..ctor();
		CarPhysics<TCar> carPhysics = this;
		this.car = car;
		this.transform = transform2;
		this.rBody = rBody;
		this.vehicleSettings = vehicleSettings;
		timeSinceWaterCheck = default(TimeSince);
		timeSinceWaterCheck = TimeSince.op_Implicit(float.MaxValue);
		prevLocalCOM = rBody.centerOfMass;
		CarWheel[] wheels = car.GetWheels();
		wheelData = new ServerWheelData[wheels.Length];
		for (int i = 0; i < wheelData.Length; i++)
		{
			wheelData[i] = AddWheel(wheels[i]);
		}
		midWheelPos = car.GetWheelsMidPos();
		wheelData[0].wheel.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
		lastMovingTime = Time.realtimeSinceStartup;
		ServerWheelData AddWheel(CarWheel wheel)
		{
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_006e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0073: Unknown result type (might be due to invalid IL or missing references)
			//IL_0078: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			ServerWheelData obj = new ServerWheelData
			{
				wheelCollider = wheel.wheelCollider,
				wheelColliderTransform = ((Component)wheel.wheelCollider).transform,
				forceDistance = GetWheelForceDistance(wheel.wheelCollider),
				wheel = wheel
			};
			obj.wheelCollider.sidewaysFriction = zeroFriction;
			obj.wheelCollider.forwardFriction = zeroFriction;
			Vector3 val2 = transform2.InverseTransformPoint(((Component)wheel.wheelCollider).transform.position);
			obj.isFrontWheel = val2.z > 0f;
			obj.isLeftWheel = val2.x < 0f;
			return obj;
		}
	}

	public void FixedUpdate(float dt, float speed)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_03c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_03cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_03e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0397: Unknown result type (might be due to invalid IL or missing references)
		//IL_039c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0441: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("CarPhysics.FixedUpdate", 0);
		try
		{
			if (rBody.centerOfMass != prevLocalCOM)
			{
				COMChanged();
			}
			float num = Mathf.Abs(speed);
			hasDriver = car.HasDriver();
			if (!hasDriver && hadDriver)
			{
				if (num <= 4f)
				{
					slowSpeedExitFlag = true;
				}
			}
			else if (hasDriver && !hadDriver)
			{
				slowSpeedExitFlag = false;
			}
			if ((hasDriver || !vehicleSettings.canSleep) && rBody.IsSleeping())
			{
				rBody.WakeUp();
			}
			Vector3 val2;
			if (!rBody.IsSleeping())
			{
				if ((!wasSleeping || rBody.isKinematic) && !(num > 0.25f))
				{
					val2 = rBody.angularVelocity;
					if (!(Mathf.Abs(((Vector3)(ref val2)).magnitude) > 0.25f))
					{
						goto IL_0103;
					}
				}
				lastMovingTime = Time.time;
				goto IL_0103;
			}
			wasSleeping = true;
			goto IL_05ed;
			IL_0103:
			bool flag = vehicleSettings.canSleep && !hasDriver && Time.time > lastMovingTime + 10f;
			if (flag && (car.GetParentEntity() as BaseVehicle).IsValid())
			{
				flag = false;
			}
			if (flag)
			{
				for (int i = 0; i < wheelData.Length; i++)
				{
					ServerWheelData serverWheelData = wheelData[i];
					serverWheelData.wheelCollider.motorTorque = 0f;
					serverWheelData.wheelCollider.brakeTorque = 0f;
					serverWheelData.wheelCollider.steerAngle = 0f;
					if (vehicle.disable_wheels_when_sleeping)
					{
						((Collider)serverWheelData.wheelCollider).enabled = false;
					}
				}
				rBody.Sleep();
				goto IL_05dd;
			}
			speedAngle = Vector3.Angle(rBody.velocity, transform.forward) * Mathf.Sign(Vector3.Dot(rBody.velocity, transform.right));
			float maxDriveForce = car.GetMaxDriveForce();
			float maxForwardSpeed = car.GetMaxForwardSpeed();
			float num2 = (car.IsOn() ? car.GetThrottleInput() : 0f);
			float steerInput = car.GetSteerInput();
			float brakeInput = (InSlowSpeedExitMode ? 1f : car.GetBrakeInput());
			float num3 = 1f;
			if (num < 3f)
			{
				num3 = 2.75f;
			}
			else if (num < 9f)
			{
				float num4 = Mathf.InverseLerp(9f, 3f, num);
				num3 = Mathf.Lerp(1f, 2.75f, num4);
			}
			maxDriveForce *= num3;
			ComputeSteerAngle(num2, steerInput, dt, speed);
			if (TimeSince.op_Implicit(timeSinceWaterCheck) > 0.25f)
			{
				float num5 = car.WaterFactor();
				float num6 = 0f;
				if (car.FindTrigger<TriggerVehicleDrag>(out var result))
				{
					num6 = result.vehicleDrag;
				}
				float num7 = ((num2 != 0f) ? 0f : 0.25f);
				float num8 = Mathf.Max(num5, num6);
				num8 = Mathf.Max(num8, car.GetModifiedDrag());
				rBody.drag = Mathf.Max(num7, num8);
				rBody.angularDrag = num8 * 0.5f;
				timeSinceWaterCheck = TimeSince.op_Implicit(0f);
			}
			int num9 = 0;
			float num10 = 0f;
			int num11;
			if (!vehicleSettings.disableHandbrakes)
			{
				if (!hasDriver)
				{
					val2 = rBody.velocity;
					if (((Vector3)(ref val2)).magnitude < 2.5f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f)
					{
						num11 = ((car.OnSurface != VehicleTerrainHandler.Surface.Frictionless) ? 1 : 0);
						goto IL_0412;
					}
				}
				num11 = 0;
			}
			else
			{
				num11 = 0;
			}
			goto IL_0412;
			IL_0412:
			bool flag2 = (byte)num11 != 0;
			bool flag3 = !vehicleSettings.disableHandbrakes && !flag2 && num2 == 0f && num < 0.2f && TimeSince.op_Implicit(car.timeSinceLastPush) > 2f && car.OnSurface != VehicleTerrainHandler.Surface.Frictionless;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData serverWheelData2 = wheelData[j];
				if (!((Collider)serverWheelData2.wheelCollider).enabled)
				{
					((Collider)serverWheelData2.wheelCollider).enabled = true;
					serverWheelData2.wheelCollider.ConfigureVehicleSubsteps(1000f, 1, 1);
				}
				serverWheelData2.wheelCollider.motorTorque = 1E-05f;
				if (flag2)
				{
					serverWheelData2.wheelCollider.brakeTorque = 10000f;
				}
				else if (flag3)
				{
					serverWheelData2.wheelCollider.brakeTorque = 1000f;
				}
				else
				{
					serverWheelData2.wheelCollider.brakeTorque = 0f;
				}
				if (serverWheelData2.wheel.steerWheel)
				{
					serverWheelData2.wheel.wheelCollider.steerAngle = (serverWheelData2.isFrontWheel ? SteerAngle : (vehicleSettings.rearWheelSteer * (0f - SteerAngle)));
				}
				UpdateSuspension(serverWheelData2);
				if (serverWheelData2.isGrounded)
				{
					num9++;
					num10 += wheelData[j].downforce;
				}
			}
			AdjustHitForces(num9, num10 / (float)num9);
			for (int k = 0; k < wheelData.Length; k++)
			{
				ServerWheelData wd = wheelData[k];
				UpdateLocalFrame(wd, dt);
				ComputeTyreForces(wd, speed, maxDriveForce, maxForwardSpeed, num2, brakeInput, num3);
				ApplyTyreForces(wd);
			}
			ComputeOverallForces();
			goto IL_05dd;
			IL_05ed:
			hadDriver = hasDriver;
			return;
			IL_05dd:
			wasSleeping = false;
			goto IL_05ed;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool IsGrounded()
	{
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].isGrounded)
			{
				num++;
			}
			if (num >= Mathf.FloorToInt((float)wheelData.Length * 0.5f))
			{
				return true;
			}
		}
		return false;
	}

	public bool IsWheelGrounded(int index)
	{
		if (index < 0 || index >= wheelData.Length)
		{
			return false;
		}
		return wheelData[index].isGrounded;
	}

	public bool HasHandbrake()
	{
		for (int i = 0; i < wheelData.Length; i++)
		{
			if (wheelData[i].wheelCollider.brakeTorque != 10000f)
			{
				return false;
			}
		}
		return true;
	}

	private void COMChanged()
	{
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			serverWheelData.forceDistance = GetWheelForceDistance(serverWheelData.wheel.wheelCollider);
		}
		prevLocalCOM = rBody.centerOfMass;
	}

	private void ComputeSteerAngle(float throttleInput, float steerInput, float dt, float speed)
	{
		if (vehicleSettings.tankSteering)
		{
			SteerAngle = 0f;
			ComputeTankSteeringThrottle(throttleInput, steerInput, speed);
			return;
		}
		float num = vehicleSettings.maxSteerAngle * steerInput;
		float num2 = Mathf.InverseLerp(0f, vehicleSettings.minSteerLimitSpeed, speed);
		if (vehicleSettings.steeringLimit)
		{
			float num3 = vehicleSettings.maxSteerAngle * car.GetSteerMaxMult(speed);
			float num4 = vehicleSettings.minSteerLimitAngle * car.GetSteerMaxMult(speed);
			float num5 = Mathf.Lerp(num3, num4, num2);
			num = Mathf.Clamp(num, 0f - num5, num5);
		}
		float num6 = 0f;
		if (vehicleSettings.steeringAssist)
		{
			float num7 = Mathf.InverseLerp(0.1f, 3f, speed);
			num6 = speedAngle * vehicleSettings.steeringAssistRatio * num7 * Mathf.InverseLerp(2f, 3f, Mathf.Abs(speedAngle));
		}
		float num8 = Mathf.Clamp(num + num6, 0f - vehicleSettings.maxSteerAngle, vehicleSettings.maxSteerAngle);
		if (SteerAngle == num8)
		{
			steerLerpSpeed = 0f;
			return;
		}
		float num9 = Mathf.Abs(SteerAngle / num8);
		float num10 = 1f - num2 * 0.7f;
		bool steerSpeedMod = car.GetSteerSpeedMod(speed);
		if ((SteerAngle == 0f || Mathf.Sign(num8) == Mathf.Sign(SteerAngle)) && Mathf.Abs(num8) > Mathf.Abs(SteerAngle))
		{
			float num11 = SteerAngle / vehicleSettings.maxSteerAngle;
			float num12 = vehicleSettings.steerMinLerpSpeed;
			if (steerSpeedMod)
			{
				num12 *= 1.8f;
			}
			float num13 = Mathf.Lerp(num12 * num10, vehicleSettings.steerMaxLerpSpeed * num10, num11 * num11);
			if (Mathf.Abs(num8) > Mathf.Abs(SteerAngle) && num9 > 0.85f)
			{
				num13 = Mathf.Lerp(num13, 0f, num9);
			}
			if (!vehicleSettings.retainLerpSpeed || num13 > steerLerpSpeed)
			{
				steerLerpSpeed = num13;
			}
		}
		else
		{
			float num14 = vehicleSettings.steerReturnLerpSpeed;
			if (num8 != 0f && Mathf.Sign(num8) != Mathf.Sign(SteerAngle))
			{
				num14 *= 1.33f;
			}
			if (steerSpeedMod)
			{
				num14 *= 1.5f;
			}
			steerLerpSpeed = num14 * num10;
		}
		if (steerSpeedMod)
		{
			steerLerpSpeed *= 1.2f;
		}
		SteerAngle = Mathf.MoveTowards(SteerAngle, num8, dt * steerLerpSpeed);
	}

	private float GetWheelForceDistance(WheelCollider col)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		return rBody.centerOfMass.y - transform.InverseTransformPoint(((Component)col).transform.position).y + col.radius + (1f - col.suspensionSpring.targetPosition) * col.suspensionDistance;
	}

	private void UpdateSuspension(ServerWheelData wd)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		wd.isGrounded = wd.wheelCollider.GetGroundHit(ref wd.hit);
		wd.origin = wd.wheelColliderTransform.TransformPoint(wd.wheelCollider.center);
		if (wd.isGrounded && GamePhysics.Trace(new Ray(wd.origin, -wd.wheelColliderTransform.up), 0f, out var hitInfo, wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius, 1235321089, (QueryTriggerInteraction)1))
		{
			((WheelHit)(ref wd.hit)).point = ((RaycastHit)(ref hitInfo)).point;
			((WheelHit)(ref wd.hit)).normal = ((RaycastHit)(ref hitInfo)).normal;
		}
		if (wd.isGrounded)
		{
			if (((WheelHit)(ref wd.hit)).force < 0f)
			{
				((WheelHit)(ref wd.hit)).force = 0f;
			}
			wd.downforce = ((WheelHit)(ref wd.hit)).force;
		}
		else
		{
			wd.downforce = 0f;
		}
	}

	private void AdjustHitForces(int groundedWheels, float neutralForcePerWheel)
	{
		float num = neutralForcePerWheel * 0.25f;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (!serverWheelData.isGrounded || !(serverWheelData.downforce < num))
			{
				continue;
			}
			if (groundedWheels == 1)
			{
				serverWheelData.downforce = num;
				continue;
			}
			float num2 = (num - serverWheelData.downforce) / (float)(groundedWheels - 1);
			serverWheelData.downforce = num;
			for (int j = 0; j < wheelData.Length; j++)
			{
				ServerWheelData serverWheelData2 = wheelData[j];
				if (serverWheelData2.isGrounded && serverWheelData2.downforce > num)
				{
					float num3 = Mathf.Min(num2, serverWheelData2.downforce - num);
					serverWheelData2.downforce -= num3;
				}
			}
		}
	}

	private void UpdateLocalFrame(ServerWheelData wd, float dt)
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0203: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_0172: Unknown result type (might be due to invalid IL or missing references)
		//IL_0177: Unknown result type (might be due to invalid IL or missing references)
		//IL_0137: Unknown result type (might be due to invalid IL or missing references)
		//IL_0142: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015a: Unknown result type (might be due to invalid IL or missing references)
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0164: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		if (!wd.isGrounded)
		{
			((WheelHit)(ref wd.hit)).point = wd.origin - wd.wheelColliderTransform.up * (wd.wheelCollider.suspensionDistance + wd.wheelCollider.radius);
			((WheelHit)(ref wd.hit)).normal = wd.wheelColliderTransform.up;
			((WheelHit)(ref wd.hit)).collider = null;
		}
		Vector3 pointVelocity = rBody.GetPointVelocity(((WheelHit)(ref wd.hit)).point);
		wd.velocity = pointVelocity - Vector3.Project(pointVelocity, ((WheelHit)(ref wd.hit)).normal);
		wd.localVelocity.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, wd.velocity);
		wd.localVelocity.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, wd.velocity);
		if (!wd.isGrounded)
		{
			wd.localRigForce = Vector2.zero;
			return;
		}
		float num = Mathf.InverseLerp(1f, 0.25f, ((Vector3)(ref wd.velocity)).sqrMagnitude);
		Vector2 val3 = default(Vector2);
		if (num > 0f)
		{
			float num2 = Vector3.Dot(Vector3.up, ((WheelHit)(ref wd.hit)).normal);
			Vector3 val2;
			if (num2 > 1E-06f)
			{
				Vector3 val = Vector3.up * wd.downforce / num2;
				val2 = val - Vector3.Project(val, ((WheelHit)(ref wd.hit)).normal);
			}
			else
			{
				val2 = Vector3.up * 100000f;
			}
			val3.y = Vector3.Dot(((WheelHit)(ref wd.hit)).forwardDir, val2);
			val3.x = Vector3.Dot(((WheelHit)(ref wd.hit)).sidewaysDir, val2);
			val3 *= num;
		}
		else
		{
			val3 = Vector2.zero;
		}
		Vector2 val4 = (0f - Mathf.Clamp(wd.downforce / (0f - Physics.gravity.y), 0f, wd.wheelCollider.sprungMass) * 0.5f) * wd.localVelocity / dt;
		wd.localRigForce = val4 + val3;
	}

	private void ComputeTyreForces(ServerWheelData wd, float speed, float maxDriveForce, float maxSpeed, float throttleInput, float brakeInput, float driveForceMultiplier)
	{
		//IL_0388: Unknown result type (might be due to invalid IL or missing references)
		//IL_038d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0393: Unknown result type (might be due to invalid IL or missing references)
		//IL_0398: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0311: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_036c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0374: Unknown result type (might be due to invalid IL or missing references)
		//IL_0332: Unknown result type (might be due to invalid IL or missing references)
		float absSpeed = Mathf.Abs(speed);
		if (vehicleSettings.tankSteering && brakeInput == 0f)
		{
			throttleInput = ((!wd.isLeftWheel) ? TankThrottleRight : TankThrottleLeft);
		}
		float num = (wd.wheel.powerWheel ? throttleInput : 0f);
		wd.hasThrottleInput = num != 0f;
		float num2 = vehicleSettings.maxDriveSlip;
		if (Mathf.Sign(num) != Mathf.Sign(wd.localVelocity.y))
		{
			num2 -= wd.localVelocity.y * Mathf.Sign(num);
		}
		float num3 = Mathf.Abs(num);
		float num4 = 0f - vehicleSettings.rollingResistance + num3 * (1f + vehicleSettings.rollingResistance) - brakeInput * (1f - vehicleSettings.rollingResistance);
		if (InSlowSpeedExitMode || num4 < 0f || maxDriveForce == 0f)
		{
			num4 *= -1f;
			wd.isBraking = true;
		}
		else
		{
			num4 *= Mathf.Sign(num);
			wd.isBraking = false;
		}
		float num6;
		if (wd.isBraking)
		{
			float num5 = Mathf.Clamp(car.GetMaxForwardSpeed() * vehicleSettings.brakeForceMultiplier, 10f * vehicleSettings.brakeForceMultiplier, 50f * vehicleSettings.brakeForceMultiplier);
			num5 += rBody.mass * 1.5f;
			num6 = num4 * num5;
		}
		else
		{
			num6 = ComputeDriveForce(speed, absSpeed, num4 * maxDriveForce, maxDriveForce, maxSpeed, driveForceMultiplier);
		}
		if (wd.isGrounded)
		{
			wd.tyreSlip.x = wd.localVelocity.x;
			wd.tyreSlip.y = wd.localVelocity.y - wd.angularVelocity * wd.wheelCollider.radius;
			float num7 = car.OnSurface switch
			{
				VehicleTerrainHandler.Surface.Road => 1f, 
				VehicleTerrainHandler.Surface.Ice => 0.25f, 
				VehicleTerrainHandler.Surface.Frictionless => 0f, 
				_ => 0.75f, 
			};
			float num8 = wd.wheel.tyreFriction * wd.downforce * num7;
			float num9 = 0f;
			if (!wd.isBraking)
			{
				num9 = Mathf.Min(Mathf.Abs(num6 * wd.tyreSlip.x) / num8, num2);
				if (num6 != 0f && num9 < 0.1f)
				{
					num9 = 0.1f;
				}
			}
			if (Mathf.Abs(wd.tyreSlip.y) < num9)
			{
				wd.tyreSlip.y = num9 * Mathf.Sign(wd.tyreSlip.y);
			}
			Vector2 val = (0f - num8) * ((Vector2)(ref wd.tyreSlip)).normalized;
			val.x = Mathf.Abs(val.x) * 1.5f;
			val.y = Mathf.Abs(val.y);
			wd.tyreForce.x = Mathf.Clamp(wd.localRigForce.x, 0f - val.x, val.x);
			if (wd.isBraking)
			{
				float num10 = Mathf.Min(val.y, num6);
				wd.tyreForce.y = Mathf.Clamp(wd.localRigForce.y, 0f - num10, num10);
			}
			else
			{
				wd.tyreForce.y = Mathf.Clamp(num6, 0f - val.y, val.y);
			}
		}
		else
		{
			wd.tyreSlip = Vector2.zero;
			wd.tyreForce = Vector2.zero;
		}
		if (wd.isGrounded)
		{
			float num11;
			if (wd.isBraking)
			{
				num11 = 0f;
			}
			else
			{
				float driveForceToMaxSlip = vehicleSettings.driveForceToMaxSlip;
				num11 = Mathf.Clamp01((Mathf.Abs(num6) - Mathf.Abs(wd.tyreForce.y)) / driveForceToMaxSlip) * num2 * Mathf.Sign(num6);
			}
			wd.angularVelocity = (wd.localVelocity.y + num11) / wd.wheelCollider.radius;
			return;
		}
		float num12 = 50f;
		float num13 = 10f;
		if (num > 0f)
		{
			wd.angularVelocity += num12 * num;
		}
		else
		{
			wd.angularVelocity -= num13;
		}
		wd.angularVelocity -= num12 * brakeInput;
		wd.angularVelocity = Mathf.Clamp(wd.angularVelocity, 0f, maxSpeed / wd.wheelCollider.radius);
	}

	private void ComputeTankSteeringThrottle(float throttleInput, float steerInput, float speed)
	{
		TankThrottleLeft = throttleInput;
		TankThrottleRight = throttleInput;
		float tankSteerInvert = GetTankSteerInvert(throttleInput, speed);
		if (throttleInput == 0f)
		{
			TankThrottleLeft = 0f - steerInput;
			TankThrottleRight = steerInput;
		}
		else if (steerInput > 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, steerInput);
		}
		else if (steerInput < 0f)
		{
			TankThrottleLeft = Mathf.Lerp(throttleInput, 1f * tankSteerInvert, 0f - steerInput);
			TankThrottleRight = Mathf.Lerp(throttleInput, -1f * tankSteerInvert, 0f - steerInput);
		}
	}

	private float ComputeDriveForce(float speed, float absSpeed, float demandedForce, float maxForce, float maxForwardSpeed, float driveForceMultiplier)
	{
		float num = ((speed >= 0f) ? maxForwardSpeed : (maxForwardSpeed * vehicleSettings.reversePercentSpeed));
		if (absSpeed < num)
		{
			if ((speed >= 0f || demandedForce <= 0f) && (speed <= 0f || demandedForce >= 0f))
			{
				maxForce = car.GetAdjustedDriveForce(absSpeed, maxForwardSpeed) * driveForceMultiplier;
			}
			return Mathf.Clamp(demandedForce, 0f - maxForce, maxForce);
		}
		float num2 = maxForce * Mathf.Max(1f - absSpeed / num, -1f) * Mathf.Sign(speed);
		if ((speed < 0f && demandedForce > 0f) || (speed > 0f && demandedForce < 0f))
		{
			num2 = Mathf.Clamp(num2 + demandedForce, 0f - maxForce, maxForce);
		}
		return num2;
	}

	private void ComputeOverallForces()
	{
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		DriveWheelVelocity = 0f;
		DriveWheelSlip = 0f;
		int num = 0;
		for (int i = 0; i < wheelData.Length; i++)
		{
			ServerWheelData serverWheelData = wheelData[i];
			if (serverWheelData.wheel.powerWheel)
			{
				DriveWheelVelocity += serverWheelData.angularVelocity;
				if (serverWheelData.isGrounded)
				{
					float num2 = ComputeCombinedSlip(serverWheelData.localVelocity, serverWheelData.tyreSlip);
					DriveWheelSlip += num2;
				}
				num++;
			}
		}
		if (num > 0)
		{
			DriveWheelVelocity /= num;
			DriveWheelSlip /= num;
		}
	}

	private static float ComputeCombinedSlip(Vector2 localVelocity, Vector2 tyreSlip)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float magnitude = ((Vector2)(ref localVelocity)).magnitude;
		if (magnitude > 0.01f)
		{
			float num = tyreSlip.x * localVelocity.x / magnitude;
			float y = tyreSlip.y;
			return Mathf.Sqrt(num * num + y * y);
		}
		return ((Vector2)(ref tyreSlip)).magnitude;
	}

	private void ApplyTyreForces(ServerWheelData wd)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		if (wd.isGrounded)
		{
			Vector3 val = ((WheelHit)(ref wd.hit)).forwardDir * wd.tyreForce.y;
			Vector3 val2 = ((WheelHit)(ref wd.hit)).sidewaysDir * wd.tyreForce.x;
			Vector3 sidewaysForceAppPoint = GetSidewaysForceAppPoint(wd, ((WheelHit)(ref wd.hit)).point);
			rBody.AddForceAtPosition(val, ((WheelHit)(ref wd.hit)).point, (ForceMode)0);
			rBody.AddForceAtPosition(val2, sidewaysForceAppPoint, (ForceMode)0);
		}
	}

	private Vector3 GetSidewaysForceAppPoint(ServerWheelData wd, Vector3 contactPoint)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = contactPoint + wd.wheelColliderTransform.up * vehicleSettings.antiRoll * wd.forceDistance;
		float num = (wd.wheel.steerWheel ? SteerAngle : 0f);
		if (num != 0f && Mathf.Sign(num) != Mathf.Sign(wd.tyreSlip.x))
		{
			val += wd.wheelColliderTransform.forward * midWheelPos * (vehicleSettings.handlingBias - 0.5f);
		}
		return val;
	}

	private float GetTankSteerInvert(float throttleInput, float speed)
	{
		float result = 1f;
		if (throttleInput < 0f && speed < 1.75f)
		{
			result = -1f;
		}
		else if (throttleInput == 0f && speed < -1f)
		{
			result = -1f;
		}
		else if (speed < -1f)
		{
			result = -1f;
		}
		return result;
	}
}


public interface ICar
{
	VehicleTerrainHandler.Surface OnSurface { get; }

	float GetThrottleInput();

	float GetBrakeInput();

	float GetSteerInput();

	bool GetSteerSpeedMod(float speed);

	float GetSteerMaxMult(float speed);

	float GetMaxForwardSpeed();

	float GetMaxDriveForce();

	float GetAdjustedDriveForce(float absSpeed, float topSpeed);

	float GetModifiedDrag();

	CarWheel[] GetWheels();

	float GetWheelsMidPos();
}


using UnityEngine;

private class ServerWheelData
{
	public CarWheel wheel;

	public Transform wheelColliderTransform;

	public WheelCollider wheelCollider;

	public bool isGrounded;

	public float downforce;

	public float forceDistance;

	public WheelHit hit;

	public Vector2 localRigForce;

	public Vector2 localVelocity;

	public float angularVelocity;

	public Vector3 origin;

	public Vector2 tyreForce;

	public Vector2 tyreSlip;

	public Vector3 velocity;

	public bool isBraking;

	public bool hasThrottleInput;

	public bool isFrontWheel;

	public bool isLeftWheel;
}


using UnityEngine;

public class CrushTrigger : TriggerHurt
{
	public bool includeNPCs = true;

	public bool requireCentreBelowPosition;

	internal override GameObject InterestedInObject(GameObject obj)
	{
		obj = base.InterestedInObject(obj);
		if ((Object)(object)obj == (Object)null)
		{
			return null;
		}
		BaseEntity baseEntity = obj.ToBaseEntity();
		if ((Object)(object)baseEntity == (Object)null)
		{
			return null;
		}
		if (baseEntity.isClient)
		{
			return null;
		}
		if (!includeNPCs && baseEntity.IsNpc)
		{
			return null;
		}
		return ((Component)baseEntity).gameObject;
	}

	protected override bool CanHurt(BaseCombatEntity ent)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		if (requireCentreBelowPosition && ent.CenterPoint().y > ((Component)this).transform.position.y)
		{
			return false;
		}
		return base.CanHurt(ent);
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class DamageRenderer : MonoBehaviour, IClientComponent
{
	[Serializable]
	private struct DamageShowingRenderer
	{
		public Renderer renderer;

		public int[] indices;

		public DamageShowingRenderer(Renderer renderer, int[] indices)
		{
			this.renderer = renderer;
			this.indices = indices;
		}
	}

	[SerializeField]
	private List<Material> damageShowingMats;

	[SerializeField]
	private float maxDamageOpacity = 0.9f;

	[SerializeField]
	[HideInInspector]
	private List<DamageShowingRenderer> damageShowingRenderers;

	[SerializeField]
	[HideInInspector]
	private List<GlassPane> damageShowingGlassRenderers;
}


using System;
using UnityEngine;

[Serializable]
private struct DamageShowingRenderer
{
	public Renderer renderer;

	public int[] indices;

	public DamageShowingRenderer(Renderer renderer, int[] indices)
	{
		this.renderer = renderer;
		this.indices = indices;
	}
}


using UnityEngine;

public class DiverPropulsionVehicleAudio : MonoBehaviour
{
	[SerializeField]
	[Header("Engine")]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	private SoundDefinition engineLoopSound;

	[SerializeField]
	private AnimationCurve engineLoopPitchCurve;

	[SerializeField]
	private SoundDefinition engineActiveLoopDef;

	[Header("Propeller")]
	[SerializeField]
	private SoundDefinition propellerLoopSoundDef;

	[SerializeField]
	private AnimationCurve propellerPitchCurve;

	[SerializeField]
	private AnimationCurve propellerGainCurve;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition waterMovementLoopDef;

	[SerializeField]
	private AnimationCurve waterMovementGainCurve;

	[SerializeField]
	private SoundDefinition waterSurfaceLoopDef;

	[SerializeField]
	private float surfaceWaterMovementStartDepth = 0.2f;

	[SerializeField]
	private float surfaceWaterMovementEndDepth = 2f;

	[SerializeField]
	private float waterMovementYSpeedScale = 0.2f;

	[SerializeField]
	private SoundDefinition waterEmergeSoundDef;

	[SerializeField]
	private SoundDefinition waterSubmergeSoundDef;
}


using System;
using System.Collections.Generic;
using Rust;
using UnityEngine;

public abstract class GroundVehicle : BaseVehicle, IEngineControllerUser, IEntity, TriggerHurtNotChild.IHurtTriggerUser
{
	[Header("GroundVehicle")]
	[SerializeField]
	public GroundVehicleAudio gvAudio;

	[SerializeField]
	private GameObjectRef fuelStoragePrefab;

	[SerializeField]
	public Transform waterloggedPoint;

	[SerializeField]
	public GameObjectRef collisionEffect;

	[SerializeField]
	public float engineStartupTime = 0.5f;

	[SerializeField]
	private float minCollisionDamageForce = 20000f;

	[SerializeField]
	private float maxCollisionDamageForce = 2500000f;

	[SerializeField]
	private float collisionDamageMultiplier = 1f;

	[SerializeField]
	private Rigidbody secondaryRigidbody;

	public VehicleEngineController<GroundVehicle> engineController;

	private Dictionary<BaseEntity, float> damageSinceLastTick = new Dictionary<BaseEntity, float>();

	private float nextCollisionDamageTime;

	private float dragMod;

	private float dragModDuration;

	private TimeSince timeSinceDragModSet;

	public Vector3 Velocity { get; protected set; }

	public abstract float DriveWheelVelocity { get; }

	public bool LightsAreOn => HasFlag(Flags.Reserved5);

	public VehicleEngineController<GroundVehicle>.EngineState CurEngineState => engineController.CurEngineState;

	public override void InitShared()
	{
		base.InitShared();
		CreateEngineController();
	}

	protected virtual void CreateEngineController()
	{
		engineController = new VehicleEngineController<GroundVehicle>(this, CreateFuelSystem(), base.isServer, engineStartupTime, waterloggedPoint);
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (old != next && base.isServer)
		{
			ServerFlagsChanged(old, next);
		}
	}

	public override float GetSpeed()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		if (IsStationary())
		{
			return 0f;
		}
		return Vector3.Dot(Velocity, ((Component)this).transform.forward);
	}

	public abstract float GetMaxForwardSpeed();

	public abstract float GetThrottleInput();

	public abstract float GetBrakeInput();

	protected override bool CanPushNow(BasePlayer pusher)
	{
		if (!base.CanPushNow(pusher))
		{
			return false;
		}
		if (pusher.isMounted || pusher.IsSwimming())
		{
			return false;
		}
		return !pusher.IsStandingOnEntity(this, 8192);
	}

	protected virtual IFuelSystem CreateFuelSystem()
	{
		return new EntityFuelSystem(base.isServer, fuelStoragePrefab, children);
	}

	public override void ServerInit()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		timeSinceDragModSet = default(TimeSince);
		timeSinceDragModSet = TimeSince.op_Implicit(float.MaxValue);
	}

	public abstract void OnEngineStartFailed();

	public abstract bool MeetsEngineRequirements();

	protected virtual void ServerFlagsChanged(Flags old, Flags next)
	{
	}

	protected void OnCollisionEnter(Collision collision)
	{
		if (base.isServer)
		{
			ProcessCollision(collision, rigidBody);
		}
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GroundVehicle.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (base.IsMovingOrOn)
			{
				Velocity = GetLocalVelocity();
			}
			else
			{
				Velocity = Vector3.zero;
			}
			if (LightsAreOn && !AnyMounted())
			{
				SetFlag(Flags.Reserved5, b: false);
			}
			if (!(Time.time >= nextCollisionDamageTime))
			{
				return;
			}
			nextCollisionDamageTime = Time.time + 0.33f;
			foreach (KeyValuePair<BaseEntity, float> item in damageSinceLastTick)
			{
				DoCollisionDamage(item.Key, item.Value);
			}
			damageSinceLastTick.Clear();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !LightsAreOn);
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return Mathf.Abs(GetSpeed()) * 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		if (!base.isClient && !hurtEntity.IsDestroyed)
		{
			Vector3 val = hurtEntity.GetLocalVelocity() - Velocity;
			Vector3 val2 = ClosestPoint(((Component)hurtEntity).transform.position);
			Vector3 val3 = Mathf.Min(hurtEntity.RealisticMass, RealisticMass) * val;
			rigidBody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			if ((Object)(object)secondaryRigidbody != (Object)null)
			{
				secondaryRigidbody.AddForceAtPosition(val3 * 1.25f, val2, (ForceMode)1);
			}
			QueueCollisionDamage(this, ((Vector3)(ref val3)).magnitude * 0.1f / Time.deltaTime);
			SetTempDrag(2.25f, 1f);
		}
	}

	private float QueueCollisionDamage(BaseEntity hitEntity, float forceMagnitude)
	{
		float num = Mathf.InverseLerp(minCollisionDamageForce, maxCollisionDamageForce, forceMagnitude);
		if (num > 0f)
		{
			float num2 = Mathf.Lerp(1f, 200f, num) * collisionDamageMultiplier;
			if (damageSinceLastTick.TryGetValue(hitEntity, out var value))
			{
				if (value < num2)
				{
					damageSinceLastTick[hitEntity] = num2;
				}
			}
			else
			{
				damageSinceLastTick[hitEntity] = num2;
			}
		}
		return num;
	}

	protected virtual void DoCollisionDamage(BaseEntity hitEntity, float damage)
	{
		Hurt(damage, DamageType.Collision, this, useProtection: false);
	}

	protected virtual void ProcessCollision(Collision collision, Rigidbody ourRigidbody)
	{
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || collision == null || (Object)(object)collision.gameObject == (Object)null || (Object)(object)collision.gameObject == (Object)null)
		{
			return;
		}
		ContactPoint contact = collision.GetContact(0);
		BaseEntity baseEntity = null;
		if ((Object)(object)((ContactPoint)(ref contact)).otherCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).otherCollider.ToBaseEntity();
		}
		else if ((Object)(object)((ContactPoint)(ref contact)).thisCollider.attachedRigidbody == (Object)(object)ourRigidbody)
		{
			baseEntity = ((ContactPoint)(ref contact)).thisCollider.ToBaseEntity();
		}
		if ((Object)(object)baseEntity != (Object)null)
		{
			Vector3 impulse = collision.impulse;
			impulse.y *= 0.5f;
			float num = ((Vector3)(ref impulse)).magnitude / Time.fixedDeltaTime;
			if (collision.gameObject.ToBaseEntity() is RidableHorse)
			{
				num *= 0.5f;
			}
			if (QueueCollisionDamage(baseEntity, num) > 0f)
			{
				TryShowCollisionFX(collision);
			}
		}
	}

	public override GameObjectRef GetCollisionFX()
	{
		return collisionEffect;
	}

	public virtual float GetModifiedDrag()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return (1f - Mathf.InverseLerp(0f, dragModDuration, TimeSince.op_Implicit(timeSinceDragModSet))) * dragMod;
	}

	public override IFuelSystem GetFuelSystem()
	{
		return engineController?.FuelSystem;
	}

	protected override void OnChildAdded(BaseEntity child)
	{
		base.OnChildAdded(child);
		if (base.isServer && isSpawned)
		{
			GetFuelSystem()?.CheckNewChild(child);
		}
	}

	private void SetTempDrag(float drag, float duration)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		dragMod = Mathf.Clamp(drag, 0f, 1000f);
		timeSinceDragModSet = TimeSince.op_Implicit(0f);
		dragModDuration = duration;
	}

	void IEngineControllerUser.Invoke(Action action, float time)
	{
		((FacepunchBehaviour)this).Invoke(action, time);
	}

	void IEngineControllerUser.CancelInvoke(Action action)
	{
		((FacepunchBehaviour)this).CancelInvoke(action);
	}
}


using UnityEngine;

public abstract class GroundVehicleAudio : MonoBehaviour, IClientComponent
{
	[SerializeField]
	protected GroundVehicle groundVehicle;

	[Header("Engine")]
	[SerializeField]
	private SoundDefinition engineStartSound;

	[SerializeField]
	private SoundDefinition engineStopSound;

	[SerializeField]
	private SoundDefinition engineStartFailSound;

	[SerializeField]
	protected BlendedLoopEngineSound blendedEngineLoops;

	[SerializeField]
	private float wheelRatioMultiplier = 600f;

	[SerializeField]
	private float overallVolume = 1f;

	[SerializeField]
	[Header("Water")]
	private SoundDefinition waterSplashSoundDef;

	[SerializeField]
	private BlendedSoundLoops waterLoops;

	[SerializeField]
	private float waterSoundsMaxSpeed = 10f;

	[SerializeField]
	[Header("Brakes")]
	private SoundDefinition brakeSoundDef;

	[SerializeField]
	private SoundDefinition brakeStartSoundDef;

	[SerializeField]
	private SoundDefinition brakeStopSoundDef;

	[Header("Lights")]
	[SerializeField]
	protected SoundDefinition lightsToggleSound;
}


using UnityEngine;

public class AttackHeliDriverSeat : BaseVehicleSeat
{
	[SerializeField]
	private Sprite rocketCrosshair;

	[SerializeField]
	private Sprite incendRocketCrosshair;

	[SerializeField]
	private Sprite hvRocketCrosshair;

	[SerializeField]
	private Sprite reloadingCrosshair;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}
}


using UnityEngine;

public class AttackHeliGunnerSeat : BaseVehicleSeat
{
	private AttackHelicopter _owner;

	private AttackHelicopter Owner
	{
		get
		{
			if ((Object)(object)_owner == (Object)null)
			{
				_owner = ((Component)this).GetComponentInParent<AttackHelicopter>();
			}
			return _owner;
		}
	}

	public override bool CanHoldItems()
	{
		if ((Object)(object)Owner != (Object)null)
		{
			return !Owner.GunnerIsInGunnerView;
		}
		return false;
	}

	public override Transform GetEyeOverride()
	{
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.gunnerEyePos;
		}
		return base.GetEyeOverride();
	}

	public override Vector3 EyePositionForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector3 EyeCenterForPlayer(BasePlayer player, Quaternion lookRot)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)player.GetMounted() != (Object)(object)this)
		{
			return Vector3.zero;
		}
		return GetEyeOverride().position;
	}

	public override Vector2 GetPitchClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretPitchClamp;
		}
		return pitchClamp;
	}

	public override Vector2 GetYawClamp()
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)Owner != (Object)null && Owner.GunnerIsInGunnerView)
		{
			return Owner.turretYawClamp;
		}
		return yawClamp;
	}
}


using Oxide.Core;
using UnityEngine;

[RequireComponent(typeof(Rigidbody))]
public class AttackHeliPilotFlare : MonoBehaviour, SeekerTarget.ISeekerTargetOwner
{
	protected void Start()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.HIGH);
	}

	protected void OnDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
	}

	public void Init(Vector3 initialVelocity)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		((Component)this).GetComponent<Rigidbody>().velocity = initialVelocity;
	}

	public Vector3 CenterPoint()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public bool IsVisible(Vector3 from, float maxDistance = float.PositiveInfinity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.LineOfSight(from, CenterPoint(), 1218519041);
	}

	public bool InSafeZone()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return GamePhysics.CheckSphere<TriggerSafeZone>(CenterPoint(), 0.1f, 262144, (QueryTriggerInteraction)2);
	}

	public bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public void OnEntityMessage(BaseEntity from, string msg)
	{
	}
}


using Rust.UI;
using UnityEngine;

public class AttackHeliUIDialog : UIDialog
{
	[SerializeField]
	[Header("Attack Helicopter")]
	private Material compassStripMat;

	[SerializeField]
	private Canvas mainCanvas;

	[SerializeField]
	private CanvasGroup gunCrosshair;

	[SerializeField]
	private CanvasGroup gunNoAmmoCrosshair;

	[SerializeField]
	private CanvasGroup gunCrosshairGhost;

	[SerializeField]
	private RectTransform gunCrosshairGhostRect;

	[SerializeField]
	private Canvas rocketCrosshairDefaultCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairDefaultRect;

	[SerializeField]
	private Canvas rocketCrosshairHVCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairHVRect;

	[SerializeField]
	private Canvas rocketCrosshairIncenCanvas;

	[SerializeField]
	private RectTransform rocketCrosshairIncenRect;

	[SerializeField]
	private GameObjectRef rocketHVItem;

	[SerializeField]
	private GameObjectRef rocketIncenItem;

	[SerializeField]
	private CanvasGroup crosshairHitMarkerGroup;

	[SerializeField]
	private RectTransform zoomIndicator;

	[SerializeField]
	private RectTransform positionBox;

	[SerializeField]
	private RustText ammoTextGunMag;

	[SerializeField]
	private RustText ammoTextGunRest;

	[SerializeField]
	private RustText ammoTextRocketMag;

	[SerializeField]
	private RustText ammoTextRocketRest;

	[SerializeField]
	private RustText rangeText;

	[SerializeField]
	private float zoomIndicatorMinY;

	[SerializeField]
	private float zoomIndicatorMaxY;

	[SerializeField]
	private float positionBoxXMult;

	[SerializeField]
	private float positionBoxYMult;

	[SerializeField]
	private Animator damageWarning;
}


using System;
using System.Collections.Generic;
using Oxide.Core;
using Rust;
using UnityEngine;

public abstract class BaseHelicopter : BaseVehicle, SeekerTarget.ISeekerTargetOwner
{
	[Serializable]
	protected class GroundEffect
	{
		public ParticleSystem effect;

		public Transform groundPoint;
	}

	public class HelicopterInputState
	{
		public float throttle;

		public float roll;

		public float yaw;

		public float pitch;

		public bool groundControl;

		public void Reset()
		{
			throttle = 0f;
			roll = 0f;
			yaw = 0f;
			pitch = 0f;
			groundControl = false;
		}
	}

	[Header("Helicopter")]
	[SerializeField]
	public float engineThrustMax;

	[SerializeField]
	public Vector3 torqueScale;

	[SerializeField]
	protected Transform com;

	[SerializeField]
	public GameObject[] killTriggers;

	[SerializeField]
	protected GroundEffect[] groundEffects;

	[SerializeField]
	public GameObjectRef serverGibs;

	[SerializeField]
	public GameObjectRef explosionEffect;

	[SerializeField]
	public GameObjectRef fireBall;

	[SerializeField]
	public GameObjectRef crashEffect;

	[Range(0.1f, 0.95f)]
	[SerializeField]
	[Tooltip("Lower values mean more lift is produced at high angles.")]
	public float liftDotMax = 0.75f;

	[SerializeField]
	[Range(0.1f, 0.95f)]
	public float altForceDotMin = 0.85f;

	[SerializeField]
	[Range(0.1f, 0.95f)]
	public float liftFraction = 0.25f;

	[SerializeField]
	public float thrustLerpSpeed = 1f;

	public const Flags Flag_InternalLights = Flags.Reserved6;

	public float currentThrottle;

	public float avgThrust;

	public float avgTerrainHeight;

	public HelicopterInputState currentInputState = new HelicopterInputState();

	public float lastPlayerInputTime;

	public float hoverForceScale = 0.99f;

	public Vector3 damageTorque;

	public float nextDamageTime;

	public float nextEffectTime;

	public float pendingImpactDamage;

	public bool autoHover { get; set; }

	public virtual bool ForceMovementHandling => false;

	public virtual float GetServiceCeiling()
	{
		return 1000f;
	}

	public virtual float GetMinimumAltitudeTerrain()
	{
		return 0f;
	}

	public override float MaxVelocity()
	{
		return 50f;
	}

	public override void ServerInit()
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.centerOfMass = com.localPosition;
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.MEDIUM);
	}

	internal override void DoServerDestroy()
	{
		SeekerTarget.SetSeekerTarget(this, SeekerTarget.SeekerStrength.OFF);
		base.DoServerDestroy();
	}

	public override void PlayerServerInput(InputState inputState, BasePlayer player)
	{
		if (IsDriver(player))
		{
			if (!autoHover)
			{
				PilotInput(inputState, player);
			}
		}
		else
		{
			PassengerInput(inputState, player);
		}
	}

	public bool ToggleAutoHover(BasePlayer player)
	{
		autoHover = !autoHover;
		if (autoHover && !IsEngineOn())
		{
			TryStartEngine(player);
		}
		return autoHover;
	}

	public virtual void PilotInput(InputState inputState, BasePlayer player)
	{
		currentInputState.Reset();
		currentInputState.throttle = (inputState.IsDown(BUTTON.FORWARD) ? 1f : 0f);
		currentInputState.throttle -= ((inputState.IsDown(BUTTON.BACKWARD) || inputState.IsDown(BUTTON.DUCK)) ? 1f : 0f);
		currentInputState.pitch = inputState.current.mouseDelta.y;
		currentInputState.roll = 0f - inputState.current.mouseDelta.x;
		currentInputState.yaw = (inputState.IsDown(BUTTON.RIGHT) ? 1f : 0f);
		currentInputState.yaw -= (inputState.IsDown(BUTTON.LEFT) ? 1f : 0f);
		currentInputState.pitch = MouseToBinary(currentInputState.pitch);
		currentInputState.roll = MouseToBinary(currentInputState.roll);
		lastPlayerInputTime = Time.time;
		static float MouseToBinary(float amount)
		{
			return Mathf.Clamp(amount, -1f, 1f);
		}
	}

	public virtual void PassengerInput(InputState inputState, BasePlayer player)
	{
	}

	public virtual void SetDefaultInputState()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		if (HasDriver())
		{
			float num = Vector3.Dot(Vector3.up, ((Component)this).transform.right);
			float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
			currentInputState.roll = ((num < 0f) ? 1f : 0f);
			currentInputState.roll -= ((num > 0f) ? 1f : 0f);
			if (num2 < -0f)
			{
				currentInputState.pitch = -1f;
			}
			else if (num2 > 0f)
			{
				currentInputState.pitch = 1f;
			}
		}
		else
		{
			currentInputState.throttle = -1f;
		}
	}

	public virtual bool IsEnginePowered()
	{
		return true;
	}

	public override void VehicleFixedUpdate()
	{
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("BaseHelicopter.VehicleFixedUpdate", 0);
		try
		{
			base.VehicleFixedUpdate();
			if (Time.time > lastPlayerInputTime + 0.5f)
			{
				SetDefaultInputState();
			}
			EnableGlobalBroadcast(IsEngineOn());
			if (IsEngineOn() || ForceMovementHandling)
			{
				MovementUpdate();
			}
			else if (!HasDriver() && TimeSince.op_Implicit(timeSinceLastPush) > 2f)
			{
				ApplyHandbrake();
			}
			SetFlag(Flags.Reserved6, TOD_Sky.Instance.IsNight);
			GameObject[] array = killTriggers;
			foreach (GameObject obj in array)
			{
				bool active = rigidBody.velocity.y < 0f;
				obj.SetActive(active);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void LightToggle(BasePlayer player)
	{
		if (IsDriver(player))
		{
			SetFlag(Flags.Reserved5, !HasFlag(Flags.Reserved5));
		}
	}

	public virtual bool IsEngineOn()
	{
		return true;
	}

	protected virtual void TryStartEngine(BasePlayer player)
	{
	}

	protected abstract void ApplyHandbrake();

	public void ClearDamageTorque()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		SetDamageTorque(Vector3.zero);
	}

	public void SetDamageTorque(Vector3 newTorque)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		damageTorque = newTorque;
	}

	public void AddDamageTorque(Vector3 torqueToAdd)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		damageTorque += torqueToAdd;
	}

	public virtual void MovementUpdate()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01db: Unknown result type (might be due to invalid IL or missing references)
		//IL_0225: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0260: Unknown result type (might be due to invalid IL or missing references)
		//IL_026b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0276: Unknown result type (might be due to invalid IL or missing references)
		//IL_027c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0281: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		//IL_028e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0293: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_029c: Unknown result type (might be due to invalid IL or missing references)
		//IL_02a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_02be: Unknown result type (might be due to invalid IL or missing references)
		//IL_02cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_02f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_02fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_030e: Unknown result type (might be due to invalid IL or missing references)
		//IL_031c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		HelicopterInputState helicopterInputState = currentInputState;
		if (autoHover)
		{
			float num = 50f - ((Component)this).transform.position.y;
			helicopterInputState.throttle = Mathf.Clamp(num * 0.01f, -1f, 1f);
			helicopterInputState.pitch = 0f;
			helicopterInputState.roll = 0f;
			helicopterInputState.yaw = 0f;
		}
		if (helicopterInputState.groundControl)
		{
			currentThrottle = -0.75f;
		}
		else
		{
			currentThrottle = Mathf.Lerp(currentThrottle, helicopterInputState.throttle, 2f * Time.fixedDeltaTime);
			currentThrottle = Mathf.Clamp(currentThrottle, -0.8f, 1f);
			if (helicopterInputState.pitch != 0f || helicopterInputState.roll != 0f || helicopterInputState.yaw != 0f)
			{
				rigidBody.AddRelativeTorque(new Vector3(helicopterInputState.pitch * torqueScale.x, helicopterInputState.yaw * torqueScale.y, helicopterInputState.roll * torqueScale.z), (ForceMode)0);
			}
		}
		if (damageTorque != Vector3.zero)
		{
			rigidBody.AddRelativeTorque(new Vector3(damageTorque.x, damageTorque.y, damageTorque.z), (ForceMode)0);
		}
		avgThrust = Mathf.Lerp(avgThrust, engineThrustMax * currentThrottle, Time.fixedDeltaTime * thrustLerpSpeed);
		float num2 = Mathf.Clamp01(Vector3.Dot(((Component)this).transform.up, Vector3.up));
		float num3 = Mathf.InverseLerp(liftDotMax, 1f, num2);
		float serviceCeiling = GetServiceCeiling();
		float num4 = Mathf.Max(GetMinimumAltitudeTerrain(), TerrainMeta.HeightMap.GetHeight(((Component)this).transform.position));
		avgTerrainHeight = Mathf.Lerp(avgTerrainHeight, num4, Time.deltaTime);
		float num5 = 1f - Mathf.InverseLerp(avgTerrainHeight + serviceCeiling - 20f, avgTerrainHeight + serviceCeiling, ((Component)this).transform.position.y);
		num3 *= num5;
		float num6 = 1f - Mathf.InverseLerp(altForceDotMin, 1f, num2);
		Vector3 val = Vector3.up * engineThrustMax * liftFraction * currentThrottle * num3;
		Vector3 val2 = ((Component)this).transform.up - Vector3.up;
		Vector3 val3 = ((Vector3)(ref val2)).normalized * engineThrustMax * currentThrottle * num6;
		float num7 = rigidBody.mass * (0f - Physics.gravity.y);
		rigidBody.AddForce(((Component)this).transform.up * num7 * num3 * hoverForceScale, (ForceMode)0);
		rigidBody.AddForce(val, (ForceMode)0);
		rigidBody.AddForce(val3, (ForceMode)0);
	}

	public void DelayedImpactDamage()
	{
		float num = explosionForceMultiplier;
		explosionForceMultiplier = 0f;
		Hurt(pendingImpactDamage * MaxHealth(), DamageType.Explosion, this, useProtection: false);
		pendingImpactDamage = 0f;
		explosionForceMultiplier = num;
	}

	public virtual bool CollisionDamageEnabled()
	{
		return true;
	}

	public void ProcessCollision(Collision collision)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0157: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient || !CollisionDamageEnabled() || Time.time < nextDamageTime)
		{
			return;
		}
		Vector3 relativeVelocity = collision.relativeVelocity;
		float magnitude = ((Vector3)(ref relativeVelocity)).magnitude;
		if (Object.op_Implicit((Object)(object)collision.gameObject))
		{
			if (((1 << ((Component)collision.collider).gameObject.layer) & 0x48A18101) <= 0)
			{
				return;
			}
			BaseEntity entity = collision.GetEntity();
			if ((Object)(object)entity != (Object)null && (entity is Parachute || entity is RidableHorse || entity is MagnetCrane))
			{
				return;
			}
		}
		float num = Mathf.InverseLerp(7f, 30f, magnitude);
		if (!(num > 0f))
		{
			return;
		}
		pendingImpactDamage += Mathf.Max(num, 0.05f);
		if (Vector3.Dot(((Component)this).transform.up, Vector3.up) < 0.5f)
		{
			pendingImpactDamage *= 5f;
		}
		if (Time.time > nextEffectTime)
		{
			nextEffectTime = Time.time + 0.25f;
			if (crashEffect.isValid)
			{
				ContactPoint contact = collision.GetContact(0);
				Vector3 point = ((ContactPoint)(ref contact)).point;
				TryShowCollisionFX(point);
			}
		}
		Rigidbody obj = rigidBody;
		ContactPoint contact2 = collision.GetContact(0);
		Vector3 val = ((ContactPoint)(ref contact2)).normal * (1f + 3f * num);
		contact2 = collision.GetContact(0);
		obj.AddForceAtPosition(val, ((ContactPoint)(ref contact2)).point, (ForceMode)2);
		nextDamageTime = Time.time + 0.333f;
		((FacepunchBehaviour)this).Invoke((Action)DelayedImpactDamage, 0.015f);
	}

	public override GameObjectRef GetCollisionFX()
	{
		return crashEffect;
	}

	public void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	public override void OnDied(HitInfo info)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_0138: Unknown result type (might be due to invalid IL or missing references)
		//IL_014d: Unknown result type (might be due to invalid IL or missing references)
		//IL_014f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0169: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_0183: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_013c: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0141: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		if (base.isClient)
		{
			base.OnDied(info);
			return;
		}
		if (explosionEffect.isValid)
		{
			Effect.server.Run(explosionEffect.resourcePath, ((Component)this).transform.position, Vector3.up, null, broadcast: true);
		}
		Vector3 val = rigidBody.velocity * 0.25f;
		List<ServerGib> list = null;
		if (serverGibs.isValid)
		{
			GameObject gibSource = serverGibs.Get().GetComponent<ServerGib>()._gibSource;
			list = ServerGib.CreateGibs(serverGibs.resourcePath, ((Component)this).gameObject, gibSource, val, 3f);
		}
		Vector3 val2 = CenterPoint();
		if (fireBall.isValid && !InSafeZone())
		{
			RaycastHit val3 = default(RaycastHit);
			for (int i = 0; i < 12; i++)
			{
				BaseEntity baseEntity = GameManager.server.CreateEntity(fireBall.resourcePath, val2, ((Component)this).transform.rotation);
				if (!Object.op_Implicit((Object)(object)baseEntity))
				{
					continue;
				}
				float num = 3f;
				float num2 = 10f;
				Vector3 onUnitSphere = Random.onUnitSphere;
				((Vector3)(ref onUnitSphere)).Normalize();
				float num3 = Random.Range(0.5f, 4f);
				bool num4 = Physics.Raycast(val2, onUnitSphere, ref val3, num3, 1218652417);
				Vector3 val4 = ((RaycastHit)(ref val3)).point;
				if (!num4)
				{
					val4 = val2 + onUnitSphere * num3;
				}
				val4 -= onUnitSphere * 0.5f;
				((Component)baseEntity).transform.position = val4;
				Collider component = ((Component)baseEntity).GetComponent<Collider>();
				baseEntity.Spawn();
				baseEntity.SetVelocity(val + onUnitSphere * Random.Range(num, num2));
				if (list == null)
				{
					continue;
				}
				foreach (ServerGib item in list)
				{
					Physics.IgnoreCollision(component, (Collider)(object)item.GetCollider(), true);
				}
			}
		}
		SeismicSensor.Notify(((Component)this).transform.position, 1);
		base.OnDied(info);
	}

	public virtual bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}
}


using System;
using UnityEngine;

[Serializable]
protected class GroundEffect
{
	public ParticleSystem effect;

	public Transform groundPoint;
}


public class HelicopterInputState
{
	public float throttle;

	public float roll;

	public float yaw;

	public float pitch;

	public bool groundControl;

	public void Reset()
	{
		throttle = 0f;
		roll = 0f;
		yaw = 0f;
		pitch = 0f;
		groundControl = false;
	}
}


using System;
using UnityEngine;

public class CH47AIBrain : BaseAIBrain
{
	public class DropCrate : BasicAIState
	{
		private float nextDropTime;

		public DropCrate()
			: base(AIState.DropCrate)
		{
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return !CanDrop();
			}
			return false;
		}

		public bool CanDrop()
		{
			if (Time.time > nextDropTime)
			{
				return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
			}
			return false;
		}

		public override float GetWeight()
		{
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0079: Unknown result type (might be due to invalid IL or missing references)
			//IL_0084: Unknown result type (might be due to invalid IL or missing references)
			if (!CanDrop())
			{
				return 0f;
			}
			if (IsInState())
			{
				return 10000f;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
			{
				CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
				if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
				{
					CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
					if ((Object)(object)component != (Object)null)
					{
						float num = Mathf.InverseLerp(300f, 600f, component.Age);
						return 1000f * num;
					}
				}
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.SetDropDoorOpen(open: true);
			obj.EnableFacingOverride(enabled: false);
			CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
			if ((Object)(object)closest == (Object)null)
			{
				nextDropTime = Time.time + 60f;
			}
			brain.mainInterestPoint = ((Component)closest).transform.position;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0025: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
			{
				Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
				if (((Vector3)(ref velocity)).magnitude < 5f)
				{
					cH47HelicopterAIController.DropCrate();
					nextDropTime = Time.time + 120f;
				}
			}
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
			nextDropTime = Time.time + 60f;
			base.StateLeave(brain, entity);
		}
	}

	public class EgressState : BasicAIState
	{
		private bool killing;

		private bool egressAltitueAchieved;

		public EgressState()
			: base(AIState.Egress)
		{
		}

		public override bool CanInterrupt()
		{
			return false;
		}

		public override float GetWeight()
		{
			CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
			if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
			{
				return 10000f;
			}
			CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
			if ((Object)(object)component != (Object)null)
			{
				if (!(component.Age > 1800f))
				{
					return 0f;
				}
				return 10000f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0043: Unknown result type (might be due to invalid IL or missing references)
			//IL_0032: Unknown result type (might be due to invalid IL or missing references)
			//IL_0037: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0048: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_004f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			//IL_0055: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_006d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_008d: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			Transform transform = ((Component)obj).transform;
			Rigidbody rigidBody = obj.rigidBody;
			Vector3 velocity = rigidBody.velocity;
			Vector3 val;
			if (!(((Vector3)(ref velocity)).magnitude < 0.1f))
			{
				velocity = rigidBody.velocity;
				val = ((Vector3)(ref velocity)).normalized;
			}
			else
			{
				val = transform.forward;
			}
			Vector3 val2 = val;
			Vector3 val3 = Vector3.Cross(Vector3.Cross(transform.up, val2), Vector3.up);
			brain.mainInterestPoint = transform.position + val3 * 8000f;
			brain.mainInterestPoint.y = 100f;
			obj.SetMoveTarget(brain.mainInterestPoint);
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			//IL_003c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0052: Unknown result type (might be due to invalid IL or missing references)
			//IL_0057: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_0082: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			if (killing)
			{
				return StateStatus.Running;
			}
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			if (position.y < 85f && !egressAltitueAchieved)
			{
				CH47LandingZone closest = CH47LandingZone.GetClosest(position);
				if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
				{
					float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
					waterOrTerrainSurface += 100f;
					Vector3 moveTarget = position;
					moveTarget.y = waterOrTerrainSurface;
					cH47HelicopterAIController.SetMoveTarget(moveTarget);
					return StateStatus.Running;
				}
			}
			egressAltitueAchieved = true;
			cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
			if (base.TimeInState > 300f)
			{
				((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
				killing = true;
			}
			return StateStatus.Running;
		}
	}

	public class IdleState : BaseIdleState
	{
		public override float GetWeight()
		{
			return 0.1f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0019: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
			base.StateEnter(brain, entity);
		}
	}

	public class LandState : BasicAIState
	{
		private float landedForSeconds;

		private float lastLandtime;

		private float landingHeight = 20f;

		private float nextDismountTime;

		public LandState()
			: base(AIState.Land)
		{
		}

		public override float GetWeight()
		{
			if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
			{
				return 0f;
			}
			float num = Time.time - lastLandtime;
			if (IsInState() && landedForSeconds < 12f)
			{
				return 1000f;
			}
			if (!IsInState() && num > 10f)
			{
				return 9000f;
			}
			return 0f;
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_002a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_004a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005a: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00be: Unknown result type (might be due to invalid IL or missing references)
			//IL_0161: Unknown result type (might be due to invalid IL or missing references)
			//IL_016c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0181: Unknown result type (might be due to invalid IL or missing references)
			//IL_0186: Unknown result type (might be due to invalid IL or missing references)
			//IL_018b: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01da: Unknown result type (might be due to invalid IL or missing references)
			//IL_01df: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
			_ = ((Component)cH47HelicopterAIController).transform.forward;
			CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
			if (!Object.op_Implicit((Object)(object)closest))
			{
				return StateStatus.Error;
			}
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			float magnitude = ((Vector3)(ref velocity)).magnitude;
			float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
			bool enabled = num < 40f;
			bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
			cH47HelicopterAIController.EnableFacingOverride(enabled);
			cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
			int num2;
			if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
			{
				num2 = ((magnitude < 1f) ? 1 : 0);
				if (num2 != 0)
				{
					landedForSeconds += delta;
					if (lastLandtime == 0f)
					{
						lastLandtime = Time.time;
					}
				}
			}
			else
			{
				num2 = 0;
			}
			float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
			landingHeight -= 4f * num3 * Time.deltaTime;
			if (landingHeight < -5f)
			{
				landingHeight = -5f;
			}
			cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
			Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
			if (num < 100f && num > 15f)
			{
				Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
				RaycastHit val2 = default(RaycastHit);
				if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
				{
					Vector3 val3 = Vector3.Cross(val, Vector3.up);
					moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
				}
			}
			cH47HelicopterAIController.SetMoveTarget(moveTarget);
			if (num2 != 0)
			{
				if (landedForSeconds > 1f && Time.time > nextDismountTime)
				{
					foreach (BaseVehicle.MountPointInfo mountPoint in cH47HelicopterAIController.mountPoints)
					{
						if (Object.op_Implicit((Object)(object)mountPoint.mountable) && mountPoint.mountable.AnyMounted())
						{
							nextDismountTime = Time.time + 0.5f;
							mountPoint.mountable.DismountAllPlayers();
							break;
						}
					}
				}
				if (landedForSeconds > 8f)
				{
					((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
				}
			}
			return StateStatus.Running;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
			landingHeight = 15f;
			base.StateEnter(brain, entity);
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.SetAltitudeProtection(on: true);
			obj.SetMinHoverHeight(30f);
			landedForSeconds = 0f;
			base.StateLeave(brain, entity);
		}

		public override bool CanInterrupt()
		{
			return true;
		}
	}

	public class OrbitState : BasicAIState
	{
		public OrbitState()
			: base(AIState.Orbit)
		{
		}

		public Vector3 GetOrbitCenter()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
				return 5f * num;
			}
			if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
			{
				return 5f;
			}
			return 0f;
		}

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: true);
			obj.InitiateAnger();
			base.StateEnter(brain, entity);
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_001c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0021: Unknown result type (might be due to invalid IL or missing references)
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			//IL_0027: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0033: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_005f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0060: Unknown result type (might be due to invalid IL or missing references)
			//IL_0065: Unknown result type (might be due to invalid IL or missing references)
			//IL_0068: Unknown result type (might be due to invalid IL or missing references)
			//IL_0072: Unknown result type (might be due to invalid IL or missing references)
			//IL_0077: Unknown result type (might be due to invalid IL or missing references)
			//IL_007c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0080: Unknown result type (might be due to invalid IL or missing references)
			//IL_0085: Unknown result type (might be due to invalid IL or missing references)
			//IL_0087: Unknown result type (might be due to invalid IL or missing references)
			//IL_008b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_0098: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
			Vector3 orbitCenter = GetOrbitCenter();
			CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
			Vector3 position = cH47HelicopterAIController.GetPosition();
			Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
			Vector3 val2 = Vector3.Cross(Vector3.up, val);
			float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
			float num2 = 75f;
			Vector3 val3 = -val + val2 * num * 0.6f;
			Vector3 normalized = ((Vector3)(ref val3)).normalized;
			Vector3 val4 = orbitCenter + normalized * num2;
			cH47HelicopterAIController.SetMoveTarget(val4);
			cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
			base.StateThink(delta, brain, entity);
			return StateStatus.Running;
		}

		public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
		{
			CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
			obj.EnableFacingOverride(enabled: false);
			obj.CancelAnger();
			base.StateLeave(brain, entity);
		}
	}

	public class PatrolState : BasePatrolState
	{
		protected float patrolApproachDist = 75f;

		public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			base.StateEnter(brain, entity);
			brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
		}

		public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			base.StateThink(delta, brain, entity);
			(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
			return StateStatus.Running;
		}

		public bool AtPatrolDestination()
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
		}

		public Vector3 GetDestination()
		{
			//IL_0006: Unknown result type (might be due to invalid IL or missing references)
			return brain.mainInterestPoint;
		}

		public override bool CanInterrupt()
		{
			if (base.CanInterrupt())
			{
				return AtPatrolDestination();
			}
			return false;
		}

		public override float GetWeight()
		{
			if (IsInState())
			{
				if (AtPatrolDestination() && base.TimeInState > 2f)
				{
					return 0f;
				}
				return 3f;
			}
			float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
			return 1f + num;
		}
	}

	public override void AddStates()
	{
		base.AddStates();
		AddState(new IdleState());
		AddState(new PatrolState());
		AddState(new OrbitState());
		AddState(new EgressState());
		AddState(new DropCrate());
		AddState(new LandState());
	}

	public override void InitializeAI()
	{
		base.InitializeAI();
		base.ThinkMode = AIThinkMode.FixedUpdate;
		base.PathFinder = new CH47PathFinder();
	}

	public void FixedUpdate()
	{
		if (!((Object)(object)base.baseEntity == (Object)null) && !base.baseEntity.isClient)
		{
			Think(Time.fixedDeltaTime);
		}
	}
}


using UnityEngine;

public class DropCrate : BasicAIState
{
	private float nextDropTime;

	public DropCrate()
		: base(AIState.DropCrate)
	{
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return !CanDrop();
		}
		return false;
	}

	public bool CanDrop()
	{
		if (Time.time > nextDropTime)
		{
			return (brain.GetBrainBaseEntity() as CH47HelicopterAIController).CanDropCrate();
		}
		return false;
	}

	public override float GetWeight()
	{
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		if (!CanDrop())
		{
			return 0f;
		}
		if (IsInState())
		{
			return 10000f;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Orbit && brain.CurrentState.TimeInState > 60f)
		{
			CH47DropZone closest = CH47DropZone.GetClosest(brain.mainInterestPoint);
			if (Object.op_Implicit((Object)(object)closest) && Vector3Ex.Distance2D(((Component)closest).transform.position, brain.mainInterestPoint) < 200f)
			{
				CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
				if ((Object)(object)component != (Object)null)
				{
					float num = Mathf.InverseLerp(300f, 600f, component.Age);
					return 1000f * num;
				}
			}
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.SetDropDoorOpen(open: true);
		obj.EnableFacingOverride(enabled: false);
		CH47DropZone closest = CH47DropZone.GetClosest(((Component)obj).transform.position);
		if ((Object)(object)closest == (Object)null)
		{
			nextDropTime = Time.time + 60f;
		}
		brain.mainInterestPoint = ((Component)closest).transform.position;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		if (CanDrop() && Vector3Ex.Distance2D(brain.mainInterestPoint, ((Component)cH47HelicopterAIController).transform.position) < 5f)
		{
			Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
			if (((Vector3)(ref velocity)).magnitude < 5f)
			{
				cH47HelicopterAIController.DropCrate();
				nextDropTime = Time.time + 120f;
			}
		}
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		(entity as CH47HelicopterAIController).SetDropDoorOpen(open: false);
		nextDropTime = Time.time + 60f;
		base.StateLeave(brain, entity);
	}
}


using System;
using UnityEngine;

public class EgressState : BasicAIState
{
	private bool killing;

	private bool egressAltitueAchieved;

	public EgressState()
		: base(AIState.Egress)
	{
	}

	public override bool CanInterrupt()
	{
		return false;
	}

	public override float GetWeight()
	{
		CH47HelicopterAIController cH47HelicopterAIController = brain.GetBrainBaseEntity() as CH47HelicopterAIController;
		if (cH47HelicopterAIController.OutOfCrates() && !cH47HelicopterAIController.ShouldLand())
		{
			return 10000f;
		}
		CH47AIBrain component = ((Component)brain).GetComponent<CH47AIBrain>();
		if ((Object)(object)component != (Object)null)
		{
			if (!(component.Age > 1800f))
			{
				return 0f;
			}
			return 10000f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		Transform transform = ((Component)obj).transform;
		Rigidbody rigidBody = obj.rigidBody;
		Vector3 velocity = rigidBody.velocity;
		Vector3 val;
		if (!(((Vector3)(ref velocity)).magnitude < 0.1f))
		{
			velocity = rigidBody.velocity;
			val = ((Vector3)(ref velocity)).normalized;
		}
		else
		{
			val = transform.forward;
		}
		Vector3 val2 = val;
		Vector3 val3 = Vector3.Cross(Vector3.Cross(transform.up, val2), Vector3.up);
		brain.mainInterestPoint = transform.position + val3 * 8000f;
		brain.mainInterestPoint.y = 100f;
		obj.SetMoveTarget(brain.mainInterestPoint);
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		if (killing)
		{
			return StateStatus.Running;
		}
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		if (position.y < 85f && !egressAltitueAchieved)
		{
			CH47LandingZone closest = CH47LandingZone.GetClosest(position);
			if ((Object)(object)closest != (Object)null && Vector3Ex.Distance2D(((Component)closest).transform.position, position) < 20f)
			{
				float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(position, waves: false, volumes: false);
				waterOrTerrainSurface += 100f;
				Vector3 moveTarget = position;
				moveTarget.y = waterOrTerrainSurface;
				cH47HelicopterAIController.SetMoveTarget(moveTarget);
				return StateStatus.Running;
			}
		}
		egressAltitueAchieved = true;
		cH47HelicopterAIController.SetMoveTarget(brain.mainInterestPoint);
		if (base.TimeInState > 300f)
		{
			((FacepunchBehaviour)SingletonComponent<InvokeHandler>.Instance).Invoke((Action)cH47HelicopterAIController.DelayedKill, 2f);
			killing = true;
		}
		return StateStatus.Running;
	}
}


using UnityEngine;

public class IdleState : BaseIdleState
{
	public override float GetWeight()
	{
		return 0.1f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		cH47HelicopterAIController.SetMoveTarget(position + ((Vector3)(ref velocity)).normalized * 10f);
		base.StateEnter(brain, entity);
	}
}


using UnityEngine;

public class LandState : BasicAIState
{
	private float landedForSeconds;

	private float lastLandtime;

	private float landingHeight = 20f;

	private float nextDismountTime;

	public LandState()
		: base(AIState.Land)
	{
	}

	public override float GetWeight()
	{
		if (!(brain.GetBrainBaseEntity() as CH47HelicopterAIController).ShouldLand())
		{
			return 0f;
		}
		float num = Time.time - lastLandtime;
		if (IsInState() && landedForSeconds < 12f)
		{
			return 1000f;
		}
		if (!IsInState() && num > 10f)
		{
			return 9000f;
		}
		return 0f;
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_0161: Unknown result type (might be due to invalid IL or missing references)
		//IL_016c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0186: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01da: Unknown result type (might be due to invalid IL or missing references)
		//IL_01df: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f0: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = ((Component)cH47HelicopterAIController).transform.position;
		_ = ((Component)cH47HelicopterAIController).transform.forward;
		CH47LandingZone closest = CH47LandingZone.GetClosest(cH47HelicopterAIController.landingTarget);
		if (!Object.op_Implicit((Object)(object)closest))
		{
			return StateStatus.Error;
		}
		Vector3 velocity = cH47HelicopterAIController.rigidBody.velocity;
		float magnitude = ((Vector3)(ref velocity)).magnitude;
		float num = Vector3Ex.Distance2D(((Component)closest).transform.position, position);
		bool enabled = num < 40f;
		bool altitudeProtection = num > 15f && position.y < ((Component)closest).transform.position.y + 10f;
		cH47HelicopterAIController.EnableFacingOverride(enabled);
		cH47HelicopterAIController.SetAltitudeProtection(altitudeProtection);
		int num2;
		if (Mathf.Abs(((Component)closest).transform.position.y - position.y) < 3f && num <= 5f)
		{
			num2 = ((magnitude < 1f) ? 1 : 0);
			if (num2 != 0)
			{
				landedForSeconds += delta;
				if (lastLandtime == 0f)
				{
					lastLandtime = Time.time;
				}
			}
		}
		else
		{
			num2 = 0;
		}
		float num3 = 1f - Mathf.InverseLerp(0f, 7f, num);
		landingHeight -= 4f * num3 * Time.deltaTime;
		if (landingHeight < -5f)
		{
			landingHeight = -5f;
		}
		cH47HelicopterAIController.SetAimDirection(((Component)closest).transform.forward);
		Vector3 moveTarget = brain.mainInterestPoint + new Vector3(0f, landingHeight, 0f);
		if (num < 100f && num > 15f)
		{
			Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, position);
			RaycastHit val2 = default(RaycastHit);
			if (Physics.SphereCast(position, 15f, val, ref val2, num, 1218511105))
			{
				Vector3 val3 = Vector3.Cross(val, Vector3.up);
				moveTarget = ((RaycastHit)(ref val2)).point + val3 * 50f;
			}
		}
		cH47HelicopterAIController.SetMoveTarget(moveTarget);
		if (num2 != 0)
		{
			if (landedForSeconds > 1f && Time.time > nextDismountTime)
			{
				foreach (BaseVehicle.MountPointInfo mountPoint in cH47HelicopterAIController.mountPoints)
				{
					if (Object.op_Implicit((Object)(object)mountPoint.mountable) && mountPoint.mountable.AnyMounted())
					{
						nextDismountTime = Time.time + 0.5f;
						mountPoint.mountable.DismountAllPlayers();
						break;
					}
				}
			}
			if (landedForSeconds > 8f)
			{
				((Component)brain).GetComponent<CH47AIBrain>().ForceSetAge(float.PositiveInfinity);
			}
		}
		return StateStatus.Running;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		brain.mainInterestPoint = (entity as CH47HelicopterAIController).landingTarget;
		landingHeight = 15f;
		base.StateEnter(brain, entity);
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.SetAltitudeProtection(on: true);
		obj.SetMinHoverHeight(30f);
		landedForSeconds = 0f;
		base.StateLeave(brain, entity);
	}

	public override bool CanInterrupt()
	{
		return true;
	}
}


using UnityEngine;

public class OrbitState : BasicAIState
{
	public OrbitState()
		: base(AIState.Orbit)
	{
	}

	public Vector3 GetOrbitCenter()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			float num = 1f - Mathf.InverseLerp(120f, 180f, base.TimeInState);
			return 5f * num;
		}
		if (brain.CurrentState != null && brain.CurrentState.StateType == AIState.Patrol && brain.CurrentState is PatrolState patrolState && patrolState.AtPatrolDestination())
		{
			return 5f;
		}
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: true);
		obj.InitiateAnger();
		base.StateEnter(brain, entity);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		Vector3 orbitCenter = GetOrbitCenter();
		CH47HelicopterAIController cH47HelicopterAIController = entity as CH47HelicopterAIController;
		Vector3 position = cH47HelicopterAIController.GetPosition();
		Vector3 val = Vector3Ex.Direction2D(orbitCenter, position);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = ((Vector3.Dot(Vector3.Cross(((Component)cH47HelicopterAIController).transform.right, Vector3.up), val2) < 0f) ? (-1f) : 1f);
		float num2 = 75f;
		Vector3 val3 = -val + val2 * num * 0.6f;
		Vector3 normalized = ((Vector3)(ref val3)).normalized;
		Vector3 val4 = orbitCenter + normalized * num2;
		cH47HelicopterAIController.SetMoveTarget(val4);
		cH47HelicopterAIController.SetAimDirection(Vector3Ex.Direction2D(val4, position));
		base.StateThink(delta, brain, entity);
		return StateStatus.Running;
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		CH47HelicopterAIController obj = entity as CH47HelicopterAIController;
		obj.EnableFacingOverride(enabled: false);
		obj.CancelAnger();
		base.StateLeave(brain, entity);
	}
}


using UnityEngine;

public class PatrolState : BasePatrolState
{
	protected float patrolApproachDist = 75f;

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		base.StateEnter(brain, entity);
		brain.mainInterestPoint = brain.PathFinder.GetRandomPatrolPoint();
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		base.StateThink(delta, brain, entity);
		(entity as CH47HelicopterAIController).SetMoveTarget(brain.mainInterestPoint);
		return StateStatus.Running;
	}

	public bool AtPatrolDestination()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return Vector3Ex.Distance2D(GetDestination(), ((Component)brain).transform.position) < patrolApproachDist;
	}

	public Vector3 GetDestination()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return brain.mainInterestPoint;
	}

	public override bool CanInterrupt()
	{
		if (base.CanInterrupt())
		{
			return AtPatrolDestination();
		}
		return false;
	}

	public override float GetWeight()
	{
		if (IsInState())
		{
			if (AtPatrolDestination() && base.TimeInState > 2f)
			{
				return 0f;
			}
			return 3f;
		}
		float num = Mathf.InverseLerp(70f, 120f, TimeSinceState()) * 5f;
		return 1f + num;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47DropZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47DropZone> dropZones = new List<CH47DropZone>();

	public void Awake()
	{
		if (!dropZones.Contains(this))
		{
			dropZones.Add(this);
		}
	}

	public static CH47DropZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47DropZone result = null;
		foreach (CH47DropZone dropZone in dropZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)dropZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = dropZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (dropZones.Contains(this))
		{
			dropZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.yellow;
		Gizmos.DrawSphere(((Component)this).transform.position, 5f);
	}
}


using Oxide.Core;
using UnityEngine;

public class CH47Helicopter : BaseHelicopter
{
	public GameObjectRef mapMarkerEntityPrefab;

	[Header("Sounds")]
	public SoundDefinition flightEngineSoundDef;

	public SoundDefinition flightThwopsSoundDef;

	public float rotorGainModSmoothing = 0.25f;

	public float engineGainMin = 0.5f;

	public float engineGainMax = 1f;

	public float thwopGainMin = 0.5f;

	public float thwopGainMax = 1f;

	public BaseEntity mapMarkerInstance;

	public override void ServerInit()
	{
		rigidBody.isKinematic = false;
		base.ServerInit();
		CreateMapMarker();
	}

	public void CreateMapMarker()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)mapMarkerInstance))
		{
			mapMarkerInstance.Kill();
		}
		BaseEntity baseEntity = GameManager.server.CreateEntity(mapMarkerEntityPrefab.resourcePath, Vector3.zero, Quaternion.identity);
		baseEntity.Spawn();
		baseEntity.SetParent(this);
		mapMarkerInstance = baseEntity;
	}

	public override bool IsValidHomingTarget()
	{
		object obj = Interface.CallHook("CanBeHomingTargeted", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return false;
	}

	protected override void ApplyHandbrake()
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using System;
using Oxide.Core;
using Rust;
using UnityEngine;

public class CH47HelicopterAIController : CH47Helicopter
{
	public GameObjectRef scientistPrefab;

	public GameObjectRef dismountablePrefab;

	public GameObjectRef weakDismountablePrefab;

	public float maxTiltAngle = 0.3f;

	public float AiAltitudeForce = 10000f;

	public GameObjectRef lockedCratePrefab;

	public const Flags Flag_Damaged = Flags.Reserved9;

	public const Flags Flag_NearDeath = Flags.OnFire;

	public const Flags Flag_DropDoorOpen = Flags.Reserved8;

	public GameObject triggerHurt;

	public Vector3 landingTarget;

	public int numCrates = 1;

	private bool shouldLand;

	public bool aimDirOverride;

	public Vector3 _aimDirection = Vector3.forward;

	public Vector3 _moveTarget = Vector3.zero;

	public int lastAltitudeCheckFrame;

	public float altOverride;

	public float currentDesiredAltitude;

	private bool altitudeProtection = true;

	public float hoverHeight = 30f;

	public void DropCrate()
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		if (numCrates > 0)
		{
			Vector3 pos = ((Component)this).transform.position + Vector3.down * 5f;
			Quaternion rot = Quaternion.Euler(0f, Random.Range(0f, 360f), 0f);
			BaseEntity baseEntity = GameManager.server.CreateEntity(lockedCratePrefab.resourcePath, pos, rot);
			if (Object.op_Implicit((Object)(object)baseEntity))
			{
				Interface.CallHook("OnHelicopterDropCrate", (object)this);
				((Component)baseEntity).SendMessage("SetWasDropped");
				baseEntity.Spawn();
			}
			numCrates--;
		}
	}

	public bool OutOfCrates()
	{
		object obj = Interface.CallHook("OnHelicopterOutOfCrates", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates <= 0;
	}

	public bool CanDropCrate()
	{
		object obj = Interface.CallHook("CanHelicopterDropCrate", (object)this);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return numCrates > 0;
	}

	public bool IsDropDoorOpen()
	{
		return HasFlag(Flags.Reserved8);
	}

	public void SetDropDoorOpen(bool open)
	{
		if (Interface.CallHook("OnHelicopterDropDoorOpen", (object)this) == null)
		{
			SetFlag(Flags.Reserved8, open);
		}
	}

	public bool ShouldLand()
	{
		return shouldLand;
	}

	public void SetLandingTarget(Vector3 target)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		shouldLand = true;
		landingTarget = target;
		numCrates = 0;
	}

	public void ClearLandingTarget()
	{
		shouldLand = false;
	}

	public void TriggeredEventSpawn()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		float x = TerrainMeta.Size.x;
		float y = 30f;
		Vector3 val = Vector3Ex.Range(-1f, 1f);
		val.y = 0f;
		((Vector3)(ref val)).Normalize();
		val *= x * 1f;
		val.y = y;
		((Component)this).transform.position = val;
	}

	public override void AttemptMount(BasePlayer player, bool doMountChecks = true)
	{
		if (Interface.CallHook("CanUseHelicopter", (object)player, (object)this) == null)
		{
			base.AttemptMount(player, doMountChecks);
		}
	}

	public override void ServerInit()
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 0.25f);
		SetMoveTarget(((Component)this).transform.position);
	}

	public void SpawnPassenger(Vector3 spawnPos, string prefabPath)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(prefabPath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		OnSpawnedHuman(component);
	}

	public void SpawnPassenger(Vector3 spawnPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(dismountablePrefab.resourcePath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		OnSpawnedHuman(component);
	}

	public void SpawnScientist(Vector3 spawnPos)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Quaternion identity = Quaternion.identity;
		HumanNPC component = ((Component)GameManager.server.CreateEntity(scientistPrefab.resourcePath, spawnPos, identity)).GetComponent<HumanNPC>();
		component.Spawn();
		AttemptMount(component);
		component.Brain.SetEnabled(flag: false);
		OnSpawnedHuman(component);
	}

	private void OnSpawnedHuman(HumanNPC human)
	{
		if (!((Object)(object)human == (Object)null) && (Object)(object)human.Brain != (Object)null && human.Brain.Senses != null)
		{
			human.Brain.Senses.ignoreTutorialPlayers = true;
		}
	}

	public void CheckSpawnScientists()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		if (ValidBounds.Test(this, ((Component)this).transform.position))
		{
			((FacepunchBehaviour)this).Invoke((Action)SpawnScientists, 2f);
		}
		else
		{
			((FacepunchBehaviour)this).Invoke((Action)CheckSpawnScientists, 2f);
		}
	}

	public void SpawnScientists()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0100: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		if (shouldLand)
		{
			float dropoffScale = CH47LandingZone.GetClosest(landingTarget).dropoffScale;
			int num = Mathf.FloorToInt((float)(mountPoints.Count - 2) * dropoffScale);
			for (int i = 0; i < num; i++)
			{
				Vector3 spawnPos = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnPassenger(spawnPos, dismountablePrefab.resourcePath);
			}
			for (int j = 0; j < 1; j++)
			{
				Vector3 spawnPos2 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
				SpawnPassenger(spawnPos2);
			}
		}
		else
		{
			for (int k = 0; k < 4; k++)
			{
				Vector3 spawnPos3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
				SpawnScientist(spawnPos3);
			}
			for (int l = 0; l < 1; l++)
			{
				Vector3 spawnPos4 = ((Component)this).transform.position - ((Component)this).transform.forward * 15f;
				SpawnScientist(spawnPos4);
			}
		}
	}

	public void EnableFacingOverride(bool enabled)
	{
		aimDirOverride = enabled;
	}

	public void SetMoveTarget(Vector3 position)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_moveTarget = position;
	}

	public Vector3 GetMoveTarget()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _moveTarget;
	}

	public void SetAimDirection(Vector3 dir)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		_aimDirection = dir;
	}

	public Vector3 GetAimDirectionOverride()
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		return _aimDirection;
	}

	public Vector3 GetPosition()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.position;
	}

	public override void MounteeTookDamage(BasePlayer mountee, HitInfo info)
	{
		InitiateAnger();
	}

	public void CancelAnger()
	{
		if (base.SecondsSinceAttacked > 120f)
		{
			UnHostile();
			((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		}
	}

	public void InitiateAnger()
	{
		((FacepunchBehaviour)this).CancelInvoke((Action)UnHostile);
		((FacepunchBehaviour)this).Invoke((Action)UnHostile, 120f);
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: true);
				}
			}
		}
	}

	public void UnHostile()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if (!((Object)(object)mountPoint.mountable != (Object)null))
			{
				continue;
			}
			BasePlayer mounted = mountPoint.mountable.GetMounted();
			if (Object.op_Implicit((Object)(object)mounted))
			{
				ScientistNPC scientistNPC = mounted as ScientistNPC;
				if ((Object)(object)scientistNPC != (Object)null)
				{
					scientistNPC.Brain.SetEnabled(flag: false);
				}
			}
		}
	}

	public override void OnDied(HitInfo info)
	{
		if (Interface.CallHook("OnEntityDestroy", (object)this) == null)
		{
			if (!OutOfCrates())
			{
				DropCrate();
			}
			base.OnDied(info);
		}
	}

	public override void OnAttacked(HitInfo info)
	{
		if (Interface.CallHook("OnHelicopterAttack", (object)this, (object)info) == null)
		{
			base.OnAttacked(info);
			InitiateAnger();
			SetFlag(Flags.Reserved9, base.healthFraction <= 0.8f);
			SetFlag(Flags.OnFire, base.healthFraction <= 0.33f);
		}
	}

	public void DelayedKill()
	{
		DismountAllPlayers();
		Kill();
	}

	public override void DismountAllPlayers()
	{
		foreach (MountPointInfo mountPoint in mountPoints)
		{
			if ((Object)(object)mountPoint.mountable != (Object)null)
			{
				BasePlayer mounted = mountPoint.mountable.GetMounted();
				if (Object.op_Implicit((Object)(object)mounted) && mounted.IsAlive())
				{
					mounted.Hurt(10000f, DamageType.Explosion, this, useProtection: false);
				}
			}
		}
	}

	public void SetAltitudeProtection(bool on)
	{
		altitudeProtection = on;
	}

	public void CalculateDesiredAltitude()
	{
		CalculateOverrideAltitude();
		if (altOverride > currentDesiredAltitude)
		{
			currentDesiredAltitude = altOverride;
		}
		else
		{
			currentDesiredAltitude = Mathf.MoveTowards(currentDesiredAltitude, altOverride, Time.fixedDeltaTime * 5f);
		}
	}

	public void SetMinHoverHeight(float newHeight)
	{
		hoverHeight = newHeight;
	}

	public float CalculateOverrideAltitude()
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_0101: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0139: Unknown result type (might be due to invalid IL or missing references)
		if (Time.frameCount == lastAltitudeCheckFrame)
		{
			return altOverride;
		}
		lastAltitudeCheckFrame = Time.frameCount;
		float y = GetMoveTarget().y;
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(GetMoveTarget(), waves: false, volumes: false);
		float num = Mathf.Max(y, waterOrTerrainSurface + hoverHeight);
		if (altitudeProtection)
		{
			Vector3 val = rigidBody.velocity;
			Vector3 val2;
			if (!(((Vector3)(ref val)).magnitude < 0.1f))
			{
				val = rigidBody.velocity;
				val2 = ((Vector3)(ref val)).normalized;
			}
			else
			{
				val2 = ((Component)this).transform.forward;
			}
			Vector3 val3 = val2;
			val = Vector3.Cross(Vector3.Cross(((Component)this).transform.up, val3), Vector3.up) + Vector3.down * 0.3f;
			Vector3 normalized = ((Vector3)(ref val)).normalized;
			RaycastHit val4 = default(RaycastHit);
			RaycastHit val5 = default(RaycastHit);
			if (Physics.SphereCast(((Component)this).transform.position - normalized * 20f, 20f, normalized, ref val4, 75f, 1218511105) && Physics.SphereCast(((RaycastHit)(ref val4)).point + Vector3.up * 200f, 20f, Vector3.down, ref val5, 200f, 1218511105))
			{
				num = ((RaycastHit)(ref val5)).point.y + hoverHeight;
			}
		}
		altOverride = num;
		return altOverride;
	}

	public override void SetDefaultInputState()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_0321: Unknown result type (might be due to invalid IL or missing references)
		//IL_0309: Unknown result type (might be due to invalid IL or missing references)
		//IL_0314: Unknown result type (might be due to invalid IL or missing references)
		//IL_0319: Unknown result type (might be due to invalid IL or missing references)
		//IL_0326: Unknown result type (might be due to invalid IL or missing references)
		//IL_0349: Unknown result type (might be due to invalid IL or missing references)
		//IL_0331: Unknown result type (might be due to invalid IL or missing references)
		//IL_033c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0341: Unknown result type (might be due to invalid IL or missing references)
		//IL_034e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0350: Unknown result type (might be due to invalid IL or missing references)
		//IL_0351: Unknown result type (might be due to invalid IL or missing references)
		//IL_035a: Unknown result type (might be due to invalid IL or missing references)
		//IL_035b: Unknown result type (might be due to invalid IL or missing references)
		currentInputState.Reset();
		Vector3 moveTarget = GetMoveTarget();
		Vector3 val = Vector3.Cross(((Component)this).transform.right, Vector3.up);
		Vector3 val2 = Vector3.Cross(Vector3.up, val);
		float num = 0f - Vector3.Dot(Vector3.up, ((Component)this).transform.right);
		float num2 = Vector3.Dot(Vector3.up, ((Component)this).transform.forward);
		float num3 = Vector3Ex.Distance2D(((Component)this).transform.position, moveTarget);
		float y = ((Component)this).transform.position.y;
		float num4 = currentDesiredAltitude;
		Vector3 val3 = ((Component)this).transform.position + ((Component)this).transform.forward * 10f;
		val3.y = num4;
		Vector3 val4 = Vector3Ex.Direction2D(moveTarget, ((Component)this).transform.position);
		float num5 = 0f - Vector3.Dot(val4, val2);
		float num6 = Vector3.Dot(val4, val);
		float num7 = Mathf.InverseLerp(0f, 25f, num3);
		if (num6 > 0f)
		{
			float num8 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num2);
			currentInputState.pitch = 1f * num6 * num8 * num7;
		}
		else
		{
			float num9 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num2);
			currentInputState.pitch = 1f * num6 * num9 * num7;
		}
		if (num5 > 0f)
		{
			float num10 = Mathf.InverseLerp(0f - maxTiltAngle, 0f, num);
			currentInputState.roll = 1f * num5 * num10 * num7;
		}
		else
		{
			float num11 = 1f - Mathf.InverseLerp(0f, maxTiltAngle, num);
			currentInputState.roll = 1f * num5 * num11 * num7;
		}
		float num12 = Mathf.Abs(num4 - y);
		float num13 = 1f - Mathf.InverseLerp(10f, 30f, num12);
		currentInputState.pitch *= num13;
		currentInputState.roll *= num13;
		float num14 = maxTiltAngle;
		float num15 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.pitch) * num14, num14 + Mathf.Abs(currentInputState.pitch) * num14, Mathf.Abs(num2));
		currentInputState.pitch += num15 * ((num2 < 0f) ? (-1f) : 1f);
		float num16 = Mathf.InverseLerp(0f + Mathf.Abs(currentInputState.roll) * num14, num14 + Mathf.Abs(currentInputState.roll) * num14, Mathf.Abs(num));
		currentInputState.roll += num16 * ((num < 0f) ? (-1f) : 1f);
		if (aimDirOverride || num3 > 30f)
		{
			Vector3 val5 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			Vector3 val6 = (aimDirOverride ? GetAimDirectionOverride() : Vector3Ex.Direction2D(GetMoveTarget(), ((Component)this).transform.position));
			float num17 = Vector3.Dot(val2, val5);
			float num18 = Vector3.Angle(val, val6);
			float num19 = Mathf.InverseLerp(0f, 70f, Mathf.Abs(num18));
			currentInputState.yaw = ((num17 > 0f) ? 1f : 0f);
			currentInputState.yaw -= ((num17 < 0f) ? 1f : 0f);
			currentInputState.yaw *= num19;
		}
		float throttle = Mathf.InverseLerp(5f, 30f, num3);
		currentInputState.throttle = throttle;
	}

	public void MaintainAIAltutide()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = ((Component)this).transform.position + rigidBody.velocity;
		float num = currentDesiredAltitude;
		float y = val.y;
		float num2 = Mathf.Abs(num - y);
		bool flag = num > y;
		float num3 = Mathf.InverseLerp(0f, 10f, num2) * AiAltitudeForce * (flag ? 1f : (-1f));
		rigidBody.AddForce(Vector3.up * num3, (ForceMode)0);
	}

	public override void VehicleFixedUpdate()
	{
		TimeWarning val = TimeWarning.New("CH47HeliAI.VehicleFixedUpdate", 0);
		try
		{
			hoverForceScale = 1f;
			base.VehicleFixedUpdate();
			SetFlag(Flags.Reserved5, TOD_Sky.Instance.IsNight);
			CalculateDesiredAltitude();
			MaintainAIAltutide();
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void DestroyShared()
	{
		if (base.isServer)
		{
			foreach (MountPointInfo mountPoint in mountPoints)
			{
				if ((Object)(object)mountPoint.mountable != (Object)null)
				{
					BasePlayer mounted = mountPoint.mountable.GetMounted();
					if (Object.op_Implicit((Object)(object)mounted) && (Object)(object)((Component)mounted).transform != (Object)null && !mounted.IsDestroyed && !mounted.IsDead() && mounted.IsNpc)
					{
						mounted.Kill();
					}
				}
			}
		}
		base.DestroyShared();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47LandingZone : MonoBehaviour
{
	public float lastDropTime;

	public static List<CH47LandingZone> landingZones = new List<CH47LandingZone>();

	public float dropoffScale = 1f;

	public static bool HasAnyLandingZones => !landingZones.IsNullOrEmpty();

	public void Awake()
	{
		if (!landingZones.Contains(this))
		{
			landingZones.Add(this);
		}
	}

	public static CH47LandingZone GetClosest(Vector3 pos)
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		float num = float.PositiveInfinity;
		CH47LandingZone result = null;
		foreach (CH47LandingZone landingZone in landingZones)
		{
			float num2 = Vector3Ex.Distance2D(pos, ((Component)landingZone).transform.position);
			if (num2 < num)
			{
				num = num2;
				result = landingZone;
			}
		}
		return result;
	}

	public void OnDestroy()
	{
		if (landingZones.Contains(this))
		{
			landingZones.Remove(this);
		}
	}

	public float TimeSinceLastDrop()
	{
		return Time.time - lastDropTime;
	}

	public void Used()
	{
		lastDropTime = Time.time;
	}

	public void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		Color magenta = Color.magenta;
		magenta.a = 0.25f;
		Gizmos.color = magenta;
		GizmosUtil.DrawCircleY(((Component)this).transform.position, 6f);
		magenta.a = 1f;
		Gizmos.color = magenta;
		GizmosUtil.DrawWireCircleY(((Component)this).transform.position, 6f);
	}
}


using System.Collections.Generic;
using UnityEngine;

public class CH47PathFinder : BasePathFinder
{
	public List<Vector3> visitedPatrolPoints = new List<Vector3>();

	public override Vector3 GetRandomPatrolPoint()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_016e: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0156: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_016b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_022d: Unknown result type (might be due to invalid IL or missing references)
		//IL_020c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3.zero;
		MonumentInfo monumentInfo = null;
		if ((Object)(object)TerrainMeta.Path != (Object)null && TerrainMeta.Path.Monuments != null && TerrainMeta.Path.Monuments.Count > 0)
		{
			int count = TerrainMeta.Path.Monuments.Count;
			int num = Random.Range(0, count);
			for (int i = 0; i < count; i++)
			{
				int num2 = i + num;
				if (num2 >= count)
				{
					num2 -= count;
				}
				MonumentInfo monumentInfo2 = TerrainMeta.Path.Monuments[num2];
				if (monumentInfo2.Type == MonumentType.Cave || monumentInfo2.Type == MonumentType.WaterWell || monumentInfo2.Tier == MonumentTier.Tier0 || monumentInfo2.IsSafeZone || (monumentInfo2.Tier & MonumentTier.Tier0) > (MonumentTier)0)
				{
					continue;
				}
				bool flag = false;
				foreach (Vector3 visitedPatrolPoint in visitedPatrolPoints)
				{
					if (Vector3Ex.Distance2D(((Component)monumentInfo2).transform.position, visitedPatrolPoint) < 100f)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					monumentInfo = monumentInfo2;
					break;
				}
			}
			if ((Object)(object)monumentInfo == (Object)null)
			{
				visitedPatrolPoints.Clear();
				monumentInfo = GetRandomValidMonumentInfo();
			}
		}
		if ((Object)(object)monumentInfo != (Object)null)
		{
			visitedPatrolPoints.Add(((Component)monumentInfo).transform.position);
			val = ((Component)monumentInfo).transform.position;
		}
		else
		{
			float x = TerrainMeta.Size.x;
			float y = 30f;
			val = Vector3Ex.Range(-1f, 1f);
			val.y = 0f;
			((Vector3)(ref val)).Normalize();
			val *= x * Random.Range(0f, 0.75f);
			val.y = y;
		}
		float waterOrTerrainSurface = WaterLevel.GetWaterOrTerrainSurface(val, waves: false, volumes: false);
		float num3 = waterOrTerrainSurface;
		RaycastHit val2 = default(RaycastHit);
		if (Physics.SphereCast(val + new Vector3(0f, 200f, 0f), 20f, Vector3.down, ref val2, 300f, 1218511105))
		{
			num3 = Mathf.Max(((RaycastHit)(ref val2)).point.y, waterOrTerrainSurface);
		}
		val.y = num3 + 30f;
		return val;
	}

	private MonumentInfo GetRandomValidMonumentInfo()
	{
		int count = TerrainMeta.Path.Monuments.Count;
		int num = Random.Range(0, count);
		for (int i = 0; i < count; i++)
		{
			int num2 = i + num;
			if (num2 >= count)
			{
				num2 -= count;
			}
			MonumentInfo monumentInfo = TerrainMeta.Path.Monuments[num2];
			if (monumentInfo.Type != 0 && monumentInfo.Type != MonumentType.WaterWell && monumentInfo.Tier != MonumentTier.Tier0 && !monumentInfo.IsSafeZone)
			{
				return monumentInfo;
			}
		}
		return null;
	}
}


using UnityEngine;

public class CH47ReinforcementListener : BaseEntity
{
	public string listenString;

	public GameObjectRef heliPrefab;

	public float startDist = 300f;

	public override void OnEntityMessage(BaseEntity from, string msg)
	{
		if (msg == listenString)
		{
			Call();
		}
	}

	public void Call()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		TryCall(heliPrefab.resourcePath, ((Component)this).transform.position, startDist);
	}

	public static bool TryCall(string resourcePath, Vector3 ourPos, float startDist)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0089: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		CH47HelicopterAIController component = ((Component)GameManager.server.CreateEntity(resourcePath)).GetComponent<CH47HelicopterAIController>();
		if (!Object.op_Implicit((Object)(object)component))
		{
			return false;
		}
		_ = TerrainMeta.Size;
		CH47LandingZone closest = CH47LandingZone.GetClosest(ourPos);
		if ((Object)(object)closest == (Object)null)
		{
			return false;
		}
		Vector3 zero = Vector3.zero;
		zero.y = ((Component)closest).transform.position.y;
		Vector3 val = Vector3Ex.Direction2D(((Component)closest).transform.position, zero);
		Vector3 position = ((Component)closest).transform.position + val * startDist;
		position.y = ((Component)closest).transform.position.y;
		((Component)component).transform.position = position;
		component.SetLandingTarget(((Component)closest).transform.position);
		component.Spawn();
		return true;
	}
}


public class Minicopter : PlayerHelicopter
{
	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;
}


using UnityEngine;

public class MiniCopterAnimation : MonoBehaviour
{
	public void UpdateRotorSpeed(float newSpeed)
	{
	}

	private void Update()
	{
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Serialization;

public class PlayerHeliSounds : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class FlightSoundLayer
	{
		public SoundDefinition loopDefinition;

		public SoundDefinition startDefinition;

		public SoundDefinition stopDefinition;

		public Transform targetParent;

		public float fadeTime = 0.25f;

		public float initialGain = 1f;

		public float gainRateUp = 5f;

		public float gainRateDown = 5f;

		public float gainInterpRate = 0.5f;

		public float initialPitch = 1f;

		public float pitchRateUp = 5f;

		public float pitchRateDown = 5f;

		public float pitchInterpRate = 0.5f;

		public bool returnToInitialWhenTurnedOff;

		public bool useUpDotPitchCurve;

		public AnimationCurve upDotPitchCurve;
	}

	[FormerlySerializedAs("miniCopter")]
	public PlayerHelicopter miniCopter;

	public GameObject soundAttachPoint;

	public List<FlightSoundLayer> flightSoundLayers = new List<FlightSoundLayer>();

	public SoundDefinition engineStartDef;

	public SoundDefinition engineLoopDef;

	public SoundDefinition engineStopDef;

	public SoundDefinition rotorLoopDef;

	public SoundDefinition radarWarningDef;

	public SoundDefinition radarLockDef;

	public SoundDefinition noAmmoDef;

	public SoundDefinition noFlaresDef;

	public SoundDefinition flaresReadyDef;

	public SoundDefinition flightControlMovementSoundDef;

	public GameObject flightControlSoundPosition;

	public float engineStartFadeOutTime = 1f;

	public float engineLoopFadeInTime = 0.7f;

	public float engineLoopFadeOutTime = 0.25f;

	public float engineStopFadeOutTime = 0.25f;

	public float rotorLoopFadeInTime = 0.7f;

	public float rotorLoopFadeOutTime = 0.25f;

	public float enginePitchInterpRate = 0.5f;

	public float rotorPitchInterpRate = 1f;

	public float rotorGainInterpRate = 0.5f;

	public float rotorStartStopPitchRateUp = 7f;

	public float rotorStartStopPitchRateDown = 9f;

	public float rotorStartStopGainRateUp = 5f;

	public float rotorStartStopGainRateDown = 4f;

	public AnimationCurve engineUpDotPitchCurve;

	public AnimationCurve rotorUpDotPitchCurve;

	public Animator animator;

	public SoundDefinition reloadStartSoundDef;

	public SoundDefinition reloadLoopSoundDef;

	public SoundDefinition reloadFinishSoundDef;
}


using System;
using UnityEngine;

[Serializable]
public class FlightSoundLayer
{
	public SoundDefinition loopDefinition;

	public SoundDefinition startDefinition;

	public SoundDefinition stopDefinition;

	public Transform targetParent;

	public float fadeTime = 0.25f;

	public float initialGain = 1f;

	public float gainRateUp = 5f;

	public float gainRateDown = 5f;

	public float gainInterpRate = 0.5f;

	public float initialPitch = 1f;

	public float pitchRateUp = 5f;

	public float pitchRateDown = 5f;

	public float pitchInterpRate = 0.5f;

	public bool returnToInitialWhenTurnedOff;

	public bool useUpDotPitchCurve;

	public AnimationCurve upDotPitchCurve;
}


using System;
using Rust;
using UnityEngine;

public class ScrapTransportHelicopter : PlayerHelicopter, TriggerHurtNotChild.IHurtTriggerUser
{
	[SerializeField]
	private Transform searchlightEye;

	[SerializeField]
	private BoxCollider parentTriggerCollider;

	[Header("Damage Effects")]
	[SerializeField]
	private ParticleSystemContainer tailDamageLight;

	[SerializeField]
	private ParticleSystemContainer tailDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageLight;

	[SerializeField]
	private ParticleSystemContainer mainEngineDamageHeavy;

	[SerializeField]
	private ParticleSystemContainer cockpitSparks;

	[SerializeField]
	private Transform tailDamageLightEffects;

	[SerializeField]
	private Transform mainEngineDamageLightEffects;

	[SerializeField]
	private SoundDefinition damagedFireSoundDef;

	[SerializeField]
	private SoundDefinition damagedFireTailSoundDef;

	[SerializeField]
	private SoundDefinition damagedSparksSoundDef;

	[SerializeField]
	private float pilotRotorScale = 1.5f;

	[SerializeField]
	private float compassOffset;

	[ServerVar(Help = "Population active on the server", ShowInAdminUI = true)]
	public static float population;

	public const string PASSENGER_ACHIEVEMENT = "RUST_AIR";

	public const int PASSENGER_ACHIEVEMENT_REQ_COUNT = 5;

	public override void ServerInit()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		base.ServerInit();
		rigidBody.inertiaTensor = new Vector3(19082f, 14356f, 7940f);
	}

	public override void OnHealthChanged(float oldvalue, float newvalue)
	{
		if (base.isServer)
		{
			((FacepunchBehaviour)this).Invoke((Action)DelayedNetworking, 0.15f);
		}
	}

	public void DelayedNetworking()
	{
		SendNetworkUpdate();
	}

	public override void OnFlagsChanged(Flags old, Flags next)
	{
		base.OnFlagsChanged(old, next);
		if (!GameInfo.HasAchievements || !base.isServer || old.HasFlag(Flags.On) || !next.HasFlag(Flags.On) || !((Object)(object)GetDriver() != (Object)null))
		{
			return;
		}
		int num = 0;
		foreach (BaseEntity child in children)
		{
			if ((Object)(object)child.ToPlayer() != (Object)null)
			{
				num++;
			}
			if (child is BaseVehicleSeat baseVehicleSeat && (Object)(object)baseVehicleSeat.GetMounted() != (Object)null && (Object)(object)baseVehicleSeat.GetMounted() != (Object)(object)GetDriver())
			{
				num++;
			}
		}
		if (num >= 5)
		{
			GetDriver().GiveAchievement("RUST_AIR");
		}
	}

	public float GetDamageMultiplier(BaseEntity ent)
	{
		return 1f;
	}

	public void OnHurtTriggerOccupant(BaseEntity hurtEntity, DamageType damageType, float damageTotal)
	{
	}

	protected override bool CanPushNow(BasePlayer pusher)
	{
		return false;
	}
}


using UnityEngine;

public class ScrapTransportHelicopterWheelEffects : MonoBehaviour, IServerComponent
{
	public WheelCollider wheelCollider;

	public GameObjectRef impactEffect;

	public float minTimeBetweenEffects = 0.25f;

	public float minDistBetweenEffects = 0.1f;

	private bool wasGrounded;

	private float lastEffectPlayed;

	private Vector3 lastCollisionPos;

	public void Update()
	{
		bool isGrounded = wheelCollider.isGrounded;
		if (isGrounded && !wasGrounded)
		{
			DoImpactEffect();
		}
		wasGrounded = isGrounded;
	}

	private void DoImpactEffect()
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		if (impactEffect.isValid && !(Time.time < lastEffectPlayed + minTimeBetweenEffects) && (!(Vector3.Distance(((Component)this).transform.position, lastCollisionPos) < minDistBetweenEffects) || lastEffectPlayed == 0f))
		{
			Effect.server.Run(impactEffect.resourcePath, ((Component)this).transform.position, ((Component)this).transform.up);
			lastEffectPlayed = Time.time;
			lastCollisionPos = ((Component)this).transform.position;
		}
	}
}


using UnityEngine;

public class AnimalRagdoll : Ragdoll
{
	public SkinnedMeshRenderer[] bodyRenderers;

	public SkinnedMeshRenderer[] hairRenderers;
}


using System;
using Facepunch;
using ProtoBuf;
using UnityEngine;

public class BaseAnimalRagdoll : BaseCombatEntity
{
	[SerializeField]
	private Ragdoll Ragdoll;

	private EntityRef<BaseCombatEntity> linkedEntity;

	public override float PositionTickRate
	{
		protected get
		{
			return 0.05f;
		}
	}

	public override void Save(SaveInfo info)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		base.Save(info);
		info.msg.temporaryRagdoll = Pool.Get<TemporaryRagdoll>();
		if (linkedEntity.IsValid(base.isServer))
		{
			info.msg.temporaryRagdoll.parentID = linkedEntity.uid;
		}
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.temporaryRagdoll != null)
		{
			Load(info.msg.temporaryRagdoll);
		}
	}

	private void Load(TemporaryRagdoll tempRagdoll)
	{
	}

	private void LateUpdate()
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		BaseCombatEntity baseCombatEntity = linkedEntity.Get(base.isServer);
		if (base.isServer)
		{
			if ((Object)(object)baseCombatEntity == (Object)null || baseCombatEntity.IsDead())
			{
				Kill();
				return;
			}
			((Component)baseCombatEntity).transform.position = ((Component)this).transform.position;
			((Component)baseCombatEntity).transform.rotation = ((Component)this).transform.rotation;
			SendNetworkUpdateImmediate();
		}
	}

	public override void ServerInit()
	{
		base.ServerInit();
		Rigidbody val = ((Component)this).GetComponent<Rigidbody>();
		if ((Object)(object)val == (Object)null)
		{
			val = ((Component)this).gameObject.AddComponent<Rigidbody>();
			val.mass = 10f;
			val.drag = 0f;
			val.angularDrag = 0f;
		}
		val.useGravity = true;
		val.collisionDetectionMode = (CollisionDetectionMode)0;
		val.sleepThreshold = Mathf.Max(0.05f, Physics.sleepThreshold);
	}

	public void InitFromEnt(BaseCombatEntity ent)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		linkedEntity.Set(ent);
		ent.model.skeleton.CopyTo(model.skeleton);
		((Component)this).transform.SetPositionAndRotation(((Component)ent).transform.position, ((Component)ent).transform.rotation);
		Ragdoll.ServerInit();
		Vector3 worldVelocity = ent.GetWorldVelocity();
		foreach (Rigidbody rigidbody in Ragdoll.rigidbodies)
		{
			rigidbody.AddForce(worldVelocity, (ForceMode)2);
			rigidbody.drag = 0f;
		}
		((FacepunchBehaviour)this).Invoke((Action)StopRagdolling, 5f);
	}

	private void StopRagdolling()
	{
		linkedEntity.Get(serverside: true)?.SetFlag(Flags.Reserved12, b: false);
		Kill();
	}

	public override void OnCollision(Collision collision, BaseEntity hitEntity)
	{
		ProcessCollision(collision);
	}

	protected void OnCollisionEnter(Collision collision)
	{
		ProcessCollision(collision);
	}

	protected void ProcessCollision(Collision collision)
	{
		if (!base.isClient && collision != null && !((Object)(object)collision.gameObject == (Object)null) && !((Object)(object)collision.gameObject == (Object)null) && linkedEntity.Get(serverside: true) is IAnimalRagdollCollisionReceiver animalRagdollCollisionReceiver)
		{
			animalRagdollCollisionReceiver.OnRagdollCollisionEnter(collision);
		}
	}
}


using UnityEngine;

public interface IAnimalRagdollCollisionReceiver
{
	void OnRagdollCollisionEnter(Collision collision);
}


using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Horse Breed", fileName = "newbreed.asset")]
public class HorseBreed : ScriptableObject
{
	public Phrase breedName;

	public Phrase breedDesc;

	public Sprite trophyHeadSprite;

	public Material[] materialOverrides;

	public float maxHealth = 1f;

	public float maxSpeed = 1f;

	public float staminaDrain = 1f;

	public float maxStamina = 1f;
}


using Facepunch;
using ProtoBuf;

public class HorseCorpse : LootableCorpse
{
	public int breedIndex;

	public Phrase lootPanelTitle;

	public override string playerName => lootPanelTitle.translated;

	public override void Save(SaveInfo info)
	{
		base.Save(info);
		info.msg.horse = Pool.Get<Horse>();
		info.msg.horse.breedIndex = breedIndex;
	}

	public override void Load(LoadInfo info)
	{
		base.Load(info);
		if (info.msg.horse != null)
		{
			breedIndex = info.msg.horse.breedIndex;
		}
	}
}


public class HorseLeadingRope : FakePhysicsRope
{
}


using UnityEngine;

public class HorseRagdoll : AnimalRagdoll
{
	public GameObject mane;

	public GameObject woodArmor;

	public GameObject roadsignArmor;

	public HorseBreed overrideBreed;

	public GameObject singleSaddle;

	public GameObject doubleSaddle;

	public GameObjectRef breedSource;
}


using UnityEngine;

public class HorseSaddle : BaseVehicleSeat
{
	public override void VehicleFixedUpdate()
	{
	}

	public override void OnPlayerMounted()
	{
		base.OnPlayerMounted();
		BasePlayer mounted = GetMounted();
		if ((Object)(object)mounted != (Object)null)
		{
			BaseVehicle baseVehicle = VehicleParent();
			if ((Object)(object)baseVehicle != (Object)null)
			{
				baseVehicle.PlayerMounted(mounted, this);
			}
		}
	}
}


public interface IHorseInputProvider
{
	float GetMoveInput();

	float GetSteerInput();
}


using UnityEngine;

public class AIHorseInputProvider : IHorseInputProvider
{
	private Transform playerTransform;

	private RidableHorse horse;

	private float followSpeed;

	private float stoppingDistance;

	private float turnChangeCooldown = 0.3f;

	private float turnCooldownTimer;

	private float currentSteerInput;

	public AIHorseInputProvider(RidableHorse horse, Transform playerTransform, float stoppingDistance)
	{
		this.horse = horse;
		this.playerTransform = playerTransform;
		this.stoppingDistance = stoppingDistance;
	}

	public float GetMoveInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		float magnitude = ((Vector3)(ref val)).magnitude;
		if (horse.GetSpeed() > 2f)
		{
			return -1f;
		}
		if (magnitude > stoppingDistance)
		{
			return Mathf.Clamp(((Component)horse).transform.InverseTransformDirection(((Vector3)(ref val)).normalized).z, 0f, 1f);
		}
		return 0f;
	}

	public float GetSteerInput()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = playerTransform.position - ((Component)horse).transform.position;
		val.y = 0f;
		if (((Vector3)(ref val)).magnitude > stoppingDistance - 2f)
		{
			Vector3 val2 = Vector3.Cross(((Component)horse).transform.forward, ((Vector3)(ref val)).normalized);
			int num = 0;
			if (val2.y > 0.4f)
			{
				num = 1;
			}
			else if (val2.y < -0.4f)
			{
				num = -1;
			}
			Quaternion val3 = Quaternion.LookRotation(val);
			float num2 = Quaternion.Angle(((Component)horse).transform.rotation, val3);
			if (num2 > 160f && num2 < 180f)
			{
				num = -1;
			}
			if ((float)num != currentSteerInput && turnCooldownTimer <= 0f)
			{
				currentSteerInput = num;
				turnCooldownTimer = turnChangeCooldown;
			}
		}
		else if (currentSteerInput != 0f && turnCooldownTimer <= 0f)
		{
			currentSteerInput = 0f;
			turnCooldownTimer = turnChangeCooldown;
		}
		if (turnCooldownTimer > 0f)
		{
			turnCooldownTimer -= Time.fixedDeltaTime;
		}
		return currentSteerInput;
	}
}


public class PlayerHorseInputProvider : IHorseInputProvider
{
	public BasePlayer player;

	public PlayerHorseInputProvider(BasePlayer player)
	{
		this.player = player;
	}

	public float GetMoveInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.FORWARD))
		{
			result = 1f;
		}
		else if (player.serverInput.IsDown(BUTTON.BACKWARD))
		{
			result = -1f;
		}
		return result;
	}

	public float GetSteerInput()
	{
		float result = 0f;
		if (player.serverInput.IsDown(BUTTON.LEFT))
		{
			result = -1f;
		}
		else if (player.serverInput.IsDown(BUTTON.RIGHT))
		{
			result = 1f;
		}
		return result;
	}
}


using UnityEngine;

[DefaultExecutionOrder(-1302)]
public class RidableHorseAnimation : EntityComponent<RidableHorse>, IClientComponent
{
}


using UnityEngine;

public class RidableHorseAudio : FacepunchBehaviour, IClientComponent
{
	[SerializeField]
	private RidableHorse horse;

	[SerializeField]
	private Animator animator;

	[Space]
	[SerializeField]
	public SoundPlayer breathingSound;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDef;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefWood;

	[SerializeField]
	private SoundDefinition saddleMovementSoundDefRoadsign;

	[SerializeField]
	private AnimationCurve saddleMovementGainCurve;

	[SerializeField]
	[Space]
	private MaterialEffect footstepEffects;

	[SerializeField]
	private Transform[] feet;

	[SerializeField]
	[Space]
	private GameObjectRef swimmingSloshEffect;

	[SerializeField]
	private string BaseFolder;

	[Space]
	[SerializeField]
	private SoundDefinition skidLoopSoundDef;

	[SerializeField]
	private AnimationCurve skidLoopGainCurve;
}


using UnityEngine;

[DefaultExecutionOrder(-1300)]
public class RidableHorseSiegeHarness : EntityComponent<RidableHorse>, IClientComponent
{
	[SerializeField]
	private Transform[] targetBone;

	[SerializeField]
	private Transform[] constrainedBone;

	[SerializeField]
	private Vector3 rotationOffset;

	private void LookAtBone(int index)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		if (targetBone != null && constrainedBone != null)
		{
			Vector3 val = targetBone[index].position - constrainedBone[index].position;
			if (!(val == Vector3.zero))
			{
				Quaternion val2 = Quaternion.LookRotation(val);
				Quaternion val3 = Quaternion.Euler(rotationOffset);
				Quaternion rotation = val2 * val3;
				constrainedBone[index].rotation = rotation;
			}
		}
	}

	private void LateUpdate()
	{
		LookAtBone(0);
		LookAtBone(1);
	}
}


using UnityEngine;

public class HumanFuelSystem : IFuelSystem
{
	private readonly bool isServer;

	private float percentFood;

	private EntityRef<BaseVehicle> vehilceRef;

	private float pendingFuel;

	public HumanFuelSystem(bool isServer, BaseVehicle owner, float percentFood)
	{
		this.isServer = isServer;
		this.percentFood = Mathf.Clamp01(percentFood);
		vehilceRef.Set(owner);
	}

	public bool HasValidInstance(bool isServer)
	{
		return vehilceRef.IsValid(isServer);
	}

	public NetworkableId GetInstanceID()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		return vehilceRef.uid;
	}

	public void SetInstanceID(NetworkableId uid)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		vehilceRef.uid = uid;
	}

	private BaseVehicle GetVehilce()
	{
		BaseVehicle baseVehicle = vehilceRef.Get(isServer);
		if (baseVehicle.IsValid())
		{
			return baseVehicle;
		}
		return null;
	}

	public int GetFuelCapacity()
	{
		return 0;
	}

	public bool CheckNewChild(BaseEntity child)
	{
		return false;
	}

	public int GetFuelAmount()
	{
		if (TryGetHuman(out var driver))
		{
			float value = driver.metabolism.calories.value;
			float value2 = driver.metabolism.hydration.value;
			return Mathf.FloorToInt(value + value2);
		}
		return 0;
	}

	public float GetFuelFraction()
	{
		if (TryGetHuman(out var driver))
		{
			float num = driver.metabolism.calories.Fraction() * percentFood;
			float num2 = driver.metabolism.hydration.Fraction() * (1f - percentFood);
			return num + num2;
		}
		return 0f;
	}

	public bool HasFuel(bool forceCheck = false)
	{
		if (!TryGetHuman(out var driver))
		{
			return false;
		}
		if (percentFood == 0f)
		{
			return driver.metabolism.hydration.Fraction() > 0f;
		}
		if (percentFood == 1f)
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		if (!(driver.metabolism.hydration.Fraction() > 0f))
		{
			return driver.metabolism.calories.Fraction() > 0f;
		}
		return true;
	}

	public int TryUseFuel(float seconds, float fuelUsedPerSecond)
	{
		if (!TryGetHuman(out var driver))
		{
			return 0;
		}
		pendingFuel += seconds + fuelUsedPerSecond;
		if (pendingFuel >= 1f)
		{
			MetabolismAttribute calories = driver.metabolism.calories;
			MetabolismAttribute hydration = driver.metabolism.hydration;
			float val = fuelUsedPerSecond * percentFood;
			float val2 = fuelUsedPerSecond * (1f - percentFood);
			float value = calories.value;
			calories.Subtract(val);
			pendingFuel -= Mathf.RoundToInt(value - calories.value);
			float value2 = hydration.value;
			hydration.Subtract(val2);
			pendingFuel -= Mathf.RoundToInt(value2 - hydration.value);
		}
		return 0;
	}

	public void LootFuel(BasePlayer player)
	{
	}

	public void AddFuel(int amount)
	{
	}

	public void RemoveFuel(int amount)
	{
	}

	public void FillFuel()
	{
	}

	private bool TryGetHuman(out BasePlayer driver)
	{
		driver = null;
		BaseVehicle vehilce = GetVehilce();
		if ((Object)(object)vehilce != (Object)null)
		{
			driver = vehilce.GetDriver();
		}
		return (Object)(object)driver != (Object)null;
	}
}


public interface IFuelSystem
{
	bool HasValidInstance(bool isServer);

	NetworkableId GetInstanceID();

	void SetInstanceID(NetworkableId uid);

	bool CheckNewChild(BaseEntity child);

	int GetFuelAmount();

	float GetFuelFraction();

	bool HasFuel(bool forceCheck = false);

	int TryUseFuel(float seconds, float fuelUsedPerSecond);

	int GetFuelCapacity();

	void LootFuel(BasePlayer player);

	void AddFuel(int amount);

	void RemoveFuel(int amount);

	void FillFuel();
}


public interface IMountable
{
}


