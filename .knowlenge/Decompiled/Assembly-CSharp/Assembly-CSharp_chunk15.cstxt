using System.Collections.Generic;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class FoliageGridMeshData
{
	public struct FoliageVertex
	{
		public Vector3 position;

		public Vector3 normal;

		public Vector4 tangent;

		public Color32 color;

		public Vector2 uv;

		public Vector4 uv2;

		public static readonly VertexAttributeDescriptor[] VertexLayout = (VertexAttributeDescriptor[])(object)new VertexAttributeDescriptor[6]
		{
			new VertexAttributeDescriptor((VertexAttribute)0, (VertexAttributeFormat)0, 3, 0),
			new VertexAttributeDescriptor((VertexAttribute)1, (VertexAttributeFormat)0, 3, 0),
			new VertexAttributeDescriptor((VertexAttribute)2, (VertexAttributeFormat)0, 4, 0),
			new VertexAttributeDescriptor((VertexAttribute)3, (VertexAttributeFormat)2, 4, 0),
			new VertexAttributeDescriptor((VertexAttribute)4, (VertexAttributeFormat)0, 2, 0),
			new VertexAttributeDescriptor((VertexAttribute)6, (VertexAttributeFormat)0, 4, 0)
		};
	}

	public List<FoliageVertex> vertices;

	public List<int> triangles;

	public Bounds bounds;

	public void Alloc()
	{
		if (triangles == null)
		{
			triangles = Pool.Get<List<int>>();
		}
		if (vertices == null)
		{
			vertices = Pool.Get<List<FoliageVertex>>();
		}
	}

	public void Free()
	{
		if (triangles != null)
		{
			Pool.FreeUnmanaged<int>(ref triangles);
		}
		if (vertices != null)
		{
			Pool.FreeUnmanaged<FoliageVertex>(ref vertices);
		}
	}

	public void Clear()
	{
		triangles?.Clear();
		vertices?.Clear();
	}

	public void Combine(MeshGroup meshGroup)
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_020d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0212: Unknown result type (might be due to invalid IL or missing references)
		//IL_0217: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f5: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_0115: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Unknown result type (might be due to invalid IL or missing references)
		//IL_014e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_015c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_0168: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		if (((List<MeshInstance>)(object)meshGroup).Count == 0)
		{
			return;
		}
		bounds = new Bounds(((List<MeshInstance>)(object)meshGroup)[0].position, Vector3.zero);
		Vector3 val3 = default(Vector3);
		for (int i = 0; i < ((List<MeshInstance>)(object)meshGroup).Count; i++)
		{
			MeshInstance meshInstance = ((List<MeshInstance>)(object)meshGroup)[i];
			Matrix4x4 val = Matrix4x4.TRS(meshInstance.position, meshInstance.rotation, meshInstance.scale);
			int count = vertices.Count;
			for (int j = 0; j < meshInstance.data.triangles.Length; j++)
			{
				triangles.Add(count + meshInstance.data.triangles[j]);
			}
			for (int k = 0; k < meshInstance.data.vertices.Length; k++)
			{
				Vector4 val2 = meshInstance.data.tangents[k];
				((Vector3)(ref val3))..ctor(val2.x, val2.y, val2.z);
				Vector3 val4 = ((Matrix4x4)(ref val)).MultiplyVector(val3);
				FoliageVertex item = default(FoliageVertex);
				item.position = ((Matrix4x4)(ref val)).MultiplyPoint3x4(meshInstance.data.vertices[k]);
				item.normal = ((Matrix4x4)(ref val)).MultiplyVector(meshInstance.data.normals[k]);
				item.uv = meshInstance.data.uv[k];
				item.uv2 = Vector4.op_Implicit(meshInstance.position);
				item.tangent = new Vector4(val4.x, val4.y, val4.z, val2.w);
				if (meshInstance.data.colors32.Length != 0)
				{
					item.color = meshInstance.data.colors32[k];
				}
				vertices.Add(item);
			}
			((Bounds)(ref bounds)).Encapsulate(new Bounds(meshInstance.position + ((Bounds)(ref meshInstance.data.bounds)).center, ((Bounds)(ref meshInstance.data.bounds)).size));
		}
		ref Bounds reference = ref bounds;
		((Bounds)(ref reference)).size = ((Bounds)(ref reference)).size + Vector3.one;
	}

	public void Apply(Mesh mesh)
	{
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		mesh.SetVertexBufferParams(vertices.Count, FoliageVertex.VertexLayout);
		mesh.SetVertexBufferData<FoliageVertex>(vertices, 0, 0, vertices.Count, 0, (MeshUpdateFlags)9);
		mesh.SetIndices(triangles, (MeshTopology)0, 0, false, 0);
		mesh.bounds = bounds;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

public struct FoliageVertex
{
	public Vector3 position;

	public Vector3 normal;

	public Vector4 tangent;

	public Color32 color;

	public Vector2 uv;

	public Vector4 uv2;

	public static readonly VertexAttributeDescriptor[] VertexLayout = (VertexAttributeDescriptor[])(object)new VertexAttributeDescriptor[6]
	{
		new VertexAttributeDescriptor((VertexAttribute)0, (VertexAttributeFormat)0, 3, 0),
		new VertexAttributeDescriptor((VertexAttribute)1, (VertexAttributeFormat)0, 3, 0),
		new VertexAttributeDescriptor((VertexAttribute)2, (VertexAttributeFormat)0, 4, 0),
		new VertexAttributeDescriptor((VertexAttribute)3, (VertexAttributeFormat)2, 4, 0),
		new VertexAttributeDescriptor((VertexAttribute)4, (VertexAttributeFormat)0, 2, 0),
		new VertexAttributeDescriptor((VertexAttribute)6, (VertexAttributeFormat)0, 4, 0)
	};
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class FoliageGridBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private FoliageGridMeshData meshData;

	private MeshGroup meshGroup;

	private bool hasRunAwake;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		hasRunAwake = true;
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new FoliageGridMeshData();
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Invalid comparison between Unknown and I4
		if (!hasRunAwake)
		{
			Awake();
		}
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshData.Clear();
		meshData.Combine(meshGroup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshGroup>(ref meshGroup);
		}
	}
}


using UnityEngine;

public static class GameObjectUtil
{
	public static void GlobalBroadcast(string messageName, object param = null)
	{
		Transform[] rootObjects = TransformUtil.GetRootObjects();
		for (int i = 0; i < rootObjects.Length; i++)
		{
			((Component)rootObjects[i]).BroadcastMessage(messageName, param, (SendMessageOptions)1);
		}
	}
}


using System;
using UnityEngine;

public static class GizmosUtil
{
	public static void DrawWireCircleX(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(0f, 1f, 1f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCircleY(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 0f, 1f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCircleZ(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 1f, 0f));
		Gizmos.DrawWireSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleX(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(0f, 1f, 1f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleY(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 0f, 1f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawCircleZ(Vector3 pos, float radius)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix *= Matrix4x4.TRS(pos, Quaternion.identity, new Vector3(1f, 1f, 0f));
		Gizmos.DrawSphere(Vector3.zero, radius);
		Gizmos.matrix = matrix;
	}

	public static void DrawWireCylinderX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleX(pos - new Vector3(0.5f * height, 0f, 0f), radius);
		DrawWireCircleX(pos + new Vector3(0.5f * height, 0f, 0f), radius);
	}

	public static void DrawWireCylinderY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleY(pos - new Vector3(0f, 0.5f * height, 0f), radius);
		DrawWireCircleY(pos + new Vector3(0f, 0.5f * height, 0f), radius);
	}

	public static void DrawWireCylinderZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleZ(pos - new Vector3(0f, 0f, 0.5f * height), radius);
		DrawWireCircleZ(pos + new Vector3(0f, 0f, 0.5f * height), radius);
	}

	public static void DrawCylinderX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleX(pos - new Vector3(0.5f * height, 0f, 0f), radius);
		DrawCircleX(pos + new Vector3(0.5f * height, 0f, 0f), radius);
	}

	public static void DrawCylinderY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleY(pos - new Vector3(0f, 0.5f * height, 0f), radius);
		DrawCircleY(pos + new Vector3(0f, 0.5f * height, 0f), radius);
	}

	public static void DrawCylinderZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		DrawCircleZ(pos - new Vector3(0f, 0f, 0.5f * height), radius);
		DrawCircleZ(pos + new Vector3(0f, 0f, 0.5f * height), radius);
	}

	public static void DrawWireCapsuleX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0.5f * height, 0f, 0f) + Vector3.right * radius;
		Vector3 val2 = pos + new Vector3(0.5f * height, 0f, 0f) - Vector3.right * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.forward * radius, val2 + Vector3.forward * radius);
		Gizmos.DrawLine(val + Vector3.up * radius, val2 + Vector3.up * radius);
		Gizmos.DrawLine(val + Vector3.back * radius, val2 + Vector3.back * radius);
		Gizmos.DrawLine(val + Vector3.down * radius, val2 + Vector3.down * radius);
	}

	public static void DrawWireCapsuleY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0.5f * height, 0f) + Vector3.up * radius;
		Vector3 val2 = pos + new Vector3(0f, 0.5f * height, 0f) - Vector3.up * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.forward * radius, val2 + Vector3.forward * radius);
		Gizmos.DrawLine(val + Vector3.right * radius, val2 + Vector3.right * radius);
		Gizmos.DrawLine(val + Vector3.back * radius, val2 + Vector3.back * radius);
		Gizmos.DrawLine(val + Vector3.left * radius, val2 + Vector3.left * radius);
	}

	public static void DrawWireCapsuleZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0f, 0.5f * height) + Vector3.forward * radius;
		Vector3 val2 = pos + new Vector3(0f, 0f, 0.5f * height) - Vector3.forward * radius;
		Gizmos.DrawWireSphere(val, radius);
		Gizmos.DrawWireSphere(val2, radius);
		Gizmos.DrawLine(val + Vector3.up * radius, val2 + Vector3.up * radius);
		Gizmos.DrawLine(val + Vector3.right * radius, val2 + Vector3.right * radius);
		Gizmos.DrawLine(val + Vector3.down * radius, val2 + Vector3.down * radius);
		Gizmos.DrawLine(val + Vector3.left * radius, val2 + Vector3.left * radius);
	}

	public static void DrawCapsuleX(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0.5f * height, 0f, 0f);
		Vector3 val2 = pos + new Vector3(0.5f * height, 0f, 0f);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawCapsuleY(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0.5f * height, 0f);
		Vector3 val2 = pos + new Vector3(0f, 0.5f * height, 0f);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawCapsuleZ(Vector3 pos, float radius, float height)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = pos - new Vector3(0f, 0f, 0.5f * height);
		Vector3 val2 = pos + new Vector3(0f, 0f, 0.5f * height);
		Gizmos.DrawSphere(val, radius);
		Gizmos.DrawSphere(val2, radius);
	}

	public static void DrawWireCube(Vector3 pos, Vector3 size, Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix = Matrix4x4.TRS(pos, rot, size);
		Gizmos.DrawWireCube(Vector3.zero, Vector3.one);
		Gizmos.matrix = matrix;
	}

	public static void DrawCube(Vector3 pos, Vector3 size, Quaternion rot)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		Matrix4x4 matrix = Gizmos.matrix;
		Gizmos.matrix = Matrix4x4.TRS(pos, rot, size);
		Gizmos.DrawCube(Vector3.zero, Vector3.one);
		Gizmos.matrix = matrix;
	}

	public static void DrawWirePath(Vector3 a, Vector3 b, float thickness)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		DrawWireCircleY(a, thickness);
		DrawWireCircleY(b, thickness);
		Vector3 val = b - a;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 val2 = Quaternion.Euler(0f, 90f, 0f) * normalized;
		Gizmos.DrawLine(b + val2 * thickness, a + val2 * thickness);
		Gizmos.DrawLine(b - val2 * thickness, a - val2 * thickness);
	}

	public static void DrawSemiCircle(float radius)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0145: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_011b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_012f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_0129: Unknown result type (might be due to invalid IL or missing references)
		float num = radius * (MathF.PI / 180f) * 0.5f;
		Vector3 val = Mathf.Cos(num) * Vector3.forward + Mathf.Sin(num) * Vector3.right;
		Gizmos.DrawLine(Vector3.zero, val);
		Vector3 val2 = Mathf.Cos(0f - num) * Vector3.forward + Mathf.Sin(0f - num) * Vector3.right;
		Gizmos.DrawLine(Vector3.zero, val2);
		float num2 = Mathf.Clamp(radius / 16f, 4f, 64f);
		float num3 = num / num2;
		for (float num4 = num; num4 > 0f; num4 -= num3)
		{
			Vector3 val3 = Mathf.Cos(num4) * Vector3.forward + Mathf.Sin(num4) * Vector3.right;
			Gizmos.DrawLine(Vector3.zero, val3);
			if (val != Vector3.zero)
			{
				Gizmos.DrawLine(val3, val);
			}
			val = val3;
			Vector3 val4 = Mathf.Cos(0f - num4) * Vector3.forward + Mathf.Sin(0f - num4) * Vector3.right;
			Gizmos.DrawLine(Vector3.zero, val4);
			if (val2 != Vector3.zero)
			{
				Gizmos.DrawLine(val4, val2);
			}
			val2 = val4;
		}
		Gizmos.DrawLine(val, val2);
	}

	public static void DrawArrowHead(Vector3 pos, Vector3 dir, float arrowHeadLength = 0.25f, float arrowHeadAngle = 20f)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Quaternion.LookRotation(dir) * Quaternion.Euler(arrowHeadAngle, 0f, 0f) * Vector3.back;
		Vector3 val2 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f - arrowHeadAngle, 0f, 0f) * Vector3.back;
		Vector3 val3 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f, arrowHeadAngle, 0f) * Vector3.back;
		Vector3 val4 = Quaternion.LookRotation(dir) * Quaternion.Euler(0f, 0f - arrowHeadAngle, 0f) * Vector3.back;
		Gizmos.DrawRay(pos + dir, val * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val2 * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val3 * arrowHeadLength);
		Gizmos.DrawRay(pos + dir, val4 * arrowHeadLength);
	}

	public static void DrawMeshes(Transform transform)
	{
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		MeshRenderer[] componentsInChildren = ((Component)transform).GetComponentsInChildren<MeshRenderer>();
		foreach (MeshRenderer val in componentsInChildren)
		{
			if (!((Renderer)val).enabled)
			{
				continue;
			}
			MeshFilter component = ((Component)val).GetComponent<MeshFilter>();
			if (Object.op_Implicit((Object)(object)component))
			{
				Transform transform2 = ((Component)val).transform;
				if ((Object)(object)transform2 != (Object)null && (Object)(object)component != (Object)null && (Object)(object)component.sharedMesh != (Object)null && component.sharedMesh.normals != null && component.sharedMesh.normals.Length != 0)
				{
					Gizmos.DrawMesh(component.sharedMesh, transform2.position, transform2.rotation, transform2.lossyScale);
				}
			}
		}
	}

	public static void DrawBounds(Transform transform)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = transform.GetBounds(includeRenderers: true, includeColliders: false);
		Vector3 lossyScale = transform.lossyScale;
		Quaternion rotation = transform.rotation;
		Vector3 pos = transform.position + rotation * Vector3.Scale(lossyScale, ((Bounds)(ref bounds)).center);
		Vector3 size = Vector3.Scale(lossyScale, ((Bounds)(ref bounds)).size);
		DrawCube(pos, size, rotation);
		DrawWireCube(pos, size, rotation);
	}
}


public class GlobalMessages
{
}


public interface IInventoryChanged
{
}


public interface IPreInventoryChanged
{
}


public interface IViewModeChanged
{
}


public interface IClothingChanged
{
}


public interface IViewModelUpdated
{
}


public interface IBlueprintsChanged
{
}


public interface IItemAmountChanged
{
}


public interface IItemIconChanged
{
}


using System;
using System.Collections.Generic;
using UnityEngine;

public static class HierarchyUtil
{
	public static Dictionary<string, GameObject> rootDict = new Dictionary<string, GameObject>(StringComparer.OrdinalIgnoreCase);

	public static GameObject GetRoot(string strName, bool groupActive = true, bool persistant = false)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Expected O, but got Unknown
		if (rootDict.TryGetValue(strName, out var value))
		{
			if ((Object)(object)value != (Object)null)
			{
				return value;
			}
			rootDict.Remove(strName);
		}
		value = new GameObject(strName);
		value.SetActive(groupActive);
		rootDict.Add(strName, value);
		if (persistant)
		{
			Object.DontDestroyOnLoad((Object)(object)value);
		}
		return value;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class LocalClock
{
	public struct TimedEvent
	{
		public float time;

		public float delta;

		public float variance;

		public Action action;
	}

	public List<TimedEvent> events = new List<TimedEvent>();

	public void Add(float delta, float variance, Action action)
	{
		TimedEvent item = default(TimedEvent);
		item.time = Time.time + delta + Random.Range(0f - variance, variance);
		item.delta = delta;
		item.variance = variance;
		item.action = action;
		events.Add(item);
	}

	public void Tick()
	{
		for (int i = 0; i < events.Count; i++)
		{
			TimedEvent value = events[i];
			if (Time.time > value.time)
			{
				float delta = value.delta;
				float variance = value.variance;
				value.action();
				value.time = Time.time + delta + Random.Range(0f - variance, variance);
				events[i] = value;
			}
		}
	}
}


using System;

public struct TimedEvent
{
	public float time;

	public float delta;

	public float variance;

	public Action action;
}


using Rust;
using UnityEngine;

public abstract class MeshBatch : MonoBehaviour
{
	public bool NeedsRefresh { get; private set; }

	public int Count { get; private set; }

	public int BatchedCount { get; private set; }

	public int VertexCount { get; private set; }

	public abstract int VertexCapacity { get; }

	public abstract int VertexCutoff { get; }

	public int AvailableVertices => Mathf.Clamp(VertexCapacity, VertexCutoff, 65534) - VertexCount;

	protected abstract void AllocMemory();

	protected abstract void FreeMemory();

	protected abstract void RefreshMesh();

	protected abstract void ApplyMesh();

	protected abstract void ToggleMesh(bool state);

	protected abstract void OnPooled();

	public void Alloc()
	{
		AllocMemory();
	}

	public void Free()
	{
		FreeMemory();
	}

	public void Refresh()
	{
		RefreshMesh();
	}

	public void Apply()
	{
		NeedsRefresh = false;
		ApplyMesh();
	}

	public void Display()
	{
		ToggleMesh(state: true);
		BatchedCount = Count;
	}

	public void Invalidate()
	{
		ToggleMesh(state: false);
		BatchedCount = 0;
	}

	protected void AddVertices(int vertices)
	{
		NeedsRefresh = true;
		Count++;
		VertexCount += vertices;
	}

	protected void OnEnable()
	{
		NeedsRefresh = false;
		Count = 0;
		BatchedCount = 0;
		VertexCount = 0;
	}

	protected void OnDisable()
	{
		if (!Application.isQuitting)
		{
			NeedsRefresh = false;
			Count = 0;
			BatchedCount = 0;
			VertexCount = 0;
			OnPooled();
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class MeshDataBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private MeshData meshData;

	private MeshGroup meshGroup;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new MeshData();
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Invalid comparison between Unknown and I4
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshData.Clear();
		meshData.Combine(meshGroup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshGroup>(ref meshGroup);
		}
	}
}


using System.Collections.Generic;
using ConVar;
using Facepunch;
using UnityEngine;
using UnityEngine.Rendering;

public class MeshRendererBatch : MeshBatch
{
	private Vector3 position;

	private Mesh meshBatch;

	private MeshFilter meshFilter;

	private MeshRenderer meshRenderer;

	private MeshRendererData meshData;

	private MeshRendererGroup meshGroup;

	private MeshRendererLookup meshLookup;

	private static MaterialPropertyBlock propertyBlock;

	public override int VertexCapacity => Batching.renderer_capacity;

	public override int VertexCutoff => Batching.renderer_vertices;

	protected void Awake()
	{
		meshFilter = ((Component)this).GetComponent<MeshFilter>();
		meshRenderer = ((Component)this).GetComponent<MeshRenderer>();
		meshData = new MeshRendererData();
		meshLookup = new MeshRendererLookup();
	}

	public void SetupColor(Color color)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Expected O, but got Unknown
		if (propertyBlock == null)
		{
			propertyBlock = new MaterialPropertyBlock();
		}
		((Renderer)meshRenderer).GetPropertyBlock(propertyBlock);
		((Renderer)meshRenderer).SetPropertyBlock(propertyBlock);
	}

	public void Setup(Vector3 position, Material material, ShadowCastingMode shadows, int layer, Color color)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Invalid comparison between Unknown and I4
		Vector3 val2 = (((Component)this).transform.position = position);
		this.position = val2;
		((Component)this).gameObject.layer = layer;
		((Renderer)meshRenderer).sharedMaterial = material;
		((Renderer)meshRenderer).shadowCastingMode = shadows;
		SetupColor(color);
		if ((int)shadows == 3)
		{
			((Renderer)meshRenderer).receiveShadows = false;
			((Renderer)meshRenderer).motionVectors = false;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)0;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)0;
		}
		else
		{
			((Renderer)meshRenderer).receiveShadows = true;
			((Renderer)meshRenderer).motionVectors = true;
			((Renderer)meshRenderer).lightProbeUsage = (LightProbeUsage)1;
			((Renderer)meshRenderer).reflectionProbeUsage = (ReflectionProbeUsage)1;
		}
	}

	public void Add(MeshRendererInstance instance)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		ref Vector3 reference = ref instance.position;
		reference -= position;
		((List<MeshRendererInstance>)(object)meshGroup).Add(instance);
		AddVertices(instance.mesh.vertexCount);
	}

	protected override void AllocMemory()
	{
		meshGroup = Pool.Get<MeshRendererGroup>();
		meshData.Alloc();
	}

	protected override void FreeMemory()
	{
		Pool.Free<MeshRendererGroup>(ref meshGroup);
		meshData.Free();
	}

	protected override void RefreshMesh()
	{
		meshLookup.dst.Clear();
		meshData.Clear();
		meshData.Combine(meshGroup, meshLookup);
	}

	protected override void ApplyMesh()
	{
		if (!Object.op_Implicit((Object)(object)meshBatch))
		{
			meshBatch = AssetPool.Get<Mesh>();
		}
		meshLookup.Apply();
		meshData.Apply(meshBatch);
		meshBatch.UploadMeshData(false);
	}

	protected override void ToggleMesh(bool state)
	{
		List<MeshRendererLookup.LookupEntry> data = meshLookup.src.data;
		for (int i = 0; i < data.Count; i++)
		{
			Renderer renderer = data[i].renderer;
			if (Object.op_Implicit((Object)(object)renderer))
			{
				renderer.enabled = !state;
			}
		}
		if (state)
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = meshBatch;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = true;
			}
		}
		else
		{
			if (Object.op_Implicit((Object)(object)meshFilter))
			{
				meshFilter.sharedMesh = null;
			}
			if (Object.op_Implicit((Object)(object)meshRenderer))
			{
				((Renderer)meshRenderer).enabled = false;
			}
		}
	}

	protected override void OnPooled()
	{
		if (Object.op_Implicit((Object)(object)meshFilter))
		{
			meshFilter.sharedMesh = null;
		}
		if (Object.op_Implicit((Object)(object)meshBatch))
		{
			AssetPool.Free(ref meshBatch);
		}
		meshData.Free();
		if (meshGroup != null)
		{
			Pool.Free<MeshRendererGroup>(ref meshGroup);
		}
		meshLookup.src.Clear();
		meshLookup.dst.Clear();
	}
}


using System.IO;
using System.Text;
using UnityEngine;

public static class ObjWriter
{
	public static string MeshToString(Mesh mesh)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		StringBuilder stringBuilder = new StringBuilder();
		stringBuilder.Append("g ").Append(((Object)mesh).name).Append("\n");
		Vector3[] vertices = mesh.vertices;
		foreach (Vector3 val in vertices)
		{
			stringBuilder.Append($"v {0f - val.x} {val.y} {val.z}\n");
		}
		stringBuilder.Append("\n");
		vertices = mesh.normals;
		foreach (Vector3 val2 in vertices)
		{
			stringBuilder.Append($"vn {0f - val2.x} {val2.y} {val2.z}\n");
		}
		stringBuilder.Append("\n");
		Vector2[] uv = mesh.uv;
		for (int i = 0; i < uv.Length; i++)
		{
			Vector3 val3 = Vector2.op_Implicit(uv[i]);
			stringBuilder.Append($"vt {val3.x} {val3.y}\n");
		}
		stringBuilder.Append("\n");
		int[] triangles = mesh.triangles;
		for (int j = 0; j < triangles.Length; j += 3)
		{
			int num = triangles[j] + 1;
			int num2 = triangles[j + 1] + 1;
			int num3 = triangles[j + 2] + 1;
			stringBuilder.Append(string.Format("f {1}/{1}/{1} {0}/{0}/{0} {2}/{2}/{2}\n", num, num2, num3));
		}
		return stringBuilder.ToString();
	}

	public static void Write(Mesh mesh, string path)
	{
		using StreamWriter streamWriter = new StreamWriter(path);
		streamWriter.Write(MeshToString(mesh));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathFinder
{
	public struct Point : IEquatable<Point>
	{
		public int x;

		public int y;

		public Point(int x, int y)
		{
			this.x = x;
			this.y = y;
		}

		public static Point operator +(Point a, Point b)
		{
			return new Point(a.x + b.x, a.y + b.y);
		}

		public static Point operator -(Point a, Point b)
		{
			return new Point(a.x - b.x, a.y - b.y);
		}

		public static Point operator *(Point p, int i)
		{
			return new Point(p.x * i, p.y * i);
		}

		public static Point operator /(Point p, int i)
		{
			return new Point(p.x / i, p.y / i);
		}

		public static bool operator ==(Point a, Point b)
		{
			return a.Equals(b);
		}

		public static bool operator !=(Point a, Point b)
		{
			return !a.Equals(b);
		}

		public override int GetHashCode()
		{
			return x.GetHashCode() ^ y.GetHashCode();
		}

		public override bool Equals(object other)
		{
			if (!(other is Point))
			{
				return false;
			}
			return Equals((Point)other);
		}

		public bool Equals(Point other)
		{
			if (x == other.x)
			{
				return y == other.y;
			}
			return false;
		}
	}

	public class Node : IMinHeapNode<Node>, ILinkedListNode<Node>
	{
		public Point point;

		public int cost;

		public int heuristic;

		public Node next { get; set; }

		public Node child { get; set; }

		public int order => cost + heuristic;

		public Node(Point point, int cost, int heuristic, Node next = null)
		{
			this.point = point;
			this.cost = cost;
			this.heuristic = heuristic;
			this.next = next;
		}
	}

	private int[,] costmap;

	private int[,] visited;

	private Point[] neighbors;

	private bool diagonals;

	private bool directional;

	public Point PushPoint;

	public int PushRadius;

	public int PushDistance;

	public int PushMultiplier;

	public List<Point> PushPointsAdditional = new List<Point>();

	public HashSet<Point> BlockedPointsAdditional = new HashSet<Point>();

	private static Point[] mooreNeighbors = new Point[8]
	{
		new Point(0, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(0, -1),
		new Point(-1, 1),
		new Point(1, 1),
		new Point(-1, -1),
		new Point(1, -1)
	};

	private static Point[] neumannNeighbors = new Point[4]
	{
		new Point(0, 1),
		new Point(-1, 0),
		new Point(1, 0),
		new Point(0, -1)
	};

	public PathFinder(int[,] costmap, bool diagonals = true, bool directional = true)
	{
		this.costmap = costmap;
		neighbors = (diagonals ? mooreNeighbors : neumannNeighbors);
		this.diagonals = diagonals;
		this.directional = directional;
	}

	public int GetResolution(int index)
	{
		return costmap.GetLength(index);
	}

	public Node FindPath(Point start, Point end, int depth = int.MaxValue)
	{
		return FindPathReversed(end, start, depth);
	}

	private Node FindPathReversed(Point start, Point end, int depth = int.MaxValue)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		int num5 = Cost(start);
		if (num5 != int.MaxValue)
		{
			int heuristic = Heuristic(start, end);
			val.Add(new Node(start, num5, heuristic));
		}
		visited[start.x, start.y] = num5;
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x < num || point.x > num2 || point.y < num3 || point.y > num4)
				{
					continue;
				}
				int num6 = Cost(point, node);
				if (num6 != int.MaxValue)
				{
					int num7 = visited[point.x, point.y];
					if (num7 == 0 || num6 < num7)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point, end);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
				else
				{
					visited[point.x, point.y] = -1;
				}
			}
		}
		return null;
	}

	public Node FindPathDirected(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		if (startList.Count == 0 || endList.Count == 0)
		{
			return null;
		}
		return FindPathReversed(endList, startList, depth);
	}

	public Node FindPathUndirected(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		if (startList.Count == 0 || endList.Count == 0)
		{
			return null;
		}
		if (startList.Count > endList.Count)
		{
			return FindPathReversed(endList, startList, depth);
		}
		return FindPathReversed(startList, endList, depth);
	}

	private Node FindPathReversed(List<Point> startList, List<Point> endList, int depth = int.MaxValue)
	{
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		foreach (Point start in startList)
		{
			int num5 = Cost(start);
			if (num5 != int.MaxValue)
			{
				int heuristic = Heuristic(start, endList);
				val.Add(new Node(start, num5, heuristic));
			}
			visited[start.x, start.y] = num5;
		}
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x < num || point.x > num2 || point.y < num3 || point.y > num4)
				{
					continue;
				}
				int num6 = Cost(point, node);
				if (num6 != int.MaxValue)
				{
					int num7 = visited[point.x, point.y];
					if (num7 == 0 || num6 < num7)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point, endList);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
				else
				{
					visited[point.x, point.y] = -1;
				}
			}
		}
		return null;
	}

	public Node FindClosestWalkable(Point start, int depth = int.MaxValue)
	{
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (visited == null)
		{
			visited = new int[costmap.GetLength(0), costmap.GetLength(1)];
		}
		else
		{
			Array.Clear(visited, 0, visited.Length);
		}
		int num = 0;
		int num2 = costmap.GetLength(0) - 1;
		int num3 = 0;
		int num4 = costmap.GetLength(1) - 1;
		if (start.x < num)
		{
			return null;
		}
		if (start.x > num2)
		{
			return null;
		}
		if (start.y < num3)
		{
			return null;
		}
		if (start.y > num4)
		{
			return null;
		}
		IntrusiveMinHeap<Node> val = default(IntrusiveMinHeap<Node>);
		int num5 = 1;
		int heuristic = Heuristic(start);
		val.Add(new Node(start, num5, heuristic));
		visited[start.x, start.y] = num5;
		while (!val.Empty && depth-- > 0)
		{
			Node node = val.Pop();
			if (node.heuristic == 0)
			{
				return node;
			}
			for (int i = 0; i < neighbors.Length; i++)
			{
				Point point = node.point + neighbors[i];
				if (point.x >= num && point.x <= num2 && point.y >= num3 && point.y <= num4)
				{
					int num6 = 1;
					if (visited[point.x, point.y] == 0)
					{
						int cost = node.cost + num6;
						int heuristic2 = Heuristic(point);
						val.Add(new Node(point, cost, heuristic2, node));
						visited[point.x, point.y] = num6;
					}
				}
			}
		}
		return null;
	}

	public bool IsWalkable(Point point)
	{
		return costmap[point.x, point.y] != int.MaxValue;
	}

	public bool IsWalkableWithNeighbours(Point point)
	{
		if (costmap[point.x, point.y] == int.MaxValue)
		{
			return false;
		}
		for (int i = 0; i < neighbors.Length; i++)
		{
			Point point2 = point + neighbors[i];
			if (costmap[point2.x, point2.y] == int.MaxValue)
			{
				return false;
			}
		}
		return true;
	}

	public Node Reverse(Node start)
	{
		Node node = null;
		Node next = null;
		for (Node node2 = start; node2 != null; node2 = node2.next)
		{
			if (node != null)
			{
				node.next = next;
			}
			next = node;
			node = node2;
		}
		if (node != null)
		{
			node.next = next;
		}
		return node;
	}

	public Node FindEnd(Node start)
	{
		for (Node node = start; node != null; node = node.next)
		{
			if (node.next == null)
			{
				return node;
			}
		}
		return start;
	}

	public int Cost(Point a)
	{
		int num = costmap[a.x, a.y];
		int num2 = 0;
		if (BlockedPointsAdditional.Contains(a))
		{
			num = int.MaxValue;
		}
		if (num == int.MaxValue)
		{
			return num;
		}
		if (PushMultiplier > 0)
		{
			int num3 = ((PushRadius > 0) ? Mathf.Max(0, Heuristic(a, PushPoint) - PushRadius) : (PushDistance * 2));
			for (int i = 0; i < PushPointsAdditional.Count; i++)
			{
				num3 = Mathf.Min(num3, Heuristic(a, PushPointsAdditional[i]));
			}
			float num4 = Mathf.Max(0f, (float)(PushDistance - num3)) / (float)PushDistance;
			num2 = ((PushMultiplier != int.MaxValue) ? Mathf.CeilToInt((float)PushMultiplier * num4) : ((num4 > 0f) ? int.MaxValue : 0));
		}
		if (num2 == int.MaxValue)
		{
			return num2;
		}
		return num + num2;
	}

	public int Cost(Point a, Node prev)
	{
		int num = Cost(a);
		int num2 = 0;
		if (num != int.MaxValue && directional && prev != null && prev.next != null && Heuristic(a, prev.next.point) <= 1)
		{
			num2 = 10000;
		}
		return num + num2;
	}

	public int Heuristic(Point a)
	{
		if (costmap[a.x, a.y] != int.MaxValue)
		{
			return 0;
		}
		return 1;
	}

	public int Heuristic(Point a, Point b)
	{
		int num = Mathf.Abs(a.x - b.x);
		int num2 = Mathf.Abs(a.y - b.y);
		if (diagonals)
		{
			return Mathf.Max(num, num2);
		}
		return num + num2;
	}

	public int Heuristic(Point a, List<Point> b)
	{
		int num = int.MaxValue;
		for (int i = 0; i < b.Count; i++)
		{
			num = Mathf.Min(num, Heuristic(a, b[i]));
		}
		return num;
	}

	public float Distance(Point a, Point b)
	{
		int num = a.x - b.x;
		int num2 = a.y - b.y;
		return Mathf.Sqrt((float)(num * num + num2 * num2));
	}

	public static Point GetPoint(Vector3 worldPos, int res)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		float num = TerrainMeta.NormalizeX(worldPos.x);
		float num2 = TerrainMeta.NormalizeZ(worldPos.z);
		Point result = default(Point);
		result.x = Mathf.Clamp((int)(num * (float)res), 0, res - 1);
		result.y = Mathf.Clamp((int)(num2 * (float)res), 0, res - 1);
		return result;
	}
}


using System;

public struct Point : IEquatable<Point>
{
	public int x;

	public int y;

	public Point(int x, int y)
	{
		this.x = x;
		this.y = y;
	}

	public static Point operator +(Point a, Point b)
	{
		return new Point(a.x + b.x, a.y + b.y);
	}

	public static Point operator -(Point a, Point b)
	{
		return new Point(a.x - b.x, a.y - b.y);
	}

	public static Point operator *(Point p, int i)
	{
		return new Point(p.x * i, p.y * i);
	}

	public static Point operator /(Point p, int i)
	{
		return new Point(p.x / i, p.y / i);
	}

	public static bool operator ==(Point a, Point b)
	{
		return a.Equals(b);
	}

	public static bool operator !=(Point a, Point b)
	{
		return !a.Equals(b);
	}

	public override int GetHashCode()
	{
		return x.GetHashCode() ^ y.GetHashCode();
	}

	public override bool Equals(object other)
	{
		if (!(other is Point))
		{
			return false;
		}
		return Equals((Point)other);
	}

	public bool Equals(Point other)
	{
		if (x == other.x)
		{
			return y == other.y;
		}
		return false;
	}
}


public class Node : IMinHeapNode<Node>, ILinkedListNode<Node>
{
	public Point point;

	public int cost;

	public int heuristic;

	public Node next { get; set; }

	public Node child { get; set; }

	public int order => cost + heuristic;

	public Node(Point point, int cost, int heuristic, Node next = null)
	{
		this.point = point;
		this.cost = cost;
		this.heuristic = heuristic;
		this.next = next;
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class PathInterpolator
{
	public Vector3[] Points;

	public Vector3[] Tangents;

	protected bool initialized;

	public int MinIndex { get; set; }

	public int MaxIndex { get; set; }

	public virtual float Length { get; private set; }

	public virtual float StepSize { get; private set; }

	public bool Circular { get; private set; }

	public int DefaultMinIndex => 0;

	public int DefaultMaxIndex => Points.Length - 1;

	public float StartOffset => Length * (float)(MinIndex - DefaultMinIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public float EndOffset => Length * (float)(DefaultMaxIndex - MaxIndex) / (float)(DefaultMaxIndex - DefaultMinIndex);

	public PathInterpolator(Vector3[] points)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		if (points.Length < 2)
		{
			throw new ArgumentException("Point list too short.");
		}
		Points = points;
		MinIndex = DefaultMinIndex;
		MaxIndex = DefaultMaxIndex;
		Circular = Vector3.Distance(points[0], points[^1]) < 0.1f;
	}

	public PathInterpolator(Vector3[] points, Vector3[] tangents)
		: this(points)
	{
		if (tangents.Length != points.Length)
		{
			throw new ArgumentException("Points and tangents lengths must match. Points: " + points.Length + " Tangents: " + tangents.Length);
		}
		Tangents = tangents;
		RecalculateLength();
		initialized = true;
	}

	public void RecalculateTangents()
	{
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		if (Tangents == null || Tangents.Length != Points.Length)
		{
			Tangents = (Vector3[])(object)new Vector3[Points.Length];
		}
		for (int i = 0; i < Points.Length; i++)
		{
			int num = i - 1;
			int num2 = i + 1;
			if (num < 0)
			{
				num = (Circular ? (Points.Length - 2) : 0);
			}
			if (num2 > Points.Length - 1)
			{
				num2 = (Circular ? 1 : (Points.Length - 1));
			}
			Vector3 val = Points[num];
			Vector3 val2 = Points[num2];
			Vector3[] tangents = Tangents;
			int num3 = i;
			Vector3 val3 = val2 - val;
			tangents[num3] = ((Vector3)(ref val3)).normalized;
		}
		RecalculateLength();
		initialized = true;
	}

	public void RecalculateLength()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		for (int i = 0; i < Points.Length - 1; i++)
		{
			Vector3 val = Points[i];
			Vector3 val2 = Points[i + 1];
			float num2 = num;
			Vector3 val3 = val2 - val;
			num = num2 + ((Vector3)(ref val3)).magnitude;
		}
		Length = num;
		StepSize = num / (float)Points.Length;
	}

	public void Resample(float distance)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ec: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		Vector3 val3;
		for (int i = 0; i < Points.Length - 1; i++)
		{
			Vector3 val = Points[i];
			Vector3 val2 = Points[i + 1];
			float num2 = num;
			val3 = val2 - val;
			num = num2 + ((Vector3)(ref val3)).magnitude;
		}
		int num3 = Mathf.RoundToInt(num / distance);
		if (num3 < 2)
		{
			return;
		}
		distance = num / (float)(num3 - 1);
		List<Vector3> list = new List<Vector3>(num3);
		float num4 = 0f;
		for (int j = 0; j < Points.Length - 1; j++)
		{
			int num5 = j;
			int num6 = j + 1;
			Vector3 val4 = Points[num5];
			Vector3 val5 = Points[num6];
			val3 = val5 - val4;
			float num7 = ((Vector3)(ref val3)).magnitude;
			if (num5 == 0)
			{
				list.Add(val4);
			}
			while (num4 + num7 > distance)
			{
				float num8 = distance - num4;
				float num9 = num8 / num7;
				Vector3 val6 = Vector3.Lerp(val4, val5, num9);
				list.Add(val6);
				val4 = val6;
				num4 = 0f;
				num7 -= num8;
			}
			num4 += num7;
			if (num6 == Points.Length - 1 && num4 > distance * 0.5f)
			{
				list.Add(val5);
			}
		}
		if (list.Count >= 2)
		{
			Points = list.ToArray();
			MinIndex = DefaultMinIndex;
			MaxIndex = DefaultMaxIndex;
			initialized = false;
		}
	}

	public void Smoothen(int iterations, Func<int, float> filter = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		Smoothen(iterations, Vector3.one, filter);
	}

	public void Smoothen(int iterations, Vector3 multipliers, Func<int, float> filter = null)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < iterations; i++)
		{
			for (int j = MinIndex + ((!Circular) ? 1 : 0); j <= MaxIndex - 1; j += 2)
			{
				SmoothenIndex(j, multipliers, filter);
			}
			for (int k = MinIndex + (Circular ? 1 : 2); k <= MaxIndex - 1; k += 2)
			{
				SmoothenIndex(k, multipliers, filter);
			}
		}
		initialized = false;
	}

	private void SmoothenIndex(int i, Vector3 multipliers, Func<int, float> filter = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0107: Unknown result type (might be due to invalid IL or missing references)
		int num = i - 1;
		int num2 = i + 1;
		if (i == 0)
		{
			num = Points.Length - 2;
		}
		Vector3 val = Points[num];
		Vector3 val2 = Points[i];
		Vector3 val3 = Points[num2];
		Vector3 val4 = (val + val2 + val2 + val3) * 0.25f;
		if (filter != null)
		{
			multipliers *= filter(i);
		}
		if (multipliers != Vector3.one)
		{
			val4.x = Mathf.LerpUnclamped(val2.x, val4.x, multipliers.x);
			val4.y = Mathf.LerpUnclamped(val2.y, val4.y, multipliers.y);
			val4.z = Mathf.LerpUnclamped(val2.z, val4.z, multipliers.z);
		}
		Points[i] = val4;
		if (i == 0)
		{
			Points[Points.Length - 1] = Points[0];
		}
	}

	public void Straighten(int diStart, int diEnd)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Points[diStart];
		Vector3 val2 = Points[diEnd];
		Vector3 val3 = Tangents[diStart];
		Vector3 val4 = Tangents[diEnd];
		float num = 1f / (float)(diEnd - diStart);
		for (int i = diStart + 1; i <= diEnd - 1; i++)
		{
			float num2 = (float)(i - diStart) * num;
			Points[i] = Vector3.Lerp(val, val2, num2);
			Tangents[i] = Vector3.Slerp(val3, val4, num2);
		}
	}

	public Vector3 GetStartPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Points[MinIndex];
	}

	public Vector3 GetEndPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return Points[MaxIndex];
	}

	public Vector3 GetStartTangent()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MinIndex];
	}

	public Vector3 GetEndTangent()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		return Tangents[MaxIndex];
	}

	public Vector3 GetPointByIndex(int i)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		if (!Circular)
		{
			return Points[Mathf.Clamp(i, 0, Points.Length - 1)];
		}
		return Points[(i % Points.Length + Points.Length) % Points.Length];
	}

	public Vector3 GetTangentByIndex(int i)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = GetPoint(i + 1) - GetPoint(i - 1);
		return ((Vector3)(ref val)).normalized;
	}

	public int GetPrevIndex(float distance)
	{
		return Mathf.FloorToInt(distance / Length * (float)(Points.Length - 1));
	}

	public int GetNextIndex(float distance)
	{
		return Mathf.CeilToInt(distance / Length * (float)(Points.Length - 1));
	}

	public Vector3 GetPoint(int index)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		if (index <= MinIndex)
		{
			return GetStartPoint();
		}
		if (index >= MaxIndex)
		{
			return GetEndPoint();
		}
		return Points[index];
	}

	public Vector3 GetPoint(float distance)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Points.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 val = Points[num2];
		Vector3 val2 = Points[num2 + 1];
		float num3 = num - (float)num2;
		return Vector3.Lerp(val, val2, num3);
	}

	public virtual Vector3 GetTangent(float distance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Tangents.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartTangent();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndTangent();
		}
		Vector3 val = Tangents[num2];
		Vector3 val2 = Tangents[num2 + 1];
		float num3 = num - (float)num2;
		return Vector3.Slerp(val, val2, num3);
	}

	public virtual Vector3 GetPointCubicHermite(float distance)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00af: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_011f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0124: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		if (!initialized)
		{
			throw new Exception("Tangents have not been calculated yet or are outdated.");
		}
		if (Length == 0f)
		{
			return GetStartPoint();
		}
		float num = distance / Length * (float)(Points.Length - 1);
		int num2 = (int)num;
		if (num <= (float)MinIndex)
		{
			return GetStartPoint();
		}
		if (num >= (float)MaxIndex)
		{
			return GetEndPoint();
		}
		Vector3 val = Points[num2];
		Vector3 val2 = Points[num2 + 1];
		Vector3 val3 = Tangents[num2] * StepSize;
		Vector3 val4 = Tangents[num2 + 1] * StepSize;
		float num3 = num - (float)num2;
		float num4 = num3 * num3;
		float num5 = num3 * num4;
		return (2f * num5 - 3f * num4 + 1f) * val + (num5 - 2f * num4 + num3) * val3 + (-2f * num5 + 3f * num4) * val2 + (num5 - num4) * val4;
	}
}


public class RadixSorter
{
	private uint[] histogram;

	private uint[] offset;

	public RadixSorter()
	{
		histogram = new uint[768];
		offset = new uint[768];
	}

	public void SortU8(uint[] values, uint[] remap, uint num)
	{
		for (int i = 0; i < 256; i++)
		{
			histogram[i] = 0u;
		}
		for (uint num2 = 0u; num2 < num; num2++)
		{
			histogram[values[num2] & 0xFF]++;
		}
		offset[0] = 0u;
		for (uint num3 = 0u; num3 < 255; num3++)
		{
			offset[num3 + 1] = offset[num3] + histogram[num3];
		}
		for (uint num4 = 0u; num4 < num; num4++)
		{
			remap[offset[values[num4] & 0xFF]++] = num4;
		}
	}

	public void SortU24(uint[] values, uint[] remap, uint[] remapTemp, uint num)
	{
		for (int i = 0; i < 768; i++)
		{
			histogram[i] = 0u;
		}
		for (uint num2 = 0u; num2 < num; num2++)
		{
			uint num3 = values[num2];
			histogram[num3 & 0xFF]++;
			histogram[256 + ((num3 >> 8) & 0xFF)]++;
			histogram[512 + ((num3 >> 16) & 0xFF)]++;
		}
		offset[0] = (offset[256] = (offset[512] = 0u));
		uint num4 = 0u;
		uint num5 = 256u;
		uint num6 = 512u;
		while (num4 < 255)
		{
			offset[num4 + 1] = offset[num4] + histogram[num4];
			offset[num5 + 1] = offset[num5] + histogram[num5];
			offset[num6 + 1] = offset[num6] + histogram[num6];
			num4++;
			num5++;
			num6++;
		}
		for (uint num7 = 0u; num7 < num; num7++)
		{
			remapTemp[offset[values[num7] & 0xFF]++] = num7;
		}
		for (uint num8 = 0u; num8 < num; num8++)
		{
			uint num9 = remapTemp[num8];
			remap[offset[256 + ((values[num9] >> 8) & 0xFF)]++] = num9;
		}
		for (uint num10 = 0u; num10 < num; num10++)
		{
			uint num9 = remap[num10];
			remapTemp[offset[512 + ((values[num9] >> 16) & 0xFF)]++] = num9;
		}
		for (uint num11 = 0u; num11 < num; num11++)
		{
			remap[num11] = remapTemp[num11];
		}
	}
}


using System.Collections.Generic;
using System.IO;

public static class RawWriter
{
	public static void Write(IEnumerable<byte> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (byte datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<int> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (int datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<short> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (short datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<ushort> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (ushort datum in data)
		{
			binaryWriter.Write(datum);
		}
	}

	public static void Write(IEnumerable<float> data, string path)
	{
		using FileStream output = File.Open(path, FileMode.Create);
		using BinaryWriter binaryWriter = new BinaryWriter(output);
		foreach (float datum in data)
		{
			binaryWriter.Write(datum);
		}
	}
}


using Network;

public struct RealTimeSinceEx
{
	private double time;

	public static implicit operator double(RealTimeSinceEx ts)
	{
		return TimeEx.realtimeSinceStartup - ts.time;
	}

	public static implicit operator RealTimeSinceEx(double ts)
	{
		RealTimeSinceEx result = default(RealTimeSinceEx);
		result.time = TimeEx.realtimeSinceStartup - ts;
		return result;
	}

	public override string ToString()
	{
		return (TimeEx.realtimeSinceStartup - time).ToString();
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class SynchronizedClock
{
	public struct TimedEvent
	{
		public float time;

		public float delta;

		public float variance;

		public Action<uint> action;
	}

	public List<TimedEvent> events = new List<TimedEvent>();

	private static float CurrentTime => Time.realtimeSinceStartup;

	public void Add(float delta, float variance, Action<uint> action)
	{
		TimedEvent item = default(TimedEvent);
		item.time = CurrentTime;
		item.delta = delta;
		item.variance = variance;
		item.action = action;
		events.Add(item);
	}

	public void Tick()
	{
		for (int i = 0; i < events.Count; i++)
		{
			TimedEvent value = events[i];
			float time = value.time;
			float currentTime = CurrentTime;
			float delta = value.delta;
			float num = time - time % delta;
			uint obj = (uint)(time / delta);
			SeedRandom.Wanghash(ref obj);
			SeedRandom.Wanghash(ref obj);
			SeedRandom.Wanghash(ref obj);
			float num2 = SeedRandom.Range(ref obj, 0f - value.variance, value.variance);
			float num3 = num + delta + num2;
			if (time < num3 && currentTime >= num3)
			{
				value.action(obj);
				value.time = currentTime;
			}
			else if (currentTime > time || currentTime < num - 5f)
			{
				value.time = currentTime;
			}
			events[i] = value;
		}
	}
}


using System;

public struct TimedEvent
{
	public float time;

	public float delta;

	public float variance;

	public Action<uint> action;
}


using UnityEngine;

public class TickHistory
{
	private Deque<Vector3> points = new Deque<Vector3>(8);

	public int Count => points.Count;

	public void Reset()
	{
		points.Clear();
	}

	public void Reset(Vector3 point)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		Reset();
		AddPoint(point);
	}

	public float Distance(BasePlayer player, Vector3 point)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		if (points.Count == 0)
		{
			return player.Distance(point);
		}
		Vector3 position = ((Component)player).transform.position;
		Quaternion rotation = ((Component)player).transform.rotation;
		Bounds bounds = player.bounds;
		Matrix4x4 tickHistoryMatrix = player.tickHistoryMatrix;
		float num = float.MaxValue;
		Line val3 = default(Line);
		OBB val5 = default(OBB);
		for (int i = 0; i < points.Count; i++)
		{
			Vector3 val = ((Matrix4x4)(ref tickHistoryMatrix)).MultiplyPoint3x4(points[i]);
			Vector3 val2 = ((i == points.Count - 1) ? position : ((Matrix4x4)(ref tickHistoryMatrix)).MultiplyPoint3x4(points[i + 1]));
			((Line)(ref val3))..ctor(val, val2);
			Vector3 val4 = ((Line)(ref val3)).ClosestPoint(point);
			((OBB)(ref val5))..ctor(val4, rotation, bounds);
			num = Mathf.Min(num, ((OBB)(ref val5)).Distance(point));
		}
		return num;
	}

	public void AddPoint(Vector3 point, int limit = -1)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		while (limit > 0 && points.Count >= limit)
		{
			points.PopFront();
		}
		points.PushBack(point);
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < points.Count; i++)
		{
			Vector3 val = points[i];
			val = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(val);
			points[i] = val;
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class TickInterpolator
{
	public struct Segment
	{
		public Vector3 point;

		public readonly float length;

		public Segment(Vector3 a, Vector3 b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			point = b;
			length = Vector3.Distance(a, b);
		}

		public Segment(Vector3 b)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			point = b;
			length = 0f;
		}
	}

	private readonly List<Segment> points = new List<Segment>();

	private int index;

	public float Length;

	public Vector3 CurrentPoint;

	public Vector3 StartPoint;

	public Vector3 EndPoint;

	public int Count => points.Count;

	public void Reset()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		index = 0;
		CurrentPoint = StartPoint;
	}

	public void Reset(Vector3 point)
	{
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		points.Clear();
		index = 0;
		Length = 0f;
		CurrentPoint = (StartPoint = (EndPoint = point));
	}

	public void AddPoint(Vector3 point)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		Segment item = new Segment(EndPoint, point);
		points.Add(item);
		Length += item.length;
		EndPoint = item.point;
	}

	public bool MoveNext(float distance)
	{
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		while (num < distance && index < points.Count)
		{
			Segment segment = points[index];
			CurrentPoint = segment.point;
			num += segment.length;
			index++;
		}
		return num > 0f;
	}

	public bool HasNext()
	{
		return index < points.Count;
	}

	public void TransformEntries(Matrix4x4 matrix)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < points.Count; i++)
		{
			Segment value = points[i];
			value.point = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(value.point);
			points[i] = value;
		}
		CurrentPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(CurrentPoint);
		StartPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(StartPoint);
		EndPoint = ((Matrix4x4)(ref matrix)).MultiplyPoint3x4(EndPoint);
	}
}


using UnityEngine;

public struct Segment
{
	public Vector3 point;

	public readonly float length;

	public Segment(Vector3 a, Vector3 b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		point = b;
		length = Vector3.Distance(a, b);
	}

	public Segment(Vector3 b)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		point = b;
		length = 0f;
	}
}


using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using UnityEngine;

public class TickInterpolatorCache
{
	public struct PlayerInfo
	{
		public int Count;

		public float Length;
	}

	public struct ReadOnlyState
	{
		public readonly ReadOnly<TickInterpolator.Segment> Segments;

		public readonly ReadOnly<PlayerInfo> Infos;

		public readonly int BufferSize;

		public ReadOnlyState(ReadOnly<TickInterpolator.Segment> playerSegments, ReadOnly<PlayerInfo> playerInfos, int bufferSize)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			Segments = playerSegments;
			Infos = playerInfos;
			BufferSize = bufferSize;
		}
	}

	public struct PlayerTickIterator
	{
		private readonly ReadOnlyState state;

		private readonly int playerIndex;

		private Vector3 currPoint;

		private int segmentIndex;

		public Vector3 CurrentPoint => currPoint;

		public Vector3 StartPoint => GetStartPoint(state, playerIndex);

		public Vector3 EndPoint => GetEndPoint(state, playerIndex);

		public float Length => state.Infos[playerIndex].Length;

		public PlayerTickIterator(ReadOnlyState state, int playerIndex)
		{
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			this.state = state;
			this.playerIndex = playerIndex;
			segmentIndex = 0;
			currPoint = GetStartPoint(state, playerIndex);
		}

		public bool MoveNext(float distance)
		{
			//IL_0023: Unknown result type (might be due to invalid IL or missing references)
			//IL_0028: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			float num = 0f;
			int num2 = playerIndex * state.BufferSize + 1;
			while (num < distance && HasNext())
			{
				TickInterpolator.Segment segment = state.Segments[num2 + segmentIndex];
				currPoint = segment.point;
				num += segment.length;
				segmentIndex++;
			}
			return num > 0f;
		}

		public void Reset()
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			segmentIndex = 0;
			currPoint = StartPoint;
		}

		public bool HasNext()
		{
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			return segmentIndex < state.Infos[playerIndex].Count;
		}
	}

	private NativeArray<TickInterpolator.Segment> playerSegments;

	private NativeArray<PlayerInfo> playerInfos;

	private int bufferSize = 9;

	public ReadOnlyState ReadOnly => new ReadOnlyState(playerSegments.AsReadOnly(), playerInfos.AsReadOnly(), bufferSize);

	public TickInterpolatorCache(int capacity = 32)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		playerSegments = new NativeArray<TickInterpolator.Segment>(bufferSize * capacity, (Allocator)4, (NativeArrayOptions)0);
		playerInfos = new NativeArray<PlayerInfo>(capacity, (Allocator)4, (NativeArrayOptions)1);
	}

	public void Dispose()
	{
		NativeArrayEx.SafeDispose(ref playerSegments);
		NativeArrayEx.SafeDispose(ref playerInfos);
	}

	public void ReplacePlayer(int index)
	{
		playerInfos[index] = default(PlayerInfo);
	}

	public unsafe void AddTick(BasePlayer player, Vector3 point)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		int stableIndex = player.StableIndex;
		int num = player.StableIndex * bufferSize;
		ref PlayerInfo reference = ref UnsafeUtility.ArrayElementAsRef<PlayerInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<PlayerInfo>(playerInfos), stableIndex);
		int num2 = ++reference.Count;
		Vector3 point2 = playerSegments[num + num2 - 1].point;
		TickInterpolator.Segment segment = new TickInterpolator.Segment(point2, point);
		reference.Length += segment.length;
		if (num2 >= bufferSize)
		{
			GrowSegments(playerInfos.Length);
		}
		playerSegments[num + num2] = segment;
	}

	public unsafe void Reset(BasePlayer player, Vector3 point)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		int stableIndex = player.StableIndex;
		ref PlayerInfo reference = ref UnsafeUtility.ArrayElementAsRef<PlayerInfo>(NativeArrayUnsafeUtility.GetUnsafePtr<PlayerInfo>(playerInfos), stableIndex);
		reference.Count = 0;
		reference.Length = 0f;
		int num = player.StableIndex * bufferSize;
		playerSegments[num] = new TickInterpolator.Segment(point);
	}

	public void Expand(int newCap)
	{
		int length = playerInfos.Length;
		if (newCap > length)
		{
			NativeArrayEx.Expand(ref playerInfos, newCap, (NativeArrayOptions)1);
			GrowSegments(length);
		}
	}

	public static Vector3 GetStartPoint(ReadOnlyState state, int playerIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		return state.Segments[playerIndex * state.BufferSize].point;
	}

	public static Vector3 GetEndPoint(ReadOnlyState state, int playerIndex)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		PlayerInfo info = state.Infos[playerIndex];
		return GetEndPoint(state, playerIndex, info);
	}

	public static Vector3 GetEndPoint(ReadOnlyState state, int playerIndex, PlayerInfo info)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		return state.Segments[playerIndex * state.BufferSize + info.Count].point;
	}

	public void TransformEntries(int playerIndex, in Matrix4x4 matrix)
	{
		PlayerInfo info = playerInfos[playerIndex];
		TransformEntries(playerIndex, info, in matrix);
	}

	public unsafe void TransformEntries(int playerIndex, PlayerInfo info, in Matrix4x4 matrix)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		NativeArray<TickInterpolator.Segment> subArray = playerSegments.GetSubArray(playerIndex * bufferSize, info.Count + 1);
		void* unsafePtr = NativeArrayUnsafeUtility.GetUnsafePtr<TickInterpolator.Segment>(subArray);
		for (int i = 0; i < subArray.Length; i++)
		{
			ref TickInterpolator.Segment reference = ref UnsafeUtility.ArrayElementAsRef<TickInterpolator.Segment>(unsafePtr, i);
			Matrix4x4 val = matrix;
			reference.point = ((Matrix4x4)(ref val)).MultiplyPoint3x4(reference.point);
		}
	}

	public static PlayerTickIterator GetPlayerTickIterator(ReadOnlyState state, int playerIndex)
	{
		return new PlayerTickIterator(state, playerIndex);
	}

	private void GrowSegments(int oldPlayerCap)
	{
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		int length = playerInfos.Length;
		int num = bufferSize;
		if (length == oldPlayerCap)
		{
			bufferSize += 4;
		}
		NativeArray<TickInterpolator.Segment> val = default(NativeArray<TickInterpolator.Segment>);
		val..ctor(length * bufferSize, (Allocator)4, (NativeArrayOptions)0);
		for (int i = 0; i < oldPlayerCap; i++)
		{
			int count = playerInfos[i].Count;
			if (count > 0)
			{
				NativeArray<TickInterpolator.Segment> subArray = playerSegments.GetSubArray(i * num, count + 1);
				NativeArray<TickInterpolator.Segment> subArray2 = val.GetSubArray(i * bufferSize, count + 1);
				subArray.CopyTo(subArray2);
			}
			else
			{
				val[i * bufferSize] = playerSegments[i * num];
			}
		}
		playerSegments.Dispose();
		playerSegments = val;
	}
}


public struct PlayerInfo
{
	public int Count;

	public float Length;
}


using Unity.Collections;

public struct ReadOnlyState
{
	public readonly ReadOnly<TickInterpolator.Segment> Segments;

	public readonly ReadOnly<PlayerInfo> Infos;

	public readonly int BufferSize;

	public ReadOnlyState(ReadOnly<TickInterpolator.Segment> playerSegments, ReadOnly<PlayerInfo> playerInfos, int bufferSize)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		Segments = playerSegments;
		Infos = playerInfos;
		BufferSize = bufferSize;
	}
}


using UnityEngine;

public struct PlayerTickIterator
{
	private readonly ReadOnlyState state;

	private readonly int playerIndex;

	private Vector3 currPoint;

	private int segmentIndex;

	public Vector3 CurrentPoint => currPoint;

	public Vector3 StartPoint => GetStartPoint(state, playerIndex);

	public Vector3 EndPoint => GetEndPoint(state, playerIndex);

	public float Length => state.Infos[playerIndex].Length;

	public PlayerTickIterator(ReadOnlyState state, int playerIndex)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		this.state = state;
		this.playerIndex = playerIndex;
		segmentIndex = 0;
		currPoint = GetStartPoint(state, playerIndex);
	}

	public bool MoveNext(float distance)
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		float num = 0f;
		int num2 = playerIndex * state.BufferSize + 1;
		while (num < distance && HasNext())
		{
			TickInterpolator.Segment segment = state.Segments[num2 + segmentIndex];
			currPoint = segment.point;
			num += segment.length;
			segmentIndex++;
		}
		return num > 0f;
	}

	public void Reset()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		segmentIndex = 0;
		currPoint = StartPoint;
	}

	public bool HasNext()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		return segmentIndex < state.Infos[playerIndex].Count;
	}
}


using System;
using UnityEngine;

public class TimeCachedValue<T>
{
	public float refreshCooldown;

	public float refreshRandomRange;

	public Func<T> updateValue;

	private T cachedValue;

	private TimeSince cooldown;

	private bool hasRun;

	private bool forceNextRun;

	public T Get(bool force)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		if (TimeSince.op_Implicit(cooldown) < refreshCooldown && !force && hasRun && !forceNextRun)
		{
			return cachedValue;
		}
		hasRun = true;
		forceNextRun = false;
		cooldown = TimeSince.op_Implicit(0f - Random.Range(0f, refreshRandomRange));
		if (updateValue != null)
		{
			cachedValue = updateValue();
		}
		else
		{
			cachedValue = default(T);
		}
		return cachedValue;
	}

	public void ForceNextRun()
	{
		forceNextRun = true;
	}

	public void UpdateImmediately()
	{
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		hasRun = true;
		forceNextRun = false;
		cooldown = TimeSince.op_Implicit(0f - Random.Range(0f, refreshRandomRange));
		if (updateValue != null)
		{
			cachedValue = updateValue();
		}
		else
		{
			cachedValue = default(T);
		}
	}
}


using System.Diagnostics;
using Facepunch.Rust;
using UnityEngine;

public struct Timing
{
	private Stopwatch sw;

	private string name;

	public static Timing Start(string name)
	{
		return new Timing(name);
	}

	public void End()
	{
		if (sw.Elapsed.TotalSeconds > 0.30000001192092896)
		{
			Debug.Log((object)("[" + sw.Elapsed.TotalSeconds.ToString("0.0") + "s] " + name));
			PerformanceLogging.server?.SetTiming(name, sw.Elapsed);
		}
	}

	public Timing(string name)
	{
		sw = Stopwatch.StartNew();
		this.name = name;
	}
}


using System.Collections.Generic;
using System.Linq;
using Facepunch;
using UnityEngine;

public static class TransformUtil
{
	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hit, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out hit, 100f, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hit, float range, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out hit, range, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out RaycastHit hitOut, float range, LayerMask mask, Transform ignoreTransform = null)
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ab: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		hitOut = default(RaycastHit);
		if (GamePhysics.Trace(new Ray(startPos, Vector3.down), 0f, out var hitInfo, range, LayerMask.op_Implicit(mask), (QueryTriggerInteraction)0))
		{
			if ((Object)(object)ignoreTransform != (Object)null && (Object)(object)((RaycastHit)(ref hitInfo)).collider != (Object)null && ((Object)(object)((Component)((RaycastHit)(ref hitInfo)).collider).transform == (Object)(object)ignoreTransform || ((Component)((RaycastHit)(ref hitInfo)).collider).transform.IsChildOf(ignoreTransform)))
			{
				return GetGroundInfo(startPos - new Vector3(0f, 0.01f, 0f), out hitOut, range, mask, ignoreTransform);
			}
			hitOut = hitInfo;
			return true;
		}
		return false;
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out pos, out normal, 100f, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, Transform ignoreTransform = null)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfo(startPos, out pos, out normal, range, LayerMask.op_Implicit(-1), ignoreTransform);
	}

	public static bool GetGroundInfo(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, LayerMask mask, Transform ignoreTransform = null)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0096: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		List<RaycastHit> list = Pool.Get<List<RaycastHit>>();
		GamePhysics.TraceAll(new Ray(startPos, Vector3.down), 0f, list, range, LayerMask.op_Implicit(mask), (QueryTriggerInteraction)1);
		foreach (RaycastHit item in list)
		{
			RaycastHit current = item;
			if (!((Object)(object)ignoreTransform != (Object)null) || !((Object)(object)((RaycastHit)(ref current)).collider != (Object)null) || (!((Object)(object)((Component)((RaycastHit)(ref current)).collider).transform == (Object)(object)ignoreTransform) && !((Component)((RaycastHit)(ref current)).collider).transform.IsChildOf(ignoreTransform)))
			{
				pos = ((RaycastHit)(ref current)).point;
				normal = ((RaycastHit)(ref current)).normal;
				Pool.FreeUnmanaged<RaycastHit>(ref list);
				return true;
			}
		}
		pos = startPos;
		normal = Vector3.up;
		Pool.FreeUnmanaged<RaycastHit>(ref list);
		return false;
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfoTerrainOnly(startPos, out pos, out normal, 100f, LayerMask.op_Implicit(-1));
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		return GetGroundInfoTerrainOnly(startPos, out pos, out normal, range, LayerMask.op_Implicit(-1));
	}

	public static bool GetGroundInfoTerrainOnly(Vector3 startPos, out Vector3 pos, out Vector3 normal, float range, LayerMask mask)
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		startPos.y += 0.25f;
		range += 0.25f;
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(new Ray(startPos, Vector3.down), ref val, range, LayerMask.op_Implicit(mask)) && ((RaycastHit)(ref val)).collider is TerrainCollider)
		{
			pos = ((RaycastHit)(ref val)).point;
			normal = ((RaycastHit)(ref val)).normal;
			return true;
		}
		pos = startPos;
		normal = Vector3.up;
		return false;
	}

	public static Transform[] GetRootObjects()
	{
		return (from x in Object.FindObjectsOfType<Transform>()
			where (Object)(object)((Component)x).transform == (Object)(object)((Component)x).transform.root
			select x).ToArray();
	}
}


using System.Collections.Generic;
using UnityEngine;

public class WorldSpline : MonoBehaviour
{
	public int dataIndex = -1;

	public Vector3[] points;

	public Vector3[] tangents;

	[Range(0.05f, 100f)]
	public float lutInterval = 0.25f;

	[SerializeField]
	private bool showGizmos = true;

	private static List<Vector3> visualSplineList = new List<Vector3>();

	private WorldSplineData privateData;

	public WorldSplineData GetData()
	{
		if (WorldSplineSharedData.TryGetDataFor(this, out var data))
		{
			return data;
		}
		if (Application.isPlaying && privateData == null)
		{
			privateData = new WorldSplineData(this);
		}
		return privateData;
	}

	public void SetAll(Vector3[] points, Vector3[] tangents, float lutInterval)
	{
		this.points = points;
		this.tangents = tangents;
		this.lutInterval = lutInterval;
	}

	public void CheckValidity()
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a9: Unknown result type (might be due to invalid IL or missing references)
		lutInterval = Mathf.Clamp(lutInterval, 0.05f, 100f);
		if (points == null || points.Length < 2)
		{
			points = (Vector3[])(object)new Vector3[2];
			points[0] = Vector3.zero;
			points[1] = Vector3.zero;
		}
		if (tangents != null && points.Length == tangents.Length)
		{
			return;
		}
		Vector3[] array = (Vector3[])(object)new Vector3[points.Length];
		for (int i = 0; i < array.Length; i++)
		{
			if (tangents != null && i < tangents.Length)
			{
				array[i] = tangents[i];
			}
			else
			{
				array[i] = Vector3.forward;
			}
		}
		tangents = array;
	}

	protected virtual void OnDrawGizmosSelected()
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		if (showGizmos)
		{
			DrawSplineGizmo(this, Color.magenta);
		}
	}

	protected static void DrawSplineGizmo(WorldSpline ws, Color splineColour)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		//IL_0120: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0149: Unknown result type (might be due to invalid IL or missing references)
		if ((Object)(object)ws == (Object)null)
		{
			return;
		}
		WorldSplineData data = ws.GetData();
		if (data == null || ws.points.Length < 2 || ws.points.Length != ws.tangents.Length)
		{
			return;
		}
		Vector3[] pointsWorld = ws.GetPointsWorld();
		Vector3[] tangentsWorld = ws.GetTangentsWorld();
		for (int i = 0; i < pointsWorld.Length; i++)
		{
			Gizmos.color = Color.magenta;
			Gizmos.DrawSphere(pointsWorld[i], 0.25f);
			if (((Vector3)(ref tangentsWorld[i])).magnitude > 0f)
			{
				Gizmos.color = Color.cyan;
				Vector3 val = pointsWorld[i] + tangentsWorld[i] + Vector3.up * 0.1f;
				Gizmos.DrawLine(pointsWorld[i] + Vector3.up * 0.1f, val);
			}
		}
		Gizmos.color = splineColour;
		Vector3[] visualSpline = GetVisualSpline(ws, data, 1f);
		for (int j = 0; j < visualSpline.Length - 1; j++)
		{
			Gizmos.color = Color.Lerp(Color.white, splineColour, (float)j / (float)(visualSpline.Length - 1));
			Gizmos.DrawLine(visualSpline[j], visualSpline[j + 1]);
			Gizmos.DrawLine(visualSpline[j], visualSpline[j] + Vector3.up * 0.25f);
		}
	}

	private static Vector3[] GetVisualSpline(WorldSpline ws, WorldSplineData data, float distBetweenPoints)
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		visualSplineList.Clear();
		if ((Object)(object)ws != (Object)null && ws.points.Length > 1)
		{
			Vector3 startPointWorld = ws.GetStartPointWorld();
			Vector3 endPointWorld = ws.GetEndPointWorld();
			visualSplineList.Add(startPointWorld);
			for (float num = distBetweenPoints; num <= data.Length - distBetweenPoints; num += distBetweenPoints)
			{
				visualSplineList.Add(ws.GetPointCubicHermiteWorld(num, data));
			}
			visualSplineList.Add(endPointWorld);
		}
		return visualSplineList.ToArray();
	}

	public Vector3 GetStartPointWorld()
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(points[0]);
	}

	public Vector3 GetEndPointWorld()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(points[points.Length - 1]);
	}

	public Vector3 GetStartTangentWorld()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * tangents[0], ((Component)this).transform.localScale);
	}

	public Vector3 GetEndTangentWorld()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * tangents[tangents.Length - 1], ((Component)this).transform.localScale);
	}

	public Vector3 GetTangentCubicHermiteWorld(float distance)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * GetData().GetTangentCubicHermite(distance), ((Component)this).transform.localScale);
	}

	public Vector3 GetTangentCubicHermiteWorld(float distance, WorldSplineData data)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		return Vector3.Scale(((Component)this).transform.rotation * data.GetTangentCubicHermite(distance), ((Component)this).transform.localScale);
	}

	public Vector3 GetPointCubicHermiteWorld(float distance)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(GetData().GetPointCubicHermite(distance));
	}

	public Vector3 GetPointCubicHermiteWorld(float distance, WorldSplineData data)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return ((Component)this).transform.TransformPoint(data.GetPointCubicHermite(distance));
	}

	public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, out Vector3 tangent)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermite = GetData().GetPointAndTangentCubicHermite(distance, out tangent);
		tangent = ((Component)this).transform.TransformVector(tangent);
		return ((Component)this).transform.TransformPoint(pointAndTangentCubicHermite);
	}

	public Vector3 GetPointAndTangentCubicHermiteWorld(float distance, WorldSplineData data, out Vector3 tangent)
	{
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		Vector3 pointAndTangentCubicHermite = data.GetPointAndTangentCubicHermite(distance, out tangent);
		tangent = ((Component)this).transform.TransformVector(tangent);
		return ((Component)this).transform.TransformPoint(pointAndTangentCubicHermite);
	}

	public Vector3[] GetPointsWorld()
	{
		return PointsToWorld(points, ((Component)this).transform);
	}

	public Vector3[] GetTangentsWorld()
	{
		return TangentsToWorld(tangents, ((Component)this).transform);
	}

	private static Vector3[] PointsToWorld(Vector3[] points, Transform tr)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[points.Length];
		for (int i = 0; i < points.Length; i++)
		{
			array[i] = tr.TransformPoint(points[i]);
		}
		return array;
	}

	private static Vector3[] TangentsToWorld(Vector3[] tangents, Transform tr)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] array = (Vector3[])(object)new Vector3[tangents.Length];
		for (int i = 0; i < tangents.Length; i++)
		{
			array[i] = Vector3.Scale(tr.rotation * tangents[i], tr.localScale);
		}
		return array;
	}
}


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

[Serializable]
public class WorldSplineData
{
	[Serializable]
	public class LUTEntry
	{
		[Serializable]
		public struct LUTPoint
		{
			public float distance;

			public Vector3 pos;

			public LUTPoint(float distance, Vector3 pos)
			{
				//IL_0008: Unknown result type (might be due to invalid IL or missing references)
				//IL_0009: Unknown result type (might be due to invalid IL or missing references)
				this.distance = distance;
				this.pos = pos;
			}
		}

		public List<LUTPoint> points = new List<LUTPoint>();
	}

	public Vector3[] inputPoints;

	public Vector3[] inputTangents;

	public float inputLUTInterval;

	public List<LUTEntry> LUTValues;

	public float Length;

	[SerializeField]
	private int maxPointsIndex;

	public WorldSplineData(WorldSpline worldSpline)
	{
		worldSpline.CheckValidity();
		LUTValues = new List<LUTEntry>();
		inputPoints = (Vector3[])(object)new Vector3[worldSpline.points.Length];
		worldSpline.points.CopyTo(inputPoints, 0);
		inputTangents = (Vector3[])(object)new Vector3[worldSpline.tangents.Length];
		worldSpline.tangents.CopyTo(inputTangents, 0);
		inputLUTInterval = worldSpline.lutInterval;
		maxPointsIndex = inputPoints.Length - 1;
		CreateLookupTable(worldSpline);
	}

	public bool IsSameAs(WorldSpline worldSpline)
	{
		if (inputPoints.SequenceEqual(worldSpline.points) && inputTangents.SequenceEqual(worldSpline.tangents))
		{
			return inputLUTInterval == worldSpline.lutInterval;
		}
		return false;
	}

	public bool IsDifferentTo(WorldSpline worldSpline)
	{
		return !IsSameAs(worldSpline);
	}

	public Vector3 GetStartPoint()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return inputPoints[0];
	}

	public Vector3 GetEndPoint()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return inputPoints[maxPointsIndex];
	}

	public Vector3 GetStartTangent()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return inputTangents[0];
	}

	public Vector3 GetEndTangent()
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		return inputTangents[maxPointsIndex];
	}

	public Vector3 GetPointCubicHermite(float distance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		Vector3 tangent;
		return GetPointAndTangentCubicHermite(distance, out tangent);
	}

	public Vector3 GetTangentCubicHermite(float distance)
	{
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		GetPointAndTangentCubicHermite(distance, out var tangent);
		return tangent;
	}

	public Vector3 GetPointAndTangentCubicHermite(float distance, out Vector3 tangent)
	{
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0150: Unknown result type (might be due to invalid IL or missing references)
		//IL_0155: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_018d: Unknown result type (might be due to invalid IL or missing references)
		//IL_018e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0193: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_019c: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a6: Unknown result type (might be due to invalid IL or missing references)
		if (distance <= 0f)
		{
			tangent = GetStartTangent();
			return GetStartPoint();
		}
		if (distance >= Length)
		{
			tangent = GetEndTangent();
			return GetEndPoint();
		}
		int num = Mathf.FloorToInt(distance);
		if (LUTValues.Count > num)
		{
			int num2 = -1;
			while (num2 < 0 && (float)num > 0f)
			{
				LUTEntry lUTEntry = LUTValues[num];
				for (int i = 0; i < lUTEntry.points.Count && !(lUTEntry.points[i].distance > distance); i++)
				{
					num2 = i;
				}
				if (num2 < 0)
				{
					num--;
				}
			}
			float num3;
			Vector3 val;
			if (num2 < 0)
			{
				num3 = 0f;
				val = GetStartPoint();
			}
			else
			{
				LUTEntry.LUTPoint lUTPoint = LUTValues[num].points[num2];
				num3 = lUTPoint.distance;
				val = lUTPoint.pos;
			}
			num2 = -1;
			while (num2 < 0 && num < LUTValues.Count)
			{
				LUTEntry lUTEntry2 = LUTValues[num];
				for (int j = 0; j < lUTEntry2.points.Count; j++)
				{
					if (lUTEntry2.points[j].distance > distance)
					{
						num2 = j;
						break;
					}
				}
				if (num2 < 0)
				{
					num++;
				}
			}
			float num4;
			Vector3 val2;
			if (num2 < 0)
			{
				num4 = Length;
				val2 = GetEndPoint();
			}
			else
			{
				LUTEntry.LUTPoint lUTPoint2 = LUTValues[num].points[num2];
				num4 = lUTPoint2.distance;
				val2 = lUTPoint2.pos;
			}
			float num5 = Mathf.InverseLerp(num3, num4, distance);
			Vector3 val3 = val2 - val;
			tangent = ((Vector3)(ref val3)).normalized;
			return Vector3.Lerp(val, val2, num5);
		}
		tangent = GetEndTangent();
		return GetEndPoint();
	}

	public void SetDefaultTangents(WorldSpline worldSpline)
	{
		PathInterpolator pathInterpolator = new PathInterpolator(worldSpline.points, worldSpline.tangents);
		pathInterpolator.RecalculateTangents();
		worldSpline.tangents = pathInterpolator.Tangents;
	}

	public bool DetectSplineProblems(WorldSpline worldSpline)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		bool result = false;
		Vector3 val = GetTangentCubicHermite(0f);
		for (float num = 0.05f; num <= Length; num += 0.05f)
		{
			Vector3 tangentCubicHermite = GetTangentCubicHermite(num);
			float num2 = Vector3.Angle(tangentCubicHermite, val);
			if (num2 > 5f)
			{
				if ((Object)(object)worldSpline != (Object)null)
				{
					Vector3 tangent;
					Vector3 pointAndTangentCubicHermiteWorld = worldSpline.GetPointAndTangentCubicHermiteWorld(num, out tangent);
					Debug.DrawRay(pointAndTangentCubicHermiteWorld, tangent, Color.red, 30f);
					Debug.DrawRay(pointAndTangentCubicHermiteWorld, Vector3.up, Color.red, 30f);
				}
				Debug.Log((object)($"Spline may have a too-sharp bend at {num / Length:P0}. Angle change: " + num2));
				result = true;
			}
			val = tangentCubicHermite;
		}
		return result;
	}

	private void CreateLookupTable(WorldSpline worldSpline)
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		PathInterpolator pathInterpolator = new PathInterpolator(worldSpline.points, worldSpline.tangents);
		Vector3 val = pathInterpolator.GetPointCubicHermite(0f);
		Length = 0f;
		AddEntry(0f, GetStartPoint());
		Vector3 pointCubicHermite;
		for (float num = worldSpline.lutInterval; num < pathInterpolator.Length; num += worldSpline.lutInterval)
		{
			pointCubicHermite = pathInterpolator.GetPointCubicHermite(num);
			Length += Vector3.Distance(pointCubicHermite, val);
			AddEntry(Length, pathInterpolator.GetPointCubicHermite(num));
			val = pointCubicHermite;
		}
		pointCubicHermite = GetEndPoint();
		Length += Vector3.Distance(pointCubicHermite, val);
		AddEntry(Length, pointCubicHermite);
	}

	private void AddEntry(float distance, Vector3 pos)
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		int num = Mathf.FloorToInt(distance);
		if (LUTValues.Count < num + 1)
		{
			for (int i = LUTValues.Count; i < num + 1; i++)
			{
				LUTValues.Add(new LUTEntry());
			}
		}
		LUTValues[num].points.Add(new LUTEntry.LUTPoint(distance, pos));
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class LUTEntry
{
	[Serializable]
	public struct LUTPoint
	{
		public float distance;

		public Vector3 pos;

		public LUTPoint(float distance, Vector3 pos)
		{
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.distance = distance;
			this.pos = pos;
		}
	}

	public List<LUTPoint> points = new List<LUTPoint>();
}


using System;
using UnityEngine;

[Serializable]
public struct LUTPoint
{
	public float distance;

	public Vector3 pos;

	public LUTPoint(float distance, Vector3 pos)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.distance = distance;
		this.pos = pos;
	}
}


using System.Collections.Generic;
using UnityEngine;

[CreateAssetMenu(menuName = "Scriptable Object/Vehicles/WorldSpline Shared Data", fileName = "WorldSpline Prefab Shared Data")]
public class WorldSplineSharedData : ScriptableObject
{
	[SerializeField]
	private List<WorldSplineData> dataList;

	public static WorldSplineSharedData _instance;

	private static readonly string[] worldSplineFolders = new string[2] { "Assets/Content/Structures", "Assets/bundled/Prefabs/autospawn" };

	public static WorldSplineSharedData instance
	{
		get
		{
			if ((Object)(object)_instance == (Object)null)
			{
				_instance = Resources.Load<WorldSplineSharedData>("WorldSpline Prefab Shared Data");
			}
			return _instance;
		}
	}

	public static bool TryGetDataFor(WorldSpline worldSpline, out WorldSplineData data)
	{
		if ((Object)(object)instance == (Object)null)
		{
			Debug.LogError((object)"No instance of WorldSplineSharedData found.");
			data = null;
			return false;
		}
		if (worldSpline.dataIndex < 0 || worldSpline.dataIndex >= instance.dataList.Count)
		{
			data = null;
			return false;
		}
		data = instance.dataList[worldSpline.dataIndex];
		return true;
	}
}


using System;
using UnityEngine;

public static class Ballistics
{
	private struct TheoreticalProjectile
	{
		public Vector3 pos;

		public Vector3 forward;

		public float gravity;

		public TheoreticalProjectile(Vector3 pos, Vector3 forward, float gravity)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0008: Unknown result type (might be due to invalid IL or missing references)
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			this.pos = pos;
			this.forward = forward;
			this.gravity = gravity;
		}
	}

	public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, out float requiredGravity)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		return GetAimToTarget(origin, target, speed, maxAngle, idealGravity, 0f, out requiredGravity);
	}

	public static Vector3 GetAimToTarget(Vector3 origin, Vector3 target, float speed, float maxAngle, float idealGravity, float minRange, out float requiredGravity)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00da: Unknown result type (might be due to invalid IL or missing references)
		requiredGravity = idealGravity;
		Vector3 val = target - origin;
		float num = Vector3Ex.Magnitude2D(val);
		float y = val.y;
		float num2 = Mathf.Sqrt(speed * speed * speed * speed - requiredGravity * (requiredGravity * (num * num) + 2f * y * speed * speed));
		float num3 = Mathf.Atan((speed * speed + num2) / (requiredGravity * num)) * 57.29578f;
		float num4 = Mathf.Clamp(num3, 0f, 90f);
		if (float.IsNaN(num3))
		{
			num4 = 45f;
			requiredGravity = ProjectileDistToGravity(num, y, num4, speed);
		}
		else if (num3 > maxAngle)
		{
			num4 = maxAngle;
			requiredGravity = ProjectileDistToGravity(Mathf.Max(num, minRange), y, num4, speed);
		}
		((Vector3)(ref val)).Normalize();
		val.y = 0f;
		Vector3 val2 = Vector3.Cross(val, Vector3.up);
		val = Quaternion.AngleAxis(num4, val2) * val;
		return val;
	}

	public static bool TryGetPhysicsProjectileHitPos(Vector3 origin, Vector3 direction, float speed, float gravity, out Vector3 result, float flightTimePerUpwardCheck = 2f, float flightTimePerDownwardCheck = 0.66f, float maxRays = 128f, BaseNetworkable owner = null)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0003: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		TheoreticalProjectile projectile = new TheoreticalProjectile(origin, direction * speed, gravity);
		int num = 0;
		float dt = ((projectile.forward.y > 0f) ? flightTimePerUpwardCheck : flightTimePerDownwardCheck);
		while (!NextRayHitSomething(ref projectile, dt, owner) && (float)num < maxRays)
		{
			num++;
		}
		result = projectile.pos;
		return (float)num < maxRays;
	}

	public static Vector3 GetBulletHitPoint(Vector3 origin, Vector3 direction)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		return GetBulletHitPoint(new Ray(origin, direction));
	}

	public static Vector3 GetBulletHitPoint(Ray aimRay)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (GamePhysics.Trace(aimRay, 0f, out var hitInfo, 300f, 1220225809, (QueryTriggerInteraction)0))
		{
			return ((RaycastHit)(ref hitInfo)).point;
		}
		return ((Ray)(ref aimRay)).origin + ((Ray)(ref aimRay)).direction * 300f;
	}

	private static bool NextRayHitSomething(ref TheoreticalProjectile projectile, float dt, BaseNetworkable owner)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0070: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fe: Unknown result type (might be due to invalid IL or missing references)
		float gravity = projectile.gravity;
		Vector3 pos = projectile.pos;
		float num = Vector3Ex.MagnitudeXZ(projectile.forward) * dt;
		float num2 = projectile.forward.y * dt + gravity * dt * dt * 0.5f;
		Vector2 val = Vector3Ex.XZ2D(projectile.forward);
		Vector2 val2 = ((Vector2)(ref val)).normalized * num;
		Vector3 val3 = default(Vector3);
		((Vector3)(ref val3))..ctor(val2.x, num2, val2.y);
		ref Vector3 pos2 = ref projectile.pos;
		pos2 += val3;
		float y = projectile.forward.y + gravity * dt;
		projectile.forward.y = y;
		RaycastHit hit = default(RaycastHit);
		if (Physics.Linecast(pos, projectile.pos, ref hit, 1084293393, (QueryTriggerInteraction)1))
		{
			projectile.pos = ((RaycastHit)(ref hit)).point;
			BaseEntity entity = hit.GetEntity();
			int num3;
			if ((Object)(object)entity != (Object)null)
			{
				num3 = (entity.EqualNetID(owner) ? 1 : 0);
				if (num3 != 0)
				{
					ref Vector3 pos3 = ref projectile.pos;
					pos3 += projectile.forward * 1f;
				}
			}
			else
			{
				num3 = 0;
			}
			return num3 == 0;
		}
		return false;
	}

	private static float ProjectileDistToGravity(float x, float y, float θ, float v)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		float num = θ * (MathF.PI / 180f);
		float num2 = (v * v * x * Mathf.Sin(2f * num) - 2f * v * v * y * Mathf.Cos(num) * Mathf.Cos(num)) / (x * x);
		if (float.IsNaN(num2) || num2 < 0.01f)
		{
			num2 = 0f - Physics.gravity.y;
		}
		return num2;
	}
}


using UnityEngine;

private struct TheoreticalProjectile
{
	public Vector3 pos;

	public Vector3 forward;

	public float gravity;

	public TheoreticalProjectile(Vector3 pos, Vector3 forward, float gravity)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		this.pos = pos;
		this.forward = forward;
		this.gravity = gravity;
	}
}


using System.Collections.Generic;
using Facepunch;
using UnityEngine;

public static class Bezier
{
	public static void ApplyLineSlack(ref Vector3[] positions, float[] slackLevels, int tesselationLevel, Transform referenceTransform = null)
	{
		ApplyLineSlack(positions, slackLevels, ref positions, tesselationLevel, referenceTransform);
	}

	public static void ApplyLineSlack(Vector3[] positions, float[] slackLevels, ref Vector3[] result, int tesselationLevel, Transform referenceTransform = null)
	{
		List<Vector3> result2 = Pool.Get<List<Vector3>>();
		ApplyLineSlack(positions, slackLevels, ref result2, tesselationLevel, referenceTransform);
		if (result.Length >= 2 && result.Length != result2.Count)
		{
			result = (Vector3[])(object)new Vector3[result2.Count];
		}
		result2.CopyTo(result);
		Pool.FreeUnmanaged<Vector3>(ref result2);
	}

	public static int CalculateArraySize(int positionCount, int tesselationLevel)
	{
		return (positionCount - 1) * tesselationLevel + 2;
	}

	public static void ApplyLineSlack(Vector3[] positions, float[] slackLevels, ref List<Vector3> result, int tesselationLevel, Transform referenceTransform = null)
	{
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_015b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0160: Unknown result type (might be due to invalid IL or missing references)
		//IL_0163: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_0108: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_010f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0123: Unknown result type (might be due to invalid IL or missing references)
		if (positions.Length < 2 || slackLevels.Length == 0)
		{
			return;
		}
		bool flag = false;
		for (int i = 0; i < slackLevels.Length; i++)
		{
			if (slackLevels[i] > 0f)
			{
				flag = true;
				break;
			}
		}
		if (!flag)
		{
			result.AddRange(positions);
			return;
		}
		bool flag2 = (Object)(object)referenceTransform != (Object)null;
		float num = 1f / (float)tesselationLevel;
		for (int j = 0; j < positions.Length - 1; j++)
		{
			Vector3 val = positions[j];
			Vector3 val2 = positions[j + 1];
			if ((Object)(object)referenceTransform != (Object)null)
			{
				val = referenceTransform.TransformPoint(val);
				val2 = referenceTransform.TransformPoint(val2);
			}
			Vector3 val3 = Vector3.Lerp(val, val2, 0.5f);
			if (j < slackLevels.Length)
			{
				val3 += Vector3.down * slackLevels[j];
			}
			if (flag2)
			{
				result.Add(referenceTransform.InverseTransformPoint(val));
			}
			else
			{
				result.Add(val);
			}
			for (int k = 0; k < tesselationLevel; k++)
			{
				float num2 = (float)k * num;
				num2 = num2 * 0.8f + 0.1f;
				Vector3 val4 = Vector3.Lerp(val, val3, num2);
				Vector3 val5 = Vector3.Lerp(val3, val2, num2);
				Vector3 val6 = Vector3.Lerp(val4, val5, num2);
				if (flag2)
				{
					result.Add(referenceTransform.InverseTransformPoint(val6));
				}
				else
				{
					result.Add(val6);
				}
			}
		}
		Vector3 item = positions[^1];
		result.Add(item);
	}
}


using UnityEngine;

public struct FixedShort3
{
	private const int FracBits = 10;

	private const float MaxFrac = 1024f;

	private const float RcpMaxFrac = 0.0009765625f;

	public short x;

	public short y;

	public short z;

	public FixedShort3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		x = (short)(vec.x * 1024f);
		y = (short)(vec.y * 1024f);
		z = (short)(vec.z * 1024f);
	}

	public static explicit operator Vector3(FixedShort3 vec)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)vec.x * 0.0009765625f, (float)vec.y * 0.0009765625f, (float)vec.z * 0.0009765625f);
	}
}


using UnityEngine;

public struct FixedSByteNorm3
{
	private const int FracBits = 7;

	private const float MaxFrac = 128f;

	private const float RcpMaxFrac = 1f / 128f;

	public sbyte x;

	public sbyte y;

	public sbyte z;

	public FixedSByteNorm3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		x = (sbyte)(vec.x * 128f);
		y = (sbyte)(vec.y * 128f);
		z = (sbyte)(vec.z * 128f);
	}

	public static explicit operator Vector3(FixedSByteNorm3 vec)
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3((float)vec.x * (1f / 128f), (float)vec.y * (1f / 128f), (float)vec.z * (1f / 128f));
	}
}


using UnityEngine;

public struct FixedSByteNorm4
{
	private const int FracBits = 7;

	private const float MaxFrac = 128f;

	private const float RcpMaxFrac = 1f / 128f;

	public sbyte x;

	public sbyte y;

	public sbyte z;

	public sbyte w;

	public FixedSByteNorm4(Vector4 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		x = (sbyte)(vec.x * 128f);
		y = (sbyte)(vec.y * 128f);
		z = (sbyte)(vec.z * 128f);
		w = (sbyte)(vec.w * 128f);
	}

	public static explicit operator Vector4(FixedSByteNorm4 vec)
	{
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4((float)vec.x * (1f / 128f), (float)vec.y * (1f / 128f), (float)vec.z * (1f / 128f), (float)vec.w * (1f / 128f));
	}
}


using UnityEngine;

public struct Half3
{
	public ushort x;

	public ushort y;

	public ushort z;

	public Half3(Vector3 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		x = Mathf.FloatToHalf(vec.x);
		y = Mathf.FloatToHalf(vec.y);
		z = Mathf.FloatToHalf(vec.z);
	}

	public static explicit operator Vector3(Half3 vec)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		return new Vector3(Mathf.HalfToFloat(vec.x), Mathf.HalfToFloat(vec.y), Mathf.HalfToFloat(vec.z));
	}
}


using UnityEngine;

public struct Half4
{
	public ushort x;

	public ushort y;

	public ushort z;

	public ushort w;

	public Half4(Vector4 vec)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		x = Mathf.FloatToHalf(vec.x);
		y = Mathf.FloatToHalf(vec.y);
		z = Mathf.FloatToHalf(vec.z);
		w = Mathf.FloatToHalf(vec.w);
	}

	public static explicit operator Vector4(Half4 vec)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		return new Vector4(Mathf.HalfToFloat(vec.x), Mathf.HalfToFloat(vec.y), Mathf.HalfToFloat(vec.z), Mathf.HalfToFloat(vec.w));
	}
}


using System.Collections.Concurrent;
using System.Collections.Generic;

public class ExactArrayPool<T>
{
	private readonly Dictionary<int, ConcurrentQueue<T[]>> _buffers = new Dictionary<int, ConcurrentQueue<T[]>>();

	public T[] Rent(int size)
	{
		if (!_buffers.TryGetValue(size, out var value))
		{
			value = new ConcurrentQueue<T[]>();
			_buffers[size] = value;
		}
		if (!value.TryDequeue(out var result))
		{
			return new T[size];
		}
		return result;
	}

	public void Return(T[] array)
	{
		if (!_buffers.TryGetValue(array.Length, out var value))
		{
			value = new ConcurrentQueue<T[]>();
			_buffers[array.Length] = value;
		}
		value.Enqueue(array);
	}
}


using System;
using System.Linq;
using ConVar;
using UnityEngine;

public class Poolable : MonoBehaviour, IClientComponent, IPrefabPostProcess
{
	[HideInInspector]
	public uint prefabID;

	[HideInInspector]
	public Behaviour[] behaviours;

	[HideInInspector]
	public Rigidbody[] rigidbodies;

	[HideInInspector]
	public Collider[] colliders;

	[HideInInspector]
	public LODGroup[] lodgroups;

	[HideInInspector]
	public Renderer[] renderers;

	[HideInInspector]
	public ParticleSystem[] particles;

	[HideInInspector]
	public bool[] behaviourStates;

	[HideInInspector]
	public bool[] rigidbodyStates;

	[HideInInspector]
	public bool[] colliderStates;

	[HideInInspector]
	public bool[] lodgroupStates;

	[HideInInspector]
	public bool[] rendererStates;

	public int ClientCount
	{
		get
		{
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<CodeLock>()))
			{
				return 200;
			}
			if ((Object)(object)((Component)this).GetComponent<LootPanel>() != (Object)null)
			{
				return 1;
			}
			if (((Component)this).GetComponent<DecorComponent>() != null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<BuildingBlock>() != (Object)null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<Door>() != (Object)null)
			{
				if ((bool)((Component)this).GetComponent<Construction>())
				{
					return 100;
				}
				return 1;
			}
			if ((Object)(object)((Component)this).GetComponent<Projectile>() != (Object)null)
			{
				return 100;
			}
			if ((Object)(object)((Component)this).GetComponent<Gib>() != (Object)null)
			{
				return 100;
			}
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<UIMapVendingMachineMarker>()))
			{
				return 25;
			}
			if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<UIMapVendingMachineMarkerCluster>()))
			{
				return 25;
			}
			if ((Object)(object)((Component)this).GetComponent<CollectableEasterEgg>() != (Object)null)
			{
				return 50;
			}
			return 1;
		}
	}

	public int ServerCount => 0;

	public void PostProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
		if (!bundling && !((Object)(object)((Component)this).gameObject != (Object)(object)rootObj))
		{
			Initialize(StringPool.Get(name));
		}
	}

	public void Initialize(uint id)
	{
		prefabID = id;
		behaviours = ((Component)this).gameObject.GetComponentsInChildren(typeof(Behaviour), true).OfType<Behaviour>().ToArray();
		rigidbodies = ((Component)this).gameObject.GetComponentsInChildren<Rigidbody>(true);
		colliders = ((Component)this).gameObject.GetComponentsInChildren<Collider>(true);
		lodgroups = ((Component)this).gameObject.GetComponentsInChildren<LODGroup>(true);
		renderers = ((Component)this).gameObject.GetComponentsInChildren<Renderer>(true);
		particles = ((Component)this).gameObject.GetComponentsInChildren<ParticleSystem>(true);
		if (behaviours.Length == 0)
		{
			behaviours = Array.Empty<Behaviour>();
		}
		if (rigidbodies.Length == 0)
		{
			rigidbodies = Array.Empty<Rigidbody>();
		}
		if (colliders.Length == 0)
		{
			colliders = Array.Empty<Collider>();
		}
		if (lodgroups.Length == 0)
		{
			lodgroups = Array.Empty<LODGroup>();
		}
		if (renderers.Length == 0)
		{
			renderers = Array.Empty<Renderer>();
		}
		if (particles.Length == 0)
		{
			particles = Array.Empty<ParticleSystem>();
		}
		behaviourStates = ArrayEx.New<bool>(behaviours.Length);
		rigidbodyStates = ArrayEx.New<bool>(rigidbodies.Length);
		colliderStates = ArrayEx.New<bool>(colliders.Length);
		lodgroupStates = ArrayEx.New<bool>(lodgroups.Length);
		rendererStates = ArrayEx.New<bool>(renderers.Length);
	}

	public void EnterPool()
	{
		if ((Object)(object)((Component)this).transform.parent != (Object)null)
		{
			((Component)this).transform.SetParent((Transform)null, false);
		}
		if (Pool.mode <= 1)
		{
			if (((Component)this).gameObject.activeSelf)
			{
				((Component)this).gameObject.SetActive(false);
			}
			return;
		}
		SetBehaviourEnabled(state: false);
		SetComponentEnabled(state: false);
		if (!((Component)this).gameObject.activeSelf)
		{
			((Component)this).gameObject.SetActive(true);
		}
	}

	public void LeavePool()
	{
		if (Pool.mode > 1)
		{
			SetComponentEnabled(state: true);
		}
	}

	public void SetBehaviourEnabled(bool state)
	{
		try
		{
			if (!state)
			{
				for (int i = 0; i < behaviours.Length; i++)
				{
					Behaviour val = behaviours[i];
					behaviourStates[i] = val.enabled;
					val.enabled = false;
				}
				for (int j = 0; j < particles.Length; j++)
				{
					ParticleSystem obj = particles[j];
					obj.Stop();
					obj.Clear();
				}
				return;
			}
			for (int k = 0; k < particles.Length; k++)
			{
				ParticleSystem val2 = particles[k];
				if (val2.playOnAwake)
				{
					val2.Play();
				}
			}
			for (int l = 0; l < behaviours.Length; l++)
			{
				behaviours[l].enabled = behaviourStates[l];
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Pooling error: " + ((Object)this).name + " (" + ex.Message + ")"));
		}
	}

	public void SetComponentEnabled(bool state)
	{
		try
		{
			if (!state)
			{
				for (int i = 0; i < renderers.Length; i++)
				{
					Renderer val = renderers[i];
					rendererStates[i] = val.enabled;
					val.enabled = false;
				}
				for (int j = 0; j < lodgroups.Length; j++)
				{
					LODGroup val2 = lodgroups[j];
					lodgroupStates[j] = val2.enabled;
					val2.enabled = false;
				}
				for (int k = 0; k < colliders.Length; k++)
				{
					Collider val3 = colliders[k];
					colliderStates[k] = val3.enabled;
					val3.enabled = false;
				}
				for (int l = 0; l < rigidbodies.Length; l++)
				{
					Rigidbody val4 = rigidbodies[l];
					rigidbodyStates[l] = val4.isKinematic;
					val4.isKinematic = true;
					val4.detectCollisions = false;
				}
			}
			else
			{
				for (int m = 0; m < renderers.Length; m++)
				{
					renderers[m].enabled = rendererStates[m];
				}
				for (int n = 0; n < lodgroups.Length; n++)
				{
					lodgroups[n].enabled = lodgroupStates[n];
				}
				for (int num = 0; num < colliders.Length; num++)
				{
					colliders[num].enabled = colliderStates[num];
				}
				for (int num2 = 0; num2 < rigidbodies.Length; num2++)
				{
					Rigidbody obj = rigidbodies[num2];
					obj.isKinematic = rigidbodyStates[num2];
					obj.detectCollisions = true;
				}
			}
		}
		catch (Exception ex)
		{
			Debug.LogError((object)("Pooling error: " + ((Object)this).name + " (" + ex.Message + ")"));
		}
	}
}


using UnityEngine;

public static class PoolableEx
{
	public static bool SupportsPoolingInParent(this GameObject gameObject)
	{
		Poolable componentInParent = gameObject.GetComponentInParent<Poolable>();
		if ((Object)(object)componentInParent != (Object)null)
		{
			return componentInParent.prefabID != 0;
		}
		return false;
	}

	public static bool SupportsPooling(this GameObject gameObject)
	{
		Poolable component = gameObject.GetComponent<Poolable>();
		if ((Object)(object)component != (Object)null)
		{
			return component.prefabID != 0;
		}
		return false;
	}

	public static void AwakeFromInstantiate(this GameObject gameObject)
	{
		if (gameObject.activeSelf)
		{
			gameObject.GetComponent<Poolable>().SetBehaviourEnabled(state: true);
		}
		else
		{
			gameObject.SetActive(true);
		}
	}
}


using System.Collections.Generic;
using UnityEngine;

public class PrefabPool
{
	public Stack<Poolable> stack = new Stack<Poolable>();

	public string PrefabName { get; private set; }

	public int Missed { get; private set; }

	public int Pushed { get; private set; }

	public int Popped { get; private set; }

	public int Count => stack.Count;

	public int TargetCapacity { get; private set; }

	public PrefabPool(uint prefabId, int targetCapacity)
	{
		PrefabName = StringPool.Get(prefabId);
		TargetCapacity = targetCapacity;
	}

	public void Push(Poolable info)
	{
		Pushed++;
		stack.Push(info);
		info.EnterPool();
	}

	public void Push(GameObject instance)
	{
		Poolable component = instance.GetComponent<Poolable>();
		Push(component);
	}

	public GameObject Pop(Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion))
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		while (stack.Count > 0)
		{
			Poolable poolable = stack.Pop();
			Popped++;
			if (Object.op_Implicit((Object)(object)poolable))
			{
				((Component)poolable).transform.position = pos;
				((Component)poolable).transform.rotation = rot;
				poolable.LeavePool();
				return ((Component)poolable).gameObject;
			}
		}
		Missed++;
		return null;
	}

	public void Clear()
	{
		foreach (Poolable item in stack)
		{
			if (Object.op_Implicit((Object)(object)item))
			{
				Object.Destroy((Object)(object)((Component)item).gameObject);
			}
		}
		stack.Clear();
	}
}


using System.Collections.Generic;
using System.Globalization;
using UnityEngine;

public class PrefabPoolCollection
{
	public Dictionary<uint, PrefabPool> storage = new Dictionary<uint, PrefabPool>();

	private bool isClient;

	public PrefabPoolCollection(bool client)
	{
		isClient = client;
	}

	public void Push(GameObject instance)
	{
		Poolable component = instance.GetComponent<Poolable>();
		if (!storage.TryGetValue(component.prefabID, out var value))
		{
			int targetCapacity = (isClient ? component.ClientCount : component.ServerCount);
			value = new PrefabPool(component.prefabID, targetCapacity);
			storage.Add(component.prefabID, value);
		}
		value.Push(component);
	}

	public GameObject Pop(uint id, Vector3 pos = default(Vector3), Quaternion rot = default(Quaternion))
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (storage.TryGetValue(id, out var value))
		{
			return value.Pop(pos, rot);
		}
		return null;
	}

	public void Clear(string filter = null)
	{
		if (string.IsNullOrEmpty(filter))
		{
			foreach (KeyValuePair<uint, PrefabPool> item in storage)
			{
				item.Value.Clear();
			}
			return;
		}
		foreach (KeyValuePair<uint, PrefabPool> item2 in storage)
		{
			if (StringEx.Contains(StringPool.Get(item2.Key), filter, CompareOptions.IgnoreCase))
			{
				item2.Value.Clear();
			}
		}
	}
}


using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.Linq;
using ConVar;
using Rust;
using UnityEngine;

public class PrefabPoolWarmup
{
	public static void Run(string filter = null, int countOverride = 0)
	{
		if (Application.isLoadingPrefabs)
		{
			return;
		}
		Application.isLoadingPrefabs = true;
		string[] assetList = GetAssetList();
		if (string.IsNullOrEmpty(filter))
		{
			for (int i = 0; i < assetList.Length; i++)
			{
				PrefabWarmup(assetList[i], countOverride);
			}
		}
		else
		{
			foreach (string text in assetList)
			{
				if (StringEx.Contains(text, filter, CompareOptions.IgnoreCase))
				{
					PrefabWarmup(text, countOverride);
				}
			}
		}
		Application.isLoadingPrefabs = false;
	}

	public static IEnumerator Run(float deltaTime, Action<string> statusFunction = null, string format = null)
	{
		if (Application.isEditor || Application.isLoadingPrefabs || !Pool.prewarm)
		{
			yield break;
		}
		Application.isLoadingPrefabs = true;
		string[] prewarmAssets = GetAssetList();
		Timing timer = new Timing("prefab_warmup");
		Stopwatch sw = Stopwatch.StartNew();
		for (int i = 0; i < prewarmAssets.Length; i++)
		{
			if (sw.Elapsed.TotalSeconds > (double)deltaTime || i == 0 || i == prewarmAssets.Length - 1)
			{
				statusFunction?.Invoke(string.Format((format != null) ? format : "{0}/{1}", i + 1, prewarmAssets.Length));
				yield return CoroutineEx.waitForEndOfFrame;
				sw.Reset();
				sw.Start();
			}
			PrefabWarmup(prewarmAssets[i]);
		}
		timer.End();
		Application.isLoadingPrefabs = false;
	}

	public static string[] GetAssetList()
	{
		return (from x in GameManifest.Current.prefabProperties
			where x.pool
			select x.name).ToArray();
	}

	private static void PrefabWarmup(string path, int countOverride = 0)
	{
		if (string.IsNullOrEmpty(path))
		{
			return;
		}
		GameObject val = GameManager.server.FindPrefab(path);
		if ((Object)(object)val != (Object)null && val.SupportsPooling())
		{
			int num = val.GetComponent<Poolable>().ServerCount;
			List<GameObject> list = new List<GameObject>();
			if (num > 0 && countOverride > 0)
			{
				num = countOverride;
			}
			for (int i = 0; i < num; i++)
			{
				list.Add(GameManager.server.CreatePrefab(path));
			}
			for (int j = 0; j < num; j++)
			{
				GameManager.server.Retire(list[j]);
			}
		}
	}
}


using UnityEngine;

public static class PorabolaUtils
{
	public static Vector3 SampleParabola(Vector3 start, Vector3 end, float height, float t, bool useLevelDirection = false)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_0058: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_005e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0032: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_008f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		float num = t * 2f - 1f;
		if (Mathf.Abs(start.y - end.y) < 0.1f)
		{
			Vector3 val = end - start;
			Vector3 result = start + t * val;
			result.y += ((0f - num) * num + 1f) * height;
			return result;
		}
		Vector3 val2 = end - start;
		Vector3 val3 = end - new Vector3(start.x, end.y, start.z);
		Vector3 val4 = Vector3.Cross(val2, val3);
		Vector3 val5 = ((!useLevelDirection) ? Vector3.Cross(val4, val2) : Vector3.Cross(val4, val3));
		if (end.y > start.y)
		{
			val5 = -val5;
		}
		return start + t * val2 + ((0f - num) * num + 1f) * height * ((Vector3)(ref val5)).normalized;
	}

	public static float FindT(Vector3 start, Vector3 end, float height, Vector3 targetPosition, bool useLevelDirection = false)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		float num = 0.5f;
		float num2 = 0.01f;
		for (num = 0f; num <= 1f; num += num2)
		{
			if (Vector3.Distance(SampleParabola(start, end, height, num, useLevelDirection), targetPosition) < 0.01f)
			{
				return num;
			}
		}
		return -1f;
	}

	public static Vector3 RotateAroundWorldAxis(Vector3 point, Vector3 pivot, Vector3 axis, float angle)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		Quaternion val = Quaternion.AngleAxis(angle, axis);
		Vector3 val2 = point - pivot;
		Vector3 val3 = val * val2;
		return pivot + val3;
	}
}


using System;
using UnityEngine;

[Serializable]
public struct LayerSelect
{
	[SerializeField]
	private int layer;

	public int Mask => 1 << layer;

	public string Name => LayerMask.LayerToName(layer);

	public LayerSelect(int layer)
	{
		this.layer = layer;
	}

	public static implicit operator int(LayerSelect layer)
	{
		return layer.layer;
	}

	public static implicit operator LayerSelect(int layer)
	{
		return new LayerSelect(layer);
	}
}


using System;

public class NetworkedProperty<T> where T : IEquatable<T>
{
	private T val;

	private BaseEntity entity;

	public T Value
	{
		get
		{
			return val;
		}
		set
		{
			if (!val.Equals(value))
			{
				val = value;
				if (entity.isServer)
				{
					entity.SendNetworkUpdate();
				}
			}
		}
	}

	public NetworkedProperty(BaseEntity entity)
	{
		this.entity = entity;
	}

	public static implicit operator T(NetworkedProperty<T> value)
	{
		return value.Value;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResettableFloat : ISerializationCallbackReceiver
{
	[SerializeField]
	private float defaultValue;

	[NonSerialized]
	private float currentValue;

	public float Value
	{
		get
		{
			return currentValue;
		}
		set
		{
			currentValue = value;
		}
	}

	public float DefaultValue => defaultValue;

	public ResettableFloat(float value)
	{
		defaultValue = value;
		currentValue = value;
	}

	public void OnBeforeSerialize()
	{
	}

	public void OnAfterDeserialize()
	{
		currentValue = defaultValue;
	}

	public void Reset()
	{
		currentValue = defaultValue;
	}
}


using System;
using UnityEngine;

[Serializable]
public class BaseEntityRef : ResourceRef<BaseEntity>
{
	public override BaseEntity Get()
	{
		if ((Object)(object)_cachedObject != (Object)null)
		{
			return _cachedObject;
		}
		Object obj = GameManifest.GUIDToObject(guid);
		GameObject val = (GameObject)(object)((obj is GameObject) ? obj : null);
		BaseEntity baseEntity = null;
		if ((Object)(object)val != (Object)null && val.TryGetComponent<BaseEntity>(ref baseEntity))
		{
			_cachedObject = baseEntity;
		}
		return baseEntity;
	}
}


using System;
using Facepunch;
using UnityEngine;

[Serializable]
public class GameObjectRef : ResourceRef<GameObject>
{
	public GameObject Instantiate(Transform parent = null)
	{
		return Instantiate.GameObject(Get(), parent);
	}

	public BaseEntity GetEntity()
	{
		GameObject val = Get();
		if (!((Object)(object)val == (Object)null))
		{
			return val.GetComponent<BaseEntity>();
		}
		return null;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ResourceRef<T> where T : Object
{
	public string guid;

	protected T _cachedObject;

	public bool isValid => !string.IsNullOrEmpty(guid);

	public string resourcePath => GameManifest.GUIDToPath(guid);

	public uint resourceID => StringPool.Get(resourcePath);

	public virtual T Get()
	{
		if ((Object)(object)_cachedObject == (Object)null)
		{
			ref T cachedObject = ref _cachedObject;
			Object obj = GameManifest.GUIDToObject(guid);
			cachedObject = (T)(object)((obj is T) ? obj : null);
		}
		return _cachedObject;
	}
}


using System;
using UnityEngine;

[Serializable]
public class ScriptableObjectRef : ResourceRef<ScriptableObject>
{
}


using System;
using UnityEngine;

[Serializable]
public class Texture2DRef : ResourceRef<Texture2D>
{
}


using UnityEngine;

public class RandomGameObject : MonoBehaviour
{
	public GameObject[] gameObjects;

	private void Awake()
	{
		EnableRandomObject();
	}

	private void EnableRandomObject()
	{
		if (gameObjects.Length != 0)
		{
			GameObject[] array = gameObjects;
			for (int i = 0; i < array.Length; i++)
			{
				array[i].SetActive(false);
			}
			gameObjects.GetRandom().SetActive(true);
		}
	}
}


using UnityEngine;

public class RandomScale : MonoBehaviour
{
	[SerializeField]
	private bool multiplyByExistingScale = true;

	[SerializeField]
	private Vector3 minScale = Vector3.one * 0.8f;

	[SerializeField]
	private Vector3 maxScale = Vector3.one * 1.2f;

	private void Awake()
	{
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		if (multiplyByExistingScale)
		{
			Transform transform = ((Component)this).transform;
			transform.localScale *= Random.Range(minScale.x, maxScale.x);
		}
		else
		{
			((Component)this).transform.localScale = Vector3.one * Random.Range(minScale.x, maxScale.x);
		}
	}
}


using System;
using System.Runtime.CompilerServices;
using UnityEngine;

[Factory("log")]
public class RustLog : ConsoleSystem
{
	public enum EntryType
	{
		General,
		Network,
		Hierarchy,
		Serialization,
		Combat,
		Item,
		Audio
	}

	private static readonly string[] names = Enum.GetNames(typeof(EntryType));

	public static readonly int[] Levels = new int[names.Length];

	[ClientVar]
	[ServerVar]
	public static void Level(Arg args)
	{
		if (args.Args.Length == 0 || args.Args.Length > 2)
		{
			return;
		}
		string @string = args.GetString(0, "");
		if (string.IsNullOrEmpty(@string))
		{
			return;
		}
		for (int i = 0; i < names.Length; i++)
		{
			string text = names[i];
			if (!(@string != text))
			{
				if (args.Args.Length == 2)
				{
					Levels[i] = args.GetInt(1, Levels[i]);
				}
				else
				{
					Debug.Log((object)GetLevel((EntryType)i));
				}
				break;
			}
		}
	}

	public static int GetLevel(EntryType type)
	{
		return Levels[(int)type];
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log(EntryType type, int level, GameObject gameObject, string msg)
	{
		if (GetLevel(type) >= level)
		{
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3, T4>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3, T4 arg4)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3, arg4);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static void Log<T1, T2, T3, T4, T5>(EntryType type, int level, GameObject gameObject, string msgFormat, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5)
	{
		if (GetLevel(type) >= level)
		{
			string msg = string.Format(msgFormat, arg1, arg2, arg3, arg4, arg5);
			LogImpl(type, msg, gameObject);
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static void LogImpl(EntryType type, string msg, GameObject gameObject)
	{
		Debug.Log((object)$"<color=white>[{type}]</color> {msg}", (Object)(object)gameObject);
	}
}


public enum EntryType
{
	General,
	Network,
	Hierarchy,
	Serialization,
	Combat,
	Item,
	Audio
}


using UnityEngine;

public class AlternateAttack : StateMachineBehaviour
{
	public bool random;

	public bool dontIncrement;

	public string[] targetTransitions;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (random)
		{
			string text = targetTransitions[Random.Range(0, targetTransitions.Length)];
			animator.Play(text, layerIndex, 0f);
			return;
		}
		int integer = animator.GetInteger("lastAttack");
		string text2 = targetTransitions[integer % targetTransitions.Length];
		animator.Play(text2, layerIndex, 0f);
		if (!dontIncrement)
		{
			animator.SetInteger("lastAttack", integer + 1);
		}
	}
}


using System.Collections.Generic;
using Rust.Workshop;
using UnityEngine;

public class BaseViewModel : FacepunchBehaviour, IPrefabPreProcess, IViewmodelWorkshopPreview, IWorkshopPreview
{
	public enum ViewmodelType
	{
		Regular,
		Gesture,
		Shield
	}

	[Header("BaseViewModel")]
	public LazyAimProperties lazyaimRegular;

	public LazyAimProperties lazyaimIronsights;

	public Transform pivot;

	public bool useViewModelCamera = true;

	public bool wantsHeldItemFlags;

	public GameObject[] hideSightMeshes;

	public ViewmodelType viewmodelType;

	public Transform MuzzlePoint;

	[Header("Skin")]
	public SubsurfaceProfile subsurfaceProfile;

	[HideInInspector]
	public List<SkinnedMeshRenderer> baseSkinPieces = new List<SkinnedMeshRenderer>();

	[Header("Shield Overrides")]
	public AnimationCurve leftArmShieldHideCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public void PreProcess(IPrefabProcessor preProcess, GameObject rootObj, string name, bool serverside, bool clientside, bool bundling)
	{
	}
}


public enum ViewmodelType
{
	Regular,
	Gesture,
	Shield
}


public interface IViewmodelComponent
{
}


using UnityEngine;

public class BinocularViewmodel : MonoBehaviour, IViewmodelComponent
{
}


using UnityEngine;

public class BlunderbussViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;

	public float ShotsLeftSpeed = 1f;

	public int HammerLayer = 1;
}


using System;
using UnityEngine;

public class FishingRodViewmodel : MonoBehaviour
{
	[Serializable]
	public struct FishViewmodel
	{
		public ItemDefinition Item;

		public GameObject Root;
	}

	public Transform PitchTransform;

	public Transform YawTransform;

	public float YawLerpSpeed = 1f;

	public float PitchLerpSpeed = 1f;

	public Transform LineRendererStartPos;

	public ParticleSystem[] StrainParticles;

	public bool ApplyTransformRotation = true;

	public GameObject CatchRoot;

	public Transform CatchLinePoint;

	public FishViewmodel[] FishViewmodels;

	public float ShakeMaxScale = 0.1f;
}


using System;
using UnityEngine;

[Serializable]
public struct FishViewmodel
{
	public ItemDefinition Item;

	public GameObject Root;
}


public enum flamethrowerState
{
	OFF,
	PILOT_LIGHT,
	FLAME_ON
}


using UnityEngine;

public class flamethrowerFire : MonoBehaviour
{
	public ParticleSystem pilotLightFX;

	public ParticleSystem[] flameFX;

	public FlameJet jet;

	public AudioSource oneShotSound;

	public AudioSource loopSound;

	public AudioClip pilotlightIdle;

	public AudioClip flameLoop;

	public AudioClip flameStart;

	public flamethrowerState flameState;

	private flamethrowerState previousflameState;

	public void PilotLightOn()
	{
		pilotLightFX.enableEmission = true;
		SetFlameStatus(status: false);
	}

	public void SetFlameStatus(bool status)
	{
		ParticleSystem[] array = flameFX;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].enableEmission = status;
		}
	}

	public void ShutOff()
	{
		pilotLightFX.enableEmission = false;
		SetFlameStatus(status: false);
	}

	public void FlameOn()
	{
		pilotLightFX.enableEmission = false;
		SetFlameStatus(status: true);
	}

	private void Start()
	{
		previousflameState = (flameState = flamethrowerState.OFF);
		ShutOff();
	}

	private void Update()
	{
		if (previousflameState != flameState)
		{
			switch (flameState)
			{
			case flamethrowerState.OFF:
				ShutOff();
				break;
			case flamethrowerState.PILOT_LIGHT:
				PilotLightOn();
				break;
			case flamethrowerState.FLAME_ON:
				FlameOn();
				break;
			}
			previousflameState = flameState;
			jet.SetOn(flameState == flamethrowerState.FLAME_ON);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

public class FoodViewModel : BaseViewModel
{
	[Serializable]
	public class FoodVisualConfig
	{
		public List<FoodVisualObject> VisualItems = new List<FoodVisualObject>();

		public string TintMaterialProperty;

		private MaterialPropertyBlock materialPB;

		private int detailAlbedo;

		public void InitForItem(Item item)
		{
			if (item != null && !((Object)(object)item.info == (Object)null))
			{
				InitForItemDef(item.info);
			}
		}

		public void InitForItemDef(ItemDefinition itemDef)
		{
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001d: Expected O, but got Unknown
			if ((Object)(object)itemDef == (Object)null)
			{
				return;
			}
			if (materialPB == null)
			{
				materialPB = new MaterialPropertyBlock();
				detailAlbedo = Shader.PropertyToID(TintMaterialProperty);
			}
			FoodVisualObject foodVisualObject = null;
			foreach (FoodVisualObject visualItem in VisualItems)
			{
				if (visualItem != null)
				{
					visualItem.SetVisible(flag: false);
					if ((Object)(object)visualItem.ItemDef == (Object)(object)itemDef)
					{
						foodVisualObject = visualItem;
					}
				}
			}
			if (foodVisualObject != null)
			{
				foodVisualObject.SetVisible(flag: true);
				foodVisualObject.ApplyTint(materialPB, detailAlbedo);
			}
		}

		public void HideAll()
		{
			foreach (FoodVisualObject visualItem in VisualItems)
			{
				visualItem?.SetVisible(flag: false);
			}
		}
	}

	[Serializable]
	public class FoodVisualObject
	{
		public ItemDefinition ItemDef;

		public List<GameObject> GameObjects;

		public SkinnedMeshRenderer TintSkinnedRenderer;

		public List<MeshRenderer> TintRenderers;

		public Color ColorTint;

		public void SetVisible(bool flag)
		{
			if (GameObjects == null)
			{
				return;
			}
			foreach (GameObject gameObject in GameObjects)
			{
				gameObject.SetActive(flag);
			}
		}

		public void ApplyTint(MaterialPropertyBlock mpb, int matPropertyName)
		{
			//IL_0022: Unknown result type (might be due to invalid IL or missing references)
			if (mpb == null || ((Object)(object)TintSkinnedRenderer == (Object)null && TintRenderers == null) || matPropertyName == 0)
			{
				return;
			}
			mpb.SetColor(matPropertyName, ColorTint);
			if ((Object)(object)TintSkinnedRenderer != (Object)null)
			{
				((Renderer)TintSkinnedRenderer).SetPropertyBlock(mpb, 0);
			}
			if (TintRenderers == null)
			{
				return;
			}
			foreach (MeshRenderer tintRenderer in TintRenderers)
			{
				if (!((Object)(object)tintRenderer == (Object)null))
				{
					((Renderer)tintRenderer).SetPropertyBlock(mpb, 0);
				}
			}
		}
	}

	public List<GameObject> VisualRoots;

	public FoodVisualConfig VisualConfig;
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FoodVisualConfig
{
	public List<FoodVisualObject> VisualItems = new List<FoodVisualObject>();

	public string TintMaterialProperty;

	private MaterialPropertyBlock materialPB;

	private int detailAlbedo;

	public void InitForItem(Item item)
	{
		if (item != null && !((Object)(object)item.info == (Object)null))
		{
			InitForItemDef(item.info);
		}
	}

	public void InitForItemDef(ItemDefinition itemDef)
	{
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		if ((Object)(object)itemDef == (Object)null)
		{
			return;
		}
		if (materialPB == null)
		{
			materialPB = new MaterialPropertyBlock();
			detailAlbedo = Shader.PropertyToID(TintMaterialProperty);
		}
		FoodVisualObject foodVisualObject = null;
		foreach (FoodVisualObject visualItem in VisualItems)
		{
			if (visualItem != null)
			{
				visualItem.SetVisible(flag: false);
				if ((Object)(object)visualItem.ItemDef == (Object)(object)itemDef)
				{
					foodVisualObject = visualItem;
				}
			}
		}
		if (foodVisualObject != null)
		{
			foodVisualObject.SetVisible(flag: true);
			foodVisualObject.ApplyTint(materialPB, detailAlbedo);
		}
	}

	public void HideAll()
	{
		foreach (FoodVisualObject visualItem in VisualItems)
		{
			visualItem?.SetVisible(flag: false);
		}
	}
}


using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class FoodVisualObject
{
	public ItemDefinition ItemDef;

	public List<GameObject> GameObjects;

	public SkinnedMeshRenderer TintSkinnedRenderer;

	public List<MeshRenderer> TintRenderers;

	public Color ColorTint;

	public void SetVisible(bool flag)
	{
		if (GameObjects == null)
		{
			return;
		}
		foreach (GameObject gameObject in GameObjects)
		{
			gameObject.SetActive(flag);
		}
	}

	public void ApplyTint(MaterialPropertyBlock mpb, int matPropertyName)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		if (mpb == null || ((Object)(object)TintSkinnedRenderer == (Object)null && TintRenderers == null) || matPropertyName == 0)
		{
			return;
		}
		mpb.SetColor(matPropertyName, ColorTint);
		if ((Object)(object)TintSkinnedRenderer != (Object)null)
		{
			((Renderer)TintSkinnedRenderer).SetPropertyBlock(mpb, 0);
		}
		if (TintRenderers == null)
		{
			return;
		}
		foreach (MeshRenderer tintRenderer in TintRenderers)
		{
			if (!((Object)(object)tintRenderer == (Object)null))
			{
				((Renderer)tintRenderer).SetPropertyBlock(mpb, 0);
			}
		}
	}
}


using UnityEngine;

public class GrenadeViewmodel : MonoBehaviour, IViewmodelComponent
{
	public Animator TargetAnimator;
}


using UnityEngine;

public class HandcuffsViewModel : BaseViewModel
{
	public SkinnedMeshRenderer handcuffsRenderer;
}


using UnityEngine;

public class IronsightAimPoint : MonoBehaviour
{
	public Transform targetPoint;

	private void OnDrawGizmos()
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c0: Unknown result type (might be due to invalid IL or missing references)
		Gizmos.color = Color.cyan;
		Vector3 val = targetPoint.position - ((Component)this).transform.position;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Gizmos.color = Color.red;
		DrawArrow(((Component)this).transform.position, ((Component)this).transform.position + normalized * 0.1f, 0.1f);
		Gizmos.color = Color.cyan;
		DrawArrow(((Component)this).transform.position, targetPoint.position, 0.02f);
		Gizmos.color = Color.yellow;
		DrawArrow(targetPoint.position, targetPoint.position + normalized * 3f, 0.02f);
	}

	private void DrawArrow(Vector3 start, Vector3 end, float arrowLength)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = end - start;
		Vector3 normalized = ((Vector3)(ref val)).normalized;
		Vector3 up = ((Component)Camera.current).transform.up;
		Gizmos.DrawLine(start, end);
		Gizmos.DrawLine(end, end + up * arrowLength - normalized * arrowLength);
		Gizmos.DrawLine(end, end - up * arrowLength - normalized * arrowLength);
		Gizmos.DrawLine(end + up * arrowLength - normalized * arrowLength, end - up * arrowLength - normalized * arrowLength);
	}
}


using UnityEngine;

public class IronSightOverride : MonoBehaviour
{
	public IronsightAimPoint aimPoint;

	public float fieldOfViewOffset = -20f;

	public float zoomFactor = -1f;

	[Tooltip("If set to 1, the FOV is set to what this override is set to. If set to 0.5 it's half way between the weapon iconsights default and this scope.")]
	public float fovBias = 0.5f;
}


using UnityEngine;

public class IronSights : MonoBehaviour
{
	[Header("View Setup")]
	public IronsightAimPoint aimPoint;

	public float fieldOfViewOffset = -20f;

	public float zoomFactor = 1f;

	[Header("Animation")]
	public float introSpeed = 1f;

	public AnimationCurve introCurve = new AnimationCurve();

	public float outroSpeed = 1f;

	public AnimationCurve outroCurve = new AnimationCurve();

	[Tooltip("Force the ironsight rotation every frame, don't lerp to the rotation. Can be useful if the ADS is animated and this component is conflicting")]
	public bool disableLerps;

	[Header("Sounds")]
	public SoundDefinition upSound;

	public SoundDefinition downSound;

	[Header("Info")]
	public IronSightOverride ironsightsOverride;

	public bool processUltrawideOffset;
}


using UnityEngine;

public class MagazineStateViewmodel : MonoBehaviour, IClientComponent, IViewmodelComponent, IAnimationEventReceiver
{
	public Animator TargetAnimator;

	[Tooltip("This gameobject will be toggled active if the gun has > 1 bullet")]
	public GameObject ShellRoot;

	[Tooltip("Will set layer 1 to full weight if the gun has no ammo")]
	public bool EmptyAmmoLayer;

	[Tooltip("Will update a parameter called 'hasAmmo' on the vm animator")]
	public bool SetHasAmmoParam;
}


using UnityEngine;

public class MetalDetectorViewmodel : BaseViewModel
{
	public GameObject[] LongRangeLights;

	public GameObject[] SweetspotLights;

	public GameObject LongRangeLight;

	public Transform YawTransform;

	public Transform DetectPos;

	public MetalDetectorViewmodelAnimEvents viewmodelAnimEvents;

	public SkinnedMeshRenderer MeshRenderer;

	[ColorUsage(false, true)]
	public Color BulbOffColor;

	[ColorUsage(false, true)]
	public Color BulbOnColor;
}


public class MetalDetectorViewmodelAnimEvents : BaseMonoBehaviour
{
	public float scanAmount = 1f;

	public SoundDefinition scanSwingSoundDef;
}


using System.Collections.Generic;
using Rust;
using UnityEngine;

public class MultiSwapArrows : MonoBehaviour, IClientComponent
{
	public List<SwapArrows> arrowSlots;

	public void UpdateAmmoType(ItemDefinition ammoType, bool hidden = false, int? slotIndex = null)
	{
		if (slotIndex.HasValue)
		{
			int value = slotIndex.Value;
			if (value >= 0 && value < arrowSlots.Count)
			{
				if ((Object)(object)arrowSlots[value] != (Object)null)
				{
					arrowSlots[value].UpdateAmmoType(ammoType, hidden);
				}
			}
			else
			{
				Debug.Log((object)"Error in MultiSwapArrows: Slot index out of range");
			}
			return;
		}
		int num = 0;
		foreach (SwapArrows arrowSlot in arrowSlots)
		{
			if ((Object)(object)arrowSlot != (Object)null)
			{
				arrowSlot.UpdateAmmoType(ammoType, hidden);
			}
			num++;
		}
	}

	private void Cleanup()
	{
		foreach (SwapArrows arrowSlot in arrowSlots)
		{
			if ((Object)(object)arrowSlot != (Object)null)
			{
				arrowSlot.HideAllArrowHeads();
			}
		}
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Cleanup();
		}
	}

	public void OnEnable()
	{
		Cleanup();
	}
}


using UnityEngine;

public class RagdollEditor : SingletonComponent<RagdollEditor>
{
	private Vector3 view;

	private Rigidbody grabbedRigid;

	private Vector3 grabPos;

	private Vector3 grabOffset;

	private void OnGUI()
	{
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		GUI.Box(new Rect((float)Screen.width * 0.5f - 2f, (float)Screen.height * 0.5f - 2f, 4f, 4f), "");
	}

	protected override void Awake()
	{
		((SingletonComponent)this).Awake();
	}

	private void Update()
	{
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0092: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_0102: Unknown result type (might be due to invalid IL or missing references)
		//IL_0103: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		Camera.main.fieldOfView = 75f;
		if (Input.GetKey((KeyCode)324))
		{
			view.y += Input.GetAxisRaw("Mouse X") * 3f;
			view.x -= Input.GetAxisRaw("Mouse Y") * 3f;
			Cursor.lockState = (CursorLockMode)1;
			Cursor.visible = false;
		}
		else
		{
			Cursor.lockState = (CursorLockMode)0;
			Cursor.visible = true;
		}
		((Component)Camera.main).transform.rotation = Quaternion.Euler(view);
		Vector3 val = Vector3.zero;
		if (Input.GetKey((KeyCode)119))
		{
			val += Vector3.forward;
		}
		if (Input.GetKey((KeyCode)115))
		{
			val += Vector3.back;
		}
		if (Input.GetKey((KeyCode)97))
		{
			val += Vector3.left;
		}
		if (Input.GetKey((KeyCode)100))
		{
			val += Vector3.right;
		}
		Transform transform = ((Component)Camera.main).transform;
		transform.position += ((Component)this).transform.rotation * val * 0.05f;
		if (Input.GetKeyDown((KeyCode)323))
		{
			StartGrab();
		}
		if (Input.GetKeyUp((KeyCode)323))
		{
			StopGrab();
		}
	}

	private void FixedUpdate()
	{
		if (Input.GetKey((KeyCode)323))
		{
			UpdateGrab();
		}
	}

	private void StartGrab()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0066: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		RaycastHit val = default(RaycastHit);
		if (Physics.Raycast(((Component)this).transform.position, ((Component)this).transform.forward, ref val, 100f))
		{
			grabbedRigid = ((Component)((RaycastHit)(ref val)).collider).GetComponent<Rigidbody>();
			if (!((Object)(object)grabbedRigid == (Object)null))
			{
				Matrix4x4 worldToLocalMatrix = ((Component)grabbedRigid).transform.worldToLocalMatrix;
				grabPos = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint(((RaycastHit)(ref val)).point);
				worldToLocalMatrix = ((Component)this).transform.worldToLocalMatrix;
				grabOffset = ((Matrix4x4)(ref worldToLocalMatrix)).MultiplyPoint(((RaycastHit)(ref val)).point);
			}
		}
	}

	private void UpdateGrab()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		if (!((Object)(object)grabbedRigid == (Object)null))
		{
			Vector3 val = ((Component)this).transform.TransformPoint(grabOffset);
			Vector3 val2 = ((Component)grabbedRigid).transform.TransformPoint(grabPos);
			Vector3 val3 = val - val2;
			grabbedRigid.AddForceAtPosition(val3 * 100f, val2, (ForceMode)5);
		}
	}

	private void StopGrab()
	{
		grabbedRigid = null;
	}
}


using UnityEngine;

public class RandomParameterNumber : StateMachineBehaviour
{
	public string parameterName;

	public int min;

	public int max;

	public bool preventRepetition;

	public bool isFloat;

	private int last;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		int num = Random.Range(min, max);
		int num2 = 0;
		while (last == num && preventRepetition && num2 < 100)
		{
			num = Random.Range(min, max);
			num2++;
		}
		if (isFloat)
		{
			animator.SetFloat(parameterName, (float)num);
		}
		else
		{
			animator.SetInteger(parameterName, num);
		}
		last = num;
	}
}


using UnityEngine;

public class RandomParameterNumberFloat : StateMachineBehaviour
{
	public string parameterName;

	public int min;

	public int max;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		if (!string.IsNullOrEmpty(parameterName))
		{
			animator.SetFloat(parameterName, Mathf.Floor(Random.Range((float)min, (float)max + 0.5f)));
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Animations;

public class SetParameterAnimatorBehaviour : StateMachineBehaviour
{
	public enum ParamType
	{
		Float,
		Bool,
		Int
	}

	public enum Timing
	{
		OnStateEnter,
		OnStateExit,
		PassThreshold
	}

	public string ParameterName;

	public ParamType ParameterType;

	public float FloatValue;

	public bool BoolValue;

	public int IntValue;

	public Timing SetParameterTiming;

	[Tooltip("Normalised time of animation")]
	[Range(0f, 1f)]
	public float ThresholdTiming;

	private float lastNormalisedTime;

	public override void OnStateEnter(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateEnter(animator, stateInfo, layerIndex);
		if (SetParameterTiming == Timing.OnStateEnter)
		{
			SetParameter(animator);
		}
	}

	public override void OnStateExit(Animator animator, AnimatorStateInfo stateInfo, int layerIndex, AnimatorControllerPlayable controller)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0004: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateExit(animator, stateInfo, layerIndex, controller);
		if (SetParameterTiming == Timing.OnStateExit)
		{
			SetParameter(animator);
		}
	}

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		if (SetParameterTiming == Timing.PassThreshold)
		{
			if (((AnimatorStateInfo)(ref stateInfo)).normalizedTime > ThresholdTiming && lastNormalisedTime < ThresholdTiming)
			{
				SetParameter(animator);
			}
			lastNormalisedTime = ((AnimatorStateInfo)(ref stateInfo)).normalizedTime;
		}
	}

	private void SetParameter(Animator animator)
	{
		switch (ParameterType)
		{
		case ParamType.Float:
			animator.SetFloat(ParameterName, FloatValue);
			break;
		case ParamType.Bool:
			animator.SetBool(ParameterName, BoolValue);
			break;
		case ParamType.Int:
			animator.SetInteger(ParameterName, IntValue);
			break;
		default:
			throw new ArgumentOutOfRangeException();
		}
	}
}


public enum ParamType
{
	Float,
	Bool,
	Int
}


public enum Timing
{
	OnStateEnter,
	OnStateExit,
	PassThreshold
}


using UnityEngine;

public class SetParameterCurveAnimatorBehaviour : StateMachineBehaviour
{
	public string FloatParameterName;

	public AnimationCurve ParameterCurve = AnimationCurve.Linear(0f, 0f, 1f, 1f);

	public override void OnStateUpdate(Animator animator, AnimatorStateInfo stateInfo, int layerIndex)
	{
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		((StateMachineBehaviour)this).OnStateUpdate(animator, stateInfo, layerIndex);
		animator.SetFloat(FloatParameterName, ParameterCurve.Evaluate(((AnimatorStateInfo)(ref stateInfo)).normalizedTime));
	}
}


using System;
using UnityEngine;

public class SwapAmmo : MonoBehaviour, IViewmodelComponent, IAnimationEventReceiver
{
	[Serializable]
	public class AmmoSetup
	{
		public ItemDefinition TargetAmmo;

		public GameObject[] Roots;
	}

	public AmmoSetup[] Setups;

	public bool EventDriven;
}


using System;
using UnityEngine;

[Serializable]
public class AmmoSetup
{
	public ItemDefinition TargetAmmo;

	public GameObject[] Roots;
}


using System;
using Rust;
using UnityEngine;

public class SwapArrows : MonoBehaviour, IClientComponent
{
	public enum ArrowType
	{
		One,
		Two,
		Three,
		Four
	}

	public GameObject[] arrowModels;

	[NonSerialized]
	private ItemDefinition curAmmoType;

	private bool wasHidden;

	public ItemDefinition CurrentAmmoType
	{
		get
		{
			return curAmmoType;
		}
		set
		{
			curAmmoType = value;
		}
	}

	public bool WasHidden
	{
		get
		{
			return wasHidden;
		}
		set
		{
			wasHidden = value;
		}
	}

	public void SelectArrowType(int iType)
	{
		HideAllArrowHeads();
		if (iType < arrowModels.Length)
		{
			arrowModels[iType].SetActive(true);
		}
	}

	public void HideAllArrowHeads()
	{
		GameObject[] array = arrowModels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
	}

	public void UpdateAmmoType(ItemDefinition ammoType, bool hidden = false)
	{
		if (hidden)
		{
			wasHidden = hidden;
			HideAllArrowHeads();
		}
		else if (!((Object)(object)curAmmoType == (Object)(object)ammoType) || hidden != wasHidden)
		{
			curAmmoType = ammoType;
			wasHidden = hidden;
			if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.WoodenArrowItemDef)
			{
				HideAllArrowHeads();
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.BoneArrowItemDef)
			{
				SelectArrowType(0);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.FireArrowItemDef)
			{
				SelectArrowType(1);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.HvArrowItemDef)
			{
				SelectArrowType(2);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.PoisonArrowItemDef)
			{
				SelectArrowType(3);
			}
			else if ((Object)(object)ammoType == (Object)(object)ArrowItemDefinitions.StoneArrowItemDef)
			{
				SelectArrowType(4);
			}
			else
			{
				HideAllArrowHeads();
			}
		}
	}

	private void Cleanup()
	{
		HideAllArrowHeads();
		curAmmoType = null;
	}

	public void OnDisable()
	{
		if (!Application.isQuitting)
		{
			Cleanup();
		}
	}

	public void OnEnable()
	{
		Cleanup();
	}
}


public enum ArrowType
{
	One,
	Two,
	Three,
	Four
}


using UnityEngine;

public class SwapKeycard : MonoBehaviour
{
	public GameObject[] accessLevels;

	public void UpdateAccessLevel(int level)
	{
		GameObject[] array = accessLevels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
		if (level > 0 && accessLevels.Length >= level)
		{
			accessLevels[level - 1].SetActive(true);
		}
	}

	public void SetRootActive(int index)
	{
		for (int i = 0; i < accessLevels.Length; i++)
		{
			accessLevels[i].SetActive(i == index);
		}
	}
}


using System;
using UnityEngine;

public class SwapRPG : MonoBehaviour
{
	public enum RPGType
	{
		One,
		Two,
		Three,
		Four
	}

	public GameObject[] rpgModels;

	[NonSerialized]
	private string curAmmoType = "";

	public void SelectRPGType(int iType)
	{
		GameObject[] array = rpgModels;
		for (int i = 0; i < array.Length; i++)
		{
			array[i].SetActive(false);
		}
		rpgModels[iType].SetActive(true);
	}

	public void UpdateAmmoType(ItemDefinition ammoType)
	{
		if (!(curAmmoType == ammoType.shortname))
		{
			curAmmoType = ammoType.shortname;
			switch (curAmmoType)
			{
			default:
				SelectRPGType(0);
				break;
			case "ammo.rocket.fire":
				SelectRPGType(1);
				break;
			case "ammo.rocket.hv":
				SelectRPGType(2);
				break;
			case "ammo.rocket.smoke":
				SelectRPGType(3);
				break;
			}
		}
	}

	private void Start()
	{
	}
}


public enum RPGType
{
	One,
	Two,
	Three,
	Four
}


using UnityEngine;

public class ViewmodelAspectOffset : MonoBehaviour
{
	public Vector3 OffsetAmount = Vector3.zero;

	[Tooltip("What aspect ratio should we start moving the viewmodel? 16:9 = 1.7, 21:9 = 2.3")]
	public float aspectCutoff = 2f;
}


public class ViewmodelAttachment : EntityComponent<BaseEntity>, IClientComponent, IViewModeChanged, IViewModelUpdated
{
	public enum AttachmentType
	{
		None,
		Scope8x,
		SmallScope,
		BurstModule,
		ExtendedMags,
		Flashlight,
		Holosight,
		LaserSight,
		MuzzleBoost,
		MuzzleBrake,
		RedDotSight,
		Silencer
	}

	public GameObjectRef modelObject;

	public string targetBone;

	public bool hideViewModelIronSights;

	public AttachmentType attachmentType;
}


public enum AttachmentType
{
	None,
	Scope8x,
	SmallScope,
	BurstModule,
	ExtendedMags,
	Flashlight,
	Holosight,
	LaserSight,
	MuzzleBoost,
	MuzzleBrake,
	RedDotSight,
	Silencer
}


using System;
using UnityEngine;

public class ViewmodelAttachmentOverride : MonoBehaviour
{
	[Serializable]
	public struct Override
	{
		public Transform TargetRoot;

		public ViewmodelAttachment.AttachmentType ForAttachment;

		public GameObjectRef ForAttachmentObject;
	}

	public Override[] Overrides;
}


using System;
using UnityEngine;

[Serializable]
public struct Override
{
	public Transform TargetRoot;

	public ViewmodelAttachment.AttachmentType ForAttachment;

	public GameObjectRef ForAttachmentObject;
}


using UnityEngine;

public class ViewmodelBob : MonoBehaviour
{
	public float bobSpeedWalk = 9f;

	public float bobSpeedRun = 13f;

	public float bobAmountWalk = 0.005f;

	public float bobAmountRun = 0.02f;

	public float leftOffsetRun = 0.04f;
}


using UnityEngine;

public class ViewModelCamera : MonoBehaviour
{
}


public enum RenderType
{
	OPAQUE_DEFERRED,
	OPAQUE_FORWARDBASE,
	TRANSPARENT_FORWARDBASE,
	TRANSPARENT,
	UNDEFINED
}


using System;
using UnityEngine;

[Serializable]
public struct ViewModelDrawEvent : IEquatable<ViewModelDrawEvent>
{
	public ViewModelRenderer viewModelRenderer;

	public Renderer renderer;

	public bool skipDepthPrePass;

	public Material material;

	public int subMesh;

	public int pass;

	public bool Equals(ViewModelDrawEvent other)
	{
		if (object.Equals(viewModelRenderer, other.viewModelRenderer) && object.Equals(renderer, other.renderer) && skipDepthPrePass == other.skipDepthPrePass && object.Equals(material, other.material) && subMesh == other.subMesh)
		{
			return pass == other.pass;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is ViewModelDrawEvent other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return ((((((((((((Object)(object)viewModelRenderer != (Object)null) ? ((object)viewModelRenderer).GetHashCode() : 0) * 397) ^ (((Object)(object)renderer != (Object)null) ? ((object)renderer).GetHashCode() : 0)) * 397) ^ skipDepthPrePass.GetHashCode()) * 397) ^ (((Object)(object)material != (Object)null) ? ((object)material).GetHashCode() : 0)) * 397) ^ subMesh) * 397) ^ pass;
	}
}


using System.Collections.Generic;
using UnityEngine;

public class ViewModelRenderer : MonoBehaviour
{
	public List<Texture2D> cachedTextureRefs = new List<Texture2D>();

	public List<ViewModelDrawEvent> opaqueEvents = new List<ViewModelDrawEvent>();

	public List<ViewModelDrawEvent> transparentEvents = new List<ViewModelDrawEvent>();

	public Matrix4x4 prevModelMatrix;

	private Renderer viewModelRenderer;
}


using UnityEngine;

public class ViewmodelCameraAnimation : MonoBehaviour
{
	public Transform CameraModifyBone;

	public bool ShouldSuppressLeftHandScreenShake;

	public float FadeInTime;

	public Vector3 PositionOffset;

	public Vector3 RotationOffset;
}


public class ViewmodelEditor : SingletonComponent<ViewmodelEditor>
{
}


using UnityEngine;

public class ViewmodelIk : MonoBehaviour
{
}


using UnityEngine;

public class ViewmodelLower : MonoBehaviour
{
	public bool lowerOnSprint = true;

	public bool lowerWhenCantAttack = true;

	public bool forceLower;

	public float lowerScale = 1f;

	public void SetShouldLower(bool shouldLower)
	{
	}
}


using UnityEngine;

public class ViewmodelMountedAnchor : MonoBehaviour
{
	public ViewmodelIk IkController;
}


using UnityEngine;

public class ViewmodelPunch : MonoBehaviour
{
	public AnimationCurve punchScale;

	public Vector3 punchDirection;

	public float punchDuration = 0.1f;

	public float punchMagnitude = 1f;
}


using UnityEngine;

public class ViewmodelSway : MonoBehaviour
{
	public float positionalSwaySpeed = 1f;

	public float positionalSwayAmount = 1f;

	public float rotationSwaySpeed = 1f;

	public float rotationSwayAmount = 1f;

	public float rotateAmountTest = 20f;
}


using System;
using UnityEngine;

[AddComponentMenu("")]
public class AmplifyOcclusionBase : MonoBehaviour
{
	public enum ApplicationMethod
	{
		PostEffect,
		Deferred,
		Debug
	}

	public enum PerPixelNormalSource
	{
		None,
		Camera,
		GBuffer,
		GBufferOctaEncoded
	}

	public enum SampleCountLevel
	{
		Low,
		Medium,
		High,
		VeryHigh
	}

	[Header("Ambient Occlusion")]
	public ApplicationMethod ApplyMethod;

	[Tooltip("Number of samples per pass.")]
	public SampleCountLevel SampleCount = SampleCountLevel.Medium;

	public PerPixelNormalSource PerPixelNormals = PerPixelNormalSource.Camera;

	[Tooltip("Final applied intensity of the occlusion effect.")]
	[Range(0f, 1f)]
	public float Intensity = 1f;

	public Color Tint = Color.black;

	[Range(0f, 32f)]
	[Tooltip("Radius spread of the occlusion.")]
	public float Radius = 2f;

	[NonSerialized]
	[Tooltip("Max sampling range in pixels.")]
	[Range(32f, 1024f)]
	public int PixelRadiusLimit = 512;

	[NonSerialized]
	[Tooltip("Occlusion contribution amount on relation to radius.")]
	[Range(0f, 2f)]
	public float RadiusIntensity = 1f;

	[Tooltip("Power exponent attenuation of the occlusion.")]
	[Range(0f, 16f)]
	public float PowerExponent = 1.8f;

	[Tooltip("Controls the initial occlusion contribution offset.")]
	[Range(0f, 0.99f)]
	public float Bias = 0.05f;

	[Range(0f, 1f)]
	[Tooltip("Controls the thickness occlusion contribution.")]
	public float Thickness = 1f;

	[Tooltip("Compute the Occlusion and Blur at half of the resolution.")]
	public bool Downsample = true;

	[Header("Distance Fade")]
	[Tooltip("Control parameters at faraway.")]
	public bool FadeEnabled;

	[Tooltip("Distance in Unity unities that start to fade.")]
	public float FadeStart = 100f;

	[Tooltip("Length distance to performe the transition.")]
	public float FadeLength = 50f;

	[Tooltip("Final Intensity parameter.")]
	[Range(0f, 1f)]
	public float FadeToIntensity;

	public Color FadeToTint = Color.black;

	[Range(0f, 32f)]
	[Tooltip("Final Radius parameter.")]
	public float FadeToRadius = 2f;

	[Tooltip("Final PowerExponent parameter.")]
	[Range(0f, 16f)]
	public float FadeToPowerExponent = 1.8f;

	[Tooltip("Final Thickness parameter.")]
	[Range(0f, 1f)]
	public float FadeToThickness = 1f;

	[Header("Bilateral Blur")]
	public bool BlurEnabled = true;

	[Tooltip("Radius in screen pixels.")]
	[Range(1f, 4f)]
	public int BlurRadius = 3;

	[Tooltip("Number of times that the Blur will repeat.")]
	[Range(1f, 4f)]
	public int BlurPasses = 1;

	[Tooltip("0 - Blured, 1 - Sharpened.")]
	[Range(0f, 20f)]
	public float BlurSharpness = 10f;

	[Tooltip("Accumulates the effect over the time.")]
	[Header("Temporal Filter")]
	public bool FilterEnabled = true;

	[Tooltip("Controls the accumulation decayment. 0 - Faster update, more flicker. 1 - Slow update (ghosting on moving objects), less flicker.")]
	[Range(0f, 1f)]
	public float FilterBlending = 0.5f;

	[Tooltip("Controls the discard sensibility based on the motion of the scene and objects. 0 - Discard less, reuse more (more ghost effect). 1 - Discard more, reuse less (less ghost effect).")]
	[Range(0f, 1f)]
	public float FilterResponse = 0.5f;

	[NonSerialized]
	[Tooltip("Enables directional variations.")]
	public bool TemporalDirections = true;

	[NonSerialized]
	[Tooltip("Enables offset variations.")]
	public bool TemporalOffsets = true;

	[NonSerialized]
	[Tooltip("Reduces ghosting effect near the objects's edges while moving.")]
	public bool TemporalDilation;

	[NonSerialized]
	[Tooltip("Uses the object movement information for calc new areas of occlusion.")]
	public bool UseMotionVectors = true;
}


public enum ApplicationMethod
{
	PostEffect,
	Deferred,
	Debug
}


public enum PerPixelNormalSource
{
	None,
	Camera,
	GBuffer,
	GBufferOctaEncoded
}


public enum SampleCountLevel
{
	Low,
	Medium,
	High,
	VeryHigh
}


using UnityEngine;

[AddComponentMenu("Image Effects/Amplify Occlusion")]
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class AmplifyOcclusionEffect : AmplifyOcclusionBase
{
}


using System;
using System.Collections;
using UnityEngine;

internal class UVTextureAnimator : MonoBehaviour
{
	public int Rows = 4;

	public int Columns = 4;

	public float Fps = 20f;

	public int OffsetMat;

	public bool IsLoop = true;

	public float StartDelay;

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float deltaFps;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private void Start()
	{
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fc: Unknown result type (might be due to invalid IL or missing references)
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)currentRenderer == (Object)null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		deltaFps = 1f / Fps;
		count = Rows * Columns;
		index = Columns - 1;
		Vector3 zero = Vector3.zero;
		OffsetMat -= OffsetMat / count * count;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / (float)Columns, 1f / (float)Rows);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", val);
			instanceMaterial.SetTextureOffset("_MainTex", Vector2.op_Implicit(zero));
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				((MonoBehaviour)this).Invoke("PlayDelay", StartDelay);
			}
			else
			{
				((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		while (isVisible && (IsLoop || allCount != count))
		{
			UpdateCorutineFrame();
			if (!IsLoop && allCount == count)
			{
				break;
			}
			yield return (object)new WaitForSeconds(deltaFps);
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateCorutineFrame()
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)index / (float)Columns - (float)(index / Columns), 1f - (float)(index / Columns) / (float)Rows);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", val);
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)instanceMaterial != (Object)null)
		{
			Object.Destroy((Object)(object)instanceMaterial);
			instanceMaterial = null;
		}
	}
}


using System;
using UnityEngine;
using UnityEngine.Rendering.PostProcessing;

[Serializable]
[PostProcess(typeof(CathodeRenderer), PostProcessEvent.AfterStack, "Custom/Cathode - Analogue Video", true)]
public class Cathode : PostProcessEffectSettings
{
	[Range(0f, 1f)]
	public FloatParameter intensity = new FloatParameter
	{
		value = 0f
	};

	[Range(1f, 16f)]
	public IntParameter downscale = new IntParameter
	{
		value = 1
	};

	[Range(1f, 16f)]
	public IntParameter downscaleTemporal = new IntParameter
	{
		value = 1
	};

	[Range(0f, 3f)]
	public FloatParameter horizontalBlur = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 3f)]
	public FloatParameter verticalBlur = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 5f)]
	public FloatParameter chromaSubsampling = new FloatParameter
	{
		value = 1.7f
	};

	[Range(0f, 5f)]
	public FloatParameter sharpen = new FloatParameter
	{
		value = 1.2f
	};

	[Range(0f, 5f)]
	public FloatParameter sharpenRadius = new FloatParameter
	{
		value = 1.2f
	};

	[Range(0f, 0.5f)]
	public FloatParameter colorNoise = new FloatParameter
	{
		value = 0.05f
	};

	[Range(0f, 5f)]
	public FloatParameter restlessFoot = new FloatParameter
	{
		value = 0.2f
	};

	[Range(0f, 0.1f)]
	public FloatParameter footAmplitude = new FloatParameter
	{
		value = 0.02f
	};

	[Range(0f, 3f)]
	public FloatParameter chromaIntensity = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter chromaInstability = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 0.1f)]
	public FloatParameter chromaOffset = new FloatParameter
	{
		value = 0.02f
	};

	[Range(-2f, 2f)]
	public FloatParameter responseCurve = new FloatParameter
	{
		value = 0f
	};

	[Range(-1f, 1f)]
	public FloatParameter saturation = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public FloatParameter cometTrailing = new FloatParameter
	{
		value = 0.3f
	};

	[Range(0f, 1f)]
	public FloatParameter burnIn = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 1f)]
	public FloatParameter tapeDust = new FloatParameter
	{
		value = 0.1f
	};

	[Range(0f, 2f)]
	public FloatParameter wobble = new FloatParameter
	{
		value = 1f
	};

	[Range(0f, 1f)]
	public Vector2Parameter blackWhiteLevels = new Vector2Parameter
	{
		value = new Vector2(0f, 1f)
	};

	[Range(0f, 1f)]
	public Vector2Parameter dynamicRange = new Vector2Parameter
	{
		value = new Vector2(0f, 1f)
	};

	[Range(-1f, 1f)]
	public FloatParameter whiteBallance = new FloatParameter
	{
		value = 0f
	};
}


using UnityEngine;
using UnityEngine.Rendering;
using UnityEngine.Rendering.PostProcessing;

public class CathodeRenderer : PostProcessEffectRenderer<Cathode>
{
	private Texture2D noiseTex;

	private RenderTexture temporalRT;

	private Shader grayShader = Shader.Find("Hidden/Shader/Gray");

	private Shader primaryShader = Shader.Find("Hidden/Shader/PrimaryTransform");

	private Shader tvShader = Shader.Find("Hidden/Shader/TV");

	private Shader postTVShader = Shader.Find("Hidden/Shader/PostTV");

	private Shader trailShader = Shader.Find("Hidden/Shader/Trail");

	private readonly int _CathodeRT1 = Shader.PropertyToID("CathodeRT1");

	private readonly int _CathodeRT2 = Shader.PropertyToID("CathodeRT2");

	private readonly int _Intensity = Shader.PropertyToID("_Intensity");

	private readonly int _SizeX = Shader.PropertyToID("_SizeX");

	private readonly int _SizeY = Shader.PropertyToID("_SizeY");

	private readonly int _ChromaSubsampling = Shader.PropertyToID("_ChromaSubsampling");

	private readonly int _Sharpen = Shader.PropertyToID("_Sharpen");

	private readonly int _SharpenRadius = Shader.PropertyToID("_SharpenRadius");

	private readonly int _ColorNoise = Shader.PropertyToID("_ColorNoise");

	private readonly int _RestlessFoot = Shader.PropertyToID("_RestlessFoot");

	private readonly int _FootAmplitude = Shader.PropertyToID("_FootAmplitude");

	private readonly int _ChromaOffset = Shader.PropertyToID("_ChromaOffset");

	private readonly int _ChromaIntensity = Shader.PropertyToID("_ChromaIntensity");

	private readonly int _ChromaInstability = Shader.PropertyToID("_ChromaInstability");

	private readonly int _BurnIn = Shader.PropertyToID("_BurnIn");

	private readonly int _TapeDust = Shader.PropertyToID("_TapeDust");

	private readonly int _TrailTex = Shader.PropertyToID("_TrailTex");

	private readonly int _NoiseTex = Shader.PropertyToID("_NoiseTex");

	private readonly int _Gamma = Shader.PropertyToID("_Gamma");

	private readonly int _ResponseCurve = Shader.PropertyToID("_ResponseCurve");

	private readonly int _Saturation = Shader.PropertyToID("_Saturation");

	private readonly int _Wobble = Shader.PropertyToID("_Wobble");

	private readonly int _Black = Shader.PropertyToID("_Black");

	private readonly int _White = Shader.PropertyToID("_White");

	private readonly int _DynamicRangeMin = Shader.PropertyToID("_DynamicRangeMin");

	private readonly int _DynamicRangeMax = Shader.PropertyToID("_DynamicRangeMax");

	private readonly int _ScreenWhiteBal = Shader.PropertyToID("_ScreenWhiteBal");

	private readonly int _Trailing = Shader.PropertyToID("_Trailing");

	public override void Init()
	{
		base.Init();
		grayShader = Shader.Find("Hidden/Shader/Gray");
		primaryShader = Shader.Find("Hidden/Shader/PrimaryTransform");
		tvShader = Shader.Find("Hidden/Shader/TV");
		postTVShader = Shader.Find("Hidden/Shader/PostTV");
		trailShader = Shader.Find("Hidden/Shader/Trail");
		noiseTex = Resources.Load<Texture2D>("Noise");
	}

	public override void Release()
	{
		if ((Object)(object)noiseTex != (Object)null)
		{
			Resources.UnloadAsset((Object)(object)noiseTex);
			noiseTex = null;
		}
		if ((Object)(object)temporalRT != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)temporalRT);
			temporalRT = null;
		}
		base.Release();
	}

	public override void Render(PostProcessRenderContext context)
	{
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Expected O, but got Unknown
		//IL_0818: Unknown result type (might be due to invalid IL or missing references)
		//IL_081e: Unknown result type (might be due to invalid IL or missing references)
		//IL_06a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_0713: Unknown result type (might be due to invalid IL or missing references)
		//IL_0715: Unknown result type (might be due to invalid IL or missing references)
		//IL_071e: Unknown result type (might be due to invalid IL or missing references)
		//IL_072d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0737: Unknown result type (might be due to invalid IL or missing references)
		//IL_0742: Unknown result type (might be due to invalid IL or missing references)
		//IL_0760: Unknown result type (might be due to invalid IL or missing references)
		//IL_076b: Unknown result type (might be due to invalid IL or missing references)
		//IL_078a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0795: Unknown result type (might be due to invalid IL or missing references)
		//IL_07b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_07bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_07de: Unknown result type (might be due to invalid IL or missing references)
		//IL_07e4: Unknown result type (might be due to invalid IL or missing references)
		CommandBuffer command = context.command;
		command.BeginSample("CathodeAnalogueVideo");
		int num = context.width / (int)base.settings.downscaleTemporal;
		int num2 = context.height / (int)base.settings.downscaleTemporal;
		if ((Object)(object)temporalRT == (Object)null || ((Texture)temporalRT).width != num || ((Texture)temporalRT).height != num2)
		{
			if ((Object)(object)temporalRT != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)temporalRT);
			}
			temporalRT = new RenderTexture(num, num2, 0, (RenderTextureFormat)9);
		}
		if ((float)base.settings.intensity > 0f)
		{
			PropertySheet propertySheet = context.propertySheets.Get(grayShader);
			PropertySheet propertySheet2 = context.propertySheets.Get(primaryShader);
			PropertySheet propertySheet3 = context.propertySheets.Get(tvShader);
			PropertySheet propertySheet4 = context.propertySheets.Get(postTVShader);
			PropertySheet propertySheet5 = context.propertySheets.Get(trailShader);
			propertySheet.properties.Clear();
			propertySheet2.properties.Clear();
			propertySheet3.properties.Clear();
			propertySheet4.properties.Clear();
			propertySheet5.properties.Clear();
			propertySheet.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet.properties.SetFloat(_SizeX, (float)base.settings.horizontalBlur);
			propertySheet.properties.SetFloat(_SizeY, (float)base.settings.verticalBlur);
			propertySheet2.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaSubsampling, (float)base.settings.chromaSubsampling * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_Sharpen, (float)base.settings.sharpen * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_SharpenRadius, (float)base.settings.sharpenRadius * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ColorNoise, (float)base.settings.colorNoise * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_RestlessFoot, (float)base.settings.restlessFoot * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_FootAmplitude, (float)base.settings.footAmplitude * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaOffset, (float)base.settings.chromaOffset * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_ChromaIntensity, Mathf.Lerp(1f, (float)base.settings.chromaIntensity, (float)base.settings.intensity));
			propertySheet2.properties.SetFloat(_ChromaInstability, (float)base.settings.chromaInstability * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_BurnIn, (float)base.settings.burnIn * (float)base.settings.intensity);
			propertySheet2.properties.SetFloat(_TapeDust, 1f - (float)base.settings.tapeDust * (float)base.settings.intensity);
			propertySheet2.properties.SetTexture(_TrailTex, (Texture)(object)temporalRT);
			propertySheet2.properties.SetTexture(_NoiseTex, (Texture)(object)noiseTex);
			propertySheet3.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet3.properties.SetFloat(_Gamma, 1f);
			propertySheet4.properties.SetFloat(_Intensity, (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_ResponseCurve, (float)base.settings.responseCurve * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_Saturation, Mathf.Lerp(1f, (float)base.settings.saturation, (float)base.settings.intensity));
			propertySheet4.properties.SetFloat(_Wobble, (float)base.settings.wobble * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_Black, base.settings.blackWhiteLevels.value.x * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_White, 1f - (1f - base.settings.blackWhiteLevels.value.y) * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_DynamicRangeMin, base.settings.dynamicRange.value.x * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_DynamicRangeMax, 1f - (1f - base.settings.dynamicRange.value.y) * (float)base.settings.intensity);
			propertySheet4.properties.SetFloat(_ScreenWhiteBal, (float)base.settings.whiteBallance * (float)base.settings.intensity);
			propertySheet5.properties.SetFloat(_Trailing, 1f - (float)base.settings.cometTrailing * (float)base.settings.intensity);
			RenderTextureDescriptor val = default(RenderTextureDescriptor);
			((RenderTextureDescriptor)(ref val)).dimension = (TextureDimension)2;
			((RenderTextureDescriptor)(ref val)).width = context.width / (int)base.settings.downscale;
			((RenderTextureDescriptor)(ref val)).height = context.height / (int)base.settings.downscale;
			((RenderTextureDescriptor)(ref val)).depthBufferBits = 0;
			((RenderTextureDescriptor)(ref val)).colorFormat = (RenderTextureFormat)9;
			((RenderTextureDescriptor)(ref val)).useMipMap = true;
			((RenderTextureDescriptor)(ref val)).autoGenerateMips = true;
			((RenderTextureDescriptor)(ref val)).msaaSamples = 1;
			RenderTextureDescriptor val2 = val;
			command.GetTemporaryRT(_CathodeRT1, val2, (FilterMode)2);
			command.GetTemporaryRT(_CathodeRT2, val2, (FilterMode)2);
			command.BlitFullscreenTriangle(context.source, RenderTargetIdentifier.op_Implicit(_CathodeRT1), propertySheet, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), RenderTargetIdentifier.op_Implicit(_CathodeRT2), propertySheet2, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), RenderTargetIdentifier.op_Implicit((Texture)(object)temporalRT), propertySheet5, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT2), RenderTargetIdentifier.op_Implicit(_CathodeRT1), propertySheet4, 0, clear: false, null);
			command.BlitFullscreenTriangle(RenderTargetIdentifier.op_Implicit(_CathodeRT1), context.destination, propertySheet3, 0, clear: false, null);
			command.ReleaseTemporaryRT(_CathodeRT1);
			command.ReleaseTemporaryRT(_CathodeRT2);
		}
		else
		{
			command.BlitFullscreenTriangle(context.source, context.destination, clear: false, null);
		}
		command.EndSample("CathodeAnalogueVideo");
	}
}


public class cui
{
	[ServerUserVar]
	public static void cui_test(Arg args)
	{
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", args.Connection), "[\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"parent\": \"Overlay\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Tiled\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"url\": \"http://files.facepunch.com/garry/2015/June/03/2015-06-03_12-19-17.jpg\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0 0\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"1 1\"\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"NeedsCursor\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"name\": \"buttonText\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"Do you want to press a button?\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":32,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleCenter\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0 0.5\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"1 0.9\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"Button88\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Button\",\r\n\t\t\t\t\t\t\t\t\t\"close\":\"TestPanel7766\",\r\n\t\t\t\t\t\t\t\t\t\"command\":\"cui.endtest\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"0.9 0.8 0.3 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Tiled\"\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\": \"0.3 0.15\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\": \"0.7 0.2\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"parent\": \"Button88\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"YES\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":20,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleCenter\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIcon\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Simple\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -151838493,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.4 0.4\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.4 0.4\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIconSkinTest\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"imagetype\": \"Simple\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -733625651,\r\n\t\t\t\t\t\t\t\t\t\"skinid\": 13035\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.6 0.6\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.6 0.6\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"UpdateLabelTest\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"This should go away once you update!\",\r\n\t\t\t\t\t\t\t\t\t\"font\":\"DroidSansMono.ttf\",\r\n\t\t\t\t\t\t\t\t\t\"fontSize\":32,\r\n\t\t\t\t\t\t\t\t\t\"align\": \"MiddleRight\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"SteamAvatar\",\r\n\t\t\t\t\t\t\t\"parent\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"1.0 1.0 1.0 1.0\",\r\n\t\t\t\t\t\t\t\t\t\"steamid\": \"76561197960279927\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"RectTransform\",\r\n\t\t\t\t\t\t\t\t\t\"anchormin\":\"0.8 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"anchormax\":\"0.8 0.8\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmin\": \"-32 -32\",\r\n\t\t\t\t\t\t\t\t\t\"offsetmax\": \"32 32\"\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t]\r\n\t\t\t\t\t");
	}

	[ServerUserVar]
	public static void cui_test_update(Arg args)
	{
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("AddUI", args.Connection), "[\t\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"TestPanel7766\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.RawImage\",\r\n\t\t\t\t\t\t\t\t\t\"url\": \"https://files.facepunch.com/paddy/20220405/zipline_01.jpg\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"buttonText\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"text\":\"This text just got updated!\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"ItemIcon\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Image\",\r\n\t\t\t\t\t\t\t\t\t\"itemid\": -2067472972,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"Button88\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Button\",\r\n\t\t\t\t\t\t\t\t\t\"color\": \"0.9 0.3 0.3 0.8\",\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\"name\": \"UpdateLabelTest\",\r\n\t\t\t\t\t\t\t\"update\": true,\r\n\t\t\t\t\t\t\t\"components\":\r\n\t\t\t\t\t\t\t[\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\"type\":\"UnityEngine.UI.Text\",\r\n\t\t\t\t\t\t\t\t\t\"enabled\": false,\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t]\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t]\r\n\t\t\t\t\t");
	}

	[ServerUserVar]
	public static void endtest(Arg args)
	{
		args.ReplyWith("Ending Test!");
		CommunityEntity.ServerInstance.ClientRPC(RpcTarget.Player("DestroyUI", args.Connection), "TestPanel7766");
	}
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
public class CoverageQueries : MonoBehaviour
{
	public class BufferSet
	{
		public int width;

		public int height;

		public Texture2D inputTexture;

		public RenderTexture resultTexture;

		public Color[] inputData = (Color[])(object)new Color[0];

		public Color32[] resultData = (Color32[])(object)new Color32[0];

		private Material coverageMat;

		private const int MaxAsyncGPUReadbackRequests = 10;

		private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

		public void Attach(Material coverageMat)
		{
			this.coverageMat = coverageMat;
		}

		public void Dispose(bool data = true)
		{
			if ((Object)(object)inputTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)inputTexture);
				inputTexture = null;
			}
			if ((Object)(object)resultTexture != (Object)null)
			{
				RenderTexture.active = null;
				resultTexture.Release();
				Object.DestroyImmediate((Object)(object)resultTexture);
				resultTexture = null;
			}
			if (data)
			{
				inputData = (Color[])(object)new Color[0];
				resultData = (Color32[])(object)new Color32[0];
			}
		}

		public bool CheckResize(int count)
		{
			//IL_006b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Expected O, but got Unknown
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Expected O, but got Unknown
			//IL_013e: Unknown result type (might be due to invalid IL or missing references)
			//IL_013f: Unknown result type (might be due to invalid IL or missing references)
			if (count > inputData.Length || ((Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
			{
				Dispose(data: false);
				width = Mathf.CeilToInt(Mathf.Sqrt((float)count));
				height = Mathf.CeilToInt((float)count / (float)width);
				inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
				((Object)inputTexture).name = "_Input";
				((Texture)inputTexture).filterMode = (FilterMode)0;
				((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
				resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
				((Object)resultTexture).name = "_Result";
				((Texture)resultTexture).filterMode = (FilterMode)0;
				((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
				resultTexture.useMipMap = false;
				resultTexture.Create();
				int num = resultData.Length;
				int num2 = width * height;
				Array.Resize(ref inputData, num2);
				Array.Resize(ref resultData, num2);
				Color32 val = default(Color32);
				((Color32)(ref val))..ctor(byte.MaxValue, (byte)0, (byte)0, (byte)0);
				for (int i = num; i < num2; i++)
				{
					resultData[i] = val;
				}
				return true;
			}
			return false;
		}

		public void UploadData()
		{
			if (inputData.Length != 0)
			{
				inputTexture.SetPixels(inputData);
				inputTexture.Apply();
			}
		}

		public void Dispatch(int count)
		{
			//IL_0009: Unknown result type (might be due to invalid IL or missing references)
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_0042: Unknown result type (might be due to invalid IL or missing references)
			if (inputData.Length != 0)
			{
				RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
				RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
				coverageMat.SetTexture("_Input", (Texture)(object)inputTexture);
				Graphics.Blit((Texture)(object)inputTexture, resultTexture, coverageMat, 0);
				Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
			}
		}

		public void IssueRead()
		{
			//IL_001d: Unknown result type (might be due to invalid IL or missing references)
			if (asyncRequests.Count < 10)
			{
				asyncRequests.Enqueue(AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
			}
		}

		public void GetResults()
		{
			//IL_0011: Unknown result type (might be due to invalid IL or missing references)
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_003a: Unknown result type (might be due to invalid IL or missing references)
			//IL_003f: Unknown result type (might be due to invalid IL or missing references)
			//IL_004e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			//IL_006c: Unknown result type (might be due to invalid IL or missing references)
			if (resultData.Length == 0)
			{
				return;
			}
			while (asyncRequests.Count > 0)
			{
				AsyncGPUReadbackRequest val = asyncRequests.Peek();
				if (((AsyncGPUReadbackRequest)(ref val)).hasError)
				{
					asyncRequests.Dequeue();
					continue;
				}
				if (((AsyncGPUReadbackRequest)(ref val)).done)
				{
					NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
					for (int i = 0; i < data.Length; i++)
					{
						resultData[i] = data[i];
					}
					asyncRequests.Dequeue();
					continue;
				}
				break;
			}
		}
	}

	public enum RadiusSpace
	{
		ScreenNormalized,
		World
	}

	public class Query
	{
		public struct Input
		{
			public Vector3 position;

			public RadiusSpace radiusSpace;

			public float radius;

			public int sampleCount;

			public float smoothingSpeed;
		}

		public struct Internal
		{
			public int id;

			public void Reset()
			{
				id = -1;
			}
		}

		public struct Result
		{
			public int passed;

			public float coverage;

			public float smoothCoverage;

			public float weightedCoverage;

			public float weightedSmoothCoverage;

			public bool originOccluded;

			public int frame;

			public float originVisibility;

			public float originSmoothVisibility;

			public void Reset()
			{
				passed = 0;
				coverage = 0f;
				smoothCoverage = 0f;
				weightedCoverage = 0f;
				weightedSmoothCoverage = 0f;
				originOccluded = true;
				frame = -1;
				originVisibility = 0f;
				originSmoothVisibility = 0f;
			}
		}

		public Input input;

		public Internal intern;

		public Result result;

		public bool IsRegistered => intern.id >= 0;
	}

	public float depthBias = -0.1f;

	public bool debug;
}


using System;
using System.Collections.Generic;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class BufferSet
{
	public int width;

	public int height;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Color[] inputData = (Color[])(object)new Color[0];

	public Color32[] resultData = (Color32[])(object)new Color32[0];

	private Material coverageMat;

	private const int MaxAsyncGPUReadbackRequests = 10;

	private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

	public void Attach(Material coverageMat)
	{
		this.coverageMat = coverageMat;
	}

	public void Dispose(bool data = true)
	{
		if ((Object)(object)inputTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)inputTexture);
			inputTexture = null;
		}
		if ((Object)(object)resultTexture != (Object)null)
		{
			RenderTexture.active = null;
			resultTexture.Release();
			Object.DestroyImmediate((Object)(object)resultTexture);
			resultTexture = null;
		}
		if (data)
		{
			inputData = (Color[])(object)new Color[0];
			resultData = (Color32[])(object)new Color32[0];
		}
	}

	public bool CheckResize(int count)
	{
		//IL_006b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Expected O, but got Unknown
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Expected O, but got Unknown
		//IL_013e: Unknown result type (might be due to invalid IL or missing references)
		//IL_013f: Unknown result type (might be due to invalid IL or missing references)
		if (count > inputData.Length || ((Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			width = Mathf.CeilToInt(Mathf.Sqrt((float)count));
			height = Mathf.CeilToInt((float)count / (float)width);
			inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
			((Object)inputTexture).name = "_Input";
			((Texture)inputTexture).filterMode = (FilterMode)0;
			((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
			resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
			((Object)resultTexture).name = "_Result";
			((Texture)resultTexture).filterMode = (FilterMode)0;
			((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
			resultTexture.useMipMap = false;
			resultTexture.Create();
			int num = resultData.Length;
			int num2 = width * height;
			Array.Resize(ref inputData, num2);
			Array.Resize(ref resultData, num2);
			Color32 val = default(Color32);
			((Color32)(ref val))..ctor(byte.MaxValue, (byte)0, (byte)0, (byte)0);
			for (int i = num; i < num2; i++)
			{
				resultData[i] = val;
			}
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (inputData.Length != 0)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
	}

	public void Dispatch(int count)
	{
		//IL_0009: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		if (inputData.Length != 0)
		{
			RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
			coverageMat.SetTexture("_Input", (Texture)(object)inputTexture);
			Graphics.Blit((Texture)(object)inputTexture, resultTexture, coverageMat, 0);
			Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
	}

	public void IssueRead()
	{
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		if (asyncRequests.Count < 10)
		{
			asyncRequests.Enqueue(AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
		}
	}

	public void GetResults()
	{
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		if (resultData.Length == 0)
		{
			return;
		}
		while (asyncRequests.Count > 0)
		{
			AsyncGPUReadbackRequest val = asyncRequests.Peek();
			if (((AsyncGPUReadbackRequest)(ref val)).hasError)
			{
				asyncRequests.Dequeue();
				continue;
			}
			if (((AsyncGPUReadbackRequest)(ref val)).done)
			{
				NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
				for (int i = 0; i < data.Length; i++)
				{
					resultData[i] = data[i];
				}
				asyncRequests.Dequeue();
				continue;
			}
			break;
		}
	}
}


public enum RadiusSpace
{
	ScreenNormalized,
	World
}


using UnityEngine;

public class Query
{
	public struct Input
	{
		public Vector3 position;

		public RadiusSpace radiusSpace;

		public float radius;

		public int sampleCount;

		public float smoothingSpeed;
	}

	public struct Internal
	{
		public int id;

		public void Reset()
		{
			id = -1;
		}
	}

	public struct Result
	{
		public int passed;

		public float coverage;

		public float smoothCoverage;

		public float weightedCoverage;

		public float weightedSmoothCoverage;

		public bool originOccluded;

		public int frame;

		public float originVisibility;

		public float originSmoothVisibility;

		public void Reset()
		{
			passed = 0;
			coverage = 0f;
			smoothCoverage = 0f;
			weightedCoverage = 0f;
			weightedSmoothCoverage = 0f;
			originOccluded = true;
			frame = -1;
			originVisibility = 0f;
			originSmoothVisibility = 0f;
		}
	}

	public Input input;

	public Internal intern;

	public Result result;

	public bool IsRegistered => intern.id >= 0;
}


using UnityEngine;

public struct Input
{
	public Vector3 position;

	public RadiusSpace radiusSpace;

	public float radius;

	public int sampleCount;

	public float smoothingSpeed;
}


public struct Internal
{
	public int id;

	public void Reset()
	{
		id = -1;
	}
}


public struct Result
{
	public int passed;

	public float coverage;

	public float smoothCoverage;

	public float weightedCoverage;

	public float weightedSmoothCoverage;

	public bool originOccluded;

	public int frame;

	public float originVisibility;

	public float originSmoothVisibility;

	public void Reset()
	{
		passed = 0;
		coverage = 0f;
		smoothCoverage = 0f;
		weightedCoverage = 0f;
		weightedSmoothCoverage = 0f;
		originOccluded = true;
		frame = -1;
		originVisibility = 0f;
		originSmoothVisibility = 0f;
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class ERVegetationStudio : ScriptableObject
{
	public static bool VegetationStudio()
	{
		return false;
	}

	public static bool VegetationStudioPro()
	{
		return false;
	}

	public static void CreateVegetationMaskLine(GameObject go, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateVegetationMaskLine(GameObject go, ERVSData[] vsData, float grassPerimeter, float plantPerimeter, float treePerimeter, float objectPerimeter, float largeObjectPerimeter)
	{
	}

	public static void UpdateHeightmap(Bounds bounds)
	{
	}

	public static void RemoveVegetationMaskLine(GameObject go)
	{
	}

	public static void CreateBiomeArea(GameObject go, float distance, float blendDistance, float noise)
	{
	}

	public static void UpdateBiomeArea(GameObject go, ERVSData[] vsData, float distance, float blendDistance, float noise)
	{
	}

	public static void RemoveBiomeArea(GameObject go)
	{
	}
}


using EasyRoads3Dv3;
using UnityEngine;

public class runtimeScript : MonoBehaviour
{
	public ERRoadNetwork roadNetwork;

	public ERRoad road;

	public GameObject go;

	public int currentElement;

	public float distance;

	public float speed = 5f;

	private void Start()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Expected O, but got Unknown
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Expected O, but got Unknown
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_009b: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ed: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		Debug.Log((object)"Please read the comments at the top of the runtime script (/Assets/EasyRoads3D/Scripts/runtimeScript) before using the runtime API!");
		roadNetwork = new ERRoadNetwork();
		ERRoadType val = new ERRoadType();
		val.roadWidth = 6f;
		ref Material roadMaterial = ref val.roadMaterial;
		Object obj = Resources.Load("Materials/roads/road material");
		roadMaterial = (Material)(object)((obj is Material) ? obj : null);
		val.layer = 1;
		val.tag = "Untagged";
		Vector3[] array = (Vector3[])(object)new Vector3[4]
		{
			new Vector3(200f, 5f, 200f),
			new Vector3(250f, 5f, 200f),
			new Vector3(250f, 5f, 250f),
			new Vector3(300f, 5f, 250f)
		};
		road = roadNetwork.CreateRoad("road 1", val, array);
		road.AddMarker(new Vector3(300f, 5f, 300f));
		road.InsertMarker(new Vector3(275f, 5f, 235f));
		road.DeleteMarker(2);
		roadNetwork.BuildRoadNetwork();
		go = GameObject.CreatePrimitive((PrimitiveType)3);
	}

	private void Update()
	{
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_0079: Unknown result type (might be due to invalid IL or missing references)
		if (roadNetwork != null)
		{
			float num = Time.deltaTime * speed;
			distance += num;
			Vector3 position = road.GetPosition(distance, ref currentElement);
			position.y += 1f;
			go.transform.position = position;
			go.transform.forward = road.GetLookatSmooth(distance, currentElement);
		}
	}

	private void OnDestroy()
	{
		if (roadNetwork != null && roadNetwork.isInBuildMode)
		{
			roadNetwork.RestoreRoadNetwork();
			Debug.Log((object)"Restore Road Network");
		}
	}
}


using FIMSpace.Basics;
using FIMSpace.GroundFitter;
using UnityEngine;

public class FGroundFitter_Demo_RMCharacterController : FSimpleFitter
{
	protected FAnimationClips clips;

	protected Animator animator;

	private float gravity;

	protected override void Start()
	{
		base.Start();
		animator = ((Component)this).GetComponentInChildren<Animator>();
		clips = new FAnimationClips(animator);
		clips.AddClip("Idle");
		clips.AddClip("Walk");
		clips.AddClip("RotateL");
		clips.AddClip("RotateR");
	}

	public void Update()
	{
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		if (Object.op_Implicit((Object)(object)optionalCharContr))
		{
			if (optionalCharContr.isGrounded)
			{
				gravity = 0f;
			}
			else
			{
				gravity += Time.deltaTime * 10f;
				optionalCharContr.Move(Vector3.down * gravity * Time.deltaTime);
			}
		}
		if (Input.GetKey((KeyCode)97))
		{
			clips.CrossFade("RotateL");
		}
		else if (Input.GetKey((KeyCode)100))
		{
			clips.CrossFade("RotateR");
		}
		else if (Input.GetKey((KeyCode)119))
		{
			clips.CrossFade("Walk");
		}
		else
		{
			clips.CrossFade("Idle");
		}
	}
}


using System;
using UnityEngine;

public static class FEasing
{
	public enum EFease
	{
		EaseInCubic,
		EaseOutCubic,
		EaseInOutCubic,
		EaseInOutElastic,
		EaseInElastic,
		EaseOutElastic,
		EaseInExpo,
		EaseOutExpo,
		EaseInOutExpo,
		Linear
	}

	public delegate float Function(float s, float e, float v, float extraParameter = 1f);

	public static float EaseInCubic(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * value * value * value + start;
	}

	public static float EaseOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value -= 1f;
		end -= start;
		return end * (value * value * value + 1f) + start;
	}

	public static float EaseInOutCubic(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * value * value * value + start;
		}
		value -= 2f;
		return end * 0.5f * (value * value * value + 2f) + start;
	}

	public static float EaseOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 * 0.25f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return num3 * Mathf.Pow(2f, -10f * value * rangeMul) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + end + start;
	}

	public static float EaseInElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num) == 1f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		return 0f - num3 * Mathf.Pow(2f, 10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) + start;
	}

	public static float EaseInOutElastic(float start, float end, float value, float rangeMul = 1f)
	{
		end -= start;
		float num = 1f;
		float num2 = num * 0.3f * rangeMul;
		float num3 = 0f;
		if (value == 0f)
		{
			return start;
		}
		if ((value /= num * 0.5f) == 2f)
		{
			return start + end;
		}
		float num4;
		if (num3 == 0f || num3 < Mathf.Abs(end))
		{
			num3 = end;
			num4 = num2 / 4f * rangeMul;
		}
		else
		{
			num4 = num2 / (MathF.PI * 2f) * Mathf.Asin(end / num3);
		}
		if (value < 1f)
		{
			return -0.5f * (num3 * Mathf.Pow(2f, 10f * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2)) + start;
		}
		return num3 * Mathf.Pow(2f, -10f * rangeMul * (value -= 1f)) * Mathf.Sin((value * num - num4) * (MathF.PI * 2f) / num2) * 0.5f + end + start;
	}

	public static float EaseInExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * Mathf.Pow(2f, 10f * (value - 1f)) + start;
	}

	public static float EaseOutExpo(float start, float end, float value, float ignore = 1f)
	{
		end -= start;
		return end * (0f - Mathf.Pow(2f, -10f * value) + 1f) + start;
	}

	public static float EaseInOutExpo(float start, float end, float value, float ignore = 1f)
	{
		value /= 0.5f;
		end -= start;
		if (value < 1f)
		{
			return end * 0.5f * Mathf.Pow(2f, 10f * (value - 1f)) + start;
		}
		value -= 1f;
		return end * 0.5f * (0f - Mathf.Pow(2f, -10f * value) + 2f) + start;
	}

	public static float Linear(float start, float end, float value, float ignore = 1f)
	{
		return Mathf.Lerp(start, end, value);
	}

	public static Function GetEasingFunction(EFease easingFunction)
	{
		return easingFunction switch
		{
			EFease.EaseInCubic => EaseInCubic, 
			EFease.EaseOutCubic => EaseOutCubic, 
			EFease.EaseInOutCubic => EaseInOutCubic, 
			EFease.EaseInElastic => EaseInElastic, 
			EFease.EaseOutElastic => EaseOutElastic, 
			EFease.EaseInOutElastic => EaseInOutElastic, 
			EFease.EaseInExpo => EaseInExpo, 
			EFease.EaseOutExpo => EaseOutExpo, 
			EFease.EaseInOutExpo => EaseInOutExpo, 
			EFease.Linear => Linear, 
			_ => null, 
		};
	}
}


public enum EFease
{
	EaseInCubic,
	EaseOutCubic,
	EaseInOutCubic,
	EaseInOutElastic,
	EaseInElastic,
	EaseOutElastic,
	EaseInExpo,
	EaseOutExpo,
	EaseInOutExpo,
	Linear
}


public delegate float Function(float s, float e, float v, float extraParameter = 1f);


using UnityEngine;

public class FHierarchyIcons
{
	static FHierarchyIcons()
	{
	}

	private static void EvaluateIcons(int instanceId, Rect selectionRect)
	{
	}

	private static void DrawIcon(string texName, Rect rect)
	{
	}

	private static Texture2D GetTex(string name)
	{
		return null;
	}
}


public interface IFHierarchyIcon
{
	string EditorIconPath { get; }
}


using System;
using UnityEngine;

public static class FSceneIcons
{
	public static void SetGizmoIconEnabled(MonoBehaviour beh, bool on)
	{
		if (!((Object)(object)beh == (Object)null))
		{
			SetGizmoIconEnabled(((object)beh).GetType(), on);
		}
	}

	public static void SetGizmoIconEnabled(Type type, bool on)
	{
	}
}


using UnityEngine;

public class FPD_FixedCurveWindowAttribute : PropertyAttribute
{
	public float StartTime;

	public float EndTime;

	public float StartValue;

	public float EndValue;

	public Color Color;

	public FPD_FixedCurveWindowAttribute(float startTime = 0f, float startValue = 0f, float endTime = 1f, float endValue = 1f, float r = 0f, float g = 1f, float b = 1f, float a = 1f)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		StartTime = startTime;
		StartValue = startValue;
		EndTime = endTime;
		EndValue = endValue;
		Color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_FoldableAttribute : PropertyAttribute
{
	public string FoldVariable;

	public FPD_FoldableAttribute(string boolFoldVariable)
	{
		FoldVariable = boolFoldVariable;
	}
}


using UnityEngine;

public class FPD_HeaderAttribute : PropertyAttribute
{
	public string HeaderText;

	public float UpperPadding;

	public float BottomPadding;

	public float Height;

	public FPD_HeaderAttribute(string headerText, float upperPadding = 6f, float bottomPadding = 4f, int addHeight = 2)
	{
		HeaderText = headerText;
		UpperPadding = upperPadding;
		BottomPadding = bottomPadding;
		Height = addHeight;
	}
}


using System;
using UnityEngine;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, Inherited = true)]
public class FPD_HideOnBoolAttribute : PropertyAttribute
{
	public string BoolVarName = "";

	public bool HideInInspector;

	public FPD_HideOnBoolAttribute(string boolVariableName)
	{
		BoolVarName = boolVariableName;
		HideInInspector = false;
	}

	public FPD_HideOnBoolAttribute(string conditionalSourceField, bool hideInInspector)
	{
		BoolVarName = conditionalSourceField;
		HideInInspector = hideInInspector;
	}
}


using UnityEngine;

public class FPD_LayersAttribute : PropertyAttribute
{
}


using UnityEngine;

public class FPD_MinMaxSliderAttribute : PropertyAttribute
{
	public float MinValue = -60f;

	public float MaxValue = 60f;

	public FPD_MinMaxSliderAttribute(int min, int max)
	{
		MinValue = min;
		MaxValue = max;
	}
}


using UnityEngine;

public class FPD_OverridableFloatAttribute : PropertyAttribute
{
	public string BoolVarName;

	public string TargetVarName;

	public int LabelWidth;

	public FPD_OverridableFloatAttribute(string boolVariableName, string targetVariableName, int labelWidth = 90)
	{
		BoolVarName = boolVariableName;
		TargetVarName = targetVariableName;
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class BackgroundColorAttribute : PropertyAttribute
{
	public float r;

	public float g;

	public float b;

	public float a;

	public Color Color => new Color(r, g, b, a);

	public BackgroundColorAttribute()
	{
		r = (g = (b = (a = 1f)));
	}

	public BackgroundColorAttribute(float aR, float aG, float aB, float aA)
	{
		r = aR;
		g = aG;
		b = aB;
		a = aA;
	}
}


using UnityEngine;

public class FPD_WidthAttribute : PropertyAttribute
{
	public float LabelWidth;

	public FPD_WidthAttribute(int labelWidth)
	{
		LabelWidth = labelWidth;
	}
}


using UnityEngine;

public class FPD_IndentAttribute : PropertyAttribute
{
	public int IndentCount = 1;

	public int LabelsWidth;

	public int SpaceAfter;

	public FPD_IndentAttribute(int indent = 1, int labelsWidth = 0, int spaceAfter = 0)
	{
		IndentCount = indent;
		LabelsWidth = labelsWidth;
		SpaceAfter = spaceAfter;
	}
}


using UnityEngine;

public class FPD_HorizontalLineAttribute : PropertyAttribute
{
	public Color color;

	public FPD_HorizontalLineAttribute(float r = 0.55f, float g = 0.55f, float b = 0.55f, float a = 0.7f)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0011: Unknown result type (might be due to invalid IL or missing references)
		color = new Color(r, g, b, a);
	}
}


using UnityEngine;

public class FPD_PercentageAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly string Suffix;

	public readonly bool from0to100;

	public readonly bool editableValue;

	public readonly bool basic;

	public FPD_PercentageAttribute(float min, float max, bool goOver100Perc = false, bool editable = true, string suffix = "%", bool basicFromTo = false)
	{
		Min = min;
		Max = max;
		from0to100 = !goOver100Perc;
		editableValue = editable;
		Suffix = suffix;
		basic = basicFromTo;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_SuffixAttribute : PropertyAttribute
{
	public enum SuffixMode
	{
		From0to100,
		PercentageUnclamped,
		FromMinToMax,
		FromMinToMaxRounded
	}

	public readonly float Min;

	public readonly float Max;

	public readonly SuffixMode Mode;

	public readonly string Suffix;

	public readonly bool editableValue;

	public readonly int widerField;

	public FPD_SuffixAttribute(float min, float max, SuffixMode mode = SuffixMode.From0to100, string suffix = "%", bool editable = true, int wider = 0)
	{
		Min = min;
		Max = max;
		Mode = mode;
		Suffix = suffix;
		editableValue = editable;
		widerField = wider;
	}
}


public enum SuffixMode
{
	From0to100,
	PercentageUnclamped,
	FromMinToMax,
	FromMinToMaxRounded
}


using UnityEngine;

public class FPD_TabAttribute : PropertyAttribute
{
	public string HeaderText;

	public float R;

	public float G;

	public float B;

	public string IconContent;

	public string ResourcesIconPath;

	public int IconSize;

	public string FoldVariable;

	public FPD_TabAttribute(string headerText, float r = 0.5f, float g = 0.5f, float b = 1f, string iconContent = "", string resourcesIconPath = "", int iconSize = 24, string foldVariable = "")
	{
		HeaderText = headerText;
		R = r;
		G = g;
		B = b;
		IconContent = iconContent;
		ResourcesIconPath = resourcesIconPath;
		IconSize = iconSize;
		FoldVariable = foldVariable;
	}
}


using UnityEngine;

[AddComponentMenu("Image Effects/FXAA")]
public class FXAA : FXAAPostEffectsBase, IImageEffect
{
	public Shader shader;

	private Material mat;

	private void CreateMaterials()
	{
		if ((Object)(object)mat == (Object)null)
		{
			mat = CheckShaderAndCreateMaterial(shader, mat);
		}
	}

	private void Start()
	{
		CreateMaterials();
		CheckSupport(needDepth: false);
	}

	public bool IsActive()
	{
		return ((Behaviour)this).enabled;
	}

	public void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		CreateMaterials();
		float num = 1f / (float)Screen.width;
		float num2 = 1f / (float)Screen.height;
		mat.SetVector("_rcpFrame", new Vector4(num, num2, 0f, 0f));
		mat.SetVector("_rcpFrameOpt", new Vector4(num * 2f, num2 * 2f, num * 0.5f, num2 * 0.5f));
		Graphics.Blit((Texture)(object)source, destination, mat);
	}
}


using UnityEngine;

public class FXAAPostEffectsBase : MonoBehaviour
{
	protected bool supportHDRTextures = true;

	protected bool isSupported = true;

	public Material CheckShaderAndCreateMaterial(Shader s, Material m2Create)
	{
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			((Behaviour)this).enabled = false;
			return null;
		}
		if (s.isSupported && Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			NotSupported();
			Debug.LogError((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not supported on this platform!"));
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private Material CreateMaterial(Shader s, Material m2Create)
	{
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Expected O, but got Unknown
		if (!Object.op_Implicit((Object)(object)s))
		{
			Debug.Log((object)("Missing shader in " + ((object)this).ToString()));
			return null;
		}
		if (Object.op_Implicit((Object)(object)m2Create) && (Object)(object)m2Create.shader == (Object)(object)s && s.isSupported)
		{
			return m2Create;
		}
		if (!s.isSupported)
		{
			return null;
		}
		m2Create = new Material(s);
		((Object)m2Create).hideFlags = (HideFlags)52;
		if (Object.op_Implicit((Object)(object)m2Create))
		{
			return m2Create;
		}
		return null;
	}

	private void OnEnable()
	{
		isSupported = true;
	}

	private bool CheckSupport()
	{
		return CheckSupport(needDepth: false);
	}

	private bool CheckResources()
	{
		Debug.LogWarning((object)("CheckResources () for " + ((object)this).ToString() + " should be overwritten."));
		return isSupported;
	}

	private void Start()
	{
		CheckResources();
	}

	public bool CheckSupport(bool needDepth)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		isSupported = true;
		supportHDRTextures = SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2);
		if (!SystemInfo.supportsImageEffects || !SystemInfo.supportsRenderTextures)
		{
			NotSupported();
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			NotSupported();
			return false;
		}
		if (needDepth)
		{
			Camera component = ((Component)this).GetComponent<Camera>();
			component.depthTextureMode = (DepthTextureMode)(component.depthTextureMode | 1);
		}
		return true;
	}

	private bool CheckSupport(bool needDepth, bool needHdr)
	{
		if (!CheckSupport(needDepth))
		{
			return false;
		}
		if (needHdr && !supportHDRTextures)
		{
			NotSupported();
			return false;
		}
		return true;
	}

	private void ReportAutoDisable()
	{
		Debug.LogWarning((object)("The image effect " + ((object)this).ToString() + " has been disabled as it's not supported on the current platform."));
	}

	private bool CheckShader(Shader s)
	{
		Debug.Log((object)("The shader " + ((object)s).ToString() + " on effect " + ((object)this).ToString() + " is not part of the Unity 3.2+ effects suite anymore. For best performance and quality, please ensure you are using the latest Standard Assets Image Effects (Pro only) package."));
		if (!s.isSupported)
		{
			NotSupported();
			return false;
		}
		return false;
	}

	private void NotSupported()
	{
		((Behaviour)this).enabled = false;
		isSupported = false;
	}

	private void DrawBorder(RenderTexture dest, Material material)
	{
		RenderTexture.active = dest;
		bool flag = true;
		GL.PushMatrix();
		GL.LoadOrtho();
		for (int i = 0; i < material.passCount; i++)
		{
			material.SetPass(i);
			float num;
			float num2;
			if (flag)
			{
				num = 1f;
				num2 = 0f;
			}
			else
			{
				num = 0f;
				num2 = 1f;
			}
			float num3 = 0f + 1f / ((float)((Texture)dest).width * 1f);
			float num4 = 0f;
			float num5 = 1f;
			GL.Begin(7);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			float num6 = 1f - 1f / ((float)((Texture)dest).width * 1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(num6, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(num6, num5, 0.1f);
			num3 = 1f;
			num4 = 0f;
			num5 = 0f + 1f / ((float)((Texture)dest).height * 1f);
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			num3 = 1f;
			num4 = 1f - 1f / ((float)((Texture)dest).height * 1f);
			num5 = 1f;
			GL.TexCoord2(0f, num);
			GL.Vertex3(0f, num4, 0.1f);
			GL.TexCoord2(1f, num);
			GL.Vertex3(num3, num4, 0.1f);
			GL.TexCoord2(1f, num2);
			GL.Vertex3(num3, num5, 0.1f);
			GL.TexCoord2(0f, num2);
			GL.Vertex3(0f, num5, 0.1f);
			GL.End();
		}
		GL.PopMatrix();
	}
}


using System;
using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
[AddComponentMenu("KriptoFX/Explosion_Bloom")]
[ImageEffectAllowedInSceneView]
public class Explosion_Bloom : MonoBehaviour
{
	[Serializable]
	public struct Settings
	{
		[SerializeField]
		[Tooltip("Filters out pixels under this level of brightness.")]
		public float threshold;

		[Range(0f, 1f)]
		[Tooltip("Makes transition between under/over-threshold gradual.")]
		[SerializeField]
		public float softKnee;

		[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
		[SerializeField]
		[Range(1f, 7f)]
		public float radius;

		[SerializeField]
		[Tooltip("Blend factor of the result image.")]
		public float intensity;

		[Tooltip("Controls filter quality and buffer resolution.")]
		[SerializeField]
		public bool highQuality;

		[SerializeField]
		[Tooltip("Reduces flashing noise with an additional filter.")]
		public bool antiFlicker;

		public float thresholdGamma
		{
			get
			{
				return Mathf.Max(0f, threshold);
			}
			set
			{
				threshold = value;
			}
		}

		public float thresholdLinear
		{
			get
			{
				return Mathf.GammaToLinearSpace(thresholdGamma);
			}
			set
			{
				threshold = Mathf.LinearToGammaSpace(value);
			}
		}

		public static Settings defaultSettings
		{
			get
			{
				Settings result = default(Settings);
				result.threshold = 2f;
				result.softKnee = 0f;
				result.radius = 7f;
				result.intensity = 0.7f;
				result.highQuality = true;
				result.antiFlicker = true;
				return result;
			}
		}
	}

	[SerializeField]
	public Settings settings = Settings.defaultSettings;

	[HideInInspector]
	[SerializeField]
	private Shader m_Shader;

	private Material m_Material;

	private const int kMaxIterations = 16;

	private RenderTexture[] m_blurBuffer1 = (RenderTexture[])(object)new RenderTexture[16];

	private RenderTexture[] m_blurBuffer2 = (RenderTexture[])(object)new RenderTexture[16];

	private int m_Threshold;

	private int m_Curve;

	private int m_PrefilterOffs;

	private int m_SampleScale;

	private int m_Intensity;

	private int m_BaseTex;

	public Shader shader
	{
		get
		{
			if ((Object)(object)m_Shader == (Object)null)
			{
				m_Shader = Shader.Find("Hidden/KriptoFX/PostEffects/Explosion_Bloom");
			}
			return m_Shader;
		}
	}

	public Material material
	{
		get
		{
			if ((Object)(object)m_Material == (Object)null)
			{
				m_Material = CheckShaderAndCreateMaterial(shader);
			}
			return m_Material;
		}
	}

	public static bool supportsDX11
	{
		get
		{
			if (SystemInfo.graphicsShaderLevel >= 50)
			{
				return SystemInfo.supportsComputeShaders;
			}
			return false;
		}
	}

	public static bool IsSupported(Shader s, bool needDepth, bool needHdr, MonoBehaviour effect)
	{
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			Debug.LogWarningFormat("Missing shader for image effect {0}", new object[1] { effect });
			return false;
		}
		if (!SystemInfo.supportsImageEffects)
		{
			Debug.LogWarningFormat("Image effects aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needDepth && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)1))
		{
			Debug.LogWarningFormat("Depth textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		if (needHdr && !SystemInfo.SupportsRenderTextureFormat((RenderTextureFormat)2))
		{
			Debug.LogWarningFormat("Floating point textures aren't supported on this device ({0})", new object[1] { effect });
			return false;
		}
		return true;
	}

	public static Material CheckShaderAndCreateMaterial(Shader s)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Expected O, but got Unknown
		if ((Object)(object)s == (Object)null || !s.isSupported)
		{
			return null;
		}
		return new Material(s)
		{
			hideFlags = (HideFlags)52
		};
	}

	private void Awake()
	{
		m_Threshold = Shader.PropertyToID("_Threshold");
		m_Curve = Shader.PropertyToID("_Curve");
		m_PrefilterOffs = Shader.PropertyToID("_PrefilterOffs");
		m_SampleScale = Shader.PropertyToID("_SampleScale");
		m_Intensity = Shader.PropertyToID("_Intensity");
		m_BaseTex = Shader.PropertyToID("_BaseTex");
	}

	private void OnEnable()
	{
		if (!IsSupported(shader, needDepth: true, needHdr: false, (MonoBehaviour)(object)this))
		{
			((Behaviour)this).enabled = false;
		}
	}

	private void OnDisable()
	{
		if ((Object)(object)m_Material != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)m_Material);
		}
		m_Material = null;
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		//IL_014c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0197: Unknown result type (might be due to invalid IL or missing references)
		//IL_0220: Unknown result type (might be due to invalid IL or missing references)
		bool isMobilePlatform = Application.isMobilePlatform;
		int num = ((Texture)source).width;
		int num2 = ((Texture)source).height;
		if (!settings.highQuality)
		{
			num /= 2;
			num2 /= 2;
		}
		RenderTextureFormat val = (RenderTextureFormat)(isMobilePlatform ? 7 : 9);
		float num3 = Mathf.Log((float)num2, 2f) + settings.radius - 8f;
		int num4 = (int)num3;
		int num5 = Mathf.Clamp(num4, 1, 16);
		float thresholdLinear = settings.thresholdLinear;
		material.SetFloat(m_Threshold, thresholdLinear);
		float num6 = thresholdLinear * settings.softKnee + 1E-05f;
		Vector3 val2 = default(Vector3);
		((Vector3)(ref val2))..ctor(thresholdLinear - num6, num6 * 2f, 0.25f / num6);
		material.SetVector(m_Curve, Vector4.op_Implicit(val2));
		bool flag = !settings.highQuality && settings.antiFlicker;
		material.SetFloat(m_PrefilterOffs, flag ? (-0.5f) : 0f);
		material.SetFloat(m_SampleScale, 0.5f + num3 - (float)num4);
		material.SetFloat(m_Intensity, Mathf.Max(0f, settings.intensity));
		RenderTexture temporary = RenderTexture.GetTemporary(num, num2, 0, val);
		Graphics.Blit((Texture)(object)source, temporary, material, settings.antiFlicker ? 1 : 0);
		RenderTexture val3 = temporary;
		for (int i = 0; i < num5; i++)
		{
			m_blurBuffer1[i] = RenderTexture.GetTemporary(((Texture)val3).width / 2, ((Texture)val3).height / 2, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer1[i], material, (i == 0) ? (settings.antiFlicker ? 3 : 2) : 4);
			val3 = m_blurBuffer1[i];
		}
		for (int num7 = num5 - 2; num7 >= 0; num7--)
		{
			RenderTexture val4 = m_blurBuffer1[num7];
			material.SetTexture(m_BaseTex, (Texture)(object)val4);
			m_blurBuffer2[num7] = RenderTexture.GetTemporary(((Texture)val4).width, ((Texture)val4).height, 0, val);
			Graphics.Blit((Texture)(object)val3, m_blurBuffer2[num7], material, settings.highQuality ? 6 : 5);
			val3 = m_blurBuffer2[num7];
		}
		int num8 = 7;
		num8 += (settings.highQuality ? 1 : 0);
		material.SetTexture(m_BaseTex, (Texture)(object)source);
		Graphics.Blit((Texture)(object)val3, destination, material, num8);
		for (int j = 0; j < 16; j++)
		{
			if ((Object)(object)m_blurBuffer1[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer1[j]);
			}
			if ((Object)(object)m_blurBuffer2[j] != (Object)null)
			{
				RenderTexture.ReleaseTemporary(m_blurBuffer2[j]);
			}
			m_blurBuffer1[j] = null;
			m_blurBuffer2[j] = null;
		}
		RenderTexture.ReleaseTemporary(temporary);
	}
}


using System;
using UnityEngine;

[Serializable]
public struct Settings
{
	[SerializeField]
	[Tooltip("Filters out pixels under this level of brightness.")]
	public float threshold;

	[Range(0f, 1f)]
	[Tooltip("Makes transition between under/over-threshold gradual.")]
	[SerializeField]
	public float softKnee;

	[Tooltip("Changes extent of veiling effects in a screen resolution-independent fashion.")]
	[SerializeField]
	[Range(1f, 7f)]
	public float radius;

	[SerializeField]
	[Tooltip("Blend factor of the result image.")]
	public float intensity;

	[Tooltip("Controls filter quality and buffer resolution.")]
	[SerializeField]
	public bool highQuality;

	[SerializeField]
	[Tooltip("Reduces flashing noise with an additional filter.")]
	public bool antiFlicker;

	public float thresholdGamma
	{
		get
		{
			return Mathf.Max(0f, threshold);
		}
		set
		{
			threshold = value;
		}
	}

	public float thresholdLinear
	{
		get
		{
			return Mathf.GammaToLinearSpace(thresholdGamma);
		}
		set
		{
			threshold = Mathf.LinearToGammaSpace(value);
		}
	}

	public static Settings defaultSettings
	{
		get
		{
			Settings result = default(Settings);
			result.threshold = 2f;
			result.softKnee = 0f;
			result.radius = 7f;
			result.intensity = 0.7f;
			result.highQuality = true;
			result.antiFlicker = true;
			return result;
		}
	}
}


using UnityEngine;

public class ExplosionDemoGUI : MonoBehaviour
{
	public GameObject[] Prefabs;

	public float reactivateTime = 4f;

	public Light Sun;

	private int currentNomber;

	private GameObject currentInstance;

	private GUIStyle guiStyleHeader = new GUIStyle();

	private float sunIntensity;

	private float dpiScale;

	private void Start()
	{
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		if (Screen.dpi < 1f)
		{
			dpiScale = 1f;
		}
		if (Screen.dpi < 200f)
		{
			dpiScale = 1f;
		}
		else
		{
			dpiScale = Screen.dpi / 200f;
		}
		guiStyleHeader.fontSize = (int)(15f * dpiScale);
		guiStyleHeader.normal.textColor = new Color(0.15f, 0.15f, 0.15f);
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
		sunIntensity = Sun.intensity;
	}

	private void OnGUI()
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c1: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		if (GUI.Button(new Rect(10f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "PREVIOUS EFFECT"))
		{
			ChangeCurrent(-1);
		}
		if (GUI.Button(new Rect(160f * dpiScale, 15f * dpiScale, 135f * dpiScale, 37f * dpiScale), "NEXT EFFECT"))
		{
			ChangeCurrent(1);
		}
		sunIntensity = GUI.HorizontalSlider(new Rect(10f * dpiScale, 70f * dpiScale, 285f * dpiScale, 15f * dpiScale), sunIntensity, 0f, 0.6f);
		Sun.intensity = sunIntensity;
		GUI.Label(new Rect(300f * dpiScale, 70f * dpiScale, 30f * dpiScale, 30f * dpiScale), "SUN INTENSITY", guiStyleHeader);
		GUI.Label(new Rect(400f * dpiScale, 15f * dpiScale, 100f * dpiScale, 20f * dpiScale), "Prefab name is \"" + ((Object)Prefabs[currentNomber]).name + "\"  \r\nHold any mouse button that would move the camera", guiStyleHeader);
	}

	private void ChangeCurrent(int delta)
	{
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		currentNomber += delta;
		if (currentNomber > Prefabs.Length - 1)
		{
			currentNomber = 0;
		}
		else if (currentNomber < 0)
		{
			currentNomber = Prefabs.Length - 1;
		}
		if ((Object)(object)currentInstance != (Object)null)
		{
			Object.Destroy((Object)(object)currentInstance);
		}
		currentInstance = Object.Instantiate<GameObject>(Prefabs[currentNomber], ((Component)this).transform.position, default(Quaternion));
		currentInstance.AddComponent<ExplosionDemoReactivator>().TimeDelayToReactivate = reactivateTime;
	}
}


using UnityEngine;

public class ExplosionDemoReactivator : MonoBehaviour
{
	public float TimeDelayToReactivate = 3f;

	private void Start()
	{
		((MonoBehaviour)this).InvokeRepeating("Reactivate", 0f, TimeDelayToReactivate);
	}

	private void Reactivate()
	{
		Transform[] componentsInChildren = ((Component)this).GetComponentsInChildren<Transform>();
		foreach (Transform obj in componentsInChildren)
		{
			((Component)obj).gameObject.SetActive(false);
			((Component)obj).gameObject.SetActive(true);
		}
	}
}


using UnityEngine;

public class ExplosionPlatformActivator : MonoBehaviour
{
	public GameObject Effect;

	public float TimeDelay;

	public float DefaultRepeatTime = 5f;

	public float NearRepeatTime = 3f;

	private float currentTime;

	private float currentRepeatTime;

	private bool canUpdate;

	private void Start()
	{
		currentRepeatTime = DefaultRepeatTime;
		((MonoBehaviour)this).Invoke("Init", TimeDelay);
	}

	private void Init()
	{
		canUpdate = true;
		Effect.SetActive(true);
	}

	private void Update()
	{
		if (canUpdate && !((Object)(object)Effect == (Object)null))
		{
			currentTime += Time.deltaTime;
			if (currentTime > currentRepeatTime)
			{
				currentTime = 0f;
				Effect.SetActive(false);
				Effect.SetActive(true);
			}
		}
	}

	private void OnTriggerEnter(Collider coll)
	{
		currentRepeatTime = NearRepeatTime;
	}

	private void OnTriggerExit(Collider other)
	{
		currentRepeatTime = DefaultRepeatTime;
	}
}


using UnityEngine;

public class ExplosionsFPS : MonoBehaviour
{
	private readonly GUIStyle guiStyleHeader = new GUIStyle();

	private float timeleft;

	private float fps;

	private int frames;

	private void Awake()
	{
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		guiStyleHeader.fontSize = 14;
		guiStyleHeader.normal.textColor = new Color(1f, 1f, 1f);
	}

	private void OnGUI()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		GUI.Label(new Rect(0f, 0f, 30f, 30f), "FPS: " + (int)fps, guiStyleHeader);
	}

	private void Update()
	{
		timeleft -= Time.deltaTime;
		frames++;
		if ((double)timeleft <= 0.0)
		{
			fps = frames;
			timeleft = 1f;
			frames = 0;
		}
	}
}


using UnityEngine;

public class ExplosionsBillboard : MonoBehaviour
{
	public Camera Camera;

	public bool Active = true;

	public bool AutoInitCamera = true;

	private GameObject myContainer;

	private Transform t;

	private Transform camT;

	private Transform contT;

	private void Awake()
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a7: Expected O, but got Unknown
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		if (AutoInitCamera)
		{
			Camera = Camera.main;
			Active = true;
		}
		t = ((Component)this).transform;
		Vector3 localScale = ((Component)t.parent).transform.localScale;
		localScale.z = localScale.x;
		((Component)t.parent).transform.localScale = localScale;
		camT = ((Component)Camera).transform;
		Transform parent = t.parent;
		myContainer = new GameObject
		{
			name = "Billboard_" + ((Object)((Component)t).gameObject).name
		};
		contT = myContainer.transform;
		contT.position = t.position;
		t.parent = myContainer.transform;
		contT.parent = parent;
	}

	private void Update()
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		if (Active)
		{
			contT.LookAt(contT.position + camT.rotation * Vector3.back, camT.rotation * Vector3.up);
		}
	}
}


using UnityEngine;

public class ExplosionsDeactivateRendererByTime : MonoBehaviour
{
	public float TimeDelay = 1f;

	private Renderer rend;

	private void Awake()
	{
		rend = ((Component)this).GetComponent<Renderer>();
	}

	private void DeactivateRenderer()
	{
		rend.enabled = false;
	}

	private void OnEnable()
	{
		rend.enabled = true;
		((MonoBehaviour)this).Invoke("DeactivateRenderer", TimeDelay);
	}
}


using UnityEngine;

public class ExplosionsLightCurves : MonoBehaviour
{
	public AnimationCurve LightCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphIntensityMultiplier = 1f;

	private bool canUpdate;

	private float startTime;

	private Light lightSource;

	private void Awake()
	{
		lightSource = ((Component)this).GetComponent<Light>();
		lightSource.intensity = LightCurve.Evaluate(0f);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float intensity = LightCurve.Evaluate(num / GraphTimeMultiplier) * GraphIntensityMultiplier;
			lightSource.intensity = intensity;
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class ExplosionsParticleSystemScaler : MonoBehaviour
{
	public float particlesScale = 1f;

	private void Start()
	{
	}

	private void Update()
	{
	}
}


using UnityEngine;

public class ExplosionsScaleCurves : MonoBehaviour
{
	public AnimationCurve ScaleCurveX = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveY = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public AnimationCurve ScaleCurveZ = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public Vector3 GraphTimeMultiplier = Vector3.one;

	public Vector3 GraphScaleMultiplier = Vector3.one;

	private float startTime;

	private Transform t;

	private float evalX;

	private float evalY;

	private float evalZ;

	private void Awake()
	{
		t = ((Component)this).transform;
	}

	private void OnEnable()
	{
		startTime = Time.time;
		evalX = 0f;
		evalY = 0f;
		evalZ = 0f;
	}

	private void Update()
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (num <= GraphTimeMultiplier.x)
		{
			evalX = ScaleCurveX.Evaluate(num / GraphTimeMultiplier.x) * GraphScaleMultiplier.x;
		}
		if (num <= GraphTimeMultiplier.y)
		{
			evalY = ScaleCurveY.Evaluate(num / GraphTimeMultiplier.y) * GraphScaleMultiplier.y;
		}
		if (num <= GraphTimeMultiplier.z)
		{
			evalZ = ScaleCurveZ.Evaluate(num / GraphTimeMultiplier.z) * GraphScaleMultiplier.z;
		}
		t.localScale = new Vector3(evalX, evalY, evalZ);
	}
}


using UnityEngine;

public class ExplosionsShaderColorGradient : MonoBehaviour
{
	public string ShaderProperty = "_TintColor";

	public int MaterialID;

	public Gradient Color = new Gradient();

	public float TimeMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private Color oldColor;

	private void Start()
	{
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_007f: Unknown result type (might be due to invalid IL or missing references)
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
		oldColor = matInstance.GetColor(propertyID);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		float num = Time.time - startTime;
		if (canUpdate)
		{
			Color val = Color.Evaluate(num / TimeMultiplier);
			matInstance.SetColor(propertyID, val * oldColor);
		}
		if (num >= TimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderFloatCurves : MonoBehaviour
{
	public string ShaderProperty = "_BumpAmt";

	public int MaterialID;

	public AnimationCurve FloatPropertyCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

	public float GraphTimeMultiplier = 1f;

	public float GraphScaleMultiplier = 1f;

	private bool canUpdate;

	private Material matInstance;

	private int propertyID;

	private float startTime;

	private void Start()
	{
		Material[] materials = ((Component)this).GetComponent<Renderer>().materials;
		if (MaterialID >= materials.Length)
		{
			Debug.Log((object)"ShaderColorGradient: Material ID more than shader materials count.");
		}
		matInstance = materials[MaterialID];
		if (!matInstance.HasProperty(ShaderProperty))
		{
			Debug.Log((object)("ShaderColorGradient: Shader not have \"" + ShaderProperty + "\" property"));
		}
		propertyID = Shader.PropertyToID(ShaderProperty);
	}

	private void OnEnable()
	{
		startTime = Time.time;
		canUpdate = true;
	}

	private void Update()
	{
		float num = Time.time - startTime;
		if (canUpdate)
		{
			float num2 = FloatPropertyCurve.Evaluate(num / GraphTimeMultiplier) * GraphScaleMultiplier;
			matInstance.SetFloat(propertyID, num2);
		}
		if (num >= GraphTimeMultiplier)
		{
			canUpdate = false;
		}
	}
}


using UnityEngine;

public class ExplosionsShaderQueue : MonoBehaviour
{
	public int AddQueue = 1;

	private Renderer rend;

	private void Start()
	{
		rend = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)rend != (Object)null)
		{
			Material sharedMaterial = rend.sharedMaterial;
			sharedMaterial.renderQueue += AddQueue;
		}
		else
		{
			((MonoBehaviour)this).Invoke("SetProjectorQueue", 0.1f);
		}
	}

	private void SetProjectorQueue()
	{
		Material material = ((Component)this).GetComponent<Projector>().material;
		material.renderQueue += AddQueue;
	}

	private void OnDisable()
	{
		if ((Object)(object)rend != (Object)null)
		{
			rend.sharedMaterial.renderQueue = -1;
		}
	}
}


using System;
using System.Collections;
using UnityEngine;

internal class ExplosionsSpriteSheetAnimation : MonoBehaviour
{
	public int TilesX = 4;

	public int TilesY = 4;

	public float AnimationFPS = 30f;

	public bool IsInterpolateFrames;

	public int StartFrameOffset;

	public bool IsLoop = true;

	public float StartDelay;

	public AnimationCurve FrameOverTime = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	private bool isInizialised;

	private int index;

	private int count;

	private int allCount;

	private float animationLifeTime;

	private bool isVisible;

	private bool isCorutineStarted;

	private Renderer currentRenderer;

	private Material instanceMaterial;

	private float currentInterpolatedTime;

	private float animationStartTime;

	private bool animationStoped;

	private void Start()
	{
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		InitDefaultVariables();
		isInizialised = true;
		isVisible = true;
		Play();
	}

	private void InitDefaultVariables()
	{
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fa: Unknown result type (might be due to invalid IL or missing references)
		//IL_010b: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		currentRenderer = ((Component)this).GetComponent<Renderer>();
		if ((Object)(object)currentRenderer == (Object)null)
		{
			throw new Exception("UvTextureAnimator can't get renderer");
		}
		if (!currentRenderer.enabled)
		{
			currentRenderer.enabled = true;
		}
		allCount = 0;
		animationStoped = false;
		animationLifeTime = (float)(TilesX * TilesY) / AnimationFPS;
		count = TilesY * TilesX;
		index = TilesX - 1;
		Vector3 zero = Vector3.zero;
		StartFrameOffset -= StartFrameOffset / count * count;
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial = currentRenderer.material;
			instanceMaterial.SetTextureScale("_MainTex", val);
			instanceMaterial.SetTextureOffset("_MainTex", Vector2.op_Implicit(zero));
		}
	}

	private void Play()
	{
		if (!isCorutineStarted)
		{
			if (StartDelay > 0.0001f)
			{
				((MonoBehaviour)this).Invoke("PlayDelay", StartDelay);
			}
			else
			{
				((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
			}
			isCorutineStarted = true;
		}
	}

	private void PlayDelay()
	{
		((MonoBehaviour)this).StartCoroutine(UpdateCorutine());
	}

	private void OnEnable()
	{
		if (isInizialised)
		{
			InitDefaultVariables();
			isVisible = true;
			Play();
		}
	}

	private void OnDisable()
	{
		isCorutineStarted = false;
		isVisible = false;
		((MonoBehaviour)this).StopAllCoroutines();
		((MonoBehaviour)this).CancelInvoke("PlayDelay");
	}

	private IEnumerator UpdateCorutine()
	{
		animationStartTime = Time.time;
		while (isVisible && (IsLoop || !animationStoped))
		{
			UpdateFrame();
			if (!IsLoop && animationStoped)
			{
				break;
			}
			float num = (Time.time - animationStartTime) / animationLifeTime;
			float num2 = FrameOverTime.Evaluate(Mathf.Clamp01(num));
			yield return (object)new WaitForSeconds(1f / (AnimationFPS * num2));
		}
		isCorutineStarted = false;
		currentRenderer.enabled = false;
	}

	private void UpdateFrame()
	{
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		allCount++;
		index++;
		if (index >= count)
		{
			index = 0;
		}
		if (count == allCount)
		{
			animationStartTime = Time.time;
			allCount = 0;
			animationStoped = true;
		}
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)index / (float)TilesX - (float)(index / TilesX), 1f - (float)(index / TilesX) / (float)TilesY);
		if ((Object)(object)currentRenderer != (Object)null)
		{
			instanceMaterial.SetTextureOffset("_MainTex", val);
		}
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime = 0f;
		}
	}

	private void Update()
	{
		//IL_0098: Unknown result type (might be due to invalid IL or missing references)
		if (IsInterpolateFrames)
		{
			currentInterpolatedTime += Time.deltaTime;
			int num = index + 1;
			if (allCount == 0)
			{
				num = index;
			}
			Vector4 val = default(Vector4);
			((Vector4)(ref val))..ctor(1f / (float)TilesX, 1f / (float)TilesY, (float)num / (float)TilesX - (float)(num / TilesX), 1f - (float)(num / TilesX) / (float)TilesY);
			if ((Object)(object)currentRenderer != (Object)null)
			{
				instanceMaterial.SetVector("_MainTex_NextFrame", val);
				float num2 = (Time.time - animationStartTime) / animationLifeTime;
				float num3 = FrameOverTime.Evaluate(Mathf.Clamp01(num2));
				instanceMaterial.SetFloat("InterpolationValue", Mathf.Clamp01(currentInterpolatedTime * AnimationFPS * num3));
			}
		}
	}

	private void OnDestroy()
	{
		if ((Object)(object)instanceMaterial != (Object)null)
		{
			Object.Destroy((Object)(object)instanceMaterial);
			instanceMaterial = null;
		}
	}
}


using ConVar;
using UnityEngine;

[ExecuteInEditMode]
[RequireComponent(typeof(Light))]
public class NGSS_Directional : MonoBehaviour
{
	public enum SAMPLER_COUNT
	{
		SAMPLERS_16,
		SAMPLERS_25,
		SAMPLERS_32,
		SAMPLERS_64
	}

	[Tooltip("Overall softness for both PCF and PCSS shadows.\nRecommended value: 0.01.")]
	[Range(0f, 0.02f)]
	public float PCSS_GLOBAL_SOFTNESS = 0.01f;

	[Range(0f, 1f)]
	[Tooltip("PCSS softness when shadows is close to caster.\nRecommended value: 0.05.")]
	public float PCSS_FILTER_DIR_MIN = 0.05f;

	[Tooltip("PCSS softness when shadows is far from caster.\nRecommended value: 0.25.\nIf too high can lead to visible artifacts when early bailout is enabled.")]
	[Range(0f, 0.5f)]
	public float PCSS_FILTER_DIR_MAX = 0.25f;

	[Tooltip("Amount of banding or noise. Example: 0.0 gives 100 % Banding and 10.0 gives 100 % Noise.")]
	[Range(0f, 10f)]
	public float BANDING_NOISE_AMOUNT = 1f;

	[Tooltip("Recommended values: Mobile = 16, Consoles = 25, Desktop Low = 32, Desktop High = 64")]
	public SAMPLER_COUNT SAMPLERS_COUNT;

	private void Update()
	{
		bool globalSettings = Graphics.shadowquality >= 2;
		SetGlobalSettings(globalSettings);
	}

	private void SetGlobalSettings(bool enabled)
	{
		if (enabled)
		{
			Shader.SetGlobalFloat("NGSS_PCSS_GLOBAL_SOFTNESS", PCSS_GLOBAL_SOFTNESS);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MIN", (PCSS_FILTER_DIR_MIN > PCSS_FILTER_DIR_MAX) ? PCSS_FILTER_DIR_MAX : PCSS_FILTER_DIR_MIN);
			Shader.SetGlobalFloat("NGSS_PCSS_FILTER_DIR_MAX", (PCSS_FILTER_DIR_MAX < PCSS_FILTER_DIR_MIN) ? PCSS_FILTER_DIR_MIN : PCSS_FILTER_DIR_MAX);
			Shader.SetGlobalFloat("NGSS_POISSON_SAMPLING_NOISE_DIR", BANDING_NOISE_AMOUNT);
		}
	}
}


public enum SAMPLER_COUNT
{
	SAMPLERS_16,
	SAMPLERS_25,
	SAMPLERS_32,
	SAMPLERS_64
}


using UnityEngine;

public struct OccludeeSphere
{
	public int id;

	public OccludeeState state;

	public OcclusionCulling.Sphere sphere;

	public bool IsRegistered => id >= 0;

	public void Invalidate()
	{
		id = -1;
		state = null;
		sphere = default(OcclusionCulling.Sphere);
	}

	public OccludeeSphere(int id)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		sphere = new OcclusionCulling.Sphere(Vector3.zero, 0f);
	}

	public OccludeeSphere(int id, OcclusionCulling.Sphere sphere)
	{
		this.id = id;
		state = ((id < 0) ? null : OcclusionCulling.GetStateById(id));
		this.sphere = sphere;
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

public class OccludeeState : OcclusionCulling.SmartListValue
{
	[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
	public struct State
	{
		[FieldOffset(0)]
		public Vector4 sphereBounds;

		[FieldOffset(16)]
		public float minTimeVisible;

		[FieldOffset(20)]
		public float waitTime;

		[FieldOffset(24)]
		public uint waitFrame;

		[FieldOffset(28)]
		public byte isVisible;

		[FieldOffset(29)]
		public byte active;

		[FieldOffset(30)]
		public byte callback;

		[FieldOffset(31)]
		public byte pad1;

		public static State Unused = new State
		{
			active = 0
		};
	}

	public int slot;

	public bool isStatic;

	public int layer;

	public OcclusionCulling.OnVisibilityChanged onVisibilityChanged;

	public OcclusionCulling.Cell cell;

	public OcclusionCulling.SimpleList<State> states;

	public bool isVisible => states[slot].isVisible != 0;

	public OccludeeState Initialize(OcclusionCulling.SimpleList<State> states, OcclusionCulling.BufferSet set, int slot, Vector4 sphereBounds, bool isVisible, float minTimeVisible, bool isStatic, int layer, OcclusionCulling.OnVisibilityChanged onVisibilityChanged)
	{
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		states[slot] = new State
		{
			sphereBounds = sphereBounds,
			minTimeVisible = minTimeVisible,
			waitTime = (isVisible ? (Time.time + minTimeVisible) : 0f),
			waitFrame = (uint)(Time.frameCount + 1),
			isVisible = (byte)(isVisible ? 1 : 0),
			active = 1,
			callback = ((onVisibilityChanged != null) ? ((byte)1) : ((byte)0))
		};
		this.slot = slot;
		this.isStatic = isStatic;
		this.layer = layer;
		this.onVisibilityChanged = onVisibilityChanged;
		cell = null;
		this.states = states;
		return this;
	}

	public void Invalidate()
	{
		states[slot] = State.Unused;
		slot = -1;
		onVisibilityChanged = null;
		cell = null;
	}

	public void MakeVisible()
	{
		states.array[slot].waitTime = Time.time + states[slot].minTimeVisible;
		states.array[slot].isVisible = 1;
		if (onVisibilityChanged != null)
		{
			onVisibilityChanged(visible: true);
		}
	}
}


using System.Runtime.InteropServices;
using UnityEngine;

[StructLayout(LayoutKind.Explicit, Pack = 1, Size = 32)]
public struct State
{
	[FieldOffset(0)]
	public Vector4 sphereBounds;

	[FieldOffset(16)]
	public float minTimeVisible;

	[FieldOffset(20)]
	public float waitTime;

	[FieldOffset(24)]
	public uint waitFrame;

	[FieldOffset(28)]
	public byte isVisible;

	[FieldOffset(29)]
	public byte active;

	[FieldOffset(30)]
	public byte callback;

	[FieldOffset(31)]
	public byte pad1;

	public static State Unused = new State
	{
		active = 0
	};
}


using UnityEngine;

public class Occludee : MonoBehaviour
{
	public float minTimeVisible = 0.1f;

	public bool isStatic = true;

	public bool autoRegister;

	public bool stickyGizmos;

	public OccludeeState state;

	protected int occludeeId = -1;

	protected Vector3 center;

	protected float radius;

	protected Renderer renderer;

	protected Collider collider;

	protected virtual void Awake()
	{
		renderer = ((Component)this).GetComponent<Renderer>();
		collider = ((Component)this).GetComponent<Collider>();
	}

	public void OnEnable()
	{
		if (autoRegister && (Object)(object)collider != (Object)null)
		{
			Register();
		}
	}

	public void OnDisable()
	{
		if (autoRegister && occludeeId >= 0)
		{
			Unregister();
		}
	}

	public void Register()
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		Bounds bounds = collider.bounds;
		center = ((Bounds)(ref bounds)).center;
		bounds = collider.bounds;
		float x = ((Bounds)(ref bounds)).extents.x;
		bounds = collider.bounds;
		float num = Mathf.Max(x, ((Bounds)(ref bounds)).extents.y);
		bounds = collider.bounds;
		radius = Mathf.Max(num, ((Bounds)(ref bounds)).extents.z);
		occludeeId = OcclusionCulling.RegisterOccludee(center, radius, renderer.enabled, minTimeVisible, isStatic, ((Component)this).gameObject.layer, OnVisibilityChanged);
		if (occludeeId < 0)
		{
			Debug.LogWarning((object)("[OcclusionCulling] Occludee registration failed for " + ((Object)this).name + ". Too many registered."));
		}
		state = OcclusionCulling.GetStateById(occludeeId);
	}

	public void Unregister()
	{
		OcclusionCulling.UnregisterOccludee(occludeeId);
	}

	protected virtual void OnVisibilityChanged(bool visible)
	{
		if ((Object)(object)renderer != (Object)null)
		{
			renderer.enabled = visible;
		}
	}
}


public class OcclusionCPUTest
{
}


using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using RustNative;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(Camera))]
[RequireComponent(typeof(Camera))]
public class OcclusionCulling : MonoBehaviour
{
	public class BufferSet
	{
		public ComputeBuffer inputBuffer;

		public ComputeBuffer resultBuffer;

		public int width;

		public int height;

		public int capacity;

		public int count;

		public Texture2D inputTexture;

		public RenderTexture resultTexture;

		public Texture2D resultReadTexture;

		public Color[] inputData = (Color[])(object)new Color[0];

		public Color32[] resultData = (Color32[])(object)new Color32[0];

		private OcclusionCulling culling;

		private const int MaxAsyncGPUReadbackRequests = 10;

		private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

		public IntPtr readbackInst = IntPtr.Zero;

		public bool Ready => resultData.Length != 0;

		public void Attach(OcclusionCulling culling)
		{
			this.culling = culling;
		}

		public void Dispose(bool data = true)
		{
			if (inputBuffer != null)
			{
				inputBuffer.Dispose();
				inputBuffer = null;
			}
			if (resultBuffer != null)
			{
				resultBuffer.Dispose();
				resultBuffer = null;
			}
			if ((Object)(object)inputTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)inputTexture);
				inputTexture = null;
			}
			if ((Object)(object)resultTexture != (Object)null)
			{
				RenderTexture.active = null;
				resultTexture.Release();
				Object.DestroyImmediate((Object)(object)resultTexture);
				resultTexture = null;
			}
			if ((Object)(object)resultReadTexture != (Object)null)
			{
				Object.DestroyImmediate((Object)(object)resultReadTexture);
				resultReadTexture = null;
			}
			if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.Destroy(readbackInst);
				readbackInst = IntPtr.Zero;
			}
			if (data)
			{
				inputData = (Color[])(object)new Color[0];
				resultData = (Color32[])(object)new Color32[0];
				capacity = 0;
				count = 0;
			}
		}

		public bool CheckResize(int count, int granularity)
		{
			//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Expected O, but got Unknown
			//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01cf: Expected O, but got Unknown
			//IL_0097: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Expected O, but got Unknown
			//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00e3: Expected O, but got Unknown
			//IL_0133: Unknown result type (might be due to invalid IL or missing references)
			//IL_013d: Expected O, but got Unknown
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_019a: Expected I4, but got Unknown
			//IL_024a: Unknown result type (might be due to invalid IL or missing references)
			//IL_024b: Unknown result type (might be due to invalid IL or missing references)
			if (count > capacity || (culling.usePixelShaderFallback && (Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
			{
				Dispose(data: false);
				int num = capacity;
				int num2 = count / granularity * granularity + granularity;
				if (culling.usePixelShaderFallback)
				{
					width = Mathf.CeilToInt(Mathf.Sqrt((float)num2));
					height = Mathf.CeilToInt((float)num2 / (float)width);
					inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
					((Object)inputTexture).name = "_Input";
					((Texture)inputTexture).filterMode = (FilterMode)0;
					((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
					resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
					((Object)resultTexture).name = "_Result";
					((Texture)resultTexture).filterMode = (FilterMode)0;
					((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
					resultTexture.useMipMap = false;
					resultTexture.Create();
					resultReadTexture = new Texture2D(width, height, (TextureFormat)5, false, true);
					((Object)resultReadTexture).name = "_ResultRead";
					((Texture)resultReadTexture).filterMode = (FilterMode)0;
					((Texture)resultReadTexture).wrapMode = (TextureWrapMode)1;
					if (!culling.useAsyncReadAPI)
					{
						readbackInst = BufferReadback.CreateForTexture(((Texture)resultTexture).GetNativeTexturePtr(), (uint)width, (uint)height, (uint)(int)resultTexture.format);
					}
					capacity = width * height;
				}
				else
				{
					inputBuffer = new ComputeBuffer(num2, 16);
					resultBuffer = new ComputeBuffer(num2, 4);
					if (!culling.useAsyncReadAPI)
					{
						uint num3 = (uint)(capacity * 4);
						readbackInst = BufferReadback.CreateForBuffer(resultBuffer.GetNativeBufferPtr(), num3);
					}
					capacity = num2;
				}
				Array.Resize(ref inputData, capacity);
				Array.Resize(ref resultData, capacity);
				Color32 val = default(Color32);
				((Color32)(ref val))..ctor(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
				for (int i = num; i < capacity; i++)
				{
					resultData[i] = val;
				}
				this.count = count;
				return true;
			}
			return false;
		}

		public void UploadData()
		{
			if (culling.usePixelShaderFallback)
			{
				inputTexture.SetPixels(inputData);
				inputTexture.Apply();
			}
			else
			{
				inputBuffer.SetData((Array)inputData);
			}
		}

		private int AlignDispatchSize(int dispatchSize)
		{
			return (dispatchSize + 63) / 64;
		}

		public void Dispatch(int count)
		{
			//IL_000d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0012: Unknown result type (might be due to invalid IL or missing references)
			//IL_0017: Unknown result type (might be due to invalid IL or missing references)
			//IL_0050: Unknown result type (might be due to invalid IL or missing references)
			if (culling.usePixelShaderFallback)
			{
				RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
				RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
				culling.fallbackMat.SetTexture("_Input", (Texture)(object)inputTexture);
				Graphics.Blit((Texture)(object)inputTexture, resultTexture, culling.fallbackMat, 0);
				Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
			}
			else if (inputBuffer != null)
			{
				culling.computeShader.SetBuffer(0, "_Input", inputBuffer);
				culling.computeShader.SetBuffer(0, "_Result", resultBuffer);
				culling.computeShader.Dispatch(0, AlignDispatchSize(count), 1, 1);
			}
		}

		public void IssueRead()
		{
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			//IL_004c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_003d: Unknown result type (might be due to invalid IL or missing references)
			//IL_0053: Unknown result type (might be due to invalid IL or missing references)
			if (SafeMode)
			{
				return;
			}
			if (culling.useAsyncReadAPI)
			{
				if (asyncRequests.Count < 10)
				{
					AsyncGPUReadbackRequest item = ((!culling.usePixelShaderFallback) ? AsyncGPUReadback.Request(resultBuffer, (Action<AsyncGPUReadbackRequest>)null) : AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
					asyncRequests.Enqueue(item);
				}
			}
			else if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.IssueRead(readbackInst);
			}
		}

		public void GetResults()
		{
			//IL_010c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_004b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0062: Unknown result type (might be due to invalid IL or missing references)
			//IL_0067: Unknown result type (might be due to invalid IL or missing references)
			//IL_0076: Unknown result type (might be due to invalid IL or missing references)
			//IL_007b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0094: Unknown result type (might be due to invalid IL or missing references)
			if (resultData == null || resultData.Length == 0)
			{
				return;
			}
			if (!SafeMode)
			{
				if (culling.useAsyncReadAPI)
				{
					while (asyncRequests.Count > 0)
					{
						AsyncGPUReadbackRequest val = asyncRequests.Peek();
						if (((AsyncGPUReadbackRequest)(ref val)).hasError)
						{
							asyncRequests.Dequeue();
							continue;
						}
						if (((AsyncGPUReadbackRequest)(ref val)).done)
						{
							NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
							for (int i = 0; i < data.Length; i++)
							{
								resultData[i] = data[i];
							}
							asyncRequests.Dequeue();
							continue;
						}
						break;
					}
				}
				else if (readbackInst != IntPtr.Zero)
				{
					BufferReadback.GetData(readbackInst, ref resultData[0]);
				}
			}
			else if (culling.usePixelShaderFallback)
			{
				RenderTexture.active = resultTexture;
				resultReadTexture.ReadPixels(new Rect(0f, 0f, (float)width, (float)height), 0, 0);
				resultReadTexture.Apply();
				Array.Copy(resultReadTexture.GetPixels32(), resultData, resultData.Length);
			}
			else
			{
				resultBuffer.GetData((Array)resultData);
			}
		}
	}

	public delegate void OnVisibilityChanged(bool visible);

	public enum DebugFilter
	{
		Off,
		Dynamic,
		Static,
		Grid,
		All
	}

	[Flags]
	public enum DebugMask
	{
		Off = 0,
		Dynamic = 1,
		Static = 2,
		Grid = 4,
		All = 7
	}

	[Serializable]
	public class DebugSettings
	{
		public bool log;

		public bool showAllVisible;

		public bool showMipChain;

		public bool showMain;

		public int showMainLod;

		public bool showFallback;

		public bool showStats;

		public bool showScreenBounds;

		public DebugMask showMask;

		public LayerMask layerFilter = LayerMask.op_Implicit(-1);
	}

	public class HashedPoolValue
	{
		public ulong hashedPoolKey = ulong.MaxValue;

		public int hashedPoolIndex = -1;
	}

	public class HashedPool<ValueType> where ValueType : HashedPoolValue, new()
	{
		private int granularity;

		private Dictionary<ulong, ValueType> dict;

		private List<ValueType> pool;

		private List<ValueType> list;

		private Queue<ValueType> recycled;

		public int Size => list.Count;

		public int Count => dict.Count;

		public ValueType this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		public HashedPool(int capacity, int granularity)
		{
			this.granularity = granularity;
			dict = new Dictionary<ulong, ValueType>(capacity);
			pool = new List<ValueType>(capacity);
			list = new List<ValueType>(capacity);
			recycled = new Queue<ValueType>();
		}

		public void Clear()
		{
			dict.Clear();
			pool.Clear();
			list.Clear();
			recycled.Clear();
		}

		public ValueType Add(ulong key, int capacityGranularity = 16)
		{
			ValueType val;
			if (recycled.Count > 0)
			{
				val = recycled.Dequeue();
				list[val.hashedPoolIndex] = val;
			}
			else
			{
				int count = pool.Count;
				if (count == pool.Capacity)
				{
					pool.Capacity += granularity;
				}
				val = new ValueType
				{
					hashedPoolIndex = count
				};
				pool.Add(val);
				list.Add(val);
			}
			val.hashedPoolKey = key;
			dict.Add(key, val);
			return val;
		}

		public void Remove(ValueType value)
		{
			dict.Remove(value.hashedPoolKey);
			list[value.hashedPoolIndex] = null;
			recycled.Enqueue(value);
			value.hashedPoolKey = ulong.MaxValue;
		}

		public bool TryGetValue(ulong key, out ValueType value)
		{
			return dict.TryGetValue(key, out value);
		}

		public bool ContainsKey(ulong key)
		{
			return dict.ContainsKey(key);
		}
	}

	public class SimpleList<T>
	{
		private const int defaultCapacity = 16;

		private static readonly T[] emptyArray = new T[0];

		public T[] array;

		public int count;

		public int Count => count;

		public int Capacity
		{
			get
			{
				return array.Length;
			}
			set
			{
				if (value == array.Length)
				{
					return;
				}
				if (value > 0)
				{
					T[] destinationArray = new T[value];
					if (count > 0)
					{
						Array.Copy(array, 0, destinationArray, 0, count);
					}
					array = destinationArray;
				}
				else
				{
					array = emptyArray;
				}
			}
		}

		public T this[int index]
		{
			get
			{
				return array[index];
			}
			set
			{
				array[index] = value;
			}
		}

		public SimpleList()
		{
			array = emptyArray;
		}

		public SimpleList(int capacity)
		{
			array = ((capacity == 0) ? emptyArray : new T[capacity]);
		}

		public void Add(T item)
		{
			if (count == array.Length)
			{
				EnsureCapacity(count + 1);
			}
			array[count++] = item;
		}

		public void Clear()
		{
			if (count > 0)
			{
				Array.Clear(array, 0, count);
				count = 0;
			}
		}

		public bool Contains(T item)
		{
			for (int i = 0; i < count; i++)
			{
				if (array[i].Equals(item))
				{
					return true;
				}
			}
			return false;
		}

		public void CopyTo(T[] array)
		{
			Array.Copy(this.array, 0, array, 0, count);
		}

		public void EnsureCapacity(int min)
		{
			if (array.Length < min)
			{
				int num = ((array.Length == 0) ? 16 : (array.Length * 2));
				num = ((num < min) ? min : num);
				Capacity = num;
			}
		}
	}

	public class SmartListValue
	{
		public int hashedListIndex = -1;
	}

	public class SmartList
	{
		private const int defaultCapacity = 16;

		private static readonly OccludeeState[] emptyList = new OccludeeState[0];

		private static readonly int[] emptySlots = new int[0];

		private OccludeeState[] list;

		private int[] slots;

		private Queue<int> recycled;

		private int count;

		public OccludeeState[] List => list;

		public int[] Slots => slots;

		public int Size => count;

		public int Count => count - recycled.Count;

		public OccludeeState this[int i]
		{
			get
			{
				return list[i];
			}
			set
			{
				list[i] = value;
			}
		}

		public int Capacity
		{
			get
			{
				return list.Length;
			}
			set
			{
				if (value == list.Length)
				{
					return;
				}
				if (value > 0)
				{
					OccludeeState[] destinationArray = new OccludeeState[value];
					int[] destinationArray2 = new int[value];
					if (count > 0)
					{
						Array.Copy(list, destinationArray, count);
						Array.Copy(slots, destinationArray2, count);
					}
					list = destinationArray;
					slots = destinationArray2;
				}
				else
				{
					list = emptyList;
					slots = emptySlots;
				}
			}
		}

		public SmartList(int capacity)
		{
			list = new OccludeeState[capacity];
			slots = new int[capacity];
			recycled = new Queue<int>();
			count = 0;
		}

		public void Add(OccludeeState value, int capacityGranularity = 16)
		{
			int num;
			if (recycled.Count > 0)
			{
				num = recycled.Dequeue();
				list[num] = value;
				slots[num] = value.slot;
			}
			else
			{
				num = count;
				if (num == list.Length)
				{
					EnsureCapacity(count + 1);
				}
				list[num] = value;
				slots[num] = value.slot;
				count++;
			}
			value.hashedListIndex = num;
		}

		public void Remove(OccludeeState value)
		{
			int hashedListIndex = value.hashedListIndex;
			list[hashedListIndex] = null;
			slots[hashedListIndex] = -1;
			recycled.Enqueue(hashedListIndex);
			value.hashedListIndex = -1;
		}

		public bool Contains(OccludeeState value)
		{
			int hashedListIndex = value.hashedListIndex;
			if (hashedListIndex >= 0)
			{
				return list[hashedListIndex] != null;
			}
			return false;
		}

		public void EnsureCapacity(int min)
		{
			if (list.Length < min)
			{
				int num = ((list.Length == 0) ? 16 : (list.Length * 2));
				num = ((num < min) ? min : num);
				Capacity = num;
			}
		}
	}

	[Serializable]
	public class Cell : HashedPoolValue
	{
		public int x;

		public int y;

		public int z;

		public Bounds bounds;

		public Vector4 sphereBounds;

		public bool isVisible;

		public SmartList staticBucket;

		public SmartList dynamicBucket;

		public void Reset()
		{
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0026: Unknown result type (might be due to invalid IL or missing references)
			//IL_002b: Unknown result type (might be due to invalid IL or missing references)
			x = (y = (z = 0));
			bounds = default(Bounds);
			sphereBounds = Vector4.zero;
			isVisible = true;
			staticBucket = null;
			dynamicBucket = null;
		}

		public Cell Initialize(int x, int y, int z, Bounds bounds)
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_0018: Unknown result type (might be due to invalid IL or missing references)
			//IL_0020: Unknown result type (might be due to invalid IL or missing references)
			//IL_002c: Unknown result type (might be due to invalid IL or missing references)
			//IL_0038: Unknown result type (might be due to invalid IL or missing references)
			//IL_0044: Unknown result type (might be due to invalid IL or missing references)
			//IL_0049: Unknown result type (might be due to invalid IL or missing references)
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			this.x = x;
			this.y = y;
			this.z = z;
			this.bounds = bounds;
			float num = ((Bounds)(ref bounds)).center.x;
			float num2 = ((Bounds)(ref bounds)).center.y;
			float num3 = ((Bounds)(ref bounds)).center.z;
			Vector3 extents = ((Bounds)(ref bounds)).extents;
			sphereBounds = new Vector4(num, num2, num3, ((Vector3)(ref extents)).magnitude);
			isVisible = true;
			staticBucket = new SmartList(32);
			dynamicBucket = new SmartList(32);
			return this;
		}
	}

	public struct Sphere
	{
		public Vector3 position;

		public float radius;

		public bool IsValid()
		{
			return radius > 0f;
		}

		public Sphere(Vector3 position, float radius)
		{
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			this.position = position;
			this.radius = radius;
		}
	}

	public ComputeShader computeShader;

	public bool usePixelShaderFallback = true;

	public bool useAsyncReadAPI;

	private Camera camera;

	private const int ComputeThreadsPerGroup = 64;

	private const int InputBufferStride = 16;

	private const int ResultBufferStride = 4;

	private const int OccludeeMaxSlotsPerPool = 1048576;

	private const int OccludeePoolGranularity = 2048;

	private const int StateBufferGranularity = 2048;

	private const int GridBufferGranularity = 256;

	private static Queue<OccludeeState> statePool = new Queue<OccludeeState>();

	private static SimpleList<OccludeeState> staticOccludees = new SimpleList<OccludeeState>(2048);

	private static SimpleList<OccludeeState.State> staticStates = new SimpleList<OccludeeState.State>(2048);

	private static SimpleList<int> staticVisibilityChanged = new SimpleList<int>(1024);

	private static SimpleList<OccludeeState> dynamicOccludees = new SimpleList<OccludeeState>(2048);

	private static SimpleList<OccludeeState.State> dynamicStates = new SimpleList<OccludeeState.State>(2048);

	private static SimpleList<int> dynamicVisibilityChanged = new SimpleList<int>(1024);

	private static List<int> staticChanged = new List<int>(256);

	private static Queue<int> staticRecycled = new Queue<int>();

	private static List<int> dynamicChanged = new List<int>(1024);

	private static Queue<int> dynamicRecycled = new Queue<int>();

	private static BufferSet staticSet = new BufferSet();

	private static BufferSet dynamicSet = new BufferSet();

	private static BufferSet gridSet = new BufferSet();

	private Vector4[] frustumPlanes = (Vector4[])(object)new Vector4[6];

	private string[] frustumPropNames = new string[6];

	private float[] matrixToFloatTemp = new float[16];

	private Material fallbackMat;

	private Material depthCopyMat;

	private Matrix4x4 viewMatrix;

	private Matrix4x4 projMatrix;

	private Matrix4x4 viewProjMatrix;

	private Matrix4x4 prevViewProjMatrix;

	private Matrix4x4 invViewProjMatrix;

	private bool useNativePath = true;

	private static OcclusionCulling instance;

	public static bool Passthrough = false;

	private static GraphicsDeviceType[] supportedDeviceTypes = (GraphicsDeviceType[])(object)new GraphicsDeviceType[1] { (GraphicsDeviceType)2 };

	private static bool _enabled = false;

	private static bool _safeMode = false;

	private static DebugFilter _debugShow = DebugFilter.Off;

	public DebugSettings debugSettings = new DebugSettings();

	private Material debugMipMat;

	private const float debugDrawDuration = 0.0334f;

	private Material downscaleMat;

	private Material blitCopyMat;

	private int hiZLevelCount;

	private int hiZWidth;

	private int hiZHeight;

	private RenderTexture depthTexture;

	private RenderTexture hiZTexture;

	private RenderTexture[] hiZLevels;

	private const int GridCellsPerAxis = 2097152;

	private const int GridHalfCellsPerAxis = 1048576;

	private const int GridMinHalfCellsPerAxis = -1048575;

	private const int GridMaxHalfCellsPerAxis = 1048575;

	private const float GridCellSize = 100f;

	private const float GridHalfCellSize = 50f;

	private const float GridRcpCellSize = 0.01f;

	private const int GridPoolCapacity = 16384;

	private const int GridPoolGranularity = 4096;

	private static HashedPool<Cell> grid = new HashedPool<Cell>(16384, 4096);

	private static Queue<Cell> gridChanged = new Queue<Cell>();

	public static OcclusionCulling Instance => instance;

	public static bool Supported => supportedDeviceTypes.Contains(SystemInfo.graphicsDeviceType);

	public static bool Enabled
	{
		get
		{
			return _enabled;
		}
		set
		{
			_enabled = value;
			if ((Object)(object)instance != (Object)null)
			{
				((Behaviour)instance).enabled = value;
			}
		}
	}

	public static bool SafeMode
	{
		get
		{
			return _safeMode;
		}
		set
		{
			_safeMode = value;
		}
	}

	public static DebugFilter DebugShow
	{
		get
		{
			return _debugShow;
		}
		set
		{
			_debugShow = value;
		}
	}

	public bool HiZReady
	{
		get
		{
			if ((Object)(object)hiZTexture != (Object)null && hiZWidth > 0)
			{
				return hiZHeight > 0;
			}
			return false;
		}
	}

	private static void GrowStatePool()
	{
		for (int i = 0; i < 2048; i++)
		{
			statePool.Enqueue(new OccludeeState());
		}
	}

	private static OccludeeState Allocate()
	{
		if (statePool.Count == 0)
		{
			GrowStatePool();
		}
		return statePool.Dequeue();
	}

	private static void Release(OccludeeState state)
	{
		statePool.Enqueue(state);
	}

	private void Awake()
	{
		instance = this;
		camera = ((Component)this).GetComponent<Camera>();
		for (int i = 0; i < 6; i++)
		{
			frustumPropNames[i] = "_FrustumPlane" + i;
		}
	}

	private void OnEnable()
	{
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Invalid comparison between Unknown and I4
		//IL_00be: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_0173: Unknown result type (might be due to invalid IL or missing references)
		//IL_0178: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Expected O, but got Unknown
		//IL_0135: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0147: Expected O, but got Unknown
		if (!Enabled)
		{
			Enabled = false;
			return;
		}
		GraphicsDeviceType graphicsDeviceType;
		if (!Supported)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogWarning((object)("[OcclusionCulling] Disabled due to graphics device type " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString() + " not supported."));
			Enabled = false;
			return;
		}
		usePixelShaderFallback = usePixelShaderFallback || !SystemInfo.supportsComputeShaders || (Object)(object)computeShader == (Object)null || !computeShader.HasKernel("compute_cull");
		useNativePath = (int)SystemInfo.graphicsDeviceType == 2 && SupportsNativePath();
		useAsyncReadAPI = !useNativePath && SystemInfo.supportsAsyncGPUReadback;
		if (!useNativePath && !useAsyncReadAPI)
		{
			graphicsDeviceType = SystemInfo.graphicsDeviceType;
			Debug.LogWarning((object)("[OcclusionCulling] Disabled due to unsupported Async GPU Reads on device " + ((object)(GraphicsDeviceType)(ref graphicsDeviceType)/*cast due to .constrained prefix*/).ToString()));
			Enabled = false;
			return;
		}
		for (int i = 0; i < staticOccludees.Count; i++)
		{
			staticChanged.Add(i);
		}
		for (int j = 0; j < dynamicOccludees.Count; j++)
		{
			dynamicChanged.Add(j);
		}
		if (usePixelShaderFallback)
		{
			fallbackMat = new Material(Shader.Find("Hidden/OcclusionCulling/Culling"))
			{
				hideFlags = (HideFlags)61
			};
		}
		staticSet.Attach(this);
		dynamicSet.Attach(this);
		gridSet.Attach(this);
		depthCopyMat = new Material(Shader.Find("Hidden/OcclusionCulling/DepthCopy"))
		{
			hideFlags = (HideFlags)61
		};
		InitializeHiZMap();
		UpdateCameraMatrices(starting: true);
	}

	private bool SupportsNativePath()
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		bool result = true;
		try
		{
			OccludeeState.State states = default(OccludeeState.State);
			Color32 results = default(Color32);
			((Color32)(ref results))..ctor((byte)0, (byte)0, (byte)0, (byte)0);
			Vector4 zero = Vector4.zero;
			int bucket = 0;
			int changed = 0;
			int changedCount = 0;
			ProcessOccludees_Native(ref states, ref bucket, 0, ref results, 0, ref changed, ref changedCount, ref zero, 0f, 0u);
		}
		catch (EntryPointNotFoundException)
		{
			Debug.Log((object)"[OcclusionCulling] Fast native path not available. Reverting to managed fallback.");
			result = false;
		}
		return result;
	}

	private void OnDisable()
	{
		if ((Object)(object)fallbackMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)fallbackMat);
			fallbackMat = null;
		}
		if ((Object)(object)depthCopyMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)depthCopyMat);
			depthCopyMat = null;
		}
		staticSet.Dispose();
		dynamicSet.Dispose();
		gridSet.Dispose();
		FinalizeHiZMap();
	}

	public static void MakeAllVisible()
	{
		for (int i = 0; i < staticOccludees.Count; i++)
		{
			if (staticOccludees[i] != null)
			{
				staticOccludees[i].MakeVisible();
			}
		}
		for (int j = 0; j < dynamicOccludees.Count; j++)
		{
			if (dynamicOccludees[j] != null)
			{
				dynamicOccludees[j].MakeVisible();
			}
		}
	}

	private void Update()
	{
		if (!Enabled)
		{
			((Behaviour)this).enabled = false;
			return;
		}
		CheckResizeHiZMap();
		DebugUpdate();
		DebugDraw();
	}

	public static void RecursiveAddOccludees<T>(Transform transform, float minTimeVisible = 0.1f, bool isStatic = true, bool stickyGizmos = false) where T : Occludee
	{
		//IL_0087: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Expected O, but got Unknown
		Renderer component = ((Component)transform).GetComponent<Renderer>();
		Collider component2 = ((Component)transform).GetComponent<Collider>();
		if ((Object)(object)component != (Object)null && (Object)(object)component2 != (Object)null)
		{
			T component3 = ((Component)component).gameObject.GetComponent<T>();
			component3 = (((Object)(object)component3 == (Object)null) ? ((Component)component).gameObject.AddComponent<T>() : component3);
			component3.minTimeVisible = minTimeVisible;
			component3.isStatic = isStatic;
			component3.stickyGizmos = stickyGizmos;
			component3.Register();
		}
		foreach (Transform item in transform)
		{
			RecursiveAddOccludees<T>(item, minTimeVisible, isStatic, stickyGizmos);
		}
	}

	private static int FindFreeSlot(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, Queue<int> recycled)
	{
		int result;
		if (recycled.Count > 0)
		{
			result = recycled.Dequeue();
		}
		else
		{
			if (occludees.Count == occludees.Capacity)
			{
				int num = Mathf.Min(occludees.Capacity + 2048, 1048576);
				if (num > 0)
				{
					occludees.Capacity = num;
					states.Capacity = num;
				}
			}
			if (occludees.Count < occludees.Capacity)
			{
				result = occludees.Count;
				occludees.Add(null);
				states.Add(default(OccludeeState.State));
			}
			else
			{
				result = -1;
			}
		}
		return result;
	}

	public static OccludeeState GetStateById(int id)
	{
		if (id >= 0 && id < 2097152)
		{
			bool num = id < 1048576;
			int index = (num ? id : (id - 1048576));
			if (num)
			{
				return staticOccludees[index];
			}
			return dynamicOccludees[index];
		}
		return null;
	}

	public static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged = null)
	{
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		int num = -1;
		num = ((!isStatic) ? RegisterOccludee(center, radius, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged, dynamicOccludees, dynamicStates, dynamicRecycled, dynamicChanged, dynamicSet, dynamicVisibilityChanged) : RegisterOccludee(center, radius, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged, staticOccludees, staticStates, staticRecycled, staticChanged, staticSet, staticVisibilityChanged));
		if (!(num < 0 || isStatic))
		{
			return num + 1048576;
		}
		return num;
	}

	private static int RegisterOccludee(Vector3 center, float radius, bool isVisible, float minTimeVisible, bool isStatic, int layer, OnVisibilityChanged onVisibilityChanged, SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, Queue<int> recycled, List<int> changed, BufferSet set, SimpleList<int> visibilityChanged)
	{
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0034: Unknown result type (might be due to invalid IL or missing references)
		int num = FindFreeSlot(occludees, states, recycled);
		if (num >= 0)
		{
			Vector4 sphereBounds = default(Vector4);
			((Vector4)(ref sphereBounds))..ctor(center.x, center.y, center.z, radius);
			OccludeeState occludeeState = Allocate().Initialize(states, set, num, sphereBounds, isVisible, minTimeVisible, isStatic, layer, onVisibilityChanged);
			occludeeState.cell = RegisterToGrid(occludeeState);
			occludees[num] = occludeeState;
			changed.Add(num);
			if (states.array[num].isVisible != 0 != occludeeState.cell.isVisible)
			{
				visibilityChanged.Add(num);
			}
		}
		return num;
	}

	public static void UnregisterOccludee(int id)
	{
		if (id >= 0 && id < 2097152)
		{
			bool num = id < 1048576;
			int slot = (num ? id : (id - 1048576));
			if (num)
			{
				UnregisterOccludee(slot, staticOccludees, staticRecycled, staticChanged);
			}
			else
			{
				UnregisterOccludee(slot, dynamicOccludees, dynamicRecycled, dynamicChanged);
			}
		}
	}

	private static void UnregisterOccludee(int slot, SimpleList<OccludeeState> occludees, Queue<int> recycled, List<int> changed)
	{
		OccludeeState occludeeState = occludees[slot];
		UnregisterFromGrid(occludeeState);
		recycled.Enqueue(slot);
		changed.Add(slot);
		Release(occludeeState);
		occludees[slot] = null;
		occludeeState.Invalidate();
	}

	public static void UpdateDynamicOccludee(int id, Vector3 center, float radius)
	{
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		int num = id - 1048576;
		if (num >= 0 && num < 1048576)
		{
			dynamicStates.array[num].sphereBounds = new Vector4(center.x, center.y, center.z, radius);
			dynamicChanged.Add(num);
		}
	}

	private void UpdateBuffers(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, BufferSet set, List<int> changed, bool isStatic)
	{
		//IL_006a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0074: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0057: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		int count = occludees.Count;
		bool flag = changed.Count > 0;
		set.CheckResize(count, 2048);
		for (int i = 0; i < changed.Count; i++)
		{
			int num = changed[i];
			OccludeeState occludeeState = occludees[num];
			if (occludeeState != null)
			{
				if (!isStatic)
				{
					UpdateInGrid(occludeeState);
				}
				set.inputData[num] = Color.op_Implicit(states[num].sphereBounds);
			}
			else
			{
				set.inputData[num] = Color.op_Implicit(Vector4.zero);
			}
		}
		changed.Clear();
		if (flag)
		{
			set.UploadData();
		}
	}

	private void UpdateCameraMatrices(bool starting = false)
	{
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0061: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0091: Unknown result type (might be due to invalid IL or missing references)
		if (!starting)
		{
			prevViewProjMatrix = viewProjMatrix;
		}
		Matrix4x4 val = Matrix4x4.Perspective(camera.fieldOfView, camera.aspect, camera.nearClipPlane, camera.farClipPlane);
		viewMatrix = camera.worldToCameraMatrix;
		projMatrix = GL.GetGPUProjectionMatrix(val, false);
		viewProjMatrix = projMatrix * viewMatrix;
		invViewProjMatrix = Matrix4x4.Inverse(viewProjMatrix);
		if (starting)
		{
			prevViewProjMatrix = viewProjMatrix;
		}
	}

	private void OnPreCull()
	{
		UpdateCameraMatrices();
		GenerateHiZMipChain();
		PrepareAndDispatch();
		IssueRead();
		if (grid.Size <= gridSet.resultData.Length)
		{
			RetrieveAndApplyVisibility();
		}
		else
		{
			Debug.LogWarning((object)("[OcclusionCulling] Grid size and result capacity are out of sync: " + grid.Size + ", " + gridSet.resultData.Length));
		}
	}

	private void OnPostRender()
	{
		//IL_0005: Unknown result type (might be due to invalid IL or missing references)
		//IL_000a: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		bool sRGBWrite = GL.sRGBWrite;
		RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
		RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
		GrabDepthTexture();
		Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		GL.sRGBWrite = sRGBWrite;
	}

	private float[] MatrixToFloatArray(Matrix4x4 m)
	{
		int i = 0;
		int num = 0;
		for (; i < 4; i++)
		{
			for (int j = 0; j < 4; j++)
			{
				matrixToFloatTemp[num++] = ((Matrix4x4)(ref m))[j, i];
			}
		}
		return matrixToFloatTemp;
	}

	private void PrepareAndDispatch()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0166: Unknown result type (might be due to invalid IL or missing references)
		//IL_0182: Unknown result type (might be due to invalid IL or missing references)
		//IL_019e: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0084: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		Vector2 val = default(Vector2);
		((Vector2)(ref val))..ctor((float)hiZWidth, (float)hiZHeight);
		ExtractFrustum(viewProjMatrix, ref frustumPlanes);
		bool flag = true;
		if (usePixelShaderFallback)
		{
			fallbackMat.SetTexture("_HiZMap", (Texture)(object)hiZTexture);
			fallbackMat.SetFloat("_HiZMaxLod", (float)(hiZLevelCount - 1));
			fallbackMat.SetMatrix("_ViewMatrix", viewMatrix);
			fallbackMat.SetMatrix("_ProjMatrix", projMatrix);
			fallbackMat.SetMatrix("_ViewProjMatrix", viewProjMatrix);
			fallbackMat.SetVector("_CameraWorldPos", Vector4.op_Implicit(((Component)this).transform.position));
			fallbackMat.SetVector("_ViewportSize", Vector4.op_Implicit(val));
			fallbackMat.SetFloat("_FrustumCull", flag ? 0f : 1f);
			for (int i = 0; i < 6; i++)
			{
				fallbackMat.SetVector(frustumPropNames[i], frustumPlanes[i]);
			}
		}
		else
		{
			computeShader.SetTexture(0, "_HiZMap", (Texture)(object)hiZTexture);
			computeShader.SetFloat("_HiZMaxLod", (float)(hiZLevelCount - 1));
			computeShader.SetFloats("_ViewMatrix", MatrixToFloatArray(viewMatrix));
			computeShader.SetFloats("_ProjMatrix", MatrixToFloatArray(projMatrix));
			computeShader.SetFloats("_ViewProjMatrix", MatrixToFloatArray(viewProjMatrix));
			computeShader.SetVector("_CameraWorldPos", Vector4.op_Implicit(((Component)this).transform.position));
			computeShader.SetVector("_ViewportSize", Vector4.op_Implicit(val));
			computeShader.SetFloat("_FrustumCull", flag ? 0f : 1f);
			for (int j = 0; j < 6; j++)
			{
				computeShader.SetVector(frustumPropNames[j], frustumPlanes[j]);
			}
		}
		if (staticOccludees.Count > 0)
		{
			UpdateBuffers(staticOccludees, staticStates, staticSet, staticChanged, isStatic: true);
			staticSet.Dispatch(staticOccludees.Count);
		}
		if (dynamicOccludees.Count > 0)
		{
			UpdateBuffers(dynamicOccludees, dynamicStates, dynamicSet, dynamicChanged, isStatic: false);
			dynamicSet.Dispatch(dynamicOccludees.Count);
		}
		UpdateGridBuffers();
		gridSet.Dispatch(grid.Size);
	}

	private void IssueRead()
	{
		if (staticOccludees.Count > 0)
		{
			staticSet.IssueRead();
		}
		if (dynamicOccludees.Count > 0)
		{
			dynamicSet.IssueRead();
		}
		if (grid.Count > 0)
		{
			gridSet.IssueRead();
		}
		GL.IssuePluginEvent(Graphics.GetRenderEventFunc(), 2);
	}

	public void ResetTiming(SmartList bucket)
	{
		for (int i = 0; i < bucket.Size; i++)
		{
			OccludeeState occludeeState = bucket[i];
			if (occludeeState != null)
			{
				occludeeState.states.array[occludeeState.slot].waitTime = 0f;
			}
		}
	}

	public void ResetTiming()
	{
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell != null)
			{
				ResetTiming(cell.staticBucket);
				ResetTiming(cell.dynamicBucket);
			}
		}
	}

	private void ProcessCallbacks(SimpleList<OccludeeState> occludees, SimpleList<OccludeeState.State> states, SimpleList<int> changed)
	{
		//IL_003f: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Expected O, but got Unknown
		for (int i = 0; i < changed.Count; i++)
		{
			int num = changed[i];
			OccludeeState occludeeState = occludees[num];
			if (occludeeState != null)
			{
				bool flag = states.array[num].isVisible == 0;
				OnVisibilityChanged onVisibilityChanged = occludeeState.onVisibilityChanged;
				if (onVisibilityChanged != null && (Object)onVisibilityChanged.Target != (Object)null)
				{
					onVisibilityChanged(flag);
				}
				if (occludeeState.slot >= 0)
				{
					states.array[occludeeState.slot].isVisible = (byte)(flag ? 1 : 0);
				}
			}
		}
		changed.Clear();
	}

	public void RetrieveAndApplyVisibility()
	{
		if (staticOccludees.Count > 0)
		{
			staticSet.GetResults();
		}
		if (dynamicOccludees.Count > 0)
		{
			dynamicSet.GetResults();
		}
		if (grid.Count > 0)
		{
			gridSet.GetResults();
		}
		if (debugSettings.showAllVisible)
		{
			for (int i = 0; i < staticSet.resultData.Length; i++)
			{
				staticSet.resultData[i].r = 1;
			}
			for (int j = 0; j < dynamicSet.resultData.Length; j++)
			{
				dynamicSet.resultData[j].r = 1;
			}
			for (int k = 0; k < gridSet.resultData.Length; k++)
			{
				gridSet.resultData[k].r = 1;
			}
		}
		staticVisibilityChanged.EnsureCapacity(staticOccludees.Count);
		dynamicVisibilityChanged.EnsureCapacity(dynamicOccludees.Count);
		float time = Time.time;
		uint frameCount = (uint)Time.frameCount;
		if (!Passthrough)
		{
			if (useNativePath)
			{
				ApplyVisibility_Native(time, frameCount);
			}
			else
			{
				ApplyVisibility_Fast(time, frameCount);
			}
		}
		else
		{
			ApplyVisibility_Passthrough(time, frameCount);
		}
		ProcessCallbacks(staticOccludees, staticStates, staticVisibilityChanged);
		ProcessCallbacks(dynamicOccludees, dynamicStates, dynamicVisibilityChanged);
	}

	public static bool DebugFilterIsDynamic(int filter)
	{
		if (filter != 1)
		{
			return filter == 4;
		}
		return true;
	}

	public static bool DebugFilterIsStatic(int filter)
	{
		if (filter != 2)
		{
			return filter == 4;
		}
		return true;
	}

	public static bool DebugFilterIsGrid(int filter)
	{
		if (filter != 3)
		{
			return filter == 4;
		}
		return true;
	}

	private void DebugInitialize()
	{
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Expected O, but got Unknown
		debugMipMat = new Material(Shader.Find("Hidden/OcclusionCulling/DebugMip"))
		{
			hideFlags = (HideFlags)61
		};
	}

	private void DebugShutdown()
	{
		if ((Object)(object)debugMipMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)debugMipMat);
			debugMipMat = null;
		}
	}

	private void DebugUpdate()
	{
		if (HiZReady)
		{
			debugSettings.showMainLod = Mathf.Clamp(debugSettings.showMainLod, 0, hiZLevels.Length - 1);
		}
	}

	private void DebugDraw()
	{
	}

	public static void NormalizePlane(ref Vector4 plane)
	{
		float num = Mathf.Sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);
		plane.x /= num;
		plane.y /= num;
		plane.z /= num;
		plane.w /= num;
	}

	public static void ExtractFrustum(Matrix4x4 viewProjMatrix, ref Vector4[] planes)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0126: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0140: Unknown result type (might be due to invalid IL or missing references)
		//IL_0146: Unknown result type (might be due to invalid IL or missing references)
		//IL_0167: Unknown result type (might be due to invalid IL or missing references)
		//IL_016d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		//IL_0187: Unknown result type (might be due to invalid IL or missing references)
		//IL_019b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_0202: Unknown result type (might be due to invalid IL or missing references)
		//IL_0215: Unknown result type (might be due to invalid IL or missing references)
		//IL_0235: Unknown result type (might be due to invalid IL or missing references)
		//IL_023b: Unknown result type (might be due to invalid IL or missing references)
		//IL_024f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0255: Unknown result type (might be due to invalid IL or missing references)
		//IL_0269: Unknown result type (might be due to invalid IL or missing references)
		//IL_026f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0289: Unknown result type (might be due to invalid IL or missing references)
		planes[0].x = viewProjMatrix.m30 + viewProjMatrix.m00;
		planes[0].y = viewProjMatrix.m31 + viewProjMatrix.m01;
		planes[0].z = viewProjMatrix.m32 + viewProjMatrix.m02;
		planes[0].w = viewProjMatrix.m33 + viewProjMatrix.m03;
		NormalizePlane(ref planes[0]);
		planes[1].x = viewProjMatrix.m30 - viewProjMatrix.m00;
		planes[1].y = viewProjMatrix.m31 - viewProjMatrix.m01;
		planes[1].z = viewProjMatrix.m32 - viewProjMatrix.m02;
		planes[1].w = viewProjMatrix.m33 - viewProjMatrix.m03;
		NormalizePlane(ref planes[1]);
		planes[2].x = viewProjMatrix.m30 - viewProjMatrix.m10;
		planes[2].y = viewProjMatrix.m31 - viewProjMatrix.m11;
		planes[2].z = viewProjMatrix.m32 - viewProjMatrix.m12;
		planes[2].w = viewProjMatrix.m33 - viewProjMatrix.m13;
		NormalizePlane(ref planes[2]);
		planes[3].x = viewProjMatrix.m30 + viewProjMatrix.m10;
		planes[3].y = viewProjMatrix.m31 + viewProjMatrix.m11;
		planes[3].z = viewProjMatrix.m32 + viewProjMatrix.m12;
		planes[3].w = viewProjMatrix.m33 + viewProjMatrix.m13;
		NormalizePlane(ref planes[3]);
		planes[4].x = viewProjMatrix.m20;
		planes[4].y = viewProjMatrix.m21;
		planes[4].z = viewProjMatrix.m22;
		planes[4].w = viewProjMatrix.m23;
		NormalizePlane(ref planes[4]);
		planes[5].x = viewProjMatrix.m30 - viewProjMatrix.m20;
		planes[5].y = viewProjMatrix.m31 - viewProjMatrix.m21;
		planes[5].z = viewProjMatrix.m32 - viewProjMatrix.m22;
		planes[5].w = viewProjMatrix.m33 - viewProjMatrix.m23;
		NormalizePlane(ref planes[5]);
	}

	public void CheckResizeHiZMap()
	{
		int pixelWidth = camera.pixelWidth;
		int pixelHeight = camera.pixelHeight;
		if (pixelWidth <= 0 || pixelHeight <= 0)
		{
			return;
		}
		int num = pixelWidth / 4;
		int num2 = pixelHeight / 4;
		if (hiZLevels == null || hiZWidth != num || hiZHeight != num2)
		{
			InitializeHiZMap(num, num2);
			hiZWidth = num;
			hiZHeight = num2;
			if (debugSettings.log)
			{
				Debug.Log((object)("[OcclusionCulling] Resized HiZ Map to " + hiZWidth + " x " + hiZHeight));
			}
		}
	}

	private void InitializeHiZMap()
	{
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Expected O, but got Unknown
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Expected O, but got Unknown
		Shader val = Shader.Find("Hidden/OcclusionCulling/DepthDownscale");
		Shader val2 = Shader.Find("Hidden/OcclusionCulling/BlitCopy");
		downscaleMat = new Material(val)
		{
			hideFlags = (HideFlags)61
		};
		blitCopyMat = new Material(val2)
		{
			hideFlags = (HideFlags)61
		};
		CheckResizeHiZMap();
	}

	private void FinalizeHiZMap()
	{
		DestroyHiZMap();
		if ((Object)(object)downscaleMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)downscaleMat);
			downscaleMat = null;
		}
		if ((Object)(object)blitCopyMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)blitCopyMat);
			blitCopyMat = null;
		}
	}

	private void InitializeHiZMap(int width, int height)
	{
		DestroyHiZMap();
		width = Mathf.Clamp(width, 1, 65536);
		height = Mathf.Clamp(height, 1, 65536);
		int num = Mathf.Min(width, height);
		hiZLevelCount = (int)(Mathf.Log((float)num, 2f) + 1f);
		hiZLevels = (RenderTexture[])(object)new RenderTexture[hiZLevelCount];
		depthTexture = CreateDepthTexture("DepthTex", width, height);
		hiZTexture = CreateDepthTexture("HiZMapTex", width, height, mips: true);
		for (int i = 0; i < hiZLevelCount; i++)
		{
			hiZLevels[i] = CreateDepthTextureMip("HiZMap" + i, width, height, i);
		}
	}

	private void DestroyHiZMap()
	{
		if ((Object)(object)depthTexture != (Object)null)
		{
			RenderTexture.active = null;
			Object.DestroyImmediate((Object)(object)depthTexture);
			depthTexture = null;
		}
		if ((Object)(object)hiZTexture != (Object)null)
		{
			RenderTexture.active = null;
			Object.DestroyImmediate((Object)(object)hiZTexture);
			hiZTexture = null;
		}
		if (hiZLevels != null)
		{
			for (int i = 0; i < hiZLevels.Length; i++)
			{
				Object.DestroyImmediate((Object)(object)hiZLevels[i]);
			}
			hiZLevels = null;
		}
	}

	private RenderTexture CreateDepthTexture(string name, int width, int height, bool mips = false)
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		RenderTexture val = new RenderTexture(width, height, 0, (RenderTextureFormat)14, (RenderTextureReadWrite)1)
		{
			name = name,
			useMipMap = mips,
			autoGenerateMips = false,
			wrapMode = (TextureWrapMode)1,
			filterMode = (FilterMode)0
		};
		val.Create();
		return val;
	}

	private RenderTexture CreateDepthTextureMip(string name, int width, int height, int mip)
	{
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Expected O, but got Unknown
		int num = width >> mip;
		int num2 = height >> mip;
		RenderTexture val = new RenderTexture(num, num2, 0, (RenderTextureFormat)14, (RenderTextureReadWrite)1)
		{
			name = name,
			useMipMap = false,
			wrapMode = (TextureWrapMode)1,
			filterMode = (FilterMode)0
		};
		val.Create();
		return val;
	}

	public void GrabDepthTexture()
	{
		if ((Object)(object)depthTexture != (Object)null)
		{
			Graphics.Blit((Texture)null, depthTexture, depthCopyMat, 0);
		}
	}

	public void GenerateHiZMipChain()
	{
		//IL_0019: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		if (HiZReady)
		{
			bool flag = true;
			depthCopyMat.SetMatrix("_CameraReprojection", prevViewProjMatrix * invViewProjMatrix);
			depthCopyMat.SetFloat("_FrustumNoDataDepth", flag ? 1f : 0f);
			Graphics.Blit((Texture)(object)depthTexture, hiZLevels[0], depthCopyMat, 1);
			for (int i = 1; i < hiZLevels.Length; i++)
			{
				RenderTexture val = hiZLevels[i - 1];
				RenderTexture val2 = hiZLevels[i];
				int num = (((((Texture)val).width & 1) != 0 || (((Texture)val).height & 1) != 0) ? 1 : 0);
				downscaleMat.SetTexture("_MainTex", (Texture)(object)val);
				Graphics.Blit((Texture)(object)val, val2, downscaleMat, num);
			}
			for (int j = 0; j < hiZLevels.Length; j++)
			{
				Graphics.SetRenderTarget(hiZTexture, j);
				Graphics.Blit((Texture)(object)hiZLevels[j], blitCopyMat);
			}
		}
	}

	private void DebugDrawGizmos()
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_004a: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		//IL_0086: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cf: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		Camera component = ((Component)this).GetComponent<Camera>();
		Gizmos.color = new Color(0.75f, 0.75f, 0f, 0.5f);
		Gizmos.matrix = Matrix4x4.TRS(((Component)this).transform.position, ((Component)this).transform.rotation, Vector3.one);
		Gizmos.DrawFrustum(Vector3.zero, component.fieldOfView, component.farClipPlane, component.nearClipPlane, component.aspect);
		Gizmos.color = Color.red;
		Gizmos.matrix = Matrix4x4.identity;
		Matrix4x4 worldToCameraMatrix = component.worldToCameraMatrix;
		Matrix4x4 val = GL.GetGPUProjectionMatrix(component.projectionMatrix, false) * worldToCameraMatrix;
		Vector4[] planes = (Vector4[])(object)new Vector4[6];
		ExtractFrustum(val, ref planes);
		for (int i = 0; i < planes.Length; i++)
		{
			Vector3 val2 = new Vector3(planes[i].x, planes[i].y, planes[i].z);
			float w = planes[i].w;
			Vector3 val3 = -val2 * w;
			Gizmos.DrawLine(val3, val3 * 2f);
		}
	}

	private static int floor(float x)
	{
		int num = (int)x;
		if (!(x < (float)num))
		{
			return num;
		}
		return num - 1;
	}

	public static Cell RegisterToGrid(OccludeeState occludee)
	{
		//IL_0111: Unknown result type (might be due to invalid IL or missing references)
		//IL_017d: Unknown result type (might be due to invalid IL or missing references)
		//IL_017f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0181: Unknown result type (might be due to invalid IL or missing references)
		int num = floor(occludee.states.array[occludee.slot].sphereBounds.x * 0.01f);
		int num2 = floor(occludee.states.array[occludee.slot].sphereBounds.y * 0.01f);
		int num3 = floor(occludee.states.array[occludee.slot].sphereBounds.z * 0.01f);
		int num4 = Mathf.Clamp(num, -1048575, 1048575);
		int num5 = Mathf.Clamp(num2, -1048575, 1048575);
		int num6 = Mathf.Clamp(num3, -1048575, 1048575);
		long num7 = ((num4 >= 0) ? num4 : (num4 + 1048575));
		ulong num8 = (ulong)((num5 >= 0) ? num5 : (num5 + 1048575));
		ulong num9 = (ulong)((num6 >= 0) ? num6 : (num6 + 1048575));
		ulong key = (ulong)(num7 << 42) | (num8 << 21) | num9;
		Cell value;
		bool num10 = grid.TryGetValue(key, out value);
		if (!num10)
		{
			Vector3 val = new Vector3
			{
				x = (float)num * 100f + 50f,
				y = (float)num2 * 100f + 50f,
				z = (float)num3 * 100f + 50f
			};
			Vector3 val2 = default(Vector3);
			((Vector3)(ref val2))..ctor(100f, 100f, 100f);
			value = grid.Add(key).Initialize(num, num2, num3, new Bounds(val, val2));
		}
		SmartList smartList = (occludee.isStatic ? value.staticBucket : value.dynamicBucket);
		if (!num10 || !smartList.Contains(occludee))
		{
			occludee.cell = value;
			smartList.Add(occludee);
			gridChanged.Enqueue(value);
		}
		return value;
	}

	public static void UpdateInGrid(OccludeeState occludee)
	{
		int num = floor(occludee.states.array[occludee.slot].sphereBounds.x * 0.01f);
		int num2 = floor(occludee.states.array[occludee.slot].sphereBounds.y * 0.01f);
		int num3 = floor(occludee.states.array[occludee.slot].sphereBounds.z * 0.01f);
		if (num != occludee.cell.x || num2 != occludee.cell.y || num3 != occludee.cell.z)
		{
			UnregisterFromGrid(occludee);
			RegisterToGrid(occludee);
		}
	}

	public static void UnregisterFromGrid(OccludeeState occludee)
	{
		Cell cell = occludee.cell;
		SmartList obj = (occludee.isStatic ? cell.staticBucket : cell.dynamicBucket);
		gridChanged.Enqueue(cell);
		obj.Remove(occludee);
		if (cell.staticBucket.Count == 0 && cell.dynamicBucket.Count == 0)
		{
			grid.Remove(cell);
			cell.Reset();
		}
		occludee.cell = null;
	}

	public void UpdateGridBuffers()
	{
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		if (gridSet.CheckResize(grid.Size, 256))
		{
			if (debugSettings.log)
			{
				Debug.Log((object)("[OcclusionCulling] Resized grid to " + grid.Size));
			}
			for (int i = 0; i < grid.Size; i++)
			{
				if (grid[i] != null)
				{
					gridChanged.Enqueue(grid[i]);
				}
			}
		}
		bool flag = gridChanged.Count > 0;
		while (gridChanged.Count > 0)
		{
			Cell cell = gridChanged.Dequeue();
			gridSet.inputData[cell.hashedPoolIndex] = Color.op_Implicit(cell.sphereBounds);
		}
		if (flag)
		{
			gridSet.UploadData();
		}
	}

	private static bool FrustumCull(Vector4[] planes, Vector4 testSphere)
	{
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		for (int i = 0; i < 6; i++)
		{
			if (planes[i].x * testSphere.x + planes[i].y * testSphere.y + planes[i].z * testSphere.z + planes[i].w < 0f - testSphere.w)
			{
				return false;
			}
		}
		return true;
	}

	private static int ProcessOccludees_Safe(SimpleList<OccludeeState.State> states, SmartList bucket, Color32[] results, SimpleList<int> changed, Vector4[] frustumPlanes, float time, uint frame)
	{
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < bucket.Size; i++)
		{
			OccludeeState occludeeState = bucket[i];
			if (occludeeState == null || occludeeState.slot >= results.Length)
			{
				continue;
			}
			int slot = occludeeState.slot;
			OccludeeState.State value = states[slot];
			bool flag = FrustumCull(frustumPlanes, value.sphereBounds);
			bool flag2 = results[slot].r > 0 && flag;
			if (flag2 || frame < value.waitFrame)
			{
				value.waitTime = time + value.minTimeVisible;
			}
			if (!flag2)
			{
				flag2 = time < value.waitTime;
			}
			if (flag2 != (value.isVisible != 0))
			{
				if (value.callback != 0)
				{
					changed.Add(slot);
				}
				else
				{
					value.isVisible = (byte)(flag2 ? 1 : 0);
				}
			}
			states[slot] = value;
			num += value.isVisible;
		}
		return num;
	}

	private static int ProcessOccludees_Fast(OccludeeState.State[] states, int[] bucket, int bucketCount, Color32[] results, int resultCount, int[] changed, ref int changedCount, Vector4[] frustumPlanes, float time, uint frame)
	{
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		int num = 0;
		for (int i = 0; i < bucketCount; i++)
		{
			int num2 = bucket[i];
			if (num2 < 0 || num2 >= resultCount || states[num2].active == 0)
			{
				continue;
			}
			OccludeeState.State state = states[num2];
			bool flag = FrustumCull(frustumPlanes, state.sphereBounds);
			bool flag2 = results[num2].r > 0 && flag;
			if (flag2 || frame < state.waitFrame)
			{
				state.waitTime = time + state.minTimeVisible;
			}
			if (!flag2)
			{
				flag2 = time < state.waitTime;
			}
			if (flag2 != (state.isVisible != 0))
			{
				if (state.callback != 0)
				{
					changed[changedCount++] = num2;
				}
				else
				{
					state.isVisible = (byte)(flag2 ? 1 : 0);
				}
			}
			states[num2] = state;
			num += ((!flag2) ? 1 : 0);
		}
		return num;
	}

	[DllImport("Renderer", EntryPoint = "CULL_ProcessOccludees")]
	private static extern int ProcessOccludees_Native(ref OccludeeState.State states, ref int bucket, int bucketCount, ref Color32 results, int resultCount, ref int changed, ref int changedCount, ref Vector4 frustumPlanes, float time, uint frame);

	private void ApplyVisibility_Safe(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Safe(staticStates, cell.staticBucket, staticSet.resultData, staticVisibilityChanged, frustumPlanes, time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Safe(dynamicStates, cell.dynamicBucket, dynamicSet.resultData, dynamicVisibilityChanged, frustumPlanes, time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Fast(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Fast(staticStates.array, cell.staticBucket.Slots, cell.staticBucket.Size, staticSet.resultData, staticSet.resultData.Length, staticVisibilityChanged.array, ref staticVisibilityChanged.count, frustumPlanes, time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Fast(dynamicStates.array, cell.dynamicBucket.Slots, cell.dynamicBucket.Size, dynamicSet.resultData, dynamicSet.resultData.Length, dynamicVisibilityChanged.array, ref dynamicVisibilityChanged.count, frustumPlanes, time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Native(float time, uint frame)
	{
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		bool ready = staticSet.Ready;
		bool ready2 = dynamicSet.Ready;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null || gridSet.resultData.Length == 0)
			{
				continue;
			}
			bool flag = FrustumCull(frustumPlanes, cell.sphereBounds);
			bool flag2 = gridSet.resultData[i].r > 0 && flag;
			if (cell.isVisible || flag2)
			{
				int num = 0;
				int num2 = 0;
				if (ready && cell.staticBucket.Count > 0)
				{
					num = ProcessOccludees_Native(ref staticStates.array[0], ref cell.staticBucket.Slots[0], cell.staticBucket.Size, ref staticSet.resultData[0], staticSet.resultData.Length, ref staticVisibilityChanged.array[0], ref staticVisibilityChanged.count, ref frustumPlanes[0], time, frame);
				}
				if (ready2 && cell.dynamicBucket.Count > 0)
				{
					num2 = ProcessOccludees_Native(ref dynamicStates.array[0], ref cell.dynamicBucket.Slots[0], cell.dynamicBucket.Size, ref dynamicSet.resultData[0], dynamicSet.resultData.Length, ref dynamicVisibilityChanged.array[0], ref dynamicVisibilityChanged.count, ref frustumPlanes[0], time, frame);
				}
				cell.isVisible = flag2 || num < cell.staticBucket.Count || num2 < cell.dynamicBucket.Count;
			}
		}
	}

	private void ApplyVisibility_Passthrough(float time, uint frame)
	{
		OccludeeState.State[] array = staticStates.array;
		OccludeeState.State[] array2 = dynamicStates.array;
		for (int i = 0; i < grid.Size; i++)
		{
			Cell cell = grid[i];
			if (cell == null)
			{
				continue;
			}
			int[] slots = cell.staticBucket.Slots;
			int size = cell.staticBucket.Size;
			int num = staticSet.resultData.Length;
			for (int j = 0; j < size; j++)
			{
				int num2 = slots[j];
				if (num2 >= 0 && num2 < num && array[num2].active != 0 && array[num2].isVisible == 0)
				{
					if (array[num2].callback != 0)
					{
						staticVisibilityChanged.array[staticVisibilityChanged.count++] = num2;
					}
					else
					{
						array[num2].isVisible = 1;
					}
				}
			}
			int[] slots2 = cell.dynamicBucket.Slots;
			int size2 = cell.dynamicBucket.Size;
			int num3 = dynamicSet.resultData.Length;
			for (int k = 0; k < size2; k++)
			{
				int num4 = slots2[k];
				if (num4 >= 0 && num4 < num3 && array2[num4].active != 0 && array2[num4].isVisible == 0)
				{
					if (array2[num4].callback != 0)
					{
						dynamicVisibilityChanged.array[dynamicVisibilityChanged.count++] = num4;
					}
					else
					{
						array2[num4].isVisible = 1;
					}
				}
			}
			cell.isVisible = true;
		}
	}
}


using System;
using System.Collections.Generic;
using RustNative;
using Unity.Collections;
using UnityEngine;
using UnityEngine.Rendering;

public class BufferSet
{
	public ComputeBuffer inputBuffer;

	public ComputeBuffer resultBuffer;

	public int width;

	public int height;

	public int capacity;

	public int count;

	public Texture2D inputTexture;

	public RenderTexture resultTexture;

	public Texture2D resultReadTexture;

	public Color[] inputData = (Color[])(object)new Color[0];

	public Color32[] resultData = (Color32[])(object)new Color32[0];

	private OcclusionCulling culling;

	private const int MaxAsyncGPUReadbackRequests = 10;

	private Queue<AsyncGPUReadbackRequest> asyncRequests = new Queue<AsyncGPUReadbackRequest>();

	public IntPtr readbackInst = IntPtr.Zero;

	public bool Ready => resultData.Length != 0;

	public void Attach(OcclusionCulling culling)
	{
		this.culling = culling;
	}

	public void Dispose(bool data = true)
	{
		if (inputBuffer != null)
		{
			inputBuffer.Dispose();
			inputBuffer = null;
		}
		if (resultBuffer != null)
		{
			resultBuffer.Dispose();
			resultBuffer = null;
		}
		if ((Object)(object)inputTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)inputTexture);
			inputTexture = null;
		}
		if ((Object)(object)resultTexture != (Object)null)
		{
			RenderTexture.active = null;
			resultTexture.Release();
			Object.DestroyImmediate((Object)(object)resultTexture);
			resultTexture = null;
		}
		if ((Object)(object)resultReadTexture != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)resultReadTexture);
			resultReadTexture = null;
		}
		if (readbackInst != IntPtr.Zero)
		{
			BufferReadback.Destroy(readbackInst);
			readbackInst = IntPtr.Zero;
		}
		if (data)
		{
			inputData = (Color[])(object)new Color[0];
			resultData = (Color32[])(object)new Color32[0];
			capacity = 0;
			count = 0;
		}
	}

	public bool CheckResize(int count, int granularity)
	{
		//IL_01b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Expected O, but got Unknown
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01cf: Expected O, but got Unknown
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Expected O, but got Unknown
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e3: Expected O, but got Unknown
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		//IL_013d: Expected O, but got Unknown
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_019a: Expected I4, but got Unknown
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024b: Unknown result type (might be due to invalid IL or missing references)
		if (count > capacity || (culling.usePixelShaderFallback && (Object)(object)resultTexture != (Object)null && !resultTexture.IsCreated()))
		{
			Dispose(data: false);
			int num = capacity;
			int num2 = count / granularity * granularity + granularity;
			if (culling.usePixelShaderFallback)
			{
				width = Mathf.CeilToInt(Mathf.Sqrt((float)num2));
				height = Mathf.CeilToInt((float)num2 / (float)width);
				inputTexture = new Texture2D(width, height, (TextureFormat)20, false, true);
				((Object)inputTexture).name = "_Input";
				((Texture)inputTexture).filterMode = (FilterMode)0;
				((Texture)inputTexture).wrapMode = (TextureWrapMode)1;
				resultTexture = new RenderTexture(width, height, 0, (RenderTextureFormat)0, (RenderTextureReadWrite)1);
				((Object)resultTexture).name = "_Result";
				((Texture)resultTexture).filterMode = (FilterMode)0;
				((Texture)resultTexture).wrapMode = (TextureWrapMode)1;
				resultTexture.useMipMap = false;
				resultTexture.Create();
				resultReadTexture = new Texture2D(width, height, (TextureFormat)5, false, true);
				((Object)resultReadTexture).name = "_ResultRead";
				((Texture)resultReadTexture).filterMode = (FilterMode)0;
				((Texture)resultReadTexture).wrapMode = (TextureWrapMode)1;
				if (!culling.useAsyncReadAPI)
				{
					readbackInst = BufferReadback.CreateForTexture(((Texture)resultTexture).GetNativeTexturePtr(), (uint)width, (uint)height, (uint)(int)resultTexture.format);
				}
				capacity = width * height;
			}
			else
			{
				inputBuffer = new ComputeBuffer(num2, 16);
				resultBuffer = new ComputeBuffer(num2, 4);
				if (!culling.useAsyncReadAPI)
				{
					uint num3 = (uint)(capacity * 4);
					readbackInst = BufferReadback.CreateForBuffer(resultBuffer.GetNativeBufferPtr(), num3);
				}
				capacity = num2;
			}
			Array.Resize(ref inputData, capacity);
			Array.Resize(ref resultData, capacity);
			Color32 val = default(Color32);
			((Color32)(ref val))..ctor(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);
			for (int i = num; i < capacity; i++)
			{
				resultData[i] = val;
			}
			this.count = count;
			return true;
		}
		return false;
	}

	public void UploadData()
	{
		if (culling.usePixelShaderFallback)
		{
			inputTexture.SetPixels(inputData);
			inputTexture.Apply();
		}
		else
		{
			inputBuffer.SetData((Array)inputData);
		}
	}

	private int AlignDispatchSize(int dispatchSize)
	{
		return (dispatchSize + 63) / 64;
	}

	public void Dispatch(int count)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		if (culling.usePixelShaderFallback)
		{
			RenderBuffer activeColorBuffer = Graphics.activeColorBuffer;
			RenderBuffer activeDepthBuffer = Graphics.activeDepthBuffer;
			culling.fallbackMat.SetTexture("_Input", (Texture)(object)inputTexture);
			Graphics.Blit((Texture)(object)inputTexture, resultTexture, culling.fallbackMat, 0);
			Graphics.SetRenderTarget(activeColorBuffer, activeDepthBuffer);
		}
		else if (inputBuffer != null)
		{
			culling.computeShader.SetBuffer(0, "_Input", inputBuffer);
			culling.computeShader.SetBuffer(0, "_Result", resultBuffer);
			culling.computeShader.Dispatch(0, AlignDispatchSize(count), 1, 1);
		}
	}

	public void IssueRead()
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_003d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		if (SafeMode)
		{
			return;
		}
		if (culling.useAsyncReadAPI)
		{
			if (asyncRequests.Count < 10)
			{
				AsyncGPUReadbackRequest item = ((!culling.usePixelShaderFallback) ? AsyncGPUReadback.Request(resultBuffer, (Action<AsyncGPUReadbackRequest>)null) : AsyncGPUReadback.Request((Texture)(object)resultTexture, 0, (Action<AsyncGPUReadbackRequest>)null));
				asyncRequests.Enqueue(item);
			}
		}
		else if (readbackInst != IntPtr.Zero)
		{
			BufferReadback.IssueRead(readbackInst);
		}
	}

	public void GetResults()
	{
		//IL_010c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_004b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0094: Unknown result type (might be due to invalid IL or missing references)
		if (resultData == null || resultData.Length == 0)
		{
			return;
		}
		if (!SafeMode)
		{
			if (culling.useAsyncReadAPI)
			{
				while (asyncRequests.Count > 0)
				{
					AsyncGPUReadbackRequest val = asyncRequests.Peek();
					if (((AsyncGPUReadbackRequest)(ref val)).hasError)
					{
						asyncRequests.Dequeue();
						continue;
					}
					if (((AsyncGPUReadbackRequest)(ref val)).done)
					{
						NativeArray<Color32> data = ((AsyncGPUReadbackRequest)(ref val)).GetData<Color32>(0);
						for (int i = 0; i < data.Length; i++)
						{
							resultData[i] = data[i];
						}
						asyncRequests.Dequeue();
						continue;
					}
					break;
				}
			}
			else if (readbackInst != IntPtr.Zero)
			{
				BufferReadback.GetData(readbackInst, ref resultData[0]);
			}
		}
		else if (culling.usePixelShaderFallback)
		{
			RenderTexture.active = resultTexture;
			resultReadTexture.ReadPixels(new Rect(0f, 0f, (float)width, (float)height), 0, 0);
			resultReadTexture.Apply();
			Array.Copy(resultReadTexture.GetPixels32(), resultData, resultData.Length);
		}
		else
		{
			resultBuffer.GetData((Array)resultData);
		}
	}
}


public delegate void OnVisibilityChanged(bool visible);


public enum DebugFilter
{
	Off,
	Dynamic,
	Static,
	Grid,
	All
}


using System;

[Flags]
public enum DebugMask
{
	Off = 0,
	Dynamic = 1,
	Static = 2,
	Grid = 4,
	All = 7
}


using System;
using UnityEngine;

[Serializable]
public class DebugSettings
{
	public bool log;

	public bool showAllVisible;

	public bool showMipChain;

	public bool showMain;

	public int showMainLod;

	public bool showFallback;

	public bool showStats;

	public bool showScreenBounds;

	public DebugMask showMask;

	public LayerMask layerFilter = LayerMask.op_Implicit(-1);
}


public class HashedPoolValue
{
	public ulong hashedPoolKey = ulong.MaxValue;

	public int hashedPoolIndex = -1;
}


using System.Collections.Generic;

public class HashedPool<ValueType> where ValueType : HashedPoolValue, new()
{
	private int granularity;

	private Dictionary<ulong, ValueType> dict;

	private List<ValueType> pool;

	private List<ValueType> list;

	private Queue<ValueType> recycled;

	public int Size => list.Count;

	public int Count => dict.Count;

	public ValueType this[int i]
	{
		get
		{
			return list[i];
		}
		set
		{
			list[i] = value;
		}
	}

	public HashedPool(int capacity, int granularity)
	{
		this.granularity = granularity;
		dict = new Dictionary<ulong, ValueType>(capacity);
		pool = new List<ValueType>(capacity);
		list = new List<ValueType>(capacity);
		recycled = new Queue<ValueType>();
	}

	public void Clear()
	{
		dict.Clear();
		pool.Clear();
		list.Clear();
		recycled.Clear();
	}

	public ValueType Add(ulong key, int capacityGranularity = 16)
	{
		ValueType val;
		if (recycled.Count > 0)
		{
			val = recycled.Dequeue();
			list[val.hashedPoolIndex] = val;
		}
		else
		{
			int count = pool.Count;
			if (count == pool.Capacity)
			{
				pool.Capacity += granularity;
			}
			val = new ValueType
			{
				hashedPoolIndex = count
			};
			pool.Add(val);
			list.Add(val);
		}
		val.hashedPoolKey = key;
		dict.Add(key, val);
		return val;
	}

	public void Remove(ValueType value)
	{
		dict.Remove(value.hashedPoolKey);
		list[value.hashedPoolIndex] = null;
		recycled.Enqueue(value);
		value.hashedPoolKey = ulong.MaxValue;
	}

	public bool TryGetValue(ulong key, out ValueType value)
	{
		return dict.TryGetValue(key, out value);
	}

	public bool ContainsKey(ulong key)
	{
		return dict.ContainsKey(key);
	}
}


using System;

public class SimpleList<T>
{
	private const int defaultCapacity = 16;

	private static readonly T[] emptyArray = new T[0];

	public T[] array;

	public int count;

	public int Count => count;

	public int Capacity
	{
		get
		{
			return array.Length;
		}
		set
		{
			if (value == array.Length)
			{
				return;
			}
			if (value > 0)
			{
				T[] destinationArray = new T[value];
				if (count > 0)
				{
					Array.Copy(array, 0, destinationArray, 0, count);
				}
				array = destinationArray;
			}
			else
			{
				array = emptyArray;
			}
		}
	}

	public T this[int index]
	{
		get
		{
			return array[index];
		}
		set
		{
			array[index] = value;
		}
	}

	public SimpleList()
	{
		array = emptyArray;
	}

	public SimpleList(int capacity)
	{
		array = ((capacity == 0) ? emptyArray : new T[capacity]);
	}

	public void Add(T item)
	{
		if (count == array.Length)
		{
			EnsureCapacity(count + 1);
		}
		array[count++] = item;
	}

	public void Clear()
	{
		if (count > 0)
		{
			Array.Clear(array, 0, count);
			count = 0;
		}
	}

	public bool Contains(T item)
	{
		for (int i = 0; i < count; i++)
		{
			if (array[i].Equals(item))
			{
				return true;
			}
		}
		return false;
	}

	public void CopyTo(T[] array)
	{
		Array.Copy(this.array, 0, array, 0, count);
	}

	public void EnsureCapacity(int min)
	{
		if (array.Length < min)
		{
			int num = ((array.Length == 0) ? 16 : (array.Length * 2));
			num = ((num < min) ? min : num);
			Capacity = num;
		}
	}
}


public class SmartListValue
{
	public int hashedListIndex = -1;
}


using System;
using System.Collections.Generic;

public class SmartList
{
	private const int defaultCapacity = 16;

	private static readonly OccludeeState[] emptyList = new OccludeeState[0];

	private static readonly int[] emptySlots = new int[0];

	private OccludeeState[] list;

	private int[] slots;

	private Queue<int> recycled;

	private int count;

	public OccludeeState[] List => list;

	public int[] Slots => slots;

	public int Size => count;

	public int Count => count - recycled.Count;

	public OccludeeState this[int i]
	{
		get
		{
			return list[i];
		}
		set
		{
			list[i] = value;
		}
	}

	public int Capacity
	{
		get
		{
			return list.Length;
		}
		set
		{
			if (value == list.Length)
			{
				return;
			}
			if (value > 0)
			{
				OccludeeState[] destinationArray = new OccludeeState[value];
				int[] destinationArray2 = new int[value];
				if (count > 0)
				{
					Array.Copy(list, destinationArray, count);
					Array.Copy(slots, destinationArray2, count);
				}
				list = destinationArray;
				slots = destinationArray2;
			}
			else
			{
				list = emptyList;
				slots = emptySlots;
			}
		}
	}

	public SmartList(int capacity)
	{
		list = new OccludeeState[capacity];
		slots = new int[capacity];
		recycled = new Queue<int>();
		count = 0;
	}

	public void Add(OccludeeState value, int capacityGranularity = 16)
	{
		int num;
		if (recycled.Count > 0)
		{
			num = recycled.Dequeue();
			list[num] = value;
			slots[num] = value.slot;
		}
		else
		{
			num = count;
			if (num == list.Length)
			{
				EnsureCapacity(count + 1);
			}
			list[num] = value;
			slots[num] = value.slot;
			count++;
		}
		value.hashedListIndex = num;
	}

	public void Remove(OccludeeState value)
	{
		int hashedListIndex = value.hashedListIndex;
		list[hashedListIndex] = null;
		slots[hashedListIndex] = -1;
		recycled.Enqueue(hashedListIndex);
		value.hashedListIndex = -1;
	}

	public bool Contains(OccludeeState value)
	{
		int hashedListIndex = value.hashedListIndex;
		if (hashedListIndex >= 0)
		{
			return list[hashedListIndex] != null;
		}
		return false;
	}

	public void EnsureCapacity(int min)
	{
		if (list.Length < min)
		{
			int num = ((list.Length == 0) ? 16 : (list.Length * 2));
			num = ((num < min) ? min : num);
			Capacity = num;
		}
	}
}


using System;
using UnityEngine;

[Serializable]
public class Cell : HashedPoolValue
{
	public int x;

	public int y;

	public int z;

	public Bounds bounds;

	public Vector4 sphereBounds;

	public bool isVisible;

	public SmartList staticBucket;

	public SmartList dynamicBucket;

	public void Reset()
	{
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		x = (y = (z = 0));
		bounds = default(Bounds);
		sphereBounds = Vector4.zero;
		isVisible = true;
		staticBucket = null;
		dynamicBucket = null;
	}

	public Cell Initialize(int x, int y, int z, Bounds bounds)
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_0018: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		this.x = x;
		this.y = y;
		this.z = z;
		this.bounds = bounds;
		float num = ((Bounds)(ref bounds)).center.x;
		float num2 = ((Bounds)(ref bounds)).center.y;
		float num3 = ((Bounds)(ref bounds)).center.z;
		Vector3 extents = ((Bounds)(ref bounds)).extents;
		sphereBounds = new Vector4(num, num2, num3, ((Vector3)(ref extents)).magnitude);
		isVisible = true;
		staticBucket = new SmartList(32);
		dynamicBucket = new SmartList(32);
		return this;
	}
}


using UnityEngine;

public struct Sphere
{
	public Vector3 position;

	public float radius;

	public bool IsValid()
	{
		return radius > 0f;
	}

	public Sphere(Vector3 position, float radius)
	{
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		this.position = position;
		this.radius = radius;
	}
}


using UnityEngine;
using UnityEngine.Rendering;

[AddComponentMenu("Image Effects/Sonic Ether/SE Screen-Space Shadows")]
[ExecuteInEditMode]
[RequireComponent(typeof(Camera))]
public class SEScreenSpaceShadows : SingletonComponent<SEScreenSpaceShadows>, IClientComponent
{
	private CommandBuffer blendShadowsCommandBuffer;

	private CommandBuffer renderShadowsCommandBuffer;

	private Camera attachedCamera;

	public Light sun;

	[Range(0f, 1f)]
	public float blendStrength = 1f;

	[Range(0f, 1f)]
	public float accumulation = 0.9f;

	[Range(0.1f, 5f)]
	public float lengthFade = 0.7f;

	[Range(0.01f, 5f)]
	public float range = 0.7f;

	[Range(0f, 1f)]
	public float zThickness = 0.1f;

	[Range(2f, 92f)]
	public int samples = 32;

	[Range(0.5f, 4f)]
	public float nearSampleQuality = 1.5f;

	[Range(0f, 1f)]
	public float traceBias = 0.03f;

	public bool stochasticSampling = true;

	public bool leverageTemporalAA;

	public bool bilateralBlur = true;

	[Range(1f, 2f)]
	public int blurPasses = 1;

	[Range(0.01f, 0.5f)]
	public float blurDepthTolerance = 0.1f;
}


using UnityEngine;

public class VTP : MonoBehaviour
{
	public static Color getSingleVertexColorAtHit(Transform transform, RaycastHit hit)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i++)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		return colors[num2];
	}

	public static Color getFaceVerticesColorAtHit(Transform transform, RaycastHit hit)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0039: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = triangles[triangleIndex * 3];
		return (colors[num] + colors[num + 1] + colors[num + 2]) / 3f;
	}

	public static void paintSingleVertexOnHit(Transform transform, RaycastHit hit, Color color, float strength)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_008e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009a: Unknown result type (might be due to invalid IL or missing references)
		//IL_009f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i += 3)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		Color val = VertexColorLerp(colors[num2], color, strength);
		colors[num2] = val;
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors = colors;
	}

	public static void paintFaceVerticesOnHit(Transform transform, RaycastHit hit, Color color, float strength)
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0043: Unknown result type (might be due to invalid IL or missing references)
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Color[] colors = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = 0;
		for (int i = 0; i < 3; i++)
		{
			num = triangles[triangleIndex * 3 + i];
			Color val = VertexColorLerp(colors[num], color, strength);
			colors[num] = val;
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.colors = colors;
	}

	public static void deformSingleVertexOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
	{
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_0059: Unknown result type (might be due to invalid IL or missing references)
		//IL_0060: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ba: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bf: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Vector3[] normals = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.normals;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		float num = float.PositiveInfinity;
		int num2 = 0;
		for (int i = 0; i < 3; i++)
		{
			float num3 = Vector3.Distance(transform.TransformPoint(vertices[triangles[triangleIndex * 3 + i]]), ((RaycastHit)(ref hit)).point);
			if (num3 < num)
			{
				num2 = triangles[triangleIndex * 3 + i];
				num = num3;
			}
		}
		int num4 = 1;
		if (!up)
		{
			num4 = -1;
		}
		ref Vector3 reference = ref vertices[num2];
		reference += (float)num4 * 0.1f * strength * normals[num2];
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices = vertices;
		if (recalculateNormals)
		{
			((Component)transform).GetComponent<MeshFilter>().sharedMesh.RecalculateNormals();
		}
		if (recalculateCollider)
		{
			((Component)transform).GetComponent<MeshCollider>().sharedMesh = ((Component)transform).GetComponent<MeshFilter>().sharedMesh;
		}
		if (recalculateFlow)
		{
			Vector4[] array = calculateMeshTangents(triangles, vertices, ((Component)transform).GetComponent<MeshCollider>().sharedMesh.uv, normals);
			((Component)transform).GetComponent<MeshCollider>().sharedMesh.tangents = array;
			recalculateMeshForFlow(transform, vertices, normals, array);
		}
	}

	public static void deformFaceVerticesOnHit(Transform transform, RaycastHit hit, bool up, float strength, bool recalculateNormals, bool recalculateCollider, bool recalculateFlow)
	{
		//IL_005f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0072: Unknown result type (might be due to invalid IL or missing references)
		//IL_0077: Unknown result type (might be due to invalid IL or missing references)
		//IL_007c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0081: Unknown result type (might be due to invalid IL or missing references)
		Vector3[] vertices = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices;
		int[] triangles = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.triangles;
		Vector3[] normals = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.normals;
		int triangleIndex = ((RaycastHit)(ref hit)).triangleIndex;
		int num = 0;
		int num2 = 1;
		if (!up)
		{
			num2 = -1;
		}
		for (int i = 0; i < 3; i++)
		{
			num = triangles[triangleIndex * 3 + i];
			ref Vector3 reference = ref vertices[num];
			reference += (float)num2 * 0.1f * strength * normals[num];
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.vertices = vertices;
		if (recalculateNormals)
		{
			((Component)transform).GetComponent<MeshFilter>().sharedMesh.RecalculateNormals();
		}
		if (recalculateCollider)
		{
			((Component)transform).GetComponent<MeshCollider>().sharedMesh = ((Component)transform).GetComponent<MeshFilter>().sharedMesh;
		}
		if (recalculateFlow)
		{
			Vector4[] array = calculateMeshTangents(triangles, vertices, ((Component)transform).GetComponent<MeshCollider>().sharedMesh.uv, normals);
			((Component)transform).GetComponent<MeshCollider>().sharedMesh.tangents = array;
			recalculateMeshForFlow(transform, vertices, normals, array);
		}
	}

	private static void recalculateMeshForFlow(Transform transform, Vector3[] currentVertices, Vector3[] currentNormals, Vector4[] currentTangents)
	{
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0052: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0080: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		Vector2[] uv = ((Component)transform).GetComponent<MeshFilter>().sharedMesh.uv4;
		for (int i = 0; i < currentVertices.Length; i++)
		{
			Vector3 val = Vector3.Cross(currentNormals[i], new Vector3(currentTangents[i].x, currentTangents[i].y, currentTangents[i].z));
			Vector3 val2 = transform.TransformDirection(((Vector3)(ref val)).normalized * currentTangents[i].w);
			Vector3 val3 = transform.TransformDirection(Vector4.op_Implicit(((Vector4)(ref currentTangents[i])).normalized));
			float num = 0.5f + 0.5f * val3.y;
			float num2 = 0.5f + 0.5f * val2.y;
			uv[i] = new Vector2(num, num2);
		}
		((Component)transform).GetComponent<MeshFilter>().sharedMesh.uv4 = uv;
	}

	private static Vector4[] calculateMeshTangents(int[] triangles, Vector3[] vertices, Vector2[] uv, Vector3[] normals)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0054: Unknown result type (might be due to invalid IL or missing references)
		//IL_005d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_0068: Unknown result type (might be due to invalid IL or missing references)
		//IL_006d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0073: Unknown result type (might be due to invalid IL or missing references)
		//IL_0078: Unknown result type (might be due to invalid IL or missing references)
		//IL_007e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0083: Unknown result type (might be due to invalid IL or missing references)
		//IL_0085: Unknown result type (might be due to invalid IL or missing references)
		//IL_008b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ff: Unknown result type (might be due to invalid IL or missing references)
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_0110: Unknown result type (might be due to invalid IL or missing references)
		//IL_011a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0121: Unknown result type (might be due to invalid IL or missing references)
		//IL_01be: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01de: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e0: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fb: Unknown result type (might be due to invalid IL or missing references)
		//IL_0200: Unknown result type (might be due to invalid IL or missing references)
		//IL_020f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0214: Unknown result type (might be due to invalid IL or missing references)
		//IL_0216: Unknown result type (might be due to invalid IL or missing references)
		//IL_021b: Unknown result type (might be due to invalid IL or missing references)
		//IL_022a: Unknown result type (might be due to invalid IL or missing references)
		//IL_022f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0231: Unknown result type (might be due to invalid IL or missing references)
		//IL_0236: Unknown result type (might be due to invalid IL or missing references)
		//IL_0245: Unknown result type (might be due to invalid IL or missing references)
		//IL_024a: Unknown result type (might be due to invalid IL or missing references)
		//IL_024c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0251: Unknown result type (might be due to invalid IL or missing references)
		//IL_0273: Unknown result type (might be due to invalid IL or missing references)
		//IL_0278: Unknown result type (might be due to invalid IL or missing references)
		//IL_027e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0283: Unknown result type (might be due to invalid IL or missing references)
		//IL_0298: Unknown result type (might be due to invalid IL or missing references)
		//IL_02ae: Unknown result type (might be due to invalid IL or missing references)
		//IL_02c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_02da: Unknown result type (might be due to invalid IL or missing references)
		//IL_02dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_02de: Unknown result type (might be due to invalid IL or missing references)
		//IL_02e7: Unknown result type (might be due to invalid IL or missing references)
		int num = triangles.Length;
		int num2 = vertices.Length;
		Vector3[] array = (Vector3[])(object)new Vector3[num2];
		Vector3[] array2 = (Vector3[])(object)new Vector3[num2];
		Vector4[] array3 = (Vector4[])(object)new Vector4[num2];
		Vector3 val7 = default(Vector3);
		Vector3 val8 = default(Vector3);
		for (long num3 = 0L; num3 < num; num3 += 3)
		{
			long num4 = triangles[num3];
			long num5 = triangles[num3 + 1];
			long num6 = triangles[num3 + 2];
			Vector3 val = vertices[num4];
			Vector3 val2 = vertices[num5];
			Vector3 val3 = vertices[num6];
			Vector2 val4 = uv[num4];
			Vector2 val5 = uv[num5];
			Vector2 val6 = uv[num6];
			float num7 = val2.x - val.x;
			float num8 = val3.x - val.x;
			float num9 = val2.y - val.y;
			float num10 = val3.y - val.y;
			float num11 = val2.z - val.z;
			float num12 = val3.z - val.z;
			float num13 = val5.x - val4.x;
			float num14 = val6.x - val4.x;
			float num15 = val5.y - val4.y;
			float num16 = val6.y - val4.y;
			float num17 = num13 * num16 - num14 * num15;
			float num18 = ((num17 == 0f) ? 0f : (1f / num17));
			((Vector3)(ref val7))..ctor((num16 * num7 - num15 * num8) * num18, (num16 * num9 - num15 * num10) * num18, (num16 * num11 - num15 * num12) * num18);
			((Vector3)(ref val8))..ctor((num13 * num8 - num14 * num7) * num18, (num13 * num10 - num14 * num9) * num18, (num13 * num12 - num14 * num11) * num18);
			ref Vector3 reference = ref array[num4];
			reference += val7;
			ref Vector3 reference2 = ref array[num5];
			reference2 += val7;
			ref Vector3 reference3 = ref array[num6];
			reference3 += val7;
			ref Vector3 reference4 = ref array2[num4];
			reference4 += val8;
			ref Vector3 reference5 = ref array2[num5];
			reference5 += val8;
			ref Vector3 reference6 = ref array2[num6];
			reference6 += val8;
		}
		for (long num19 = 0L; num19 < num2; num19++)
		{
			Vector3 val9 = normals[num19];
			Vector3 val10 = array[num19];
			Vector3.OrthoNormalize(ref val9, ref val10);
			array3[num19].x = val10.x;
			array3[num19].y = val10.y;
			array3[num19].z = val10.z;
			array3[num19].w = ((Vector3.Dot(Vector3.Cross(val9, val10), array2[num19]) < 0f) ? (-1f) : 1f);
		}
		return array3;
	}

	public static Color VertexColorLerp(Color colorA, Color colorB, float value)
	{
		//IL_0008: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		//IL_002a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_004c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		//IL_005c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0062: Unknown result type (might be due to invalid IL or missing references)
		//IL_006c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		if (value >= 1f)
		{
			return colorB;
		}
		if (value <= 0f)
		{
			return colorA;
		}
		return new Color(colorA.r + (colorB.r - colorA.r) * value, colorA.g + (colorB.g - colorA.g) * value, colorA.b + (colorB.b - colorA.b) * value, colorA.a + (colorB.a - colorA.a) * value);
	}
}


using System;
using UnityEngine;

[Serializable]
public class MeshHolder
{
	[HideInInspector]
	public Vector3[] _vertices;

	[HideInInspector]
	public Vector3[] _normals;

	[HideInInspector]
	public int[] _triangles;

	[HideInInspector]
	public trisPerSubmesh[] _TrianglesOfSubs;

	[HideInInspector]
	public Matrix4x4[] _bindPoses;

	[HideInInspector]
	public BoneWeight[] _boneWeights;

	[HideInInspector]
	public Bounds _bounds;

	[HideInInspector]
	public int _subMeshCount;

	[HideInInspector]
	public Vector4[] _tangents;

	[HideInInspector]
	public Vector2[] _uv;

	[HideInInspector]
	public Vector2[] _uv2;

	[HideInInspector]
	public Vector2[] _uv3;

	[HideInInspector]
	public Color[] _colors;

	[HideInInspector]
	public Vector2[] _uv4;

	public void setAnimationData(Mesh mesh)
	{
		_colors = mesh.colors;
	}
}


using System;

[Serializable]
public class trisPerSubmesh
{
	public int[] triangles;
}


using System.Collections.Generic;
using UnityEngine;

public class VertexColorAnimator : MonoBehaviour
{
	public List<MeshHolder> animationMeshes;

	public List<float> animationKeyframes;

	public float timeScale = 2f;

	public int mode;

	private float elapsedTime;

	public void initLists()
	{
		animationMeshes = new List<MeshHolder>();
		animationKeyframes = new List<float>();
	}

	public void addMesh(Mesh mesh, float atPosition)
	{
		MeshHolder meshHolder = new MeshHolder();
		meshHolder.setAnimationData(mesh);
		animationMeshes.Add(meshHolder);
		animationKeyframes.Add(atPosition);
	}

	private void Start()
	{
		elapsedTime = 0f;
	}

	public void replaceKeyframe(int frameIndex, Mesh mesh)
	{
		animationMeshes[frameIndex].setAnimationData(mesh);
	}

	public void deleteKeyframe(int frameIndex)
	{
		animationMeshes.RemoveAt(frameIndex);
		animationKeyframes.RemoveAt(frameIndex);
	}

	public void scrobble(float scrobblePos)
	{
		//IL_00cd: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ee: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f3: Unknown result type (might be due to invalid IL or missing references)
		if (animationMeshes.Count == 0)
		{
			return;
		}
		Color[] array = (Color[])(object)new Color[((Component)this).GetComponent<MeshFilter>().sharedMesh.colors.Length];
		int num = 0;
		for (int i = 0; i < animationKeyframes.Count; i++)
		{
			if (scrobblePos >= animationKeyframes[i])
			{
				num = i;
			}
		}
		if (num >= animationKeyframes.Count - 1)
		{
			((Component)this).GetComponent<VertexColorStream>().setColors(animationMeshes[num]._colors);
			return;
		}
		float num2 = animationKeyframes[num + 1] - animationKeyframes[num];
		float num3 = animationKeyframes[num];
		float num4 = (scrobblePos - num3) / num2;
		for (int j = 0; j < array.Length; j++)
		{
			array[j] = Color.Lerp(animationMeshes[num]._colors[j], animationMeshes[num + 1]._colors[j], num4);
		}
		((Component)this).GetComponent<VertexColorStream>().setColors(array);
	}

	private void Update()
	{
		//IL_015f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0179: Unknown result type (might be due to invalid IL or missing references)
		//IL_0180: Unknown result type (might be due to invalid IL or missing references)
		//IL_0185: Unknown result type (might be due to invalid IL or missing references)
		if (mode == 0)
		{
			elapsedTime += Time.fixedDeltaTime / timeScale;
		}
		else if (mode == 1)
		{
			elapsedTime += Time.fixedDeltaTime / timeScale;
			if (elapsedTime > 1f)
			{
				elapsedTime = 0f;
			}
		}
		else if (mode == 2)
		{
			if (Mathf.FloorToInt(Time.fixedTime / timeScale) % 2 == 0)
			{
				elapsedTime += Time.fixedDeltaTime / timeScale;
			}
			else
			{
				elapsedTime -= Time.fixedDeltaTime / timeScale;
			}
		}
		Color[] array = (Color[])(object)new Color[((Component)this).GetComponent<MeshFilter>().sharedMesh.colors.Length];
		int num = 0;
		for (int i = 0; i < animationKeyframes.Count; i++)
		{
			if (elapsedTime >= animationKeyframes[i])
			{
				num = i;
			}
		}
		if (num < animationKeyframes.Count - 1)
		{
			float num2 = animationKeyframes[num + 1] - animationKeyframes[num];
			float num3 = animationKeyframes[num];
			float num4 = (elapsedTime - num3) / num2;
			for (int j = 0; j < array.Length; j++)
			{
				array[j] = Color.Lerp(animationMeshes[num]._colors[j], animationMeshes[num + 1]._colors[j], num4);
			}
		}
		else
		{
			array = animationMeshes[num]._colors;
		}
		((Component)this).GetComponent<VertexColorStream>().setColors(array);
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class VertexColorStream : MonoBehaviour
{
	[HideInInspector]
	public Mesh originalMesh;

	[HideInInspector]
	public Mesh paintedMesh;

	[HideInInspector]
	public MeshHolder meshHold;

	[HideInInspector]
	public Vector3[] _vertices;

	[HideInInspector]
	public Vector3[] _normals;

	[HideInInspector]
	public int[] _triangles;

	[HideInInspector]
	public int[][] _Subtriangles;

	[HideInInspector]
	public Matrix4x4[] _bindPoses;

	[HideInInspector]
	public BoneWeight[] _boneWeights;

	[HideInInspector]
	public Bounds _bounds;

	[HideInInspector]
	public int _subMeshCount;

	[HideInInspector]
	public Vector4[] _tangents;

	[HideInInspector]
	public Vector2[] _uv;

	[HideInInspector]
	public Vector2[] _uv2;

	[HideInInspector]
	public Vector2[] _uv3;

	[HideInInspector]
	public Color[] _colors;

	[HideInInspector]
	public Vector2[] _uv4;

	private void OnDidApplyAnimationProperties()
	{
	}

	public void init(Mesh origMesh, bool destroyOld)
	{
		//IL_012e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0133: Unknown result type (might be due to invalid IL or missing references)
		originalMesh = origMesh;
		paintedMesh = Object.Instantiate<Mesh>(origMesh);
		if (destroyOld)
		{
			Object.DestroyImmediate((Object)(object)origMesh);
		}
		((Object)paintedMesh).hideFlags = (HideFlags)0;
		((Object)paintedMesh).name = "vpp_" + ((Object)((Component)this).gameObject).name;
		meshHold = new MeshHolder();
		meshHold._vertices = paintedMesh.vertices;
		meshHold._normals = paintedMesh.normals;
		meshHold._triangles = paintedMesh.triangles;
		meshHold._TrianglesOfSubs = new trisPerSubmesh[paintedMesh.subMeshCount];
		for (int i = 0; i < paintedMesh.subMeshCount; i++)
		{
			meshHold._TrianglesOfSubs[i] = new trisPerSubmesh();
			meshHold._TrianglesOfSubs[i].triangles = paintedMesh.GetTriangles(i);
		}
		meshHold._bindPoses = paintedMesh.bindposes;
		meshHold._boneWeights = paintedMesh.boneWeights;
		meshHold._bounds = paintedMesh.bounds;
		meshHold._subMeshCount = paintedMesh.subMeshCount;
		meshHold._tangents = paintedMesh.tangents;
		meshHold._uv = paintedMesh.uv;
		meshHold._uv2 = paintedMesh.uv2;
		meshHold._uv3 = paintedMesh.uv3;
		meshHold._colors = paintedMesh.colors;
		meshHold._uv4 = paintedMesh.uv4;
		((Component)this).GetComponent<MeshFilter>().sharedMesh = paintedMesh;
		if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshCollider>()))
		{
			((Component)this).GetComponent<MeshCollider>().sharedMesh = paintedMesh;
		}
	}

	public void setWholeMesh(Mesh tmpMesh)
	{
		paintedMesh.vertices = tmpMesh.vertices;
		paintedMesh.triangles = tmpMesh.triangles;
		paintedMesh.normals = tmpMesh.normals;
		paintedMesh.colors = tmpMesh.colors;
		paintedMesh.uv = tmpMesh.uv;
		paintedMesh.uv2 = tmpMesh.uv2;
		paintedMesh.uv3 = tmpMesh.uv3;
		meshHold._vertices = tmpMesh.vertices;
		meshHold._triangles = tmpMesh.triangles;
		meshHold._normals = tmpMesh.normals;
		meshHold._colors = tmpMesh.colors;
		meshHold._uv = tmpMesh.uv;
		meshHold._uv2 = tmpMesh.uv2;
		meshHold._uv3 = tmpMesh.uv3;
	}

	public Vector3[] setVertices(Vector3[] _deformedVertices)
	{
		//IL_0050: Unknown result type (might be due to invalid IL or missing references)
		//IL_0055: Unknown result type (might be due to invalid IL or missing references)
		paintedMesh.vertices = _deformedVertices;
		meshHold._vertices = _deformedVertices;
		paintedMesh.RecalculateNormals();
		paintedMesh.RecalculateBounds();
		meshHold._normals = paintedMesh.normals;
		meshHold._bounds = paintedMesh.bounds;
		((Component)this).GetComponent<MeshCollider>().sharedMesh = null;
		if (Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshCollider>()))
		{
			((Component)this).GetComponent<MeshCollider>().sharedMesh = paintedMesh;
		}
		return meshHold._normals;
	}

	public Vector3[] getVertices()
	{
		return paintedMesh.vertices;
	}

	public Vector3[] getNormals()
	{
		return paintedMesh.normals;
	}

	public int[] getTriangles()
	{
		return paintedMesh.triangles;
	}

	public void setTangents(Vector4[] _meshTangents)
	{
		paintedMesh.tangents = _meshTangents;
		meshHold._tangents = _meshTangents;
	}

	public Vector4[] getTangents()
	{
		return paintedMesh.tangents;
	}

	public void setColors(Color[] _vertexColors)
	{
		paintedMesh.colors = _vertexColors;
		meshHold._colors = _vertexColors;
	}

	public Color[] getColors()
	{
		return paintedMesh.colors;
	}

	public Vector2[] getUVs()
	{
		return paintedMesh.uv;
	}

	public void setUV4s(Vector2[] _uv4s)
	{
		paintedMesh.uv4 = _uv4s;
		meshHold._uv4 = _uv4s;
	}

	public Vector2[] getUV4s()
	{
		return paintedMesh.uv4;
	}

	public void unlink()
	{
		init(paintedMesh, destroyOld: false);
	}

	public void rebuild()
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0019: Expected O, but got Unknown
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0267: Unknown result type (might be due to invalid IL or missing references)
		if (!Object.op_Implicit((Object)(object)((Component)this).GetComponent<MeshFilter>()))
		{
			return;
		}
		paintedMesh = new Mesh();
		((Object)paintedMesh).hideFlags = (HideFlags)61;
		((Object)paintedMesh).name = "vpp_" + ((Object)((Component)this).gameObject).name;
		if (meshHold == null || meshHold._vertices.Length == 0 || meshHold._TrianglesOfSubs.Length == 0)
		{
			paintedMesh.subMeshCount = _subMeshCount;
			paintedMesh.vertices = _vertices;
			paintedMesh.normals = _normals;
			paintedMesh.triangles = _triangles;
			meshHold._TrianglesOfSubs = new trisPerSubmesh[paintedMesh.subMeshCount];
			for (int i = 0; i < paintedMesh.subMeshCount; i++)
			{
				meshHold._TrianglesOfSubs[i] = new trisPerSubmesh();
				meshHold._TrianglesOfSubs[i].triangles = paintedMesh.GetTriangles(i);
			}
			paintedMesh.bindposes = _bindPoses;
			paintedMesh.boneWeights = _boneWeights;
			paintedMesh.bounds = _bounds;
			paintedMesh.tangents = _tangents;
			paintedMesh.uv = _uv;
			paintedMesh.uv2 = _uv2;
			paintedMesh.uv3 = _uv3;
			paintedMesh.colors = _colors;
			paintedMesh.uv4 = _uv4;
			init(paintedMesh, destroyOld: true);
		}
		else
		{
			paintedMesh.subMeshCount = meshHold._subMeshCount;
			paintedMesh.vertices = meshHold._vertices;
			paintedMesh.normals = meshHold._normals;
			for (int j = 0; j < meshHold._subMeshCount; j++)
			{
				paintedMesh.SetTriangles(meshHold._TrianglesOfSubs[j].triangles, j);
			}
			paintedMesh.bindposes = meshHold._bindPoses;
			paintedMesh.boneWeights = meshHold._boneWeights;
			paintedMesh.bounds = meshHold._bounds;
			paintedMesh.tangents = meshHold._tangents;
			paintedMesh.uv = meshHold._uv;
			paintedMesh.uv2 = meshHold._uv2;
			paintedMesh.uv3 = meshHold._uv3;
			paintedMesh.colors = meshHold._colors;
			paintedMesh.uv4 = meshHold._uv4;
			init(paintedMesh, destroyOld: true);
		}
	}

	private void Start()
	{
		if (!Object.op_Implicit((Object)(object)paintedMesh) || meshHold == null)
		{
			rebuild();
		}
	}
}


using UnityEngine;

[ExecuteInEditMode]
public class VertexStreamChildrenRebuilder : MonoBehaviour
{
}


using System;
using UnityEngine;

[ImageEffectAllowedInSceneView]
[AddComponentMenu("Rendering/Visualize Texture Density")]
[ExecuteInEditMode]
public class VisualizeTexelDensity : MonoBehaviour
{
	public Shader shader;

	public string shaderTag = "RenderType";

	[Range(1f, 1024f)]
	public int texelsPerMeter = 256;

	[Range(0f, 1f)]
	public float overlayOpacity = 0.5f;

	public bool showHUD = true;

	private Camera mainCamera;

	private bool initialized;

	private int screenWidth;

	private int screenHeight;

	private Camera texelDensityCamera;

	private RenderTexture texelDensityRT;

	private Texture texelDensityGradTex;

	private Material texelDensityOverlayMat;

	private static VisualizeTexelDensity instance;

	public static VisualizeTexelDensity Instance => instance;

	private void Awake()
	{
		instance = this;
		mainCamera = ((Component)this).GetComponent<Camera>();
	}

	private void OnEnable()
	{
		mainCamera = ((Component)this).GetComponent<Camera>();
		screenWidth = Screen.width;
		screenHeight = Screen.height;
		LoadResources();
		initialized = true;
	}

	private void OnDisable()
	{
		SafeDestroyViewTexelDensity();
		SafeDestroyViewTexelDensityRT();
		initialized = false;
	}

	private void LoadResources()
	{
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Expected O, but got Unknown
		if ((Object)(object)texelDensityGradTex == (Object)null)
		{
			ref Texture reference = ref texelDensityGradTex;
			Object obj = Resources.Load("TexelDensityGrad");
			reference = (Texture)(object)((obj is Texture) ? obj : null);
		}
		if ((Object)(object)texelDensityOverlayMat == (Object)null)
		{
			texelDensityOverlayMat = new Material(Shader.Find("Hidden/TexelDensityOverlay"))
			{
				hideFlags = (HideFlags)52
			};
		}
	}

	private void SafeDestroyViewTexelDensity()
	{
		if ((Object)(object)texelDensityCamera != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)((Component)texelDensityCamera).gameObject);
			texelDensityCamera = null;
		}
		if ((Object)(object)texelDensityGradTex != (Object)null)
		{
			Resources.UnloadAsset((Object)(object)texelDensityGradTex);
			texelDensityGradTex = null;
		}
		if ((Object)(object)texelDensityOverlayMat != (Object)null)
		{
			Object.DestroyImmediate((Object)(object)texelDensityOverlayMat);
			texelDensityOverlayMat = null;
		}
	}

	private void SafeDestroyViewTexelDensityRT()
	{
		if ((Object)(object)texelDensityRT != (Object)null)
		{
			Graphics.SetRenderTarget((RenderTexture)null);
			texelDensityRT.Release();
			Object.DestroyImmediate((Object)(object)texelDensityRT);
			texelDensityRT = null;
		}
	}

	private void UpdateViewTexelDensity(bool screenResized)
	{
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0037: Expected O, but got Unknown
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_0063: Unknown result type (might be due to invalid IL or missing references)
		//IL_0128: Unknown result type (might be due to invalid IL or missing references)
		//IL_012d: Unknown result type (might be due to invalid IL or missing references)
		//IL_013a: Expected O, but got Unknown
		if ((Object)(object)texelDensityCamera == (Object)null)
		{
			GameObject val = new GameObject("Texel Density Camera", new Type[1] { typeof(Camera) })
			{
				hideFlags = (HideFlags)61
			};
			val.transform.parent = ((Component)mainCamera).transform;
			val.transform.localPosition = Vector3.zero;
			val.transform.localRotation = Quaternion.identity;
			texelDensityCamera = val.GetComponent<Camera>();
			texelDensityCamera.CopyFrom(mainCamera);
			texelDensityCamera.renderingPath = (RenderingPath)1;
			texelDensityCamera.allowMSAA = false;
			texelDensityCamera.allowHDR = false;
			texelDensityCamera.clearFlags = (CameraClearFlags)1;
			texelDensityCamera.depthTextureMode = (DepthTextureMode)0;
			texelDensityCamera.SetReplacementShader(shader, shaderTag);
			((Behaviour)texelDensityCamera).enabled = false;
		}
		if ((Object)(object)texelDensityRT == (Object)null || screenResized || !texelDensityRT.IsCreated())
		{
			texelDensityCamera.targetTexture = null;
			SafeDestroyViewTexelDensityRT();
			texelDensityRT = new RenderTexture(screenWidth, screenHeight, 24, (RenderTextureFormat)0)
			{
				hideFlags = (HideFlags)52
			};
			((Object)texelDensityRT).name = "TexelDensityRT";
			((Texture)texelDensityRT).filterMode = (FilterMode)0;
			((Texture)texelDensityRT).wrapMode = (TextureWrapMode)1;
			texelDensityRT.Create();
		}
		if ((Object)(object)texelDensityCamera.targetTexture != (Object)(object)texelDensityRT)
		{
			texelDensityCamera.targetTexture = texelDensityRT;
		}
		Shader.SetGlobalFloat("global_TexelsPerMeter", (float)texelsPerMeter);
		Shader.SetGlobalTexture("global_TexelDensityGrad", texelDensityGradTex);
		texelDensityCamera.fieldOfView = mainCamera.fieldOfView;
		texelDensityCamera.nearClipPlane = mainCamera.nearClipPlane;
		texelDensityCamera.farClipPlane = mainCamera.farClipPlane;
		texelDensityCamera.cullingMask = mainCamera.cullingMask;
	}

	private bool CheckScreenResized(int width, int height)
	{
		if (screenWidth != width || screenHeight != height)
		{
			screenWidth = width;
			screenHeight = height;
			return true;
		}
		return false;
	}

	private void OnPreCull()
	{
		if ((Object)(object)texelDensityCamera != (Object)null)
		{
			texelDensityCamera.Render();
		}
	}

	private void OnRenderImage(RenderTexture source, RenderTexture destination)
	{
		if (initialized)
		{
			UpdateViewTexelDensity(CheckScreenResized(((Texture)source).width, ((Texture)source).height));
			texelDensityOverlayMat.SetTexture("_TexelDensityMap", (Texture)(object)texelDensityRT);
			texelDensityOverlayMat.SetFloat("_Opacity", overlayOpacity);
			Graphics.Blit((Texture)(object)source, destination, texelDensityOverlayMat, 0);
		}
		else
		{
			Graphics.Blit((Texture)(object)source, destination);
		}
	}

	private void DrawGUIText(float x, float y, Vector2 size, string text, GUIStyle fontStyle)
	{
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0025: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0053: Unknown result type (might be due to invalid IL or missing references)
		//IL_006f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0097: Unknown result type (might be due to invalid IL or missing references)
		//IL_009d: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ca: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		fontStyle.normal.textColor = Color.black;
		GUI.Label(new Rect(x - 1f, y + 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x + 1f, y - 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x + 1f, y + 1f, size.x, size.y), text, fontStyle);
		GUI.Label(new Rect(x - 1f, y - 1f, size.x, size.y), text, fontStyle);
		fontStyle.normal.textColor = Color.white;
		GUI.Label(new Rect(x, y, size.x, size.y), text, fontStyle);
	}

	private void OnGUI()
	{
		//IL_00c5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f1: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f8: Expected O, but got Unknown
		//IL_0104: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Expected O, but got Unknown
		//IL_0109: Unknown result type (might be due to invalid IL or missing references)
		//IL_010e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0113: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Expected O, but got Unknown
		//IL_0118: Unknown result type (might be due to invalid IL or missing references)
		//IL_011d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0122: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Expected O, but got Unknown
		//IL_0127: Unknown result type (might be due to invalid IL or missing references)
		//IL_012c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0131: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Expected O, but got Unknown
		//IL_0136: Unknown result type (might be due to invalid IL or missing references)
		//IL_013b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0144: Unknown result type (might be due to invalid IL or missing references)
		//IL_0154: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		//IL_017a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018b: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		if (initialized && showHUD)
		{
			string text = "Texels Per Meter";
			string text2 = "0";
			string text3 = texelsPerMeter.ToString();
			string text4 = (texelsPerMeter << 1) + "+";
			float num = texelDensityGradTex.width;
			float num2 = texelDensityGradTex.height * 2;
			float num3 = (Screen.width - texelDensityGradTex.width) / 2;
			float num4 = 32f;
			GL.PushMatrix();
			GL.LoadPixelMatrix(0f, (float)Screen.width, (float)Screen.height, 0f);
			Graphics.DrawTexture(new Rect(num3 - 2f, num4 - 2f, num + 4f, num2 + 4f), (Texture)(object)Texture2D.whiteTexture);
			Graphics.DrawTexture(new Rect(num3, num4, num, num2), texelDensityGradTex);
			GL.PopMatrix();
			GUIStyle val = new GUIStyle();
			val.fontSize = 13;
			Vector2 val2 = val.CalcSize(new GUIContent(text));
			Vector2 size = val.CalcSize(new GUIContent(text2));
			Vector2 val3 = val.CalcSize(new GUIContent(text3));
			Vector2 val4 = val.CalcSize(new GUIContent(text4));
			DrawGUIText(((float)Screen.width - val2.x) / 2f, num4 - val2.y - 5f, val2, text, val);
			DrawGUIText(num3, num4 + num2 + 6f, size, text2, val);
			DrawGUIText(((float)Screen.width - val3.x) / 2f, num4 + num2 + 6f, val3, text3, val);
			DrawGUIText(num3 + num - val4.x, num4 + num2 + 6f, val4, text4, val);
		}
	}
}


using System;
using Facepunch;
using UnityEngine;

public class ViewmodelClothing : MonoBehaviour
{
	[Flags]
	public enum SkinArea
	{
		Arms = 1,
		Hands = 2
	}

	public enum Slot
	{
		Under,
		Over
	}

	public SkeletonSkin[] SkeletonSkins;

	public bool DisableHandsEntirely;

	[Header("Conditional Logic")]
	public bool isConditional;

	[Tooltip("This is the slot the clothing will fit into. Over clothing will use MaxSkins when on top of under clothing.")]
	public Slot ClothingSlot;

	[Tooltip("A mask to allow multiple over clothing on the same model, but affecting different areas.")]
	public SkinArea AreasCovered = SkinArea.Arms | SkinArea.Hands;

	[Tooltip("Max Skins are the skins displayed if clothing is on top.")]
	public SkeletonSkin[] MaxSkin;
}


using System;

[Flags]
public enum SkinArea
{
	Arms = 1,
	Hands = 2
}


public enum Slot
{
	Under,
	Over
}


using UnityEngine;

public class WorkshopIconRender : MonoBehaviour
{
	public int MinimumId;

	public int MaximumId = -1;
}


