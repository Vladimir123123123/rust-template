using System;
using UnityEngine;
using UnityEngine.AI;

public static class NavMeshPathEx
{
	private static Vector3[] cornersBuffer = (Vector3[])(object)new Vector3[128];

	public static float GetPathLength(this NavMeshPath path)
	{
		//IL_0033: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetPathLength", 0);
		try
		{
			float num = 0f;
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 2)
			{
				return num;
			}
			for (int i = 0; i < cornersNonAlloc - 1; i++)
			{
				num += Vector3.Distance(cornersBuffer[i], cornersBuffer[i + 1]);
			}
			return num;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetOrigin(this NavMeshPath path)
	{
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetOrigin", 0);
		try
		{
			if (path.GetCornersNonAlloc(cornersBuffer) < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[0];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public static Vector3 GetDestination(this NavMeshPath path)
	{
		//IL_002c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0031: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_003e: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("GetDestination", 0);
		try
		{
			int cornersNonAlloc = path.GetCornersNonAlloc(cornersBuffer);
			if (cornersNonAlloc < 1)
			{
				return Vector3.zero;
			}
			return cornersBuffer[cornersNonAlloc - 1];
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}
}


using ConVar;
using Rust;
using UnityEngine;

public class BaseNPC2 : BaseCombatEntity
{
	[SerializeField]
	private float mass = 45f;

	public override bool IsNpc => true;

	public bool IsAnimal => true;

	public override float RealisticMass => mass;

	public string displayName
	{
		get
		{
			PrefabInformation prefabInformation = null;
			if (base.isServer)
			{
				prefabInformation = PrefabAttribute.server.Find<PrefabInformation>(prefabID);
			}
			if (prefabInformation == null)
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)("PrefabInformation not found for " + Categorize() + ")"));
				}
				return "NPC";
			}
			return prefabInformation.title.english;
		}
	}

	public override float MaxVelocity()
	{
		return 10f;
	}

	public override void InitShared()
	{
		base.InitShared();
		if (base.isServer)
		{
			Query.Server.AddBrain(this);
		}
	}

	public override void DestroyShared()
	{
		base.DestroyShared();
		if (base.isServer && !Application.isQuitting)
		{
			Query.Server.RemoveBrain(this);
		}
	}
}


using System;
using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

[SoftRequireComponent(typeof(SenseComponent))]
public class NPCEncounterTimer : EntityComponent<BaseEntity>, IServerComponent
{
	public float giveUpDurationSeconds = 120f;

	[NonSerialized]
	public UnityEvent onShouldGiveUp = new UnityEvent();

	private const float fireTimeMultiplier = 4f;

	private const float mountedTimeMultiplier = 12f;

	private float? encounterRemainingTimeSeconds;

	private double? _lastTickTime;

	private SenseComponent _senseComponent;

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	private SenseComponent Senses => _senseComponent ?? (_senseComponent = ((Component)base.baseEntity).GetComponent<SenseComponent>());

	public void Tick()
	{
		float num = (float)(Time.timeAsDouble - LastTickTime);
		LastTickTime = Time.timeAsDouble;
		BaseEntity target;
		bool flag = Senses.FindTarget(out target);
		if (encounterRemainingTimeSeconds.HasValue && !flag)
		{
			encounterRemainingTimeSeconds = null;
		}
		else if (!encounterRemainingTimeSeconds.HasValue && flag)
		{
			StartTimer();
		}
		else
		{
			if (!encounterRemainingTimeSeconds.HasValue)
			{
				return;
			}
			if (base.baseEntity is BaseCombatEntity { SecondsSinceAttacked: <5f })
			{
				StartTimer();
				PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					Senses.GetInitialAllies((List<BaseEntity>)(object)val);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val)
					{
						((Component)item).GetComponent<NPCEncounterTimer>().StartTimer();
					}
				}
				finally
				{
					((IDisposable)val)?.Dispose();
				}
			}
			float num2 = 1f;
			if (target.ToNonNpcPlayer(out var player) && player.isMounted)
			{
				num2 = 12f;
			}
			else if (Trans_TargetIsNearFire.Test(base.baseEntity, Senses))
			{
				num2 = 4f;
			}
			encounterRemainingTimeSeconds -= num * num2;
			if (!(encounterRemainingTimeSeconds <= 0f))
			{
				return;
			}
			GiveUp();
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				Senses.GetInitialAllies((List<BaseEntity>)(object)val2);
				foreach (BaseEntity item2 in (List<BaseEntity>)(object)val2)
				{
					((Component)item2).GetComponent<NPCEncounterTimer>().GiveUp();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
	}

	private void StartTimer()
	{
		encounterRemainingTimeSeconds = giveUpDurationSeconds;
	}

	private void GiveUp()
	{
		if (encounterRemainingTimeSeconds.HasValue)
		{
			encounterRemainingTimeSeconds = null;
			onShouldGiveUp.Invoke();
		}
	}
}


using UnityEngine;

[CreateAssetMenu(menuName = "Rust/AI/NPC team", fileName = "NPCTeam_new", order = 0)]
public class NPCTeam : BaseScriptableObject
{
}


using System;
using ConVar;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine;

[SoftRequireComponent(typeof(LimitedTurnNavAgent))]
public class RootMotionPlayer : EntityComponent<BaseEntity>, IServerComponent
{
	public struct Warp
	{
		public float startTime;

		public float endTime;

		public Vector3 translationScale;

		public float rotationScale;

		public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
		{
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0010: Unknown result type (might be due to invalid IL or missing references)
			this.startTime = startTime;
			this.endTime = endTime;
			this.translationScale = translationScale;
			this.rotationScale = rotationScale;
		}
	}

	public class PlayServerState : IPooled
	{
		public AnimationClip animClip;

		public RootMotionData rmData;

		public float elapsedTime;

		public Vector3 initialLocation;

		public Quaternion initialRotation;

		public Action ServerTickAction;

		public Warp[] warps;

		public bool constrainToNavmesh;

		public Vector3 lastUnscaledOffset;

		public float lastUnscaledRotation;

		public bool isPlaying;

		public void Reset()
		{
			//IL_0016: Unknown result type (might be due to invalid IL or missing references)
			//IL_001b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			isPlaying = false;
			rmData = null;
			animClip = null;
			initialRotation = Quaternion.identity;
			warps = null;
			constrainToNavmesh = true;
			elapsedTime = 0f;
			ServerTickAction = null;
			lastUnscaledOffset = Vector3.zero;
			lastUnscaledRotation = 0f;
		}

		void IPooled.EnterPool()
		{
			Reset();
		}

		void IPooled.LeavePool()
		{
			Reset();
		}

		public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.rmData = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
		{
			//IL_000e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0013: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_001f: Unknown result type (might be due to invalid IL or missing references)
			PlayServerState playServerState = Pool.Get<PlayServerState>();
			playServerState.animClip = data;
			playServerState.initialLocation = transform.position;
			playServerState.initialRotation = transform.rotation;
			return playServerState;
		}

		public int GetAnimHash()
		{
			if (rmData != null)
			{
				if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
				{
					Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
				}
				return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
			}
			if ((Object)(object)animClip == (Object)null)
			{
				Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
			}
			return Animator.StringToHash(((Object)animClip).name);
		}

		public float GetAnimLength()
		{
			if (!(rmData != null))
			{
				return animClip.length;
			}
			return rmData.inPlaceAnimation.length;
		}

		public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
		{
			//IL_0041: Unknown result type (might be due to invalid IL or missing references)
			//IL_0046: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
			//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
			//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
			//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00db: Unknown result type (might be due to invalid IL or missing references)
			//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
			//IL_018a: Unknown result type (might be due to invalid IL or missing references)
			//IL_018f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0190: Unknown result type (might be due to invalid IL or missing references)
			//IL_0195: Unknown result type (might be due to invalid IL or missing references)
			//IL_0199: Unknown result type (might be due to invalid IL or missing references)
			//IL_019f: Unknown result type (might be due to invalid IL or missing references)
			//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
			//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
			//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
			//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
			//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
			//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
			//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0201: Unknown result type (might be due to invalid IL or missing references)
			//IL_0209: Unknown result type (might be due to invalid IL or missing references)
			//IL_020e: Unknown result type (might be due to invalid IL or missing references)
			//IL_0213: Unknown result type (might be due to invalid IL or missing references)
			//IL_0218: Unknown result type (might be due to invalid IL or missing references)
			//IL_0134: Unknown result type (might be due to invalid IL or missing references)
			//IL_014b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0162: Unknown result type (might be due to invalid IL or missing references)
			if (elapsedTime >= GetAnimLength())
			{
				return false;
			}
			if (rmData == null)
			{
				elapsedTime += deltaTime;
				return elapsedTime < GetAnimLength() - 0.25f;
			}
			Vector3 zero = Vector3.zero;
			zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
			zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
			zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
			float num = rmData.yRotationCurve.Evaluate(elapsedTime);
			Vector3 val = zero - lastUnscaledOffset;
			float num2 = num - lastUnscaledRotation;
			lastUnscaledOffset = zero;
			lastUnscaledRotation = num;
			if (warps != null)
			{
				Warp[] array = warps;
				for (int i = 0; i < array.Length; i++)
				{
					Warp warp = array[i];
					if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
					{
						val.x *= warp.translationScale.x;
						val.y *= warp.translationScale.y;
						val.z *= warp.translationScale.z;
						num2 *= warp.rotationScale;
					}
				}
			}
			Vector3 val2 = initialRotation * val;
			location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			location += val2;
			rotation *= Quaternion.Euler(0f, num2, 0f);
			location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}

		public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
		{
			//IL_0000: Unknown result type (might be due to invalid IL or missing references)
			//IL_0001: Unknown result type (might be due to invalid IL or missing references)
			//IL_0002: Unknown result type (might be due to invalid IL or missing references)
			//IL_0007: Unknown result type (might be due to invalid IL or missing references)
			//IL_000c: Unknown result type (might be due to invalid IL or missing references)
			//IL_000f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0014: Unknown result type (might be due to invalid IL or missing references)
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0024: Unknown result type (might be due to invalid IL or missing references)
			//IL_0029: Unknown result type (might be due to invalid IL or missing references)
			//IL_002e: Unknown result type (might be due to invalid IL or missing references)
			//IL_002f: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0036: Unknown result type (might be due to invalid IL or missing references)
			//IL_003b: Unknown result type (might be due to invalid IL or missing references)
			//IL_0040: Unknown result type (might be due to invalid IL or missing references)
			//IL_0045: Unknown result type (might be due to invalid IL or missing references)
			//IL_0047: Unknown result type (might be due to invalid IL or missing references)
			Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
			initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
			rotation *= Quaternion.Inverse(rotation) * initialRotation;
			return rotation;
		}
	}

	[SerializeField]
	private float rootBoneLocalZOffset;

	private LimitedTurnNavAgent _agent;

	private PlayServerState currentPlayState;

	private Action _playServerTickAction;

	private LockState.LockHandle lockHandle;

	private LimitedTurnNavAgent Agent => _agent ?? (_agent = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>());

	private Action PlayServerTickAction => PlayServerTick;

	public PlayServerState PlayServerAndTakeFromPool(RootMotionData data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public PlayServerState PlayServerAndTakeFromPool(AnimationClip data)
	{
		PlayServerState playServerState = PlayServerState.TakeFromPool(data, ((Component)base.baseEntity).transform);
		PlayServer(playServerState);
		return playServerState;
	}

	public void PlayServer(PlayServerState state)
	{
		if (AI.logIssues && state.rmData == null && (Object)(object)state.animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: state.rmData and state.animClip are both null");
			return;
		}
		if (currentPlayState != null)
		{
			StopServer(currentPlayState);
		}
		currentPlayState = state;
		currentPlayState.isPlaying = true;
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayMontageDelayed"), currentPlayState.GetAnimHash());
		lockHandle = Agent.Pause();
		((FacepunchBehaviour)base.baseEntity).InvokeRepeating(PlayServerTickAction, 0f, 0f);
	}

	public void PlayServerAdditive(AnimationClip animClip)
	{
		base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_PlayAdditiveMontage"), Animator.StringToHash(((Object)animClip).name));
	}

	private void PlayServerTick()
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_001c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0028: Unknown result type (might be due to invalid IL or missing references)
		//IL_002d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0099: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_007d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0082: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("RootMotionPlayer:PlayServerTick", 0);
		try
		{
			Vector3 location = ((Component)base.baseEntity).transform.position;
			Quaternion rotation = ((Component)base.baseEntity).transform.rotation;
			bool num = !currentPlayState.Step(Time.deltaTime, ref location, ref rotation, rootBoneLocalZOffset);
			if (currentPlayState.rmData != null)
			{
				if (currentPlayState.constrainToNavmesh)
				{
					Agent.Move(location - ((Component)base.baseEntity).transform.position);
				}
				else
				{
					((Component)base.baseEntity).transform.position = location;
				}
				((Component)base.baseEntity).transform.rotation = rotation;
			}
			if (num)
			{
				StopServer(currentPlayState, interrupt: false);
				currentPlayState = null;
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void Track(Vector3 targetPos, float trackingSpeed = 45f, float? timeStep = null)
	{
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_005a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0067: Unknown result type (might be due to invalid IL or missing references)
		if (currentPlayState != null && !(currentPlayState.rmData == null))
		{
			if (!timeStep.HasValue)
			{
				timeStep = Time.deltaTime;
			}
			((Component)base.baseEntity).transform.rotation = currentPlayState.Track(((Component)this).transform.position, targetPos, ((Component)base.baseEntity).transform.rotation, trackingSpeed, timeStep.Value);
		}
	}

	private void StopServer(PlayServerState state, bool interrupt = true)
	{
		if (state != null && state.isPlaying)
		{
			state.isPlaying = false;
			if (state == currentPlayState)
			{
				((FacepunchBehaviour)base.baseEntity).CancelInvoke(PlayServerTickAction);
				Agent.Unpause(ref lockHandle);
				currentPlayState = null;
			}
			if (interrupt)
			{
				base.baseEntity.ClientRPC(RpcTarget.NetworkGroup("CL_StopMontage"));
			}
		}
	}

	public void StopServerAndReturnToPool(ref PlayServerState state, bool interrupt = true)
	{
		if (state != null)
		{
			StopServer(state, interrupt);
			Pool.Free<PlayServerState>(ref state);
		}
	}
}


using UnityEngine;

public struct Warp
{
	public float startTime;

	public float endTime;

	public Vector3 translationScale;

	public float rotationScale;

	public Warp(float startTime, float endTime, Vector3 translationScale, float rotationScale = 1f)
	{
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		this.startTime = startTime;
		this.endTime = endTime;
		this.translationScale = translationScale;
		this.rotationScale = rotationScale;
	}
}


using System;
using Facepunch;
using UnityEngine;

public class PlayServerState : IPooled
{
	public AnimationClip animClip;

	public RootMotionData rmData;

	public float elapsedTime;

	public Vector3 initialLocation;

	public Quaternion initialRotation;

	public Action ServerTickAction;

	public Warp[] warps;

	public bool constrainToNavmesh;

	public Vector3 lastUnscaledOffset;

	public float lastUnscaledRotation;

	public bool isPlaying;

	public void Reset()
	{
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		isPlaying = false;
		rmData = null;
		animClip = null;
		initialRotation = Quaternion.identity;
		warps = null;
		constrainToNavmesh = true;
		elapsedTime = 0f;
		ServerTickAction = null;
		lastUnscaledOffset = Vector3.zero;
		lastUnscaledRotation = 0f;
	}

	void IPooled.EnterPool()
	{
		Reset();
	}

	void IPooled.LeavePool()
	{
		Reset();
	}

	public static PlayServerState TakeFromPool(RootMotionData data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.rmData = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public static PlayServerState TakeFromPool(AnimationClip data, Transform transform)
	{
		//IL_000e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0013: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_001f: Unknown result type (might be due to invalid IL or missing references)
		PlayServerState playServerState = Pool.Get<PlayServerState>();
		playServerState.animClip = data;
		playServerState.initialLocation = transform.position;
		playServerState.initialRotation = transform.rotation;
		return playServerState;
	}

	public int GetAnimHash()
	{
		if (rmData != null)
		{
			if ((Object)(object)rmData.inPlaceAnimation == (Object)null)
			{
				Debug.LogError((object)("RootMotionPlayer.PlayServer: rmData.inPlaceAnimation is null for " + ((Object)rmData).name));
			}
			return Animator.StringToHash(((Object)rmData.inPlaceAnimation).name);
		}
		if ((Object)(object)animClip == (Object)null)
		{
			Debug.LogError((object)"RootMotionPlayer.PlayServer: animClip is null");
		}
		return Animator.StringToHash(((Object)animClip).name);
	}

	public float GetAnimLength()
	{
		if (!(rmData != null))
		{
			return animClip.length;
		}
		return rmData.inPlaceAnimation.length;
	}

	public bool Step(float deltaTime, ref Vector3 location, ref Quaternion rotation, float rootBoneLocalZOffset = 0f)
	{
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0046: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00cb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00db: Unknown result type (might be due to invalid IL or missing references)
		//IL_00dc: Unknown result type (might be due to invalid IL or missing references)
		//IL_018a: Unknown result type (might be due to invalid IL or missing references)
		//IL_018f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0190: Unknown result type (might be due to invalid IL or missing references)
		//IL_0195: Unknown result type (might be due to invalid IL or missing references)
		//IL_0199: Unknown result type (might be due to invalid IL or missing references)
		//IL_019f: Unknown result type (might be due to invalid IL or missing references)
		//IL_01a4: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ac: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b1: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01bb: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c2: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c7: Unknown result type (might be due to invalid IL or missing references)
		//IL_01c9: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ce: Unknown result type (might be due to invalid IL or missing references)
		//IL_01d5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01e5: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_01ef: Unknown result type (might be due to invalid IL or missing references)
		//IL_01f6: Unknown result type (might be due to invalid IL or missing references)
		//IL_01fc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0201: Unknown result type (might be due to invalid IL or missing references)
		//IL_0209: Unknown result type (might be due to invalid IL or missing references)
		//IL_020e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0213: Unknown result type (might be due to invalid IL or missing references)
		//IL_0218: Unknown result type (might be due to invalid IL or missing references)
		//IL_0134: Unknown result type (might be due to invalid IL or missing references)
		//IL_014b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0162: Unknown result type (might be due to invalid IL or missing references)
		if (elapsedTime >= GetAnimLength())
		{
			return false;
		}
		if (rmData == null)
		{
			elapsedTime += deltaTime;
			return elapsedTime < GetAnimLength() - 0.25f;
		}
		Vector3 zero = Vector3.zero;
		zero.x = rmData.xMotionCurve.Evaluate(elapsedTime);
		zero.y = (constrainToNavmesh ? 0f : rmData.yMotionCurve.Evaluate(elapsedTime));
		zero.z = rmData.zMotionCurve.Evaluate(elapsedTime);
		float num = rmData.yRotationCurve.Evaluate(elapsedTime);
		Vector3 val = zero - lastUnscaledOffset;
		float num2 = num - lastUnscaledRotation;
		lastUnscaledOffset = zero;
		lastUnscaledRotation = num;
		if (warps != null)
		{
			Warp[] array = warps;
			for (int i = 0; i < array.Length; i++)
			{
				Warp warp = array[i];
				if (warp.startTime <= elapsedTime && elapsedTime <= warp.endTime)
				{
					val.x *= warp.translationScale.x;
					val.y *= warp.translationScale.y;
					val.z *= warp.translationScale.z;
					num2 *= warp.rotationScale;
				}
			}
		}
		Vector3 val2 = initialRotation * val;
		location -= rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		location += val2;
		rotation *= Quaternion.Euler(0f, num2, 0f);
		location += rotation * (Vector3.forward * (0f - rootBoneLocalZOffset));
		elapsedTime += deltaTime;
		return elapsedTime < GetAnimLength() - 0.25f;
	}

	public Quaternion Track(Vector3 ownerPos, Vector3 targetPos, Quaternion rotation, float trackingSpeed, float deltaTime)
	{
		//IL_0000: Unknown result type (might be due to invalid IL or missing references)
		//IL_0001: Unknown result type (might be due to invalid IL or missing references)
		//IL_0002: Unknown result type (might be due to invalid IL or missing references)
		//IL_0007: Unknown result type (might be due to invalid IL or missing references)
		//IL_000c: Unknown result type (might be due to invalid IL or missing references)
		//IL_000f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0024: Unknown result type (might be due to invalid IL or missing references)
		//IL_0029: Unknown result type (might be due to invalid IL or missing references)
		//IL_002e: Unknown result type (might be due to invalid IL or missing references)
		//IL_002f: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0036: Unknown result type (might be due to invalid IL or missing references)
		//IL_003b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		//IL_0045: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		Vector3 val = Vector3Ex.NormalizeXZ(targetPos - ownerPos);
		initialRotation = Quaternion.RotateTowards(initialRotation, Quaternion.LookRotation(val, Vector3.up), trackingSpeed * deltaTime);
		rotation *= Quaternion.Inverse(rotation) * initialRotation;
		return rotation;
	}
}


using UnityEngine;

public class RootMotionTester : MonoBehaviour
{
	public RootMotionData anim;

	public Transform target;

	public float timeStep = 0.1f;

	public float trackingSpeed = 90f;

	public float trackingDuration = 1f;

	public float rotArrowLength = 0.2f;

	public float targetVelocityYaw = 45f;

	public float targetVelocityMagnitude = 5f;

	public int trackingStepIndex;

	public float parentFrontOffset;
}


using System;
using System.Collections.Generic;
using ConVar;
using Facepunch;
using Oxide.Core;
using ProtoBuf;
using Rust.Ai;
using Rust.Ai.Gen2;
using UnityEngine;
using UnityEngine.Events;

public class SenseComponent : EntityComponent<BaseEntity>
{
	[Serializable]
	public struct Cone
	{
		public float halfAngle;

		public float range;

		public Cone(float halfAngle = 80f, float range = 10f)
		{
			this.halfAngle = halfAngle;
			this.range = range;
		}
	}

	public class VisibilityStatus : IPooled
	{
		private BaseEntity baseEntity;

		private BaseEntity targetEntity;

		public Vector3 lastKnownPosition;

		private const float waterCheckInterval = 1f;

		private double? lastTimeInWaterUpdated;

		public float timeVisible { get; private set; }

		public float timeNotVisible { get; private set; }

		public bool isVisible => timeVisible > 0f;

		public float timeWatched { get; private set; }

		public float timeNotWatched { get; private set; }

		public float timeAimedAt { get; private set; }

		public float timeNotAimedAt { get; private set; }

		public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

		public bool isInWaterCached
		{
			get
			{
				//IL_0093: Unknown result type (might be due to invalid IL or missing references)
				//IL_009d: Unknown result type (might be due to invalid IL or missing references)
				//IL_008c: Unknown result type (might be due to invalid IL or missing references)
				//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
				//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
				if (!targetEntity.ToNonNpcPlayer(out var player))
				{
					return false;
				}
				if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
				{
					BaseMountable entAsT;
					Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
					lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
					lastTimeInWaterUpdated = Time.timeAsDouble;
				}
				return lastWaterInfo.Value.currentDepth >= 0.3f;
			}
		}

		private void Reset()
		{
			//IL_0051: Unknown result type (might be due to invalid IL or missing references)
			//IL_0056: Unknown result type (might be due to invalid IL or missing references)
			targetEntity = null;
			baseEntity = null;
			timeWatched = 0f;
			timeNotWatched = 100f;
			timeAimedAt = 0f;
			timeNotAimedAt = 100f;
			timeVisible = 0f;
			timeNotVisible = 100f;
			lastKnownPosition = Vector3.zero;
			lastWaterInfo = null;
			lastTimeInWaterUpdated = null;
		}

		public void EnterPool()
		{
			Reset();
		}

		public void LeavePool()
		{
			Reset();
		}

		public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
			visibilityStatus.baseEntity = baseEntity;
			visibilityStatus.targetEntity = targetEntity;
			visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
			return visibilityStatus;
		}

		private bool CheckValid()
		{
			if (!baseEntity.IsValid() || !targetEntity.IsValid())
			{
				if (AI.logIssues)
				{
					Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
				}
				return false;
			}
			return true;
		}

		public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
		{
			//IL_0015: Unknown result type (might be due to invalid IL or missing references)
			//IL_001a: Unknown result type (might be due to invalid IL or missing references)
			//IL_0030: Unknown result type (might be due to invalid IL or missing references)
			//IL_0035: Unknown result type (might be due to invalid IL or missing references)
			//IL_0064: Unknown result type (might be due to invalid IL or missing references)
			//IL_0069: Unknown result type (might be due to invalid IL or missing references)
			//IL_0075: Unknown result type (might be due to invalid IL or missing references)
			//IL_007a: Unknown result type (might be due to invalid IL or missing references)
			//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
			//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
			//IL_0090: Unknown result type (might be due to invalid IL or missing references)
			//IL_0095: Unknown result type (might be due to invalid IL or missing references)
			//IL_009c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
			if (!CheckValid())
			{
				return;
			}
			if (lastKnownPositionOverride.HasValue)
			{
				lastKnownPosition = lastKnownPositionOverride.Value;
			}
			else if (isVisible)
			{
				lastKnownPosition = ((Component)targetEntity).transform.position;
			}
			if (isVisible)
			{
				timeNotVisible = 0f;
				timeVisible += deltaTime;
				Vector3 val = ((Component)targetEntity).transform.forward;
				Vector3 position = ((Component)targetEntity).transform.position;
				if (targetEntity.ToNonNpcPlayer(out var player))
				{
					val = player.eyes.HeadForward();
					position = player.eyes.position;
				}
				Vector3 val2 = ((Component)baseEntity).transform.position - position;
				float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
				bool num2 = num < AI.watchedAngle;
				if (num2)
				{
					timeNotWatched = 0f;
					timeWatched += deltaTime;
				}
				else
				{
					timeWatched = 0f;
					timeNotWatched += deltaTime;
				}
				if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
				{
					timeNotAimedAt = 0f;
					timeAimedAt += deltaTime;
				}
				else
				{
					timeAimedAt = 0f;
					timeNotAimedAt += deltaTime;
				}
			}
			else
			{
				timeVisible = 0f;
				timeNotVisible += deltaTime;
				timeWatched = 0f;
				timeNotWatched += deltaTime;
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
	}

	[SerializeField]
	private Vector3 LongRangeVisionRectangle = new Vector3(6f, 30f, 60f);

	[SerializeField]
	private Cone ShortRangeVisionCone = new Cone(100f, 30f);

	[SerializeField]
	private float touchDistance = 6f;

	[SerializeField]
	private float noiseRangeMultiplier = 1f;

	[SerializeField]
	private float hearingRange = 50f;

	[SerializeField]
	private NPCTeam team;

	[NonSerialized]
	public ResettableFloat timeToForgetSightings = new ResettableFloat(30f);

	private const float timeToForgetNoises = 5f;

	private static HashSet<BaseEntity> entitiesUpdatedThisFrame = new HashSet<BaseEntity>();

	[ServerVar]
	public static float minRefreshIntervalSeconds = 0.2f;

	[ServerVar]
	public static float maxRefreshIntervalSeconds = 1f;

	private double? _lastTickTime;

	private double nextRefreshTime;

	private double spawnTime;

	private Dictionary<BaseEntity, double> _alliesWeAreAwareOf = new Dictionary<BaseEntity, double>(3);

	private Dictionary<BaseEntity, VisibilityStatus> entitiesWeAreAwareOf = new Dictionary<BaseEntity, VisibilityStatus>(8);

	private static readonly Dictionary<NpcNoiseIntensity, float> noiseRadii = new Dictionary<NpcNoiseIntensity, float>
	{
		{
			NpcNoiseIntensity.None,
			0f
		},
		{
			NpcNoiseIntensity.Low,
			10f
		},
		{
			NpcNoiseIntensity.Medium,
			20f
		},
		{
			NpcNoiseIntensity.High,
			50f
		}
	};

	private NpcNoiseEvent _currentNoise;

	[SerializeField]
	private float foodDetectionRange = 30f;

	private BaseEntity _nearestFood;

	[SerializeField]
	private float fireDetectionRange = 20f;

	[NonSerialized]
	public UnityEvent onFireMelee = new UnityEvent();

	private BaseEntity _nearestFire;

	private double? lastMeleeTime;

	[SerializeField]
	private float TargetingCooldown = 5f;

	private BaseEntity _target;

	private const float npcDistPenaltyToFavorTargetingPlayers = 10f;

	private double? lastTargetTime;

	private LockState lockState = new LockState();

	public float RefreshInterval
	{
		get
		{
			if (!ShouldRefreshFast)
			{
				return maxRefreshIntervalSeconds;
			}
			return minRefreshIntervalSeconds;
		}
	}

	private double LastTickTime
	{
		get
		{
			double valueOrDefault = _lastTickTime.GetValueOrDefault();
			if (!_lastTickTime.HasValue)
			{
				valueOrDefault = Time.timeAsDouble;
				_lastTickTime = valueOrDefault;
				return valueOrDefault;
			}
			return valueOrDefault;
		}
		set
		{
			_lastTickTime = value;
		}
	}

	public bool HasPlayerInVicinity { get; private set; }

	public bool ShouldRefreshFast
	{
		get
		{
			if (!HasPlayerInVicinity)
			{
				if ((Object)(object)Target != (Object)null)
				{
					return Target.IsNonNpcPlayer();
				}
				return false;
			}
			return true;
		}
	}

	public NpcNoiseEvent currentNoise => _currentNoise;

	private BaseEntity Target
	{
		get
		{
			return _target;
		}
		set
		{
			if (base.baseEntity.isServer)
			{
				BaseEntity target = _target;
				_target = value;
				if ((Object)(object)target != (Object)(object)_target)
				{
					base.baseEntity.SendNetworkUpdate();
				}
			}
		}
	}

	private bool ChangedTargetRecently
	{
		get
		{
			if (lastTargetTime.HasValue)
			{
				return Time.timeAsDouble - lastTargetTime.Value < (double)TargetingCooldown;
			}
			return true;
		}
	}

	public void GetInitialAllies(List<BaseEntity> allies)
	{
		PooledList<BaseEntity> val = Pool.Get<PooledList<BaseEntity>>();
		try
		{
			foreach (var (baseEntity2, num2) in _alliesWeAreAwareOf)
			{
				if (!baseEntity2.IsValid() || (baseEntity2 is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead()))
				{
					((List<BaseEntity>)(object)val).Add(baseEntity2);
				}
				else if (!(num2 - spawnTime > (double)(maxRefreshIntervalSeconds * 2f)))
				{
					allies.Add(baseEntity2);
				}
			}
			foreach (BaseEntity item in (List<BaseEntity>)(object)val)
			{
				_alliesWeAreAwareOf.Remove(item);
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public Vector3? GetLKP(BaseEntity entity)
	{
		//IL_0021: Unknown result type (might be due to invalid IL or missing references)
		//IL_0014: Unknown result type (might be due to invalid IL or missing references)
		if (GetVisibilityStatus(entity, out var status))
		{
			return status.isVisible ? ((Component)entity).transform.position : status.lastKnownPosition;
		}
		return null;
	}

	public bool GetVisibilityStatus(BaseEntity entity, out VisibilityStatus status)
	{
		status = null;
		if (!CanTarget(entity))
		{
			return false;
		}
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out status))
		{
			return false;
		}
		return true;
	}

	public bool Forget(BaseEntity entity)
	{
		if (!entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			return false;
		}
		entitiesWeAreAwareOf.Remove(entity);
		Pool.Free<VisibilityStatus>(ref value);
		return true;
	}

	public bool IsVisible(BaseEntity entity)
	{
		if (!GetVisibilityStatus(entity, out var status))
		{
			return false;
		}
		return status.isVisible;
	}

	public void GetSeenEntities(List<BaseEntity> perceivedEntities)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:GetSeenEntities", 0);
		try
		{
			foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
			{
				if (IsVisible(key))
				{
					perceivedEntities.Add(key);
				}
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public void GetOncePerceivedEntities(List<BaseEntity> perceivedEntities)
	{
		foreach (BaseEntity key in entitiesWeAreAwareOf.Keys)
		{
			if (GetVisibilityStatus(key, out var _))
			{
				perceivedEntities.Add(key);
			}
		}
	}

	private Matrix4x4 GetEyeTransform()
	{
		//IL_0006: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0020: Unknown result type (might be due to invalid IL or missing references)
		return Matrix4x4.TRS(base.baseEntity.CenterPoint(), ((Component)base.baseEntity).transform.rotation, Vector3.one);
	}

	public override void InitShared()
	{
		base.InitShared();
		spawnTime = Time.timeAsDouble;
	}

	public override void Hurt(HitInfo hitInfo)
	{
		//IL_0017: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0044: Unknown result type (might be due to invalid IL or missing references)
		//IL_0049: Unknown result type (might be due to invalid IL or missing references)
		//IL_004e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0088: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_0076: Unknown result type (might be due to invalid IL or missing references)
		BaseEntity initiator = hitInfo.Initiator;
		if (!CanTarget(initiator))
		{
			return;
		}
		Vector3 val = ((Component)initiator).transform.position + Quaternion.AngleAxis(Random.Range(0f, 360f), Vector3.up) * Vector3.forward * 5f;
		if (entitiesWeAreAwareOf.TryGetValue(initiator, out var value))
		{
			if (!value.isVisible && value.timeNotVisible > 3f)
			{
				value.lastKnownPosition = val;
			}
		}
		else
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, initiator, 0.01f, val);
			entitiesWeAreAwareOf.Add(initiator, fromPool);
		}
	}

	public void Tick()
	{
		//IL_0065: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:Tick", 0);
		try
		{
			double timeAsDouble = Time.timeAsDouble;
			if (timeAsDouble < nextRefreshTime)
			{
				return;
			}
			float deltaTime = (float)(timeAsDouble - LastTickTime);
			LastTickTime = timeAsDouble;
			HasPlayerInVicinity = false;
			entitiesUpdatedThisFrame.Clear();
			TimeWarning val2 = TimeWarning.New("SenseComponent:Tick:ProcessEntities", 0);
			try
			{
				PooledList<BaseEntity> val3 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					BaseEntity.Query.Server.GetPlayersAndBrainsInSphere(((Component)base.baseEntity).transform.position, LongRangeVisionRectangle.z, (List<BaseEntity>)(object)val3, BaseEntity.Query.DistanceCheckType.None);
					foreach (BaseEntity item in (List<BaseEntity>)(object)val3)
					{
						if (!((Object)(object)item == (Object)(object)base.baseEntity))
						{
							if (item.IsNonNpcPlayer())
							{
								HasPlayerInVicinity = true;
							}
							if (InSameTeam(item) && !_alliesWeAreAwareOf.ContainsKey(item))
							{
								_alliesWeAreAwareOf.Add(item, timeAsDouble);
							}
							if (CanTarget(item))
							{
								UpdateEntityVisibility(item, deltaTime);
							}
						}
					}
				}
				finally
				{
					((IDisposable)val3)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
			TimeWarning val4 = TimeWarning.New("SenseComponent:Tick:RemoveEntities", 0);
			try
			{
				PooledList<BaseEntity> val5 = Pool.Get<PooledList<BaseEntity>>();
				try
				{
					foreach (var (baseEntity2, visibilityStatus2) in entitiesWeAreAwareOf)
					{
						if (!CanTarget(baseEntity2))
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!visibilityStatus2.isVisible && visibilityStatus2.timeNotVisible > timeToForgetSightings.Value)
						{
							((List<BaseEntity>)(object)val5).Add(baseEntity2);
						}
						else if (!entitiesUpdatedThisFrame.Contains(baseEntity2) && visibilityStatus2.isVisible)
						{
							entitiesWeAreAwareOf[baseEntity2].UpdateVisibility(isVisible: false, deltaTime, null);
						}
					}
					entitiesUpdatedThisFrame.Clear();
					foreach (BaseEntity item2 in (List<BaseEntity>)(object)val5)
					{
						if (Target.IsValid() && (Object)(object)Target == (Object)(object)item2)
						{
							ClearTarget(forget: false);
						}
						Forget(item2);
					}
				}
				finally
				{
					((IDisposable)val5)?.Dispose();
				}
			}
			finally
			{
				((IDisposable)val4)?.Dispose();
			}
			TickHearing(deltaTime);
			TickFoodDetection(deltaTime);
			TickFireDetection(deltaTime);
			TickTargeting(deltaTime);
			nextRefreshTime = Time.timeAsDouble + (double)RefreshInterval;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void GetModifiedSenses(BaseEntity entity, out float modTouchDistance, out float modHalfAngle, out float modShortVisionRange, out Vector3 modLongVisionRectangle)
	{
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_008c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a0: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a5: Unknown result type (might be due to invalid IL or missing references)
		//IL_00aa: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ea: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f9: Unknown result type (might be due to invalid IL or missing references)
		modTouchDistance = touchDistance;
		modHalfAngle = ShortRangeVisionCone.halfAngle;
		modShortVisionRange = ShortRangeVisionCone.range;
		modLongVisionRectangle = LongRangeVisionRectangle;
		if (entity.ToNonNpcPlayer(out var player))
		{
			if (player.IsDucked())
			{
				modTouchDistance = ((Bounds)(ref base.baseEntity.bounds)).extents.z * 1.5f;
				modHalfAngle = ShortRangeVisionCone.halfAngle * 0.85f;
				modShortVisionRange = ShortRangeVisionCone.range * 0.5f;
				modLongVisionRectangle = Vector3.Scale(LongRangeVisionRectangle, new Vector3(3f, 0.5f, 0.5f));
			}
			else if (player.IsRunning())
			{
				modTouchDistance = touchDistance * 3f;
				modHalfAngle = ShortRangeVisionCone.halfAngle;
				modShortVisionRange = ShortRangeVisionCone.range * 1.3f;
				modLongVisionRectangle = LongRangeVisionRectangle * 1.15f;
			}
		}
	}

	private bool IsInAnyRange(BaseEntity entity)
	{
		//IL_000d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0012: Unknown result type (might be due to invalid IL or missing references)
		//IL_0016: Unknown result type (might be due to invalid IL or missing references)
		//IL_001b: Unknown result type (might be due to invalid IL or missing references)
		//IL_001d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0026: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_003c: Unknown result type (might be due to invalid IL or missing references)
		//IL_0041: Unknown result type (might be due to invalid IL or missing references)
		//IL_0042: Unknown result type (might be due to invalid IL or missing references)
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_006e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0071: Unknown result type (might be due to invalid IL or missing references)
		//IL_009e: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
		//IL_00c3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00de: Unknown result type (might be due to invalid IL or missing references)
		//IL_00df: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e4: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f2: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("IsInAnyRange", 0);
		try
		{
			Matrix4x4 eyeTransform = GetEyeTransform();
			Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
			eyeTransform = GetEyeTransform();
			Vector3 val2 = ((Matrix4x4)(ref eyeTransform)).rotation * Vector3.forward;
			Vector3 val3 = ((Component)entity).transform.position - position;
			float magnitude = ((Vector3)(ref val3)).magnitude;
			GetModifiedSenses(entity, out var modTouchDistance, out var modHalfAngle, out var modShortVisionRange, out var modLongVisionRectangle);
			if (magnitude < modTouchDistance)
			{
				return true;
			}
			if (Vector3.Angle(val2, ((Vector3)(ref val3)).normalized) < modHalfAngle)
			{
				if (magnitude < modShortVisionRange)
				{
					return true;
				}
				if (TOD_Sky.Instance.IsDay && magnitude < modLongVisionRectangle.z && Mathf.Abs(((Component)entity).transform.position.y - position.y) < modLongVisionRectangle.y * 0.5f)
				{
					Vector3 val4 = Vector3.Cross(val2, ((Component)entity).transform.position - position);
					if (((Vector3)(ref val4)).magnitude < modLongVisionRectangle.x * 0.5f)
					{
						return true;
					}
				}
			}
			return false;
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	private void UpdateEntityVisibility(BaseEntity entity, float deltaTime)
	{
		//IL_0022: Unknown result type (might be due to invalid IL or missing references)
		//IL_0027: Unknown result type (might be due to invalid IL or missing references)
		//IL_002b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0038: Unknown result type (might be due to invalid IL or missing references)
		//IL_0040: Unknown result type (might be due to invalid IL or missing references)
		bool flag = IsInAnyRange(entity);
		if (flag && entity.ToNonNpcPlayer(out var player))
		{
			TimeWarning val = TimeWarning.New("SenseComponent:ProcessEntity:CanSee", 0);
			try
			{
				Matrix4x4 eyeTransform = GetEyeTransform();
				Vector3 position = ((Matrix4x4)(ref eyeTransform)).GetPosition();
				flag = base.baseEntity.CanSee(position, player.eyes.position);
			}
			finally
			{
				((IDisposable)val)?.Dispose();
			}
		}
		if (entitiesWeAreAwareOf.TryGetValue(entity, out var value))
		{
			value.UpdateVisibility(flag, deltaTime, null);
			entitiesUpdatedThisFrame.Add(entity);
		}
		else if (flag)
		{
			VisibilityStatus fromPool = VisibilityStatus.GetFromPool(base.baseEntity, entity, deltaTime, null);
			entitiesWeAreAwareOf.Add(entity, fromPool);
			entitiesUpdatedThisFrame.Add(entity);
		}
	}

	public bool InSameTeam(BaseEntity other)
	{
		if (team != null && ((Object)(object)((Component)other).GetComponent<SenseComponent>()).Is<SenseComponent>(out SenseComponent entAsT) && team == entAsT.team)
		{
			return true;
		}
		return base.baseEntity.InSameNpcTeam(other);
	}

	private void TickHearing(float deltaTime)
	{
		//IL_0047: Unknown result type (might be due to invalid IL or missing references)
		//IL_01af: Unknown result type (might be due to invalid IL or missing references)
		//IL_01b4: Unknown result type (might be due to invalid IL or missing references)
		//IL_0106: Unknown result type (might be due to invalid IL or missing references)
		//IL_0116: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickHearing", 0);
		try
		{
			if (_currentNoise != null)
			{
				Pool.Free<NpcNoiseEvent>(ref _currentNoise);
			}
			if (noiseRangeMultiplier <= 0f)
			{
				return;
			}
			PooledList<NpcNoiseEvent> val2 = Pool.Get<PooledList<NpcNoiseEvent>>();
			try
			{
				SingletonComponent<NpcNoiseManager>.Instance.GetNoisesAround(((Component)base.baseEntity).transform.position, hearingRange, (List<NpcNoiseEvent>)(object)val2);
				NpcNoiseEvent npcNoiseEvent = null;
				float? num = null;
				foreach (NpcNoiseEvent item in (List<NpcNoiseEvent>)(object)val2)
				{
					if ((Object)(object)item.Initiator == (Object)(object)base.baseEntity || !CanTarget(item.Initiator))
					{
						continue;
					}
					float num2 = (float)(Time.timeAsDouble - item.EventTime);
					if (!(num2 > 5f) && (npcNoiseEvent == null || item.Intensity >= npcNoiseEvent.Intensity))
					{
						if (!noiseRadii.TryGetValue(item.Intensity, out var value))
						{
							Debug.LogError((object)$"Unknown noise intensity: {item.Intensity}");
						}
						else if (!(Vector3.Distance(item.Position, ((Component)base.baseEntity).transform.position) > Mathf.Min(value * noiseRangeMultiplier, hearingRange)) && (npcNoiseEvent == null || item.Intensity != npcNoiseEvent.Intensity || !(num2 > num)))
						{
							npcNoiseEvent = item;
							num = num2;
						}
					}
				}
				if (npcNoiseEvent != null)
				{
					_currentNoise = Pool.Get<NpcNoiseEvent>();
					_currentNoise.Initiator = npcNoiseEvent.Initiator;
					_currentNoise.Position = npcNoiseEvent.Position;
					_currentNoise.Intensity = npcNoiseEvent.Intensity;
					if (!FindTarget(out var _))
					{
						TrySetTarget(npcNoiseEvent.Initiator);
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool ConsumeCurrentNoise()
	{
		if (_currentNoise == null)
		{
			return false;
		}
		Pool.Free<NpcNoiseEvent>(ref _currentNoise);
		return true;
	}

	public bool FindFood(out BaseEntity food)
	{
		if (!_nearestFood.IsValid() || _nearestFood.IsDestroyed || !SingletonComponent<NpcFoodManager>.Instance.Contains(_nearestFood))
		{
			food = null;
			return false;
		}
		food = _nearestFood;
		return true;
	}

	private void TickFoodDetection(float deltaTime)
	{
		//IL_004f: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00fd: Unknown result type (might be due to invalid IL or missing references)
		//IL_010d: Unknown result type (might be due to invalid IL or missing references)
		//IL_0112: Unknown result type (might be due to invalid IL or missing references)
		//IL_0117: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFoodDetection", 0);
		try
		{
			_nearestFood = null;
			if (foodDetectionRange <= 0f)
			{
				return;
			}
			float num = foodDetectionRange * foodDetectionRange;
			float num2 = float.MaxValue;
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFoodManager>.Instance.GetFoodAround(((Component)base.baseEntity).transform.position, foodDetectionRange, (List<BaseEntity>)(object)val2);
				LimitedTurnNavAgent component = ((Component)base.baseEntity).GetComponent<LimitedTurnNavAgent>();
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (!NpcFoodManager.IsFoodImmobile(item) || (item is BaseCorpse baseCorpse && ((Object)(object)((Component)baseCorpse).GetComponent<HeadDispenser>()).Is<HeadDispenser>(out HeadDispenser entAsT) && ((Object)(object)entAsT.SourceEntity.GetEntity()).Is<BaseEntity>(out BaseEntity entAsT2) && entAsT2.InSameNpcTeam(base.baseEntity)))
					{
						continue;
					}
					if (!component.IsPositionOnNavmesh(((Component)item).transform.position, out var sample))
					{
						SingletonComponent<NpcFoodManager>.Instance.Remove(item);
						continue;
					}
					sample = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref sample)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						_nearestFood = item;
						num2 = sqrMagnitude;
					}
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public bool FindFire(out BaseEntity fire)
	{
		if (!_nearestFire.IsValid() || _nearestFire.IsDestroyed || !NpcFireManager.IsOnFire(_nearestFire))
		{
			_nearestFire = null;
		}
		fire = _nearestFire;
		return (Object)(object)fire != (Object)null;
	}

	private void TickFireDetection(float deltaTime)
	{
		//IL_0093: Unknown result type (might be due to invalid IL or missing references)
		//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00e6: Unknown result type (might be due to invalid IL or missing references)
		//IL_00eb: Unknown result type (might be due to invalid IL or missing references)
		//IL_00f0: Unknown result type (might be due to invalid IL or missing references)
		TimeWarning val = TimeWarning.New("SenseComponent:TickFireDetection", 0);
		try
		{
			if (fireDetectionRange <= 0f)
			{
				return;
			}
			if ((Object)(object)Target != (Object)null && SingletonComponent<NpcFireManager>.Instance.DidMeleeWithFireRecently(base.baseEntity, Target, out var meleeTime) && (!lastMeleeTime.HasValue || meleeTime != lastMeleeTime.Value))
			{
				lastMeleeTime = meleeTime;
				onFireMelee.Invoke();
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				SingletonComponent<NpcFireManager>.Instance.GetFiresAround(((Component)base.baseEntity).transform.position, fireDetectionRange, (List<BaseEntity>)(object)val2);
				BaseEntity baseEntity = null;
				float num = fireDetectionRange * fireDetectionRange;
				float num2 = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					Vector3 val3 = ((Component)item).transform.position - ((Component)base.baseEntity).transform.position;
					float sqrMagnitude = ((Vector3)(ref val3)).sqrMagnitude;
					if (sqrMagnitude < num2 && sqrMagnitude < num)
					{
						baseEntity = item;
						num2 = sqrMagnitude;
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					_nearestFire = baseEntity;
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public LockState.LockHandle LockCurrentTarget()
	{
		return lockState.AddLock();
	}

	public bool UnlockTarget(ref LockState.LockHandle handle)
	{
		return lockState.RemoveLock(ref handle);
	}

	public bool CanTarget(BaseEntity entity)
	{
		if (!entity.IsValid())
		{
			return false;
		}
		if (entity.IsTransferProtected())
		{
			return false;
		}
		if (entity.IsDestroyed)
		{
			return false;
		}
		if (!entity.IsNonNpcPlayer() && !entity.IsNpc)
		{
			return false;
		}
		if (entity.IsNpcPlayer())
		{
			return false;
		}
		if (entity is BaseCombatEntity baseCombatEntity && baseCombatEntity.IsDead())
		{
			return false;
		}
		if (InSameTeam(entity))
		{
			return false;
		}
		if (entity is BasePlayer item)
		{
			if (AI.ignoreplayers)
			{
				return false;
			}
			if (SimpleAIMemory.PlayerIgnoreList.Contains(item))
			{
				return false;
			}
		}
		object obj = Interface.CallHook("IOnNpcTarget", (object)this, (object)entity);
		if (obj is bool)
		{
			return (bool)obj;
		}
		return true;
	}

	public bool FindTarget(out BaseEntity target)
	{
		if (!CanTarget(Target))
		{
			ClearTarget();
			target = null;
			return false;
		}
		target = Target;
		return (Object)(object)target != (Object)null;
	}

	public bool FindTargetPosition(out Vector3 targetPosition)
	{
		//IL_001e: Unknown result type (might be due to invalid IL or missing references)
		//IL_0023: Unknown result type (might be due to invalid IL or missing references)
		//IL_000b: Unknown result type (might be due to invalid IL or missing references)
		//IL_0010: Unknown result type (might be due to invalid IL or missing references)
		if (!FindTarget(out var target))
		{
			targetPosition = Vector3.zero;
			return false;
		}
		targetPosition = ((Component)target).transform.position;
		return true;
	}

	public bool TrySetTarget(BaseEntity newTarget, bool bypassCooldown = true)
	{
		if (lockState.IsLocked)
		{
			return false;
		}
		if ((Object)(object)newTarget == (Object)null)
		{
			ClearTarget();
			return true;
		}
		if ((Object)(object)newTarget == (Object)(object)Target)
		{
			return true;
		}
		if (!CanTarget(newTarget))
		{
			return false;
		}
		if ((Object)(object)Target != (Object)null && !bypassCooldown && ChangedTargetRecently)
		{
			return false;
		}
		lastTargetTime = Time.timeAsDouble;
		Target = newTarget;
		return true;
	}

	public void ClearTarget(bool forget = true)
	{
		if (Target.IsValid())
		{
			if (forget)
			{
				Forget(Target);
			}
			lastTargetTime = null;
			Target = null;
		}
	}

	private void TickTargeting(float deltaTime)
	{
		TimeWarning val = TimeWarning.New("SenseComponent:TickTargeting", 0);
		try
		{
			if ((Object)(object)Target != (Object)null && !CanTarget(Target))
			{
				ClearTarget();
			}
			if ((Object)(object)Target != (Object)null && ChangedTargetRecently)
			{
				return;
			}
			PooledList<BaseEntity> val2 = Pool.Get<PooledList<BaseEntity>>();
			try
			{
				GetOncePerceivedEntities((List<BaseEntity>)(object)val2);
				if (((List<BaseEntity>)(object)val2).Count == 0)
				{
					return;
				}
				BaseEntity baseEntity = null;
				float num = float.MaxValue;
				foreach (BaseEntity item in (List<BaseEntity>)(object)val2)
				{
					if (CanTarget(item))
					{
						float num2 = base.baseEntity.SqrDistance(item);
						if (item.IsNpc)
						{
							num2 += 100f;
						}
						if (num2 < num)
						{
							num = num2;
							baseEntity = item;
						}
					}
				}
				if ((Object)(object)baseEntity != (Object)null)
				{
					TrySetTarget(baseEntity, bypassCooldown: false);
				}
			}
			finally
			{
				((IDisposable)val2)?.Dispose();
			}
		}
		finally
		{
			((IDisposable)val)?.Dispose();
		}
	}

	public override void SaveComponent(BaseNetworkable.SaveInfo info)
	{
		//IL_0048: Unknown result type (might be due to invalid IL or missing references)
		//IL_004d: Unknown result type (might be due to invalid IL or missing references)
		base.SaveComponent(info);
		if (base.baseEntity.isServer)
		{
			info.msg.npcSensesState = Pool.Get<NPCSensesState>();
			if ((Object)(object)Target != (Object)null)
			{
				info.msg.npcSensesState.targetEntityId = Target.net.ID;
			}
		}
	}

	public override void LoadComponent(BaseNetworkable.LoadInfo info)
	{
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		NPCSensesState npcSensesState = info.msg.npcSensesState;
		if (npcSensesState != null)
		{
			if (((NetworkableId)(ref npcSensesState.targetEntityId)).IsValid)
			{
				if (base.baseEntity.isServer)
				{
					_target = BaseNetworkable.serverEntities.Find(npcSensesState.targetEntityId) as BaseEntity;
				}
			}
			else
			{
				_target = null;
			}
		}
		base.LoadComponent(info);
	}
}


using System;

[Serializable]
public struct Cone
{
	public float halfAngle;

	public float range;

	public Cone(float halfAngle = 80f, float range = 10f)
	{
		this.halfAngle = halfAngle;
		this.range = range;
	}
}


using ConVar;
using Facepunch;
using UnityEngine;

public class VisibilityStatus : IPooled
{
	private BaseEntity baseEntity;

	private BaseEntity targetEntity;

	public Vector3 lastKnownPosition;

	private const float waterCheckInterval = 1f;

	private double? lastTimeInWaterUpdated;

	public float timeVisible { get; private set; }

	public float timeNotVisible { get; private set; }

	public bool isVisible => timeVisible > 0f;

	public float timeWatched { get; private set; }

	public float timeNotWatched { get; private set; }

	public float timeAimedAt { get; private set; }

	public float timeNotAimedAt { get; private set; }

	public WaterLevel.WaterInfo? lastWaterInfo { get; private set; }

	public bool isInWaterCached
	{
		get
		{
			//IL_0093: Unknown result type (might be due to invalid IL or missing references)
			//IL_009d: Unknown result type (might be due to invalid IL or missing references)
			//IL_008c: Unknown result type (might be due to invalid IL or missing references)
			//IL_00a2: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b0: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b5: Unknown result type (might be due to invalid IL or missing references)
			//IL_00b7: Unknown result type (might be due to invalid IL or missing references)
			if (!targetEntity.ToNonNpcPlayer(out var player))
			{
				return false;
			}
			if (!lastWaterInfo.HasValue || !lastTimeInWaterUpdated.HasValue || Time.timeAsDouble - lastTimeInWaterUpdated > 1.0)
			{
				BaseMountable entAsT;
				Vector3 val = (((Object)(object)player.GetMounted()).Is<BaseMountable>(out entAsT) ? (Vector3.down * 0.5f) : Vector3.zero);
				lastWaterInfo = WaterLevel.GetWaterInfo(((Component)targetEntity).transform.position + val, waves: false, volumes: false);
				lastTimeInWaterUpdated = Time.timeAsDouble;
			}
			return lastWaterInfo.Value.currentDepth >= 0.3f;
		}
	}

	private void Reset()
	{
		//IL_0051: Unknown result type (might be due to invalid IL or missing references)
		//IL_0056: Unknown result type (might be due to invalid IL or missing references)
		targetEntity = null;
		baseEntity = null;
		timeWatched = 0f;
		timeNotWatched = 100f;
		timeAimedAt = 0f;
		timeNotAimedAt = 100f;
		timeVisible = 0f;
		timeNotVisible = 100f;
		lastKnownPosition = Vector3.zero;
		lastWaterInfo = null;
		lastTimeInWaterUpdated = null;
	}

	public void EnterPool()
	{
		Reset();
	}

	public void LeavePool()
	{
		Reset();
	}

	public static VisibilityStatus GetFromPool(BaseEntity baseEntity, BaseEntity targetEntity, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		VisibilityStatus visibilityStatus = Pool.Get<VisibilityStatus>();
		visibilityStatus.baseEntity = baseEntity;
		visibilityStatus.targetEntity = targetEntity;
		visibilityStatus.UpdateVisibility(isVisible: true, deltaTime, lastKnownPositionOverride);
		return visibilityStatus;
	}

	private bool CheckValid()
	{
		if (!baseEntity.IsValid() || !targetEntity.IsValid())
		{
			if (AI.logIssues)
			{
				Debug.LogError((object)$"SenseComponent:UpdateVisibility NRE: {baseEntity} {targetEntity}");
			}
			return false;
		}
		return true;
	}

	public void UpdateVisibility(bool isVisible, float deltaTime, Vector3? lastKnownPositionOverride = null)
	{
		//IL_0015: Unknown result type (might be due to invalid IL or missing references)
		//IL_001a: Unknown result type (might be due to invalid IL or missing references)
		//IL_0030: Unknown result type (might be due to invalid IL or missing references)
		//IL_0035: Unknown result type (might be due to invalid IL or missing references)
		//IL_0064: Unknown result type (might be due to invalid IL or missing references)
		//IL_0069: Unknown result type (might be due to invalid IL or missing references)
		//IL_0075: Unknown result type (might be due to invalid IL or missing references)
		//IL_007a: Unknown result type (might be due to invalid IL or missing references)
		//IL_00ad: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b2: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b3: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b8: Unknown result type (might be due to invalid IL or missing references)
		//IL_00b9: Unknown result type (might be due to invalid IL or missing references)
		//IL_00bc: Unknown result type (might be due to invalid IL or missing references)
		//IL_0090: Unknown result type (might be due to invalid IL or missing references)
		//IL_0095: Unknown result type (might be due to invalid IL or missing references)
		//IL_009c: Unknown result type (might be due to invalid IL or missing references)
		//IL_00a1: Unknown result type (might be due to invalid IL or missing references)
		if (!CheckValid())
		{
			return;
		}
		if (lastKnownPositionOverride.HasValue)
		{
			lastKnownPosition = lastKnownPositionOverride.Value;
		}
		else if (isVisible)
		{
			lastKnownPosition = ((Component)targetEntity).transform.position;
		}
		if (isVisible)
		{
			timeNotVisible = 0f;
			timeVisible += deltaTime;
			Vector3 val = ((Component)targetEntity).transform.forward;
			Vector3 position = ((Component)targetEntity).transform.position;
			if (targetEntity.ToNonNpcPlayer(out var player))
			{
				val = player.eyes.HeadForward();
				position = player.eyes.position;
			}
			Vector3 val2 = ((Component)baseEntity).transform.position - position;
			float num = Mathf.Acos(Vector3.Dot(val, ((Vector3)(ref val2)).normalized)) * 57.29578f * 2f;
			bool num2 = num < AI.watchedAngle;
			if (num2)
			{
				timeNotWatched = 0f;
				timeWatched += deltaTime;
			}
			else
			{
				timeWatched = 0f;
				timeNotWatched += deltaTime;
			}
			if (num2 && (Object)(object)player != (Object)null && player.modelState.aiming && num < AI.aimedAtAngle && !(player.GetHeldEntity() is BaseMelee { canScareAiWhenAimed: false }))
			{
				timeNotAimedAt = 0f;
				timeAimedAt += deltaTime;
			}
			else
			{
				timeAimedAt = 0f;
				timeNotAimedAt += deltaTime;
			}
		}
		else
		{
			timeVisible = 0f;
			timeNotVisible += deltaTime;
			timeWatched = 0f;
			timeNotWatched += deltaTime;
			timeAimedAt = 0f;
			timeNotAimedAt += deltaTime;
		}
	}
}


using System.Collections.Generic;
using Facepunch;
using Rust.Ai.Gen2;
using UnityEngine.Assertions;

public class LockState
{
	public class LockHandle
	{
	}

	private HashSet<LockHandle> locks = new HashSet<LockHandle>();

	public bool IsLocked => locks.Count > 0;

	public LockHandle AddLock()
	{
		LockHandle lockHandle = Pool.Get<LockHandle>();
		locks.Add(lockHandle);
		return lockHandle;
	}

	public bool RemoveLock(ref LockHandle handle)
	{
		if (handle == null)
		{
			return false;
		}
		bool num = locks.Remove(handle);
		Assert.IsTrue(num, "Trying to remove a lock that doesn't exist");
		if (num)
		{
			Pool.FreeUnsafe<LockHandle>(ref handle);
		}
		return num;
	}
}


public class LockHandle
{
}


using UnityEngine;

public static class BaseEntityTargettingExtensions
{
	public static bool InSameNpcTeam(this BaseEntity entity, BaseEntity other)
	{
		if ((Object)(object)entity == (Object)null || (Object)(object)other == (Object)null)
		{
			return false;
		}
		return ((object)entity).GetType() == ((object)other).GetType();
	}

	public static bool IsNonNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return !basePlayer.IsNpc;
		}
		return false;
	}

	public static bool IsNpcPlayer(this BaseEntity entity)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer != (Object)null)
		{
			return basePlayer.IsNpc;
		}
		return false;
	}

	public static bool ToNonNpcPlayer(this BaseEntity entity, out BasePlayer player)
	{
		BasePlayer basePlayer = entity.ToPlayer();
		if ((Object)(object)basePlayer == (Object)null || basePlayer.IsNpc)
		{
			player = null;
			return false;
		}
		player = basePlayer;
		return true;
	}
}


public static class PlayerMenuAnimation
{
	public enum Layers
	{
		Movement
	}

	public static class Groups
	{
	}
}


public enum Layers
{
	Movement
}


public static class Groups
{
}


using System;
using AntiHackJobs;
using BasePlayerJobs;
using CoarseQueryGridJobs;
using CompanionServer.Cameras;
using Facepunch.MarchingCubes;
using Facepunch.NativeMeshSimplification;
using GamePhysicsJobs;
using Instancing;
using Rust.Water5;
using TerrainHeightMapJobs;
using TerrainTexturingJobs;
using TerrainTopologyMapJobs;
using TerrainWaterMapJobs;
using Unity.Jobs;
using UnityEngine;
using UnityEngine.Jobs;
using UtilityJobs;
using WaterLevelJobs;

[DOTSCompilerGenerated]
internal class __JobReflectionRegistrationOutput__1221673671587648887
{
	public static void CreateJobReflectionData()
	{
		try
		{
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionGatherJob>();
			IJobExtensions.EarlyJobInit<FishShoal.FishCollisionProcessJob>();
			IJobParallelForExtensions.EarlyJobInit<FishShoal.FishUpdateJob>();
			IJobExtensions.EarlyJobInit<FishShoal.KillFish>();
			IJobParallelForTransformExtensions.EarlyJobInit<TransformLineRenderer.LineRendererUpdateJob>();
			IJobExtensions.EarlyJobInit<AddAndBlurSphereJob>();
			IJobForExtensions.EarlyJobInit<BoxBlur3DJob>();
			IJobExtensions.EarlyJobInit<BoxBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<BoxBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurCylinderJob>();
			IJobExtensions.EarlyJobInit<CarveAndBlurSphereJob>();
			IJobExtensions.EarlyJobInit<CleanFloatingIslandsJob>();
			IJobParallelForExtensions.EarlyJobInit<Hopper.FillRaycastJob>();
			IJobExtensions.EarlyJobInit<CalculatePathBetweenGridsJob>();
			IJobExtensions.EarlyJobInit<PostCullingJob>();
			IJobExtensions.EarlyJobInit<GenerateAscSeqListJob>();
			IJobExtensions.EarlyJobInit<InvertIndexListJob>();
			IJobExtensions.EarlyJobInit<RaycastSamplePositionsJob>();
			IJobExtensions.EarlyJobInit<RaycastBufferSetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRaySetupJob>();
			IJobParallelForExtensions.EarlyJobInit<RaycastRayProcessingJob>();
			IJobExtensions.EarlyJobInit<RaycastOutputCompressJob>();
			IJobExtensions.EarlyJobInit<RaycastColliderProcessingJob>();
			IJobExtensions.EarlyJobInit<GatherPlayersWithTicksJob>();
			IJobExtensions.EarlyJobInit<BuildLayerMasksJob>();
			IJobExtensions.EarlyJobInit<GatherHitIndicesJob>();
			IJobExtensions.EarlyJobInit<BuildBatchLookupMapJob>();
			IJobExtensions.EarlyJobInit<GatherNoClipBatchesJob>();
			IJobExtensions.EarlyJobInit<FindValidIndicesJob>();
			IJobExtensions.EarlyJobInit<PreCullingJob>();
			IJobExtensions.EarlyJobInit<GetCoarseDistsToShoreJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByPosJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJob>();
			IJobExtensions.EarlyJobInit<GetHeightByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightByIndexJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByPosJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJob>();
			IJobExtensions.EarlyJobInit<GetTopologyRadiusJob>();
			IJobExtensions.EarlyJobInit<GetTopologyByUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GetTopologyByIndexJob>();
			IJobExtensions.EarlyJobInit<GetHeightsFastJobIndirect>();
			IJobExtensions.EarlyJobInit<GetHeightsJob>();
			IJobExtensions.EarlyJobInit<TerrainHeightMapJobs.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckPosRadJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJob>();
			IJobExtensions.EarlyJobInit<CheckPosRadBatchJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckBoundsJob>();
			IJobExtensions.EarlyJobInit<CheckBoundsJobIndirect>();
			IJobExtensions.EarlyJobInit<CheckRayJob>();
			IJobExtensions.EarlyJobInit<ToUVJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherWavesIndicesJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyMaxHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SelectMaxWaterLevelJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcCenterJobIndirect>();
			IJobExtensions.EarlyJobInit<InitialValidateInfoJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherValidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherInvalidInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<SetupHeadQueryJobIndirect>();
			IJobExtensions.EarlyJobInit<ApplyHeadQueryResultsJobIndirect>();
			IJobExtensions.EarlyJobInit<ResolveWaterInfosJobIndirect>();
			IJobExtensions.EarlyJobInit<UpdateWaterCache>();
			IJobExtensions.EarlyJobInit<GatherPosToValidateJob>();
			IJobParallelForTransformExtensions.EarlyJobInit<RecacheTransforms>();
			IJobExtensions.EarlyJobInit<CalcWaterFactorsJobIndirect>();
			IJobExtensions.EarlyJobInit<GetWaterFactorsParamsJobIndirect>();
			IJobExtensions.EarlyJobInit<CalcMidpoingJob>();
			IJobExtensions.EarlyJobInit<CheckHitsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapCapsuleCommandsJob>();
			IJobExtensions.EarlyJobInit<FindSphereCmdsInCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateSphereCmdsFromCapsuleCmdsJob>();
			IJobExtensions.EarlyJobInit<GenerateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<ValidateOverlapSphereCommandsJob>();
			IJobExtensions.EarlyJobInit<RemoveLayerMaskJob>();
			IJobExtensions.EarlyJobInit<CountRaycastHitsJobs>();
			IJobExtensions.EarlyJobInit<ScatterColliderHitsJob>();
			IJobExtensions.EarlyJobInit<CopyBackJob>();
			IJobExtensions.EarlyJobInit<PopulateArraysJob>();
			IJobExtensions.EarlyJobInit<SimplifyMeshJob>();
			IJobParallelForExtensions.EarlyJobInit<BakePhysicsMeshesJob>();
			IJobExtensions.EarlyJobInit<CleanupDuplicateVerticesJob>();
			IJobExtensions.EarlyJobInit<MarchJob>();
			IJobExtensions.EarlyJobInit<GetHeightBatchedJob>();
			IJobExtensions.EarlyJobInit<Rust.Water5.GetHeightsJobIndirect>();
			IJobExtensions.EarlyJobInit<GatherJob<OverlapCapsuleCommand>>();
			IJobExtensions.EarlyJobInit<FillJob<float>>();
			IJobExtensions.EarlyJobInit<FillJob<int>>();
			IJobExtensions.EarlyJobInit<FillJob<bool>>();
			IJobExtensions.EarlyJobInit<GatherJob<Vector3>>();
			IJobExtensions.EarlyJobInit<GatherJob<float>>();
			IJobExtensions.EarlyJobInit<GatherJob<int>>();
		}
		catch (Exception ex)
		{
			EarlyInitHelpers.JobReflectionDataCreationFailed(ex);
		}
	}

	[RuntimeInitializeOnLoadMethod(/*Could not decode attribute arguments.*/)]
	public static void EarlyInit()
	{
		CreateJobReflectionData();
	}
}


