using UnityEngine;

public class BaseFollowPathState : BasicAIState
{
	private AIMovePointPath path;

	private StateStatus status;

	private AIMovePoint currentTargetPoint;

	private float currentWaitTime;

	private AIMovePointPath.PathDirection pathDirection;

	private int currentNodeIndex;

	public BaseFollowPathState()
		: base(AIState.FollowPath)
	{
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		status = StateStatus.Error;
		brain.Navigator.SetBrakingEnabled(flag: false);
		path = brain.Navigator.Path;
		if (path == null)
		{
			AIInformationZone forPoint = AIInformationZone.GetForPoint(entity.ServerPosition);
			if (forPoint == null)
			{
				return;
			}
			path = forPoint.GetNearestPath(entity.ServerPosition);
			if (path == null)
			{
				return;
			}
		}
		currentNodeIndex = path.FindNearestPointIndex(entity.ServerPosition);
		currentTargetPoint = path.FindNearestPoint(entity.ServerPosition);
		if (!(currentTargetPoint == null))
		{
			status = StateStatus.Running;
			currentWaitTime = 0f;
			brain.Navigator.SetDestination(currentTargetPoint.transform.position, BaseNavigator.NavigationSpeed.Slow);
		}
	}

	public override void StateLeave(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateLeave(brain, entity);
		brain.Navigator.ClearFacingDirectionOverride();
		brain.Navigator.SetBrakingEnabled(flag: true);
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		if (status == StateStatus.Error)
		{
			return status;
		}
		if (!brain.Navigator.Moving)
		{
			if (currentWaitTime <= 0f && currentTargetPoint.HasLookAtPoints())
			{
				Transform randomLookAtPoint = currentTargetPoint.GetRandomLookAtPoint();
				if (randomLookAtPoint != null)
				{
					brain.Navigator.SetFacingDirectionOverride(Vector3Ex.Direction2D(randomLookAtPoint.transform.position, entity.ServerPosition));
				}
			}
			if (currentTargetPoint.WaitTime > 0f)
			{
				currentWaitTime += delta;
			}
			if (currentTargetPoint.WaitTime <= 0f || currentWaitTime >= currentTargetPoint.WaitTime)
			{
				brain.Navigator.ClearFacingDirectionOverride();
				currentWaitTime = 0f;
				int num = currentNodeIndex;
				currentNodeIndex = path.GetNextPointIndex(currentNodeIndex, ref pathDirection);
				currentTargetPoint = path.GetPointAtIndex(currentNodeIndex);
				if ((!(currentTargetPoint != null) || currentNodeIndex != num) && (currentTargetPoint == null || !brain.Navigator.SetDestination(currentTargetPoint.transform.position, BaseNavigator.NavigationSpeed.Slow)))
				{
					return StateStatus.Error;
				}
			}
		}
		else if (currentTargetPoint != null)
		{
			brain.Navigator.SetDestination(currentTargetPoint.transform.position, BaseNavigator.NavigationSpeed.Slow, 1f);
		}
		return StateStatus.Running;
	}
}
