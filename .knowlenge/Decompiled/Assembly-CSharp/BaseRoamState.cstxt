using UnityEngine;

public class BaseRoamState : BasicAIState
{
	private float nextRoamPositionTime = -1f;

	private float lastDestinationTime;

	public BaseRoamState()
		: base(AIState.Roam)
	{
	}

	public override float GetWeight()
	{
		return 0f;
	}

	public override void StateEnter(BaseAIBrain brain, BaseEntity entity)
	{
		base.StateEnter(brain, entity);
		nextRoamPositionTime = -1f;
		lastDestinationTime = Time.time;
	}

	public virtual Vector3 GetDestination()
	{
		return Vector3.zero;
	}

	public virtual Vector3 GetForwardDirection()
	{
		return Vector3.forward;
	}

	public virtual void SetDestination(Vector3 destination)
	{
	}

	public override void DrawGizmos()
	{
		base.DrawGizmos();
		brain.PathFinder.DebugDraw();
	}

	public virtual Vector3 GetRoamAnchorPosition()
	{
		if (brain.Navigator.MaxRoamDistanceFromHome > -1f)
		{
			return brain.Events.Memory.Position.Get(4);
		}
		return brain.GetBaseEntity().transform.position;
	}

	public override StateStatus StateThink(float delta, BaseAIBrain brain, BaseEntity entity)
	{
		base.StateThink(delta, brain, entity);
		bool flag = Time.time - lastDestinationTime > 25f;
		if ((Vector3.Distance(GetDestination(), entity.transform.position) < 2f || flag) && nextRoamPositionTime == -1f)
		{
			nextRoamPositionTime = Time.time + Random.Range(5f, 10f);
		}
		if (nextRoamPositionTime != -1f && Time.time > nextRoamPositionTime)
		{
			AIMovePoint bestRoamPoint = brain.PathFinder.GetBestRoamPoint(GetRoamAnchorPosition(), entity.ServerPosition, GetForwardDirection(), brain.Navigator.MaxRoamDistanceFromHome, brain.Navigator.BestRoamPointMaxDistance);
			if ((bool)bestRoamPoint)
			{
				float num = Vector3.Distance(bestRoamPoint.transform.position, entity.transform.position) / 1.5f;
				bestRoamPoint.SetUsedBy(entity, num + 11f);
			}
			lastDestinationTime = Time.time;
			Vector3 insideUnitSphere = Random.insideUnitSphere;
			insideUnitSphere.y = 0f;
			insideUnitSphere.Normalize();
			Vector3 destination = ((bestRoamPoint == null) ? entity.transform.position : (bestRoamPoint.transform.position + insideUnitSphere * bestRoamPoint.radius));
			SetDestination(destination);
			nextRoamPositionTime = -1f;
		}
		return StateStatus.Running;
	}
}
