using System;
using System.Runtime.CompilerServices;
using Unity.Burst;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

[BurstCompile(FloatMode = FloatMode.Fast, OptimizeFor = OptimizeFor.Performance, DisableSafetyChecks = true)]
public struct CalculatePathBetweenGridsJob : IJob
{
	public ServerOcclusion.SubGrid Grid1;

	public ServerOcclusion.SubGrid Grid2;

	public NativeReference<bool> PathBlocked;

	[ReadOnly]
	[NativeDisableContainerSafetyRestriction]
	public NativeArray<NativeBitArray> OcclusionSubGridBlocked;

	public int server_occlusion_blocked_grid_threshold;

	public int server_occlusion_neighbour_threshold;

	public bool server_occlusion_use_neighbour_thresholds;

	public int3 ChunkCount;

	public int3 SubChunkCount;

	private static readonly int3[] neighbours = new int3[6]
	{
		math.int3(1, 0, 0),
		math.int3(-1, 0, 0),
		math.int3(0, 1, 0),
		math.int3(0, -1, 0),
		math.int3(0, 0, 1),
		math.int3(0, 0, -1)
	};

	public void Execute()
	{
		int num = 0;
		int neighboursChecked = 0;
		PathBlocked.Value = false;
		int num2 = Grid1.x;
		int num3 = Grid1.y;
		int num4 = Grid1.z;
		int x = Grid2.x;
		int y = Grid2.y;
		int z = Grid2.z;
		int num5 = x - Grid1.x;
		int num6 = y - Grid1.y;
		int num7 = z - Grid1.z;
		int num8 = Mathf.Abs(num5);
		int num9 = Mathf.Abs(num6);
		int num10 = Mathf.Abs(num7);
		int num11 = num8 << 1;
		int num12 = num9 << 1;
		int num13 = num10 << 1;
		int num14 = ((num5 >= 0) ? 1 : (-1));
		int num15 = ((num6 >= 0) ? 1 : (-1));
		int num16 = ((num7 >= 0) ? 1 : (-1));
		int3 nStep = -math.int3(num14, num15, num16);
		int num17;
		int num18;
		if (num8 >= num9 && num8 >= num10)
		{
			num17 = num12 - num8;
			num18 = num13 - num8;
			for (int i = 0; i < num8; i++)
			{
				ServerOcclusion.SubGrid grid = new ServerOcclusion.SubGrid(num2, num3, num4);
				if (!AddToGridArea(grid, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
				{
					PathBlocked.Value = true;
					break;
				}
				if (num17 > 0)
				{
					num3 += num15;
					num17 -= num11;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num11;
				}
				num17 += num12;
				num18 += num13;
				num2 += num14;
			}
			return;
		}
		if (num9 >= num8 && num9 >= num10)
		{
			num17 = num11 - num9;
			num18 = num13 - num9;
			for (int j = 0; j < num9; j++)
			{
				ServerOcclusion.SubGrid grid2 = new ServerOcclusion.SubGrid(num2, num3, num4);
				if (!AddToGridArea(grid2, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
				{
					PathBlocked.Value = true;
					break;
				}
				if (num17 > 0)
				{
					num2 += num14;
					num17 -= num12;
				}
				if (num18 > 0)
				{
					num4 += num16;
					num18 -= num12;
				}
				num17 += num11;
				num18 += num13;
				num3 += num15;
			}
			return;
		}
		num17 = num12 - num10;
		num18 = num11 - num10;
		for (int k = 0; k < num10; k++)
		{
			ServerOcclusion.SubGrid grid3 = new ServerOcclusion.SubGrid(num2, num3, num4);
			if (!AddToGridArea(grid3, nStep, ref neighboursChecked) && ++num > server_occlusion_blocked_grid_threshold)
			{
				PathBlocked.Value = true;
				break;
			}
			if (num17 > 0)
			{
				num3 += num15;
				num17 -= num13;
			}
			if (num18 > 0)
			{
				num2 += num14;
				num18 -= num13;
			}
			num17 += num12;
			num18 += num11;
			num4 += num16;
		}
	}

	private bool IsValidGrid(int3 p)
	{
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= ChunkCount.x || p.y >= ChunkCount.y || p.z >= ChunkCount.z)
		{
			return false;
		}
		return true;
	}

	private bool IsValidSubGrid(int3 p)
	{
		if (p.x < 0 || p.y < 0 || p.z < 0)
		{
			return false;
		}
		if (p.x >= SubChunkCount.x || p.y >= SubChunkCount.y || p.z >= SubChunkCount.z)
		{
			return false;
		}
		return true;
	}

	private bool AddNeighbours(ServerOcclusion.SubGrid grid, int3 nStep)
	{
		int3 @int = math.int3(grid.x, grid.y, grid.z);
		for (int i = 0; i < neighbours.Length; i++)
		{
			int3 int2 = neighbours[i];
			if (!math.any(int2 == nStep))
			{
				int3 p = @int + int2;
				if (IsValidSubGrid(p) && !IsBlocked(p))
				{
					return true;
				}
			}
		}
		return false;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private int GetGridIndex(int x, int y, int z)
	{
		return z * ChunkCount.x * ChunkCount.y + y * ChunkCount.z + x;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool IsBlocked(ServerOcclusion.SubGrid grid)
	{
		return IsBlocked(grid.x, grid.y, grid.z);
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private bool IsBlocked(int3 p)
	{
		return IsBlocked(p.x, p.y, p.z);
	}

	private bool IsBlocked(int x, int y, int z)
	{
		int result;
		int x2 = Math.DivRem(x, 8, out result);
		int result2;
		int y2 = Math.DivRem(y, 8, out result2);
		int result3;
		int z2 = Math.DivRem(z, 8, out result3);
		int gridIndex = GetGridIndex(x2, y2, z2);
		NativeBitArray nativeBitArray = (IsValidGrid(math.int3(x2, y2, z2)) ? OcclusionSubGridBlocked[gridIndex] : default(NativeBitArray));
		int pos = result3 * 8 * 8 + result2 * 8 + result;
		if (nativeBitArray.IsCreated)
		{
			return nativeBitArray.IsSet(pos);
		}
		return false;
	}

	private bool AddToGridArea(ServerOcclusion.SubGrid grid, int3 nStep, ref int neighboursChecked)
	{
		if (!IsBlocked(grid))
		{
			return true;
		}
		if (!server_occlusion_use_neighbour_thresholds || ++neighboursChecked <= server_occlusion_neighbour_threshold)
		{
			return AddNeighbours(grid, nStep);
		}
		return false;
	}
}
