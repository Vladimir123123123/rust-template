using System.Collections.Generic;
using Rust;

public class DamageTypeList
{
	public float[] types = new float[26];

	public void Set(DamageType index, float amount)
	{
		types[(int)index] = amount;
	}

	public float Get(DamageType index)
	{
		return types[(int)index];
	}

	public void Add(DamageType index, float amount)
	{
		Set(index, Get(index) + amount);
	}

	public void Scale(DamageType index, float amount)
	{
		Set(index, Get(index) * amount);
	}

	public bool Has(DamageType index)
	{
		return Get(index) > 0f;
	}

	public float Total()
	{
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2))
			{
				num += num2;
			}
		}
		return num;
	}

	public void Clear()
	{
		for (int i = 0; i < types.Length; i++)
		{
			types[i] = 0f;
		}
	}

	public void Add(List<DamageTypeEntry> entries)
	{
		foreach (DamageTypeEntry entry in entries)
		{
			Add(entry.type, entry.amount);
		}
	}

	public void ScaleAll(float amount)
	{
		for (int i = 0; i < types.Length; i++)
		{
			Scale((DamageType)i, amount);
		}
	}

	public DamageType GetMajorityDamageType()
	{
		int result = 0;
		float num = 0f;
		for (int i = 0; i < types.Length; i++)
		{
			float num2 = types[i];
			if (!float.IsNaN(num2) && !float.IsInfinity(num2) && !(num2 < num))
			{
				result = i;
				num = num2;
			}
		}
		return (DamageType)result;
	}

	public bool Contains(DamageType damage)
	{
		if (damage < DamageType.Generic || (int)damage >= types.Length)
		{
			return false;
		}
		float num = types[(int)damage];
		if (!float.IsNaN(num) && !float.IsInfinity(num))
		{
			return num > 0f;
		}
		return false;
	}

	public bool IsMeleeType()
	{
		return GetMajorityDamageType().IsMeleeType();
	}

	public bool IsBleedCausing()
	{
		return GetMajorityDamageType().IsBleedCausing();
	}

	public bool IsConsideredAnAttack()
	{
		return GetMajorityDamageType().IsConsideredAnAttack();
	}

	public DamageTypeList Clone()
	{
		DamageTypeList damageTypeList = new DamageTypeList();
		for (int i = 0; i < types.Length; i++)
		{
			damageTypeList.types[i] = types[i];
		}
		return damageTypeList;
	}
}
