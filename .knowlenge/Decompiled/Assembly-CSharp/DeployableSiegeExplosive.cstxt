using Facepunch;
using Rust;
using UnityEngine;

public class DeployableSiegeExplosive : BaseCombatEntity, IIgniteable, ISplashable
{
	public GameObjectRef ExplosionEffect;

	public GameObjectRef ExplosionImpact;

	public Vector3 EffectOffset;

	public Transform ExplosionSpawnPoint;

	public const Flags Lit = Flags.Reserved1;

	public float MinimumFuseTime = 3f;

	public float MaximumFuseTime = 10f;

	public float NeighbourExplodeRadius = 2f;

	public override void OnDeployed(BaseEntity parent, BasePlayer deployedBy, Item fromItem)
	{
		base.OnDeployed(parent, deployedBy, fromItem);
		creatorEntity = deployedBy;
	}

	public override void Hurt(HitInfo info)
	{
		if (!base.isClient && !HasFlag(Flags.Reserved1))
		{
			info.damageTypes.ScaleAll(0f);
			base.Hurt(info);
			SetFlag(Flags.Reserved1, b: true);
			Invoke(ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
		}
	}

	public override void PostServerLoad()
	{
		base.PostServerLoad();
		if (HasFlag(Flags.Reserved1))
		{
			Invoke(ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
		}
	}

	private void ActuallyExplode()
	{
		if (ExplosionEffect.isValid)
		{
			Vector3 position = ExplosionSpawnPoint.position;
			BaseEntity baseEntity = GameManager.server.CreateEntity(ExplosionEffect.resourcePath, position);
			ServerProjectile component = baseEntity.GetComponent<ServerProjectile>();
			component.InitializeVelocity(Vector3.up);
			baseEntity.Spawn();
			if (component.TryGetComponent<TimedExplosive>(out var component2))
			{
				component2.creatorEntity = creatorEntity;
				component2.Explode();
			}
			if (ExplosionImpact.isValid)
			{
				Effect.server.Run(ExplosionImpact.resourcePath, position + EffectOffset);
			}
			using PooledList<DeployableSiegeExplosive> pooledList = Pool.Get<PooledList<DeployableSiegeExplosive>>();
			Vis.Entities(position, NeighbourExplodeRadius, pooledList, 256);
			foreach (DeployableSiegeExplosive item in pooledList)
			{
				if (item.isServer && !item.HasFlag(Flags.Reserved1) && CanSee(position, item.ExplosionSpawnPoint.position))
				{
					item.Hurt(3f, DamageType.Heat, this);
				}
			}
		}
		Kill();
	}

	public void Ignite(Vector3 fromPos)
	{
		SetFlag(Flags.Reserved1, b: true);
		Invoke(ActuallyExplode, Random.Range(MinimumFuseTime, MaximumFuseTime));
	}

	public bool CanIgnite()
	{
		return !HasFlag(Flags.Reserved1);
	}

	public bool WantsSplash(ItemDefinition splashType, int amount)
	{
		return HasFlag(Flags.Reserved1);
	}

	public int DoSplash(ItemDefinition splashType, int amount)
	{
		SetFlag(Flags.Reserved1, b: false);
		CancelInvoke(ActuallyExplode);
		return 0;
	}

	private void OnGroundMissing()
	{
		ActuallyExplode();
	}

	public override bool CanPickup(BasePlayer player)
	{
		if (!HasFlag(Flags.Reserved1))
		{
			return base.CanPickup(player);
		}
		return false;
	}
}
