using System;
using System.Collections.Generic;
using Spatial;
using UnityEngine;

public class EntityTree
{
	public Grid<BaseEntity> Grid;

	public Grid<BasePlayer> PlayerGrid;

	public Grid<BaseEntity> BrainGrid;

	public EntityTree(float worldSize)
	{
		Grid = new Grid<BaseEntity>(32, worldSize);
		PlayerGrid = new Grid<BasePlayer>(32, worldSize);
		BrainGrid = new Grid<BaseEntity>(32, worldSize);
	}

	public void Add(BaseEntity ent)
	{
		Vector3 position = ent.transform.position;
		Grid.Add(ent, position.x, position.z);
	}

	public void AddPlayer(BasePlayer player)
	{
		Vector3 position = player.transform.position;
		PlayerGrid.Add(player, position.x, position.z);
	}

	public void AddBrain(BaseEntity entity)
	{
		Vector3 position = entity.transform.position;
		BrainGrid.Add(entity, position.x, position.z);
	}

	public void Remove(BaseEntity ent, bool isPlayer = false)
	{
		Grid.Remove(ent);
		if (isPlayer)
		{
			BasePlayer basePlayer = ent as BasePlayer;
			if (basePlayer != null)
			{
				PlayerGrid.Remove(basePlayer);
			}
		}
	}

	public void RemovePlayer(BasePlayer player)
	{
		PlayerGrid.Remove(player);
	}

	public void RemoveBrain(BaseEntity entity)
	{
		if (!(entity == null))
		{
			BrainGrid.Remove(entity);
		}
	}

	public void Move(BaseEntity ent)
	{
		Vector3 position = ent.transform.position;
		Grid.Move(ent, position.x, position.z);
		BasePlayer basePlayer = ent as BasePlayer;
		if (basePlayer != null)
		{
			MovePlayer(basePlayer);
		}
		if (ent.HasBrain)
		{
			MoveBrain(ent);
		}
	}

	public void MovePlayer(BasePlayer player)
	{
		Vector3 position = player.transform.position;
		PlayerGrid.Move(player, position.x, position.z);
	}

	public void MoveBrain(BaseEntity entity)
	{
		Vector3 position = entity.transform.position;
		BrainGrid.Move(entity, position.x, position.z);
	}

	public void GetInSphere<T>(Vector3 position, float distance, List<T> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter) where T : BaseEntity
	{
		using (TimeWarning.New("GetInSphereList"))
		{
			Grid.Query(position.x, position.z, distance, results);
			if (distanceCheckType != 0)
			{
				NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
			}
		}
	}

	public int GetInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		int broadCount = Grid.Query(position.x, position.z, distance, results, filter);
		return NarrowPhaseReduce(position, distance, results, broadCount);
	}

	public int GetInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		return Grid.Query(position.x, position.z, distance, results, filter);
	}

	public void GetPlayersInSphere(Vector3 position, float distance, List<BasePlayer> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter, bool includeHumanoidNpcs = false)
	{
		using (TimeWarning.New("GetPlayersInSphereList"))
		{
			PlayerGrid.Query(position.x, position.z, distance, results);
			if (!includeHumanoidNpcs)
			{
				for (int num = results.Count - 1; num >= 0; num--)
				{
					if (results[num].IsNpc)
					{
						results.RemoveAt(num);
					}
				}
			}
			if (distanceCheckType != 0)
			{
				NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
			}
		}
	}

	public int GetPlayersInSphere(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
	{
		int broadCount = PlayerGrid.Query(position.x, position.z, distance, results, filter);
		return NarrowPhaseReduce(position, distance, results, broadCount);
	}

	public int GetPlayersInSphereFast(Vector3 position, float distance, BasePlayer[] results, Func<BasePlayer, bool> filter = null)
	{
		return PlayerGrid.Query(position.x, position.z, distance, results, filter);
	}

	public void GetBrainsInSphere<T>(Vector3 position, float distance, List<T> results, bool filterPastDistance = true) where T : BaseEntity
	{
		using (TimeWarning.New("GetBrainsInSphereList"))
		{
			BrainGrid.Query(position.x, position.z, distance, results);
			if (filterPastDistance)
			{
				NarrowPhaseReduce(position, distance, results);
			}
		}
	}

	public int GetBrainsInSphere(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		int broadCount = BrainGrid.Query(position.x, position.z, distance, results, filter);
		return NarrowPhaseReduce(position, distance, results, broadCount);
	}

	public int GetBrainsInSphereFast(Vector3 position, float distance, BaseEntity[] results, Func<BaseEntity, bool> filter = null)
	{
		return BrainGrid.Query(position.x, position.z, distance, results, filter);
	}

	public void GetPlayersAndBrainsInSphere(Vector3 position, float distance, List<BaseEntity> results, DistanceCheckType distanceCheckType = DistanceCheckType.OnlyCenter)
	{
		using (TimeWarning.New("GetPlayersAndBrainsInSphereList"))
		{
			PlayerGrid.Query(position.x, position.z, distance, results);
			BrainGrid.Query(position.x, position.z, distance, results);
			if (distanceCheckType != 0)
			{
				NarrowPhaseReduce(position, distance, results, distanceCheckType == DistanceCheckType.OnlyCenter);
			}
		}
	}

	private int NarrowPhaseReduce<T>(Vector3 position, float radius, T[] results, int broadCount) where T : BaseEntity
	{
		using (TimeWarning.New("NarrowPhaseReduce"))
		{
			int num = broadCount;
			float num2 = radius * radius;
			for (int i = 0; i < num; i++)
			{
				if ((results[i].WorldSpaceBounds().ClosestPoint(position) - position).sqrMagnitude > num2)
				{
					results[i] = results[num - 1];
					num--;
					i--;
				}
			}
			return num;
		}
	}

	private static void NarrowPhaseReduce<T>(Vector3 position, float radius, List<T> results, bool onlyConsiderCenter = true) where T : BaseEntity
	{
		using (TimeWarning.New("NarrowPhaseReduceList"))
		{
			float num = radius * radius;
			for (int num2 = results.Count - 1; num2 >= 0; num2--)
			{
				T val = results[num2];
				if (((onlyConsiderCenter ? val.transform.position : val.WorldSpaceBounds().ClosestPoint(position)) - position).sqrMagnitude > num)
				{
					results.RemoveAt(num2);
				}
			}
		}
	}

	private static bool IsEntityInRadius<T>(Vector3 position, float radiusSq, T entity) where T : BaseEntity
	{
		using (TimeWarning.New("IsEntityInRadius"))
		{
			return (entity.WorldSpaceBounds().ClosestPoint(position) - position).sqrMagnitude < radiusSq;
		}
	}
}
