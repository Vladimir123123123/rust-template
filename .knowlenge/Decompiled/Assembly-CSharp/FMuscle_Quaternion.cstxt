using System;
using System.Collections;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class FMuscle_Quaternion
{
	[HideInInspector]
	public Quaternion DesiredRotation;

	private FMuscle_Float x;

	private FMuscle_Float y;

	private FMuscle_Float z;

	private FMuscle_Float w;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Acceleration = 5000f;

	[FPD_Suffix(0f, 10000f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float AccelerationLimit = 1000f;

	[FPD_Suffix(0f, 50f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float Damping = 10f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float BrakePower = 0.2f;

	public Quaternion ProceduralRotation { get; private set; }

	public bool IsCorrect => x != null;

	public void Initialize(Quaternion initRotation)
	{
		x = new FMuscle_Float();
		y = new FMuscle_Float();
		z = new FMuscle_Float();
		w = new FMuscle_Float();
		x.Initialize(initRotation.x);
		y.Initialize(initRotation.y);
		z.Initialize(initRotation.z);
		w.Initialize(initRotation.w);
		ProceduralRotation = initRotation;
	}

	public bool IsWorking()
	{
		if (!x.IsWorking() && !y.IsWorking() && !z.IsWorking())
		{
			return w.IsWorking();
		}
		return true;
	}

	public void Push(Quaternion value)
	{
		x.Push(value.x);
		y.Push(value.y);
		z.Push(value.z);
		w.Push(value.w);
	}

	public void Push(float v)
	{
		x.Push(v);
		y.Push(v);
		z.Push(v);
		w.Push(v);
	}

	public void Push(Quaternion value, float multiply)
	{
		x.Push(value.x * multiply);
		y.Push(value.y * multiply);
		z.Push(value.z * multiply);
		w.Push(value.w * multiply);
	}

	public void Update(float delta, Quaternion desired, float acceleration, float accelerationLimit, float damping, float brakePower)
	{
		x.Update(delta, ProceduralRotation.x, desired.x, acceleration, accelerationLimit, damping, brakePower);
		y.Update(delta, ProceduralRotation.y, desired.y, acceleration, accelerationLimit, damping, brakePower);
		z.Update(delta, ProceduralRotation.z, desired.z, acceleration, accelerationLimit, damping, brakePower);
		w.Update(delta, ProceduralRotation.w, desired.w, acceleration, accelerationLimit, damping, brakePower);
		ProceduralRotation = new Quaternion(x.OutValue, y.OutValue, z.OutValue, w.OutValue);
	}

	public void Update(float delta, Quaternion desired)
	{
		x.Update(delta, ProceduralRotation.x, desired.x, Acceleration, AccelerationLimit, Damping, BrakePower);
		y.Update(delta, ProceduralRotation.y, desired.y, Acceleration, AccelerationLimit, Damping, BrakePower);
		z.Update(delta, ProceduralRotation.z, desired.z, Acceleration, AccelerationLimit, Damping, BrakePower);
		w.Update(delta, ProceduralRotation.w, desired.w, Acceleration, AccelerationLimit, Damping, BrakePower);
		ProceduralRotation = new Quaternion(x.OutValue, y.OutValue, z.OutValue, w.OutValue);
	}

	public void UpdateEnsured(float delta, Quaternion desired)
	{
		Update(delta, EnsureQuaternionContinuity(ProceduralRotation, desired));
	}

	public static Quaternion EnsureQuaternionContinuity(Quaternion latestRot, Quaternion targetRot)
	{
		Quaternion result = new Quaternion(0f - targetRot.x, 0f - targetRot.y, 0f - targetRot.z, 0f - targetRot.w);
		Quaternion b = new Quaternion(Mathf.LerpUnclamped(latestRot.x, targetRot.x, 0.5f), Mathf.LerpUnclamped(latestRot.y, targetRot.y, 0.5f), Mathf.LerpUnclamped(latestRot.z, targetRot.z, 0.5f), Mathf.LerpUnclamped(latestRot.w, targetRot.w, 0.5f));
		Quaternion b2 = new Quaternion(Mathf.LerpUnclamped(latestRot.x, result.x, 0.5f), Mathf.LerpUnclamped(latestRot.y, result.y, 0.5f), Mathf.LerpUnclamped(latestRot.z, result.z, 0.5f), Mathf.LerpUnclamped(latestRot.w, result.w, 0.5f));
		float num = Quaternion.Angle(latestRot, b);
		if (!(Quaternion.Angle(latestRot, b2) < num))
		{
			return targetRot;
		}
		return result;
	}

	public IEnumerator PushImpulseCoroutine(Quaternion power, float duration, bool fadeOutPower = false, float delay = 0f)
	{
		if (delay > 0f)
		{
			yield return new WaitForSeconds(delay);
		}
		float elapsed = 0f;
		Push(0.001f);
		while (elapsed / duration < 1f)
		{
			if (!fadeOutPower)
			{
				Push(power, Time.deltaTime * 60f);
			}
			else
			{
				Push(power, (1f - elapsed / duration) * Time.deltaTime * 60f);
			}
			elapsed += Time.deltaTime;
			yield return null;
		}
	}

	public static void Lerp(ref FMuscle_Quaternion source, FMuscle_Quaternion a, FMuscle_Quaternion b, float t)
	{
		if (a != null && b != null && source != null)
		{
			source.Acceleration = Mathf.LerpUnclamped(a.Acceleration, b.Acceleration, t);
			source.AccelerationLimit = Mathf.LerpUnclamped(a.AccelerationLimit, b.AccelerationLimit, t);
			source.BrakePower = Mathf.LerpUnclamped(a.BrakePower, b.BrakePower, t);
			source.Damping = Mathf.LerpUnclamped(a.Damping, b.Damping, t);
		}
	}

	public void OverrideProceduralRotation(Quaternion rotation)
	{
		ProceduralRotation = rotation;
		DesiredRotation = rotation;
		x.OverrideValue(rotation.x);
		y.OverrideValue(rotation.y);
		z.OverrideValue(rotation.z);
		w.OverrideValue(rotation.w);
	}
}
