using System;
using System.Runtime.CompilerServices;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Mathematics;

public struct FishUpdateJob : IJobParallelFor
{
	[ReadOnly]
	public float3 cameraPosition;

	[ReadOnly]
	public uint seed;

	[ReadOnly]
	public float dt;

	[ReadOnly]
	public float minSpeed;

	[ReadOnly]
	public float maxSpeed;

	[ReadOnly]
	public float minTurnSpeed;

	[ReadOnly]
	public float maxTurnSpeed;

	[ReadOnly]
	public float minDepth;

	[NativeDisableUnsafePtrRestriction]
	public unsafe FishData* fishDataArray;

	[NativeDisableUnsafePtrRestriction]
	public unsafe FishRenderData* fishRenderDataArray;

	public unsafe void Execute(int i)
	{
		FishData* ptr = fishDataArray + i;
		FishRenderData* ptr2 = fishRenderDataArray + i;
		Unity.Mathematics.Random random = new Unity.Mathematics.Random((uint)(i * 3245 + seed));
		float num = math.distancesq(cameraPosition, ptr2->position);
		bool flag = ptr->startleTime > 0f;
		if (num > math.pow(40f, 2f) || ptr2->position.y > minDepth)
		{
			ptr->isAlive = false;
			return;
		}
		if (!flag && num < 100f)
		{
			ptr->startleTime = 2f;
			flag = true;
		}
		float3 @float = new float3(ptr->destinationX, ptr2->position.y, ptr->destinationZ);
		if (ptr->updateTime >= 8f || math.distancesq(@float, ptr2->position) < 1f)
		{
			float3 target = GetTarget(new float3(ptr->spawnX, 0f, ptr->spawnZ), ref random);
			ptr->updateTime = 0f;
			ptr->destinationX = target.x;
			ptr->destinationZ = target.z;
		}
		ptr2->scale = math.lerp(ptr2->scale, ptr->scale, dt * 5f);
		ptr->speed = math.lerp(ptr->speed, flag ? maxSpeed : minSpeed, dt * 4f);
		float3 float2 = math.normalize(@float - ptr2->position);
		float a = math.atan2(float2.z, float2.x);
		ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
		float num2 = (flag ? maxTurnSpeed : minTurnSpeed);
		ptr2->rotation = LerpAngle(ptr2->rotation, a, dt * num2);
		float3 zero = float3.zero;
		math.sincos(ptr2->rotation, out zero.z, out zero.x);
		ptr->directionX = zero.x;
		ptr->directionZ = zero.z;
		ptr2->position += zero * ptr->speed * dt;
		ptr2->rotation = 0f - ptr2->rotation + MathF.PI / 2f;
		ptr2->distance += ptr->speed * dt;
		ptr->updateTime += dt;
		ptr->startleTime -= dt;
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	private static float LerpAngle(float a0, float a1, float t)
	{
		float num = a1 - a0;
		num = math.clamp(num - math.floor(num / (MathF.PI * 2f)) * (MathF.PI * 2f), 0f, MathF.PI * 2f);
		return math.lerp(a0, a0 + ((num > MathF.PI) ? (num - MathF.PI * 2f) : num), t);
	}
}
