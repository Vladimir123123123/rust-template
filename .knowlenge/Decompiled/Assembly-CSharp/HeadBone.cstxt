using System.Collections.Generic;
using UnityEngine;

public class HeadBone
{
	public Transform baseTransform;

	public Transform transform;

	private Vector3 snapshotPoseBaseTrSpacePosition;

	public Vector3 SnapshotPosition;

	private Quaternion snapshotPoseBaseTrSpaceRotationF;

	private Quaternion snapshotPoseBaseTrSpaceRotationB;

	public Quaternion snapshotPoseLocalRotation;

	public Quaternion SnapshotRotation;

	public Vector3 InitialLocalPosition { get; private set; }

	public Quaternion InitialLocalRotation { get; private set; }

	public HeadBone(Transform t)
	{
		transform = t;
	}

	public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
	{
		TakePoseSnapshot(baseTransform, bones, index);
		InitialLocalPosition = transform.localPosition;
		InitialLocalRotation = transform.localRotation;
	}

	internal Quaternion GetLocalRotationDiff()
	{
		return transform.rotation * Quaternion.Inverse(snapshotPoseLocalRotation);
	}

	public void SetCoordsForFrameForward()
	{
		SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
		SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationF;
	}

	public void SetCoordsForFrameBackward()
	{
		SnapshotPosition = baseTransform.TransformPoint(snapshotPoseBaseTrSpacePosition);
		SnapshotRotation = baseTransform.rotation * snapshotPoseBaseTrSpaceRotationB;
	}

	public void TakePoseSnapshot(Transform targetSpace, List<SpineBone> bones, int index)
	{
		baseTransform = targetSpace;
		snapshotPoseBaseTrSpacePosition = targetSpace.InverseTransformPoint(transform.position);
		Vector3 vector2;
		Vector3 vector3;
		if (index == bones.Count - 1)
		{
			Vector3 vector = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
			vector2 = snapshotPoseBaseTrSpacePosition + vector;
			vector3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
		}
		else if (index == 0)
		{
			vector2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
			Vector3 vector4 = targetSpace.InverseTransformPoint(transform.position) - targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
			vector3 = snapshotPoseBaseTrSpacePosition + vector4;
		}
		else
		{
			vector2 = targetSpace.InverseTransformPoint(bones[index + 1].transform.position);
			vector3 = targetSpace.InverseTransformPoint(bones[index - 1].transform.position);
		}
		snapshotPoseBaseTrSpaceRotationF = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(vector2 - snapshotPoseBaseTrSpacePosition);
		snapshotPoseBaseTrSpaceRotationB = Quaternion.Inverse(targetSpace.rotation) * Quaternion.LookRotation(vector3 - snapshotPoseBaseTrSpacePosition);
		snapshotPoseLocalRotation = Quaternion.Inverse(targetSpace.rotation) * transform.rotation;
	}
}
