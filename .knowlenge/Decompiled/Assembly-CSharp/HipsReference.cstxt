using System;
using System.Collections.Generic;
using FIMSpace.FTools;
using UnityEngine;

[Serializable]
public class HipsReference
{
	public class HipsHubBackbone
	{
		public Transform frontBone;

		private Vector3 _dir = Vector3.zero;

		private Vector3 _sd_dir = Vector3.zero;

		private FMuscle_Vector3 _FMuscle;

		public LegsAnimator Owner { get; private set; }

		public Transform bone { get; private set; }

		public Quaternion initialLocalRotation { get; private set; }

		public Vector3 keyframePosition { get; private set; }

		public Quaternion TargetRotation { get; internal set; }

		public HipsHubBackbone(LegsAnimator owner, Transform b)
		{
			Owner = owner;
			bone = b;
			initialLocalRotation = b.localRotation;
			_FMuscle = new FMuscle_Vector3();
			_FMuscle.Initialize(Vector3.zero);
		}

		public void PreCalibrate()
		{
			bone.localRotation = initialLocalRotation;
		}

		public void Calibrate()
		{
			keyframePosition = bone.position;
		}

		public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
		{
			if (Owner.HubBackBonesElasticity < 0.0001f)
			{
				return toHubNewB;
			}
			if (Owner.HubBackBonesElasticity <= 0.1f)
			{
				_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
			}
			else
			{
				_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
			}
			return _dir;
		}
	}

	[Tooltip("Applying elasticity algorithm on the pelvis bone align motion, to make it look more organic.")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float HipsElasticityBlend = 1f;

	public FMuscle_Vector3 HipsMuscle;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float HipsRotElasticityBlend;

	public FMuscle_Quaternion HipsRotMuscle;

	[NonSerialized]
	public Vector3 LastKeyframePosition;

	[NonSerialized]
	public Vector3 LastKeyframeLocalPosition;

	[NonSerialized]
	public Quaternion LastKeyframeRotation;

	[NonSerialized]
	public Quaternion LastKeyframeLocalRotation;

	[NonSerialized]
	public Vector3 LastRootLocalPos;

	[NonSerialized]
	public float LastHipsHeightDiff;

	[NonSerialized]
	public Vector3 InitHipsPositionRootSpace;

	[NonSerialized]
	public float InitialHipsHeightLocal;

	[NonSerialized]
	internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

	private Transform root;

	private Vector3 initLocalPos;

	private Quaternion initLocalRot;

	private Vector3 _Hips_StabilityLocalAdjustement = Vector3.zero;

	private Vector3 _Hips_sd_StabilAdjustm = Vector3.zero;

	private Vector3 _stretchPreventerOff = Vector3.zero;

	private float _sd_Hips_StepHeightAdjustOffset;

	private int _h_lowestHitLeg = -1;

	private Vector3 _reAdjustLocal = Vector3.zero;

	private Vector3 _sd_readj = Vector3.zero;

	private Vector3 _pushSmoothed = Vector3.zero;

	private Vector3 _sd_pushSmoothed = Vector3.zero;

	public LegsAnimator Owner { get; private set; }

	public List<Leg> ChildLegs { get; private set; }

	public Transform bone { get; private set; }

	public UniRotateBone UniRotate { get; private set; }

	public List<HipsHubBackbone> HubBackBones { get; private set; }

	public Vector3 _Get_Hips_StabilityLocalAdjustement => _Hips_StabilityLocalAdjustement;

	public float _Hips_LastHipsOffset { get; private set; }

	public float _Hips_StepHeightAdjustOffset { get; private set; }

	public Vector3 ExtraNonElasticOffset { get; internal set; }

	public Vector3 _PreHipsAdjustPosition { get; internal set; }

	public void Initialize(LegsAnimator owner, Transform bone, Transform root)
	{
		Owner = owner;
		this.bone = bone;
		this.root = root;
		initLocalPos = bone.localPosition;
		initLocalRot = bone.localRotation;
		ExtraNonElasticOffset = Vector3.zero;
		_Hips_StabilityLocalAdjustement = Vector3.zero;
		_Hips_sd_StabilAdjustm = Vector3.zero;
		InitHipsPositionRootSpace = root.InverseTransformPoint(bone.position);
		InitialHipsHeightLocal = InitHipsPositionRootSpace.y;
		if (HipsMuscle == null)
		{
			HipsMuscle = new FMuscle_Vector3();
		}
		if (HipsRotMuscle == null)
		{
			HipsRotMuscle = new FMuscle_Quaternion();
		}
		HipsMuscle.Initialize(Vector3.zero);
		HipsRotMuscle.Initialize(Quaternion.identity);
		UniRotate = new UniRotateBone(bone, root);
		Calibrate();
	}

	internal void PrepareLegs()
	{
		ChildLegs = new List<Leg>();
		if (!Owner._hipsHubs_using)
		{
			ChildLegs = Owner.Legs;
		}
		else
		{
			for (int i = 0; i < Owner.Legs.Count; i++)
			{
				bool? flag = IsFirstParent(Owner.Legs[i], bone);
				if (flag == true)
				{
					ChildLegs.Add(Owner.Legs[i]);
				}
				else if (!flag.HasValue && this == Owner.HipsSetup)
				{
					ChildLegs.Add(Owner.Legs[i]);
				}
			}
		}
		for (int j = 0; j < ChildLegs.Count; j++)
		{
			ChildLegs[j].AssignParentHub(this);
		}
	}

	internal void PrepareHubBones()
	{
		PrepareLegs();
		HubBackBones = new List<HipsHubBackbone>();
		Transform frontBone = bone;
		Transform parent = bone.parent;
		while (parent != null)
		{
			bool flag = false;
			for (int i = 0; i < Owner.HipsHubs.Count; i++)
			{
				if (parent == Owner.HipsHubs[i].bone)
				{
					flag = true;
					break;
				}
			}
			if (!flag)
			{
				HipsHubBackbone hipsHubBackbone = new HipsHubBackbone(Owner, parent);
				hipsHubBackbone.frontBone = frontBone;
				HubBackBones.Add(hipsHubBackbone);
				if (!(parent == Owner.HipsSetup.bone))
				{
					frontBone = parent;
					parent = parent.parent;
					continue;
				}
				break;
			}
			break;
		}
	}

	private bool? IsFirstParent(Leg leg, Transform hub)
	{
		if (leg.BoneStart == null)
		{
			return false;
		}
		Transform transform = leg.BoneStart;
		while (transform != null)
		{
			if (transform == hub)
			{
				return true;
			}
			if (transform == Owner.Hips)
			{
				return false;
			}
			for (int i = 0; i < Owner.ExtraHipsHubs.Count; i++)
			{
				if (transform == Owner.ExtraHipsHubs[i])
				{
					return false;
				}
			}
			transform = transform.parent;
		}
		return null;
	}

	public void Reset()
	{
		Calibrate();
		_Hips_LastHipsOffset = 0f;
	}

	public void PreCalibrate()
	{
		UniRotate.PreCalibrate();
		if (Owner.Calibrate != ECalibrateMode.FixedCalibrate)
		{
			UniRotate.PreCalibrate();
		}
		else
		{
			bone.localPosition = LastKeyframeLocalPosition;
			bone.localRotation = LastKeyframeLocalRotation;
		}
		if (HubBackBones != null)
		{
			for (int i = 0; i < HubBackBones.Count; i++)
			{
				HubBackBones[i].PreCalibrate();
			}
		}
	}

	public void Calibrate()
	{
		LastKeyframePosition = bone.position;
		LastKeyframeLocalPosition = bone.localPosition;
		LastKeyframeLocalRotation = bone.localRotation;
		LastKeyframeRotation = bone.rotation;
		LastRootLocalPos = Owner.ToRootLocalSpace(LastKeyframePosition);
		LastHipsHeightDiff = GetHeightDiff(LastRootLocalPos.y);
		if (HubBackBones != null)
		{
			for (int i = 0; i < HubBackBones.Count; i++)
			{
				HubBackBones[i].Calibrate();
			}
		}
	}

	public float GetHeightDiff(float rootSpaceHeight)
	{
		return Mathf.InverseLerp(0f, InitialHipsHeightLocal, rootSpaceHeight);
	}

	public void CopyMuscleSettingsFrom(HipsReference hipsSetup)
	{
		HipsMuscle.Acceleration = hipsSetup.HipsMuscle.Acceleration;
		HipsMuscle.AccelerationLimit = hipsSetup.HipsMuscle.AccelerationLimit;
		HipsMuscle.Damping = hipsSetup.HipsMuscle.Damping;
		HipsMuscle.BrakePower = hipsSetup.HipsMuscle.BrakePower;
	}

	public Vector3 CalculateCenterOfMassStability(float stabilizingMultiplier)
	{
		if (Owner.StabilizeCenterOfMass > 0f)
		{
			Vector3 vector = new Vector3(0f, 0f, 0f);
			float num = ChildLegs.Count;
			if (Owner.StabilityAlgorithm == EStabilityMode.Biped_Deprecated)
			{
				for (int i = 0; i < ChildLegs.Count; i++)
				{
					Leg leg = ChildLegs[i];
					Vector3 vector2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
					Vector3 previousFinalIKPosForStability = leg._PreviousFinalIKPosForStability;
					Vector3 vector3 = Owner.ToRootLocalSpace(previousFinalIKPosForStability + vector2);
					Vector3 initialPosInRootSpace = leg.InitialPosInRootSpace;
					initialPosInRootSpace.y += _Hips_LastHipsOffset;
					Vector3 vector4 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace, leg.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace) : leg.AnkleH.LastKeyframeRootPos);
					Vector3 vector5 = vector3 - vector4;
					vector5.y *= 0.25f;
					vector += vector5 * leg.BlendWeight * 0.5f * (stabilizingMultiplier * Owner.StabilizeCenterOfMass);
				}
				vector.y /= num;
			}
			else if (Owner.StabilityAlgorithm == EStabilityMode.Universal)
			{
				Vector3 lastRootLocalPos = LastRootLocalPos;
				for (int j = 0; j < ChildLegs.Count; j++)
				{
					Leg leg2 = ChildLegs[j];
					Vector3 initialPosInRootSpace2 = leg2.InitialPosInRootSpace;
					initialPosInRootSpace2.y += _Hips_LastHipsOffset;
					Vector3 vector6 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace2, leg2.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace2) : leg2.AnkleH.LastKeyframeRootPos);
					Vector3 vector7 = lastRootLocalPos - vector6;
					Vector3 vector8 = Owner.ToRootLocalSpace(leg2._PreviousFinalIKPosForStability);
					Vector3 vector9 = lastRootLocalPos - vector8;
					Vector3 vector10 = vector7 - vector9;
					vector10.y *= 0.25f;
					vector += vector10 * leg2.BlendWeight * (stabilizingMultiplier * Owner.StabilizeCenterOfMass) / num;
				}
			}
			if (vector.y > 0f)
			{
				vector.y = 0f;
			}
			if (Owner.StabilizingSpeed < 1f)
			{
				float duration = 0f;
				if (Owner.StabilizingSpeed < 1f)
				{
					duration = 0.001f + (1f - Owner.StabilizingSpeed) * 0.4f;
				}
				Owner.ValueTowards(ref _Hips_StabilityLocalAdjustement, vector, ref _Hips_sd_StabilAdjustm, duration);
			}
			else
			{
				_Hips_StabilityLocalAdjustement = vector;
			}
		}
		else
		{
			_Hips_StabilityLocalAdjustement = Vector3.zero;
		}
		return _Hips_StabilityLocalAdjustement;
	}

	public Vector3 CalculateStretchPreventerOffset()
	{
		if (Owner.HipsStretchPreventer < 0.0001f)
		{
			return Vector3.zero;
		}
		Vector3 zero = Vector3.zero;
		float num = 0f;
		Vector3 lastRootLocalPos = LastRootLocalPos;
		lastRootLocalPos.y = 0f;
		lastRootLocalPos = Owner.baseTransform.TransformPoint(lastRootLocalPos);
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			float stretchValue = leg.IKProcessor.GetStretchValue(leg._PreviousFinalIKPosForStability);
			if (stretchValue > Owner.LimitLegStretch * 0.975f)
			{
				num += 1f;
				float num2 = stretchValue - Owner.LimitLegStretch * 0.975f;
				Vector3 vec = lastRootLocalPos - leg._PreviousFinalIKPosForStability;
				vec = Owner.ToRootLocalSpaceVec(vec);
				if (vec.y > 0f)
				{
					vec.y = 0f;
				}
				vec.x *= -0.6f;
				vec.z *= -0.6f;
				zero += vec * Mathf.Clamp(num2 * 3f, 0f, 0.5f);
			}
		}
		if (Owner.StretchPreventerSpeed < 1f)
		{
			float num3 = Mathf.Lerp(8f, 40f, Owner.StretchPreventerSpeed) * Owner.DeltaTime;
			if (num > 0f)
			{
				_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, zero / num, num3);
			}
			else
			{
				_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, Vector3.zero, num3 * 0.7f);
			}
		}
		else
		{
			_stretchPreventerOff = zero;
		}
		return _stretchPreventerOff;
	}

	public Vector3 CalculateGlueMovePush()
	{
		Vector3 zero = Vector3.zero;
		if (Owner.GlueBlend < 0.0001f)
		{
			return zero;
		}
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			if ((leg.G_Attached || leg.G_DuringLegAdjustMovement) && leg.G_LastLegMoveDistanceFactor > 0.055f && leg.G_GlueInternalTransition > 0f && leg.G_GlueInternalTransition < 1f && leg.G_HandlerExecutingLegAnimationMode == EGlueMode.Idle)
			{
				Vector3 vector = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd);
				Vector3 vector2 = Owner.ToRootLocalSpace(leg._PreviousFinalIKPosForStability + vector);
				vector2.z = 0f - vector2.z;
				float num = Owner.BaseLegAnimating.PushHipsOnMoveCurve.Evaluate(leg.G_GlueInternalTransition);
				Vector3 vector3 = -vector2 * num * 1f;
				vector3.y -= num * leg.G_LastLegMoveDistanceFactor * Owner.ScaleReferenceNoScale * 0.75f;
				Vector3 vector4;
				if (Owner.NormalizePush)
				{
					float num2 = Mathf.Min(1f, vector3.magnitude / (Owner.ScaleReferenceNoScale * 0.33f));
					num2 *= num2;
					vector4 = vector3.normalized * Owner.ScaleReferenceNoScale * 0.33f * num2;
				}
				else
				{
					vector4 = vector3;
				}
				vector4.y *= Owner.PushYBlend;
				zero += vector4 * leg.BlendWeight;
			}
		}
		return zero;
	}

	private void AnimateStepAdjustTo(float yOffset)
	{
		if (Owner.HipsHeightStepSpeed >= 1f)
		{
			_Hips_StepHeightAdjustOffset = yOffset;
			return;
		}
		float landingBoost = Owner.GetLandingBoost();
		if (Owner.HipsAdjustStyle == EHipsAdjustStyle.FollowLegHeight && yOffset < _Hips_StepHeightAdjustOffset && _h_lowestHitLeg != -1)
		{
			Vector3 previousFinalIKPos = Owner.Legs[_h_lowestHitLeg]._PreviousFinalIKPos;
			previousFinalIKPos = Owner.ToRootLocalSpace(previousFinalIKPos);
			previousFinalIKPos.y -= Owner.ScaleReferenceNoScale * 0.325f;
			if (previousFinalIKPos.y > yOffset)
			{
				yOffset = previousFinalIKPos.y;
			}
		}
		_Hips_StepHeightAdjustOffset = Mathf.SmoothDamp(_Hips_StepHeightAdjustOffset, yOffset, ref _sd_Hips_StepHeightAdjustOffset, Mathf.LerpUnclamped(0.4f, 0.01f, landingBoost), 1000000f, Owner.DeltaTime);
		_h_lowestHitLeg = -1;
	}

	public float CalculateBodyAdjust()
	{
		_Hips_LastHipsOffset = 0f;
		if (Owner.HipsHeightStepBlend <= 0f)
		{
			return 0f;
		}
		if (Owner.IsGrounded)
		{
			Vector3 vector = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			Vector3 vector2 = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				if (!leg.RaycastHitted)
				{
					continue;
				}
				Vector3 point = leg.LastGroundHit.point;
				point = Owner.ToRootLocalSpace(point);
				if (point.y <= 0f)
				{
					if (0f - point.y < Owner.BodyStepDown * Owner.ScaleReferenceNoScale && point.y < vector.y)
					{
						vector = point;
						_h_lowestHitLeg = i;
					}
				}
				else if (point.y < Owner.MaxBodyStepUp * Owner.ScaleReferenceNoScale && point.y < vector.y)
				{
					vector2 = point;
				}
			}
			bool flag = false;
			if (vector.x != float.MaxValue && Owner.BodyStepDown > 0f && vector.y <= 0f)
			{
				AnimateStepAdjustTo(vector.y);
				flag = true;
			}
			if (!flag && Owner.MaxBodyStepUp > 0f && vector2.x != float.MaxValue)
			{
				AnimateStepAdjustTo(vector2.y);
				flag = true;
			}
			if (!flag)
			{
				AnimateStepAdjustTo(0f);
			}
		}
		else
		{
			AnimateStepAdjustTo(0f);
		}
		float num = Owner.HipsBlendWeight * Owner._MainBlend * Owner.IsGroundedBlend * Owner.RagdolledDisablerBlend;
		_Hips_LastHipsOffset = _Hips_StepHeightAdjustOffset * Owner.baseTransform.lossyScale.y * num;
		return _Hips_LastHipsOffset;
	}

	public Vector3 CalculateStretchReadjust()
	{
		Vector3 zero = Vector3.zero;
		for (int i = 0; i < ChildLegs.Count; i++)
		{
			Leg leg = ChildLegs[i];
			Vector3 vector = leg._FinalIKPos - zero;
			if (leg.IKProcessor.GetStretchValue(vector) > Owner.LimitLegStretch)
			{
				Vector3 notStretchedPositionTowards = leg.IKProcessor.GetNotStretchedPositionTowards(vector, Owner.LimitLegStretch);
				Vector3 vector2 = vector - notStretchedPositionTowards;
				zero += vector2;
			}
		}
		zero = Owner.ToRootLocalSpaceVec(zero);
		_reAdjustLocal = Vector3.SmoothDamp(_reAdjustLocal, zero, ref _sd_readj, 0.1f, 10000000f, Owner.DeltaTime);
		return _reAdjustLocal;
	}

	public Vector3 SmoothPushOffset(Vector3 pushLocalOffset, float pushDuration)
	{
		Owner.ValueTowards(ref _pushSmoothed, pushLocalOffset, ref _sd_pushSmoothed, pushDuration);
		return _pushSmoothed;
	}

	public Vector3 AnimateOffset(Vector3 hubOffset)
	{
		return hubOffset;
	}
}
