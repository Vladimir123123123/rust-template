using Rust;
using UnityEngine;

public class ItemModContainerArmorSlot : ItemModContainer
{
	public int MinSlots;

	public int MaxSlots = 3;

	public bool CraftedItemsOnly = true;

	private static float[] RollChances = new float[2] { 0.3f, 0.2f };

	public override void OnVirginItem(Item item, BasePlayer creatingPlayer)
	{
		if (item.isServer)
		{
			base.OnVirginItem(item, creatingPlayer);
			CreateForPlayer(item, creatingPlayer);
		}
	}

	public void CreateForPlayer(Item item, BasePlayer player)
	{
		if (player == null && CraftedItemsOnly)
		{
			return;
		}
		int num = 0;
		if (player != null)
		{
			float num2 = Mathf.Clamp01(player.modifiers.GetValue(Modifier.ModifierType.Crafting_Quality));
			num = 0;
			if (num2 > 0f || Roll(0.5f))
			{
				num = MinSlots;
				for (int i = 0; i < MaxSlots - MinSlots && Roll(RollChances[Mathf.Clamp(i, 0, RollChances.Length)]); i++)
				{
					num++;
				}
			}
		}
		CreateAtCapacity(num, item);
		static bool Roll(float chance)
		{
			return Random.Range(0f, 1f) <= chance;
		}
	}

	public void CreateAtCapacity(int cap, Item item)
	{
		capacity = cap;
		if (capacity != 0)
		{
			CreateContents(item);
			if (item != null && item.contents != null)
			{
				item.contents.canAcceptItem = CanAcceptArmorItem;
			}
		}
	}

	public override void OnItemCreated(Item item)
	{
		if (capacity > 0 && item != null && item.contents != null)
		{
			item.contents.canAcceptItem = CanAcceptArmorItem;
		}
	}

	protected bool CanAcceptArmorItem(Item item, int count)
	{
		if (item == null || item.info == null)
		{
			return false;
		}
		if (item.info.GetComponent<ItemModArmorInsert>() == null)
		{
			return false;
		}
		return true;
	}

	public float TotalSpeedReduction(Item item)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		foreach (Item item2 in item.contents.itemList)
		{
			if (item2.info.TryGetComponent<ItemModArmorInsert>(out var component))
			{
				num += component.SpeedReduction;
			}
		}
		return num;
	}

	public float GetProtection(Item item, DamageType damageType)
	{
		if (item == null)
		{
			return 0f;
		}
		if (item.contents == null)
		{
			return 0f;
		}
		if (item.contents.itemList == null)
		{
			return 0f;
		}
		float num = 0f;
		foreach (Item item2 in item.contents.itemList)
		{
			if (item2.info.TryGetComponent<ItemModArmorInsert>(out var component))
			{
				num += component.protectionProperties.amounts[(int)damageType];
			}
		}
		return num;
	}

	public void CollectProtection(Item item, ProtectionProperties protection)
	{
		if (item == null || item.contents == null || protection == null)
		{
			return;
		}
		foreach (Item item2 in item.contents.itemList)
		{
			if (item2.info.TryGetComponent<ItemModArmorInsert>(out var component) && !(component.protectionProperties == null))
			{
				protection.Add(component.protectionProperties, 1f);
			}
		}
	}
}
