using FIMSpace.FProceduralAnimation;
using UnityEngine;

public class LAM_AutoGroundAlignBodyMatrix : LegsAnimatorControlModuleBase
{
	private Vector3 averageNormal;

	private Vector3 animatedAverageNormal;

	private Quaternion lastOrientation;

	private LegsAnimator.Variable _blendV;

	private LegsAnimator.Variable _rotateV;

	private LegsAnimator.Variable _alignSpdV;

	private LegsAnimator.Variable _alignDownV;

	private LegsAnimator.Variable _AxisBlendV;

	private float _blend = 1f;

	public override bool AskForSpineBone => true;

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		animatedAverageNormal = base.LA.Up;
		lastOrientation = base.LA.BaseTransform.rotation;
		_blendV = helper.RequestVariable("Matrix Blend", 1f);
		_rotateV = helper.RequestVariable("Rotate Hips", 1f);
		_alignSpdV = helper.RequestVariable("Aligning Speed", 0.7f);
		_alignDownV = helper.RequestVariable("Spine Restore", 0.5f);
		_AxisBlendV = helper.RequestVariable("Rotation Axis Blend", Vector3.one);
	}

	public override void Leg_LatePreRaycastingUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper, LegsAnimator.Leg leg)
	{
		_blend = base.EffectBlend;
		if (leg.RaycastHitted)
		{
			averageNormal += leg.LastGroundHit.normal;
		}
	}

	public override void OnUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		Quaternion quaternion = lastOrientation;
		float num = _blend * _blendV.GetFloat();
		if (num < 1f)
		{
			quaternion = Quaternion.SlerpUnclamped(Quaternion.identity, lastOrientation, num);
		}
		Matrix4x4 mx = Matrix4x4.TRS(base.LA.BaseTransform.position, quaternion * base.LA.BaseTransform.rotation, base.LA.BaseTransform.lossyScale);
		base.LA.User_OverwriteCastMatrix(mx);
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		float num = _blend * _rotateV.GetFloat();
		if (!(num < 0.001f))
		{
			Vector3 eulerAngles = lastOrientation.eulerAngles;
			eulerAngles.x = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.x);
			eulerAngles.y = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.y);
			eulerAngles.z = LAM_DirectionalMovement.FormatAngleToPM180(eulerAngles.z);
			Quaternion identity = Quaternion.identity;
			identity *= Quaternion.AngleAxis(eulerAngles.x * num, Vector3.right);
			identity *= Quaternion.AngleAxis(eulerAngles.y * num, Vector3.up);
			identity *= Quaternion.AngleAxis(eulerAngles.z * num, Vector3.forward);
			base.LA._LastHipsRotationOffsetOutsideInfo *= identity;
			if ((bool)base.LA.SpineBone)
			{
				Quaternion rotation = base.LA.SpineBone.rotation;
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
				base.LA.SpineBone.rotation = Quaternion.Slerp(base.LA.SpineBone.rotation, rotation, _alignDownV.GetFloat());
			}
			else
			{
				base.LA.HipsSetup.bone.rotation = identity * base.LA.HipsSetup.bone.rotation;
			}
		}
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (averageNormal == Vector3.zero)
		{
			averageNormal = base.LA.Up;
		}
		else
		{
			averageNormal.Normalize();
		}
		if (_alignSpdV.GetFloat() < 0.999f)
		{
			float num = Mathf.LerpUnclamped(5f, 20f, _alignSpdV.GetFloat());
			animatedAverageNormal = Vector3.Slerp(animatedAverageNormal, averageNormal, base.LA.DeltaTime * num);
		}
		else
		{
			animatedAverageNormal = averageNormal;
		}
		lastOrientation = Quaternion.FromToRotation(Vector3.up, animatedAverageNormal);
		Vector3 vector = _AxisBlendV.GetVector3();
		if (vector != Vector3.one)
		{
			Vector3 eulerAngles = lastOrientation.eulerAngles;
			vector = helper.Parent.BaseTransform.TransformDirection(vector);
			lastOrientation = Quaternion.Euler(eulerAngles.x * vector.x, eulerAngles.y * vector.y, eulerAngles.z * vector.z);
		}
		averageNormal = Vector3.zero;
	}
}
