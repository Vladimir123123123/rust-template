using System;
using System.Collections.Generic;
using FIMSpace;
using FIMSpace.FProceduralAnimation;
using UnityEngine;

[CreateAssetMenu(fileName = "LAM_DirectionalMovement", menuName = "FImpossible Creations/Legs Animator/Module - 360 Movement Animation", order = 2)]
public class LAM_DirectionalMovement : LegsAnimatorControlModuleBase
{
	[Serializable]
	public class AnglesSetup
	{
		public Vector3 AnglesOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips rotations on reaching 45 angle movement")]
		public Vector3 AnglesOn45 = new Vector3(-10f, 14f, -5f);

		[Tooltip(" Hips rotations on reaching 90 angle movement")]
		public Vector3 AnglesOn90 = new Vector3(-7f, 40f, -3f);

		[Tooltip(" Hips rotations on reaching 135 angle movement")]
		public Vector3 AnglesOn135 = new Vector3(-8f, -25f, -4f);

		[Tooltip(" Hips rotations on reaching 180 angle movement")]
		public Vector3 AnglesOn180 = new Vector3(-20f, 0f, 0f);

		[Space(8f)]
		public Vector3 HipsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Hips position offset on reaching 45 angle movement")]
		public Vector3 HipsOffsetOn45 = new Vector3(-0.05f, 0f, -0.05f);

		[Tooltip(" Hips position offset on reaching 90 angle movement")]
		public Vector3 HipsOffsetOn90 = new Vector3(-0.1f, 0f, 0.05f);

		[Tooltip(" Hips position offset on reaching 135 angle movement")]
		public Vector3 HipsOffsetOn135 = new Vector3(-0.1f, 0f, 0.1f);

		[Tooltip(" Hips position offset on reaching 180 angle movement")]
		public Vector3 HipsOffsetOn180 = new Vector3(0f, 0.05f, 0.2f);

		[Space(8f)]
		public Vector3 IKsOffsetOn0 = new Vector3(0f, 0f, 0f);

		[Tooltip(" Foot IK position offset on reaching 45 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn45 = new Vector3(0f, 0f, -0.04f);

		[Tooltip(" Foot IK position offset on reaching 90 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn90 = new Vector3(0f, 0f, -0.08f);

		[Tooltip(" Foot IK position offset on reaching 135 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn135 = new Vector3(0f, 0f, 0.08f);

		[Tooltip(" Foot IK position offset on reaching 180 angle movement (x on left leg goes negative)")]
		public Vector3 IKsOffsetOn180 = new Vector3(0f, 0f, 0f);
	}

	private class LegRedirectHelper
	{
		private LAM_DirectionalMovement parent;

		private LegsAnimator.Leg leg;

		internal LegRedirectHelper oppositeHelper;

		private Vector3 computedPosLocal = Vector3.zero;

		private Quaternion _footRedirCache = Quaternion.identity;

		private LegsAnimator LA => parent.LA;

		public Vector3 LastComputedWorldSpaceLegPos { get; private set; }

		public LegRedirectHelper(LAM_DirectionalMovement parent, LegsAnimator.Leg leg)
		{
			this.parent = parent;
			this.leg = leg;
			LastComputedWorldSpaceLegPos = leg.BoneEnd.position;
			computedPosLocal = leg.Owner.ToRootLocalSpace(LastComputedWorldSpaceLegPos);
		}

		public Vector3 ComputeIKOffset(Vector3 localPos, float smoother = 1f)
		{
			float @float = parent._play_TrDur.GetFloat();
			Vector3 vector = parent._calc_LocalRotDir * localPos;
			float num = Vector3.Magnitude(vector - computedPosLocal);
			float num2 = num / leg.Owner.ScaleReferenceNoScale;
			float num3 = 0f;
			if (num > 0.2f)
			{
				num3 = Mathf.InverseLerp(0.2f, 1f, num);
				num3 *= 0.1f;
				if (@float < 0.1f)
				{
					num3 *= @float / 0.1f;
				}
			}
			if (parent._calc_toNegativeXProgress > 0f)
			{
				Vector3 vector2 = localPos;
				vector2.x *= -1f;
				Vector3 b = parent._calc_LocalRotDir * vector2;
				vector = Vector3.Lerp(vector, b, parent._calc_toNegativeXProgress);
			}
			float num4 = 0f;
			if (!(smoother >= 3f))
			{
				if (smoother > 0f)
				{
					if (num2 < 0.1f / smoother)
					{
						computedPosLocal = vector;
					}
					else
					{
						num4 = Mathf.InverseLerp(1.5f * smoother, 0.1f / smoother, num2) * 6f;
					}
					num4 = Mathf.Max(0f, num4);
				}
				else
				{
					computedPosLocal = vector;
				}
			}
			computedPosLocal = Vector3.Lerp(computedPosLocal, vector, LA.DeltaTime * (Mathf.Lerp(20f, 4f, (parent._calc_angleDiffFactor * @float + num3) * 1.5f) + num4));
			computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, vector.y, 0.5f);
			if (parent._var_raiseLimit > 0f)
			{
				float c_AnimatedAnkleFlatHeight = leg.C_AnimatedAnkleFlatHeight;
				float num5 = 0f;
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorR);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					num5 = Mathf.Lerp(0f, 0.5f, parent._calc_sideFactorL);
				}
				if (parent._calc_toNegativeXProgress > 0f)
				{
					num5 = Mathf.Lerp(num5, 1f, parent._calc_toNegativeXProgress);
				}
				computedPosLocal.y = Mathf.Lerp(computedPosLocal.y, c_AnimatedAnkleFlatHeight, num5 * parent._var_raiseLimit);
			}
			LastComputedWorldSpaceLegPos = LA.RootToWorldSpace(computedPosLocal);
			return computedPosLocal;
		}

		internal Quaternion FootRedirectSmoother(Quaternion target)
		{
			_footRedirCache = Quaternion.Lerp(_footRedirCache, target, parent._calc_deltaSpeedSlow);
			return _footRedirCache;
		}
	}

	private LegsAnimator.LegsAnimatorCustomModuleHelper _useHelper;

	private LegsAnimator.Variable _play_HipsRedir;

	private LegsAnimator.Variable _play_FeetRedir;

	private LegsAnimator.Variable _play_KneesRedir;

	private LegsAnimator.Variable _play_TrDur;

	private LegsAnimator.Variable _play_LimitRaise;

	private LegsAnimator.Variable _play_FixFeet;

	private LegsAnimator.Variable _play_AdjustStretch;

	private LegsAnimator.Variable _play_RestoreSpine;

	private LegsAnimator.Variable _play_Smoother;

	private LegsAnimator.Variable _play_reAdj;

	private LegsAnimator.Variable _play_offInAir;

	private int _hash_xDir = -1;

	private int _hash_zDir = -1;

	private Vector3 _calc_WorldDir = Vector3.zero;

	private Vector3 _calc_LocalDir = Vector3.zero;

	private Quaternion _calc_LocalRotDir = Quaternion.identity;

	private float _localTargetAngle;

	private float _wrappedAngle;

	private float _smoothedWrappedAngle;

	private float _calc_smoothedTargetAngle;

	private float _calc_angleDiffFactor;

	private float _calc_toNegativeXProgress;

	internal float _calc_backAngleOff;

	private float _calc_sideFactorL;

	private float _calc_sideFactorR;

	internal float _calc_sideFactor;

	private float _calc_deltaSpeed;

	private float _calc_deltaSpeedSlow;

	private float _var_raiseLimit;

	private float _var_fixFeet;

	private Vector3 _calc_hipsPositionOffsets = Vector3.zero;

	private Vector3 _calc_hipsRotationOffsets = Vector3.zero;

	private Vector3 _calc_hipsStretchOffset = Vector3.zero;

	private Vector3 _sd_hipsStretchOff = Vector3.zero;

	private Vector3 _calc_ikOff = Vector3.zero;

	private List<LegRedirectHelper> legRedirectHelpers;

	[NonSerialized]
	public Transform SpineBone;

	[NonSerialized]
	public Vector3 User_MultiplyHipsOffsets = Vector3.one;

	[FPD_Header("Angles setup to drive procedural animation", 6f, 4f, 2)]
	public AnglesSetup Animation360Angles;

	[NonSerialized]
	public float User_StretchRotatorAnglePower = 30f;

	[NonSerialized]
	public float User_StretchPositionMultiplier = 1f;

	private float _mainBlend = 1f;

	private bool _wasUpdated;

	private Vector3 overridingDirection = Vector3.zero;

	private bool useOverridingDirection;

	[NonSerialized]
	public float overrideDirectionFadeSpeed = 6f;

	private float overrideDirectionBlend;

	private float _calc_lStretch;

	private float _calc_rStretch;

	private LegsAnimator.Variable HipsRedirVar => _useHelper.RequestVariable("Redirect Hips", 0.8f);

	private LegsAnimator.Variable FeetRedirVar => _useHelper.RequestVariable("Redirect Feet", 0.8f);

	private LegsAnimator.Variable KneesRedirVar => _useHelper.RequestVariable("Redirect Knees", 0.4f);

	private LegsAnimator.Variable TrDurationVar => _useHelper.RequestVariable("Transitions Duration", 0.25f);

	private LegsAnimator.Variable LimitRaiseVar => _useHelper.RequestVariable("Limit Leg Raise", 0.1f);

	private LegsAnimator.Variable FixFeetVar => _useHelper.RequestVariable("Fix Backward Feet", 1f);

	private LegsAnimator.Variable AdjustStretchVar => _useHelper.RequestVariable("Adjust Stretched", 0.2f);

	private LegsAnimator.Variable RestoreSpineVar => _useHelper.RequestVariable("Restore Spine", 0.5f);

	private LegsAnimator.Variable ExtraSmootherVar => _useHelper.RequestVariable("Extra Smoother", 0f);

	private LegsAnimator.Variable ReAdjVar => _useHelper.RequestVariable("Re-adjust with hips offset", false);

	private LegsAnimator.Variable FadeOffInAirVar => _useHelper.RequestVariable("Disable When Jumping", false);

	private LegsAnimator.Variable XDirAnimVarVar => _useHelper.RequestVariable("Animator World X Dir", "");

	private LegsAnimator.Variable ZDirAnimVarVar => _useHelper.RequestVariable("Animator World Z Dir", "");

	public override void OnInit(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_useHelper = helper;
		_play_HipsRedir = HipsRedirVar;
		_play_TrDur = TrDurationVar;
		_play_LimitRaise = LimitRaiseVar;
		_play_FeetRedir = FeetRedirVar;
		_play_KneesRedir = KneesRedirVar;
		_play_FixFeet = FixFeetVar;
		_play_AdjustStretch = AdjustStretchVar;
		_play_RestoreSpine = RestoreSpineVar;
		_play_Smoother = ExtraSmootherVar;
		_play_offInAir = FadeOffInAirVar;
		_play_reAdj = ReAdjVar;
		_wasUpdated = false;
		legRedirectHelpers = new List<LegRedirectHelper>();
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegRedirectHelper item = new LegRedirectHelper(this, base.LA.Legs[i]);
			legRedirectHelpers.Add(item);
		}
		for (int j = 0; j < base.LA.Legs.Count; j++)
		{
			if (base.LA.Legs[j].OppositeLegIndex >= 0)
			{
				legRedirectHelpers[j].oppositeHelper = legRedirectHelpers[base.LA.Legs[j].OppositeLegIndex];
			}
		}
		if (SpineBone == null && base.LA.Hips.childCount > 0)
		{
			if (base.LA.Hips.childCount == 1)
			{
				SpineBone = base.LA.Hips.GetChild(0);
			}
			else
			{
				for (int k = 0; k < base.LA.Hips.childCount; k++)
				{
					if (base.LA.Hips.GetChild(k).name.ToLower().Contains("spin"))
					{
						SpineBone = base.LA.Hips.GetChild(k);
						break;
					}
				}
				if (SpineBone == null)
				{
					SpineBone = base.LA.Hips.GetChild(0);
				}
			}
		}
		if ((bool)base.LA.Mecanim)
		{
			LegsAnimator.Variable xDirAnimVarVar = XDirAnimVarVar;
			if (!string.IsNullOrWhiteSpace(xDirAnimVarVar.GetString()))
			{
				_hash_xDir = Animator.StringToHash(xDirAnimVarVar.GetString());
				LegsAnimator.Variable zDirAnimVarVar = ZDirAnimVarVar;
				_hash_zDir = Animator.StringToHash(zDirAnimVarVar.GetString());
			}
		}
	}

	public override void OnPreLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		_mainBlend = base.LA._MainBlend * base.ModuleBlend;
		if (_play_offInAir.GetBool())
		{
			_mainBlend *= base.LA.IsGroundedBlend;
		}
		float @float = _play_TrDur.GetFloat();
		if (_mainBlend < 0.001f)
		{
			return;
		}
		if (useOverridingDirection)
		{
			if (overrideDirectionFadeSpeed < 0.0001f)
			{
				overrideDirectionBlend = 1f;
			}
			else
			{
				overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 1f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
			}
		}
		else if (overrideDirectionFadeSpeed < 0.0001f)
		{
			overrideDirectionBlend = 0f;
		}
		else
		{
			overrideDirectionBlend = Mathf.MoveTowards(overrideDirectionBlend, 0f, base.Owner.DeltaTime * overrideDirectionFadeSpeed);
		}
		Vector3 calc_WorldDir;
		if (_hash_zDir != -1)
		{
			calc_WorldDir = new Vector3(base.LA.Mecanim.GetFloat(_hash_xDir), 0f, base.LA.Mecanim.GetFloat(_hash_zDir)).normalized;
		}
		else
		{
			calc_WorldDir = base.LA.DesiredMovementDirection;
			calc_WorldDir.y = 0f;
			if (calc_WorldDir.magnitude < 0.1f)
			{
				calc_WorldDir = Vector3.zero;
			}
		}
		_calc_WorldDir = calc_WorldDir;
		if (overrideDirectionBlend > 0.0001f)
		{
			if (overrideDirectionBlend >= 1f)
			{
				_calc_WorldDir = overridingDirection;
			}
			else
			{
				_calc_WorldDir = Vector3.Slerp(_calc_WorldDir, overridingDirection, overrideDirectionBlend);
			}
		}
		_calc_LocalDir = base.LA.ToRootLocalSpaceVec(_calc_WorldDir);
		_var_raiseLimit = _play_LimitRaise.GetFloat();
		_var_fixFeet = _play_FixFeet.GetFloat();
		if (_calc_LocalDir.sqrMagnitude < 1E-05f)
		{
			_localTargetAngle = 0f;
		}
		_localTargetAngle = FEngineering.GetAngleRad(_calc_LocalDir.x, _calc_LocalDir.z);
		float num = ((!(@float <= 0f)) ? (3f * Mathf.Lerp(5f, 0.5f, @float / 0.6f)) : 1000f);
		_calc_deltaSpeed = base.LA.DeltaTime * num;
		_calc_deltaSpeedSlow = base.LA.DeltaTime * (num * 0.6f);
		_calc_smoothedTargetAngle = Mathf.LerpAngle(_calc_smoothedTargetAngle, _localTargetAngle, _calc_deltaSpeedSlow);
		_calc_angleDiffFactor = Mathf.InverseLerp(0.0001f, 0.25f, Mathf.Abs((_localTargetAngle - _calc_smoothedTargetAngle) / MathF.PI));
		_localTargetAngle *= 57.29578f;
		_wrappedAngle = FormatAngleToPM180(_localTargetAngle);
		_smoothedWrappedAngle = Mathf.LerpAngle(_smoothedWrappedAngle, _wrappedAngle, _calc_deltaSpeed * 1.25f);
		_smoothedWrappedAngle = FormatAngleToPM180(_smoothedWrappedAngle);
		if (_smoothedWrappedAngle < -179.9f && _wrappedAngle > 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		if (_smoothedWrappedAngle > 179.9f && _wrappedAngle < 0f)
		{
			_smoothedWrappedAngle = 0f - _smoothedWrappedAngle;
		}
		float wrappedAngle = _wrappedAngle;
		_calc_sideFactorR = Mathf.Lerp(b: (!(_wrappedAngle < 90f)) ? Mathf.InverseLerp(180f, 90f, wrappedAngle) : Mathf.InverseLerp(0f, 90f, wrappedAngle), a: _calc_sideFactorR, t: _calc_deltaSpeed * 2f);
		_calc_sideFactorL = Mathf.Lerp(b: (!(_wrappedAngle > -90f)) ? Mathf.InverseLerp(-180f, -90f, wrappedAngle) : Mathf.InverseLerp(0f, -90f, wrappedAngle), a: _calc_sideFactorL, t: _calc_deltaSpeed * 2f);
		if (_wrappedAngle < 0f)
		{
			_calc_sideFactor = _calc_sideFactorL;
		}
		else
		{
			_calc_sideFactor = _calc_sideFactorR;
		}
		_calc_toNegativeXProgress = 0f;
		float wrappedAngle2 = _wrappedAngle;
		if (wrappedAngle2 < -90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(-90f, -135f, wrappedAngle2);
		}
		else if (wrappedAngle2 > 90f)
		{
			_calc_toNegativeXProgress = Mathf.InverseLerp(90f, 135f, wrappedAngle2);
		}
		_calc_LocalRotDir = Quaternion.Euler(0f, _localTargetAngle, 0f);
		_wasUpdated = true;
	}

	public override void OnAfterAnimatorCaptureUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (!_wasUpdated)
		{
			return;
		}
		float smoother = _play_Smoother.GetFloat() + 1f;
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			Vector3 animatorEndBonePos = leg._AnimatorEndBonePos;
			Vector3 localPos = base.LA.ToRootLocalSpace(animatorEndBonePos);
			LegRedirectHelper legRedirectHelper = legRedirectHelpers[leg.PlaymodeIndex];
			legRedirectHelper.ComputeIKOffset(localPos, smoother);
			Vector3 vector = legRedirectHelper.LastComputedWorldSpaceLegPos;
			if (_mainBlend < 1f)
			{
				vector = Vector3.LerpUnclamped(animatorEndBonePos, vector, _mainBlend);
			}
			Vector3 calc_ikOff = _calc_ikOff;
			if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Left)
			{
				calc_ikOff.x = 0f - calc_ikOff.x;
			}
			else if (base.LA.Legs[i].Side == LegsAnimator.ELegSide.Right)
			{
				calc_ikOff.z = 0f - calc_ikOff.z;
			}
			calc_ikOff = base.LA.RootToWorldSpaceVec(calc_ikOff);
			vector += calc_ikOff;
			leg.OverrideAnimatorAnklePosition(vector);
		}
	}

	public void OverrideMoveDirection(Vector3? direction)
	{
		if (!direction.HasValue)
		{
			useOverridingDirection = false;
			return;
		}
		useOverridingDirection = true;
		overridingDirection = direction.Value;
	}

	public override void OnLateUpdatePreApply(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (!_wasUpdated)
		{
			return;
		}
		float @float = _play_HipsRedir.GetFloat();
		float float2 = _play_FeetRedir.GetFloat();
		float float3 = _play_KneesRedir.GetFloat();
		float float4 = _play_AdjustStretch.GetFloat();
		float num = Mathf.Abs(_wrappedAngle);
		float num2 = Mathf.InverseLerp(0f, 45f, num);
		float wrappedAngle = _wrappedAngle;
		float num3 = wrappedAngle;
		if (float2 > 0f)
		{
			if (wrappedAngle < -90f)
			{
				num3 = ((!(wrappedAngle > -135f)) ? Mathf.Lerp(40f, 0f, Mathf.InverseLerp(-135f, -180f, wrappedAngle)) : Mathf.Lerp(-90f, 40f, Mathf.InverseLerp(-90f, -135f, wrappedAngle)));
			}
			else if (wrappedAngle > 90f)
			{
				num3 = ((!(wrappedAngle < 135f)) ? Mathf.Lerp(-40f, 0f, Mathf.InverseLerp(135f, 180f, wrappedAngle)) : Mathf.Lerp(90f, -40f, Mathf.InverseLerp(90f, 135f, wrappedAngle)));
			}
		}
		Vector3 zero = Vector3.zero;
		float num4 = 0f;
		float num5 = 0f;
		float num6 = 0f;
		num6 = ((!(num > 135f)) ? Mathf.InverseLerp(90f, 135f, num) : Mathf.InverseLerp(180f, 135f, num));
		num6 = Mathf.Lerp(1f, -0.5f, num6);
		for (int i = 0; i < base.LA.Legs.Count; i++)
		{
			LegsAnimator.Leg leg = base.LA.Legs[i];
			if (float2 > 0f)
			{
				float num7 = num3;
				float num8 = 1f - float2;
				num8 = num8 * num8 * num8;
				Quaternion target = Quaternion.AngleAxis(num7 * (1f - num8) * 0.8f * _mainBlend, base.LA.BaseTransform.up);
				target = legRedirectHelpers[i].FootRedirectSmoother(target);
				leg.OverrideFinalIKRot(target * leg.GetFinalIKRot());
			}
			if (float3 > 0f)
			{
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorR) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
				else if (leg.Side == LegsAnimator.ELegSide.Right)
				{
					leg.IKProcessor.StartBoneRotationOffset = Quaternion.Euler(0f, (0f - _calc_sideFactorL) * Mathf.Min(35f, 50f * float3) * num6, 0f);
				}
			}
			else
			{
				leg.IKProcessor.StartBoneRotationOffset = Quaternion.identity;
			}
			if (!(float4 > 0.01f))
			{
				continue;
			}
			float stretchValue = leg.IKProcessor.GetStretchValue(legRedirectHelpers[i].LastComputedWorldSpaceLegPos);
			if (stretchValue > 0.9f)
			{
				float num9 = Mathf.InverseLerp(0.9f, 1.125f, stretchValue);
				if (leg.Side == LegsAnimator.ELegSide.Left)
				{
					num4 += num9;
				}
				else
				{
					num5 += num9;
				}
				Vector3 vec = leg._PreviousFinalIKPos - base.LA.BaseTransform.position;
				vec = base.LA.ToRootLocalSpaceVec(vec);
				vec.y *= -0.8f;
				vec = base.LA.RootToWorldSpaceVec(vec);
				zero += vec * (num9 * 1f);
			}
		}
		Vector3 val = Animation360Angles.AnglesOn0;
		Vector3 val2 = Animation360Angles.HipsOffsetOn0;
		Vector3 val3 = Animation360Angles.IKsOffsetOn0;
		if (num > 0f)
		{
			if (num < 90f)
			{
				float t = InverseLerpDoubleSide(0f, 45f, num, 90f);
				LerpIt(ref val, Animation360Angles.AnglesOn45, t);
				LerpIt(ref val2, Animation360Angles.HipsOffsetOn45, t);
				LerpIt(ref val3, Animation360Angles.IKsOffsetOn45, t);
			}
			if (num > 45f && num < 135f)
			{
				float t2 = InverseLerpDoubleSide(45f, 90f, num, 135f);
				LerpIt(ref val, Animation360Angles.AnglesOn90, t2);
				LerpIt(ref val2, Animation360Angles.HipsOffsetOn90, t2);
				LerpIt(ref val3, Animation360Angles.IKsOffsetOn90, t2);
			}
			if (num > 90f)
			{
				float t3 = InverseLerpDoubleSide(90f, 135f, num, 180f);
				LerpIt(ref val, Animation360Angles.AnglesOn135, t3);
				LerpIt(ref val2, Animation360Angles.HipsOffsetOn135, t3);
				LerpIt(ref val3, Animation360Angles.IKsOffsetOn135, t3);
			}
			if (num > 135f)
			{
				float t4 = Mathf.InverseLerp(135f, 180f, num);
				LerpIt(ref val, Animation360Angles.AnglesOn180, t4);
				LerpIt(ref val2, Animation360Angles.HipsOffsetOn180, t4);
				LerpIt(ref val3, Animation360Angles.IKsOffsetOn180, t4);
			}
			if (_wrappedAngle < 0f)
			{
				val.y = 0f - val.y;
				val.z = 0f - val.z;
				val2.x = 0f - val2.x;
				val3.z = 0f - val3.z;
			}
			val *= @float;
			val2 *= 0.7f * @float;
			val = Vector3.Scale(val, User_MultiplyHipsOffsets);
		}
		val3 *= @float * _mainBlend * base.LA.ScaleReference;
		_calc_ikOff = val3;
		float num10 = 0.25f + float4 * 0.75f;
		_calc_lStretch = Mathf.Lerp(_calc_lStretch, num4, _calc_deltaSpeed);
		_calc_rStretch = Mathf.Lerp(_calc_rStretch, num5, _calc_deltaSpeed);
		val.y -= _calc_lStretch * User_StretchRotatorAnglePower * @float * num10;
		val.y += _calc_rStretch * User_StretchRotatorAnglePower * @float * num10;
		_calc_hipsRotationOffsets.x = Mathf.LerpAngle(_calc_hipsRotationOffsets.x, val.x, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.y = Mathf.LerpAngle(_calc_hipsRotationOffsets.y, val.y, _calc_deltaSpeed);
		_calc_hipsRotationOffsets.z = Mathf.LerpAngle(_calc_hipsRotationOffsets.z, val.z, _calc_deltaSpeed);
		_calc_hipsPositionOffsets = Vector3.Lerp(_calc_hipsPositionOffsets, val2, _calc_deltaSpeed);
		val2 *= User_StretchPositionMultiplier;
		Quaternion b = Quaternion.identity;
		float num11 = _play_RestoreSpine.GetFloat();
		if (SpineBone != null)
		{
			b = SpineBone.rotation;
		}
		else
		{
			num11 = 0f;
		}
		Quaternion quaternion = Quaternion.AngleAxis(_calc_hipsRotationOffsets.y * _mainBlend, base.LA.BaseTransform.up);
		quaternion *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.z * _mainBlend, base.LA.BaseTransform.forward);
		quaternion *= Quaternion.AngleAxis(_calc_hipsRotationOffsets.x * _mainBlend, base.LA.BaseTransform.right);
		base.LA.Hips.rotation = quaternion * base.LA.Hips.rotation;
		if (num11 > 0f)
		{
			SpineBone.rotation = Quaternion.Slerp(SpineBone.rotation, b, Mathf.Lerp(1f, num11, _mainBlend));
		}
		_calc_hipsStretchOffset = Vector3.SmoothDamp(_calc_hipsStretchOffset, num2 * zero, ref _sd_hipsStretchOff, 0.2f + 0.3f * _play_TrDur.GetFloat(), 100000f, base.LA.DeltaTime);
		Vector3 vector = base.LA.RootToWorldSpaceVec(_calc_hipsPositionOffsets * 0.5f * base.LA.ScaleReference) * _mainBlend;
		base.LA._Hips_Modules_ExtraWOffset += vector + _calc_hipsStretchOffset * float4 * _mainBlend;
		if (_play_reAdj.GetBool())
		{
			for (int j = 0; j < base.LA.Legs.Count; j++)
			{
				base.LA.Legs[j].OverrideFinalIKPos(base.LA.Legs[j].GetFinalIKPos() - vector);
			}
		}
	}

	public override void OnPostLateUpdate(LegsAnimator.LegsAnimatorCustomModuleHelper helper)
	{
		if (!(_mainBlend < 0.001f) && _wasUpdated && _var_fixFeet > 0f)
		{
			for (int i = 0; i < base.LA.Legs.Count; i++)
			{
				LegsAnimator.Leg leg = base.LA.Legs[i];
				Quaternion rotation = leg.IKProcessor.EndIKBone.transform.rotation;
				Quaternion b = leg.IKProcessor.EndIKBone.transform.parent.rotation * leg.IKProcessor.EndIKBone.InitialLocalRotation;
				b = Quaternion.LerpUnclamped(rotation, b, (1f - leg.A_AligningHelperBlend) * _var_fixFeet * base.LA.IsMovingBlend * _calc_toNegativeXProgress);
				leg.IKProcessor.EndIKBone.transform.rotation = b;
			}
		}
	}

	public static float FormatAngleToPM180(float angle)
	{
		float num = angle % 360f;
		if (num > 180f)
		{
			num -= 360f;
		}
		if (num < -180f)
		{
			num += 360f;
		}
		return num;
	}

	private static float InverseLerpDoubleSide(float from, float to, float t, float toRange)
	{
		if (t > to)
		{
			return Mathf.InverseLerp(toRange, to, t);
		}
		return Mathf.InverseLerp(from, to, t);
	}

	private static void LerpIt(ref Vector3 val, Vector3 to, float t)
	{
		val = Vector3.LerpUnclamped(val, to, t);
	}
}
