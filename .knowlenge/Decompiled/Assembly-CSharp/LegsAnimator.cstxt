using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using FIMSpace;
using FIMSpace.AnimationTools;
using FIMSpace.FProceduralAnimation;
using FIMSpace.FTools;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;

[DefaultExecutionOrder(-1301)]
[HelpURL("https://assetstore.unity.com/packages/tools/animation/legs-animator-154245")]
[AddComponentMenu("FImpossible Creations/Legs Animator")]
public class LegsAnimator : MonoBehaviour, IDropHandler, IEventSystemHandler, IFHierarchyIcon
{
	private struct CalibrateTransform
	{
		public Transform Transform;

		private Quaternion initLocalRot;

		public CalibrateTransform(Transform t)
		{
			Transform = t;
			initLocalRot = t.localRotation;
		}

		public void Calibrate()
		{
			Transform.localRotation = initLocalRot;
		}
	}

	public enum EStepType
	{
		IdleGluing,
		MovementGluing,
		OnLanding,
		OnStopping
	}

	public interface ILegStepReceiver
	{
		void LegAnimatorStepEvent(Leg leg, float power, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
	}

	public interface ILegRaiseReceiver
	{
		void LegAnimatorRaiseEvent(Leg leg, float predictedDistance, bool isRight, Vector3 position, Quaternion rotation, EStepType type);
	}

	[Serializable]
	public class LegsAnimatorCustomModuleHelper
	{
		public bool Enabled = true;

		public LegsAnimator Parent;

		public LegsAnimatorControlModuleBase ModuleReference;

		[SerializeField]
		[HideInInspector]
		public List<string> customStringList;

		[HideInInspector]
		[SerializeField]
		public List<UnityEngine.Object> customObjectList;

		[SerializeField]
		private List<Variable> variables = new List<Variable>();

		public LegsAnimatorControlModuleBase PlaymodeModule { get; private set; }

		public LegsAnimatorControlModuleBase CurrentModule => PlaymodeModule;

		public LegsAnimatorCustomModuleHelper(LegsAnimator get)
		{
			Parent = get;
		}

		public void PreparePlaymodeModule(LegsAnimator parent)
		{
			if (!(PlaymodeModule != null) && !(ModuleReference == null))
			{
				PlaymodeModule = UnityEngine.Object.Instantiate(ModuleReference);
				PlaymodeModule.Base_Init(parent, this);
			}
		}

		public void DisposeModule()
		{
			if (PlaymodeModule != null)
			{
				UnityEngine.Object.Destroy(PlaymodeModule);
			}
			PlaymodeModule = null;
		}

		public Variable RequestVariable(string name, object defaultValue)
		{
			if (variables == null)
			{
				variables = new List<Variable>();
			}
			int hashCode = name.GetHashCode();
			for (int i = 0; i < variables.Count; i++)
			{
				if (variables[i].GetNameHash == hashCode)
				{
					return variables[i];
				}
			}
			Variable variable = new Variable(name, defaultValue);
			variables.Add(variable);
			return variable;
		}
	}

	[Serializable]
	public class PelvisImpulseSettings
	{
		public string OptionalName = "Impulse";

		[Space(3f)]
		public float PowerMultiplier = 1f;

		[Tooltip("Duration of translation impulse in seconds")]
		public float ImpulseDuration = 0.5f;

		[Space(5f)]
		public Vector3 WorldTranslation = Vector3.zero;

		public Vector3 LocalTranslation = new Vector3(0f, -0.2f, 0.1f);

		[Space(5f)]
		public Vector3 HipsRotate = Vector3.zero;

		[Range(0f, 1f)]
		[Space(5f)]
		public float InheritElasticness = 0.75f;

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve ImpulseCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 0f);

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve YAxisMultiplyCurve = AnimationCurve.EaseInOut(0f, 1f, 1f, 1f);

		[Tooltip("Local Offset Z-forward will bo rotated to face the legs animator's current desired move direction value")]
		[Space(5f)]
		public bool AlignWithDesiredMoveDirection;

		public PelvisImpulseSettings Copy()
		{
			return (PelvisImpulseSettings)MemberwiseClone();
		}

		public PelvisImpulseSettings()
		{
			ImpulseCurve = GetDefaultCurveInstance();
		}

		public static AnimationCurve GetDefaultCurveInstance()
		{
			AnimationCurve animationCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);
			animationCurve.AddKey(new Keyframe(0.2f, 1f));
			animationCurve.SmoothTangents(1, 0.5f);
			return animationCurve;
		}

		public PelvisImpulseSettings(Vector3 vector3, float duration, float power)
			: this()
		{
			LocalTranslation = vector3;
			ImpulseDuration = duration;
			PowerMultiplier = power;
		}
	}

	public struct ImpulseExecutor
	{
		public float Elapsed;

		public float PowerMultiplier;

		public float ImpulseDuration;

		public Vector3 WorldTranslation;

		public Vector3 LocalTranslation;

		public float InheritElasticness;

		public Vector3 HipsRotation;

		public bool AlignDesired;

		public AnimationCurve ImpulseCurve;

		public AnimationCurve YAxisMultiplyCurve;

		private static AnimationCurve _defaultCurve;

		private static AnimationCurve _defaultCurve11;

		public static AnimationCurve DefaultCurve
		{
			get
			{
				if (_defaultCurve == null)
				{
					_defaultCurve = PelvisImpulseSettings.GetDefaultCurveInstance();
				}
				return _defaultCurve;
			}
		}

		public static AnimationCurve DefaultCurve11
		{
			get
			{
				if (_defaultCurve11 == null)
				{
					_defaultCurve11 = AnimationCurve.Linear(0f, 1f, 1f, 1f);
				}
				return _defaultCurve11;
			}
		}

		public bool Finished => Elapsed >= ImpulseDuration;

		public float Progress
		{
			get
			{
				if (ImpulseDuration != 0f)
				{
					return Elapsed / ImpulseDuration;
				}
				return 1f;
			}
		}

		public float Evaluation => ImpulseCurve.Evaluate(Progress);

		public float Elastic => InheritElasticness;

		public float Power => PowerMultiplier;

		public Vector3 CurrentLocalOffset => LocalTranslation * Evaluation * Power;

		public float CurrentLocalYAxisMultiplier => YAxisMultiplyCurve.Evaluate(Progress);

		public Vector3 CurrentWorldOffset => WorldTranslation * Evaluation * Power;

		public ImpulseExecutor(PelvisImpulseSettings settings, float powerMultiplier = 1f, float durationMultiplier = 1f)
		{
			Elapsed = 0f;
			PowerMultiplier = settings.PowerMultiplier * powerMultiplier;
			ImpulseDuration = settings.ImpulseDuration * durationMultiplier;
			WorldTranslation = settings.WorldTranslation;
			LocalTranslation = settings.LocalTranslation;
			InheritElasticness = settings.InheritElasticness;
			HipsRotation = settings.HipsRotate;
			ImpulseCurve = settings.ImpulseCurve;
			YAxisMultiplyCurve = settings.YAxisMultiplyCurve;
			AlignDesired = settings.AlignWithDesiredMoveDirection;
		}

		public ImpulseExecutor(Vector3 localOffset, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = Vector3.zero;
			LocalTranslation = localOffset;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			HipsRotation = Vector3.zero;
			AlignDesired = alignWithDesiredDir;
		}

		public ImpulseExecutor(Vector3 localOffset, Vector3 hipsRotation, float duration, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = Vector3.zero;
			HipsRotation = hipsRotation;
			LocalTranslation = localOffset;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			AlignDesired = alignWithDesiredDir;
		}

		public ImpulseExecutor(float duration, Vector3 worldOffset, float elastic = 1f, AnimationCurve curve = null, bool alignWithDesiredDir = false)
		{
			Elapsed = 0f;
			PowerMultiplier = 1f;
			ImpulseDuration = duration;
			WorldTranslation = worldOffset;
			HipsRotation = Vector3.zero;
			LocalTranslation = Vector3.zero;
			InheritElasticness = elastic;
			ImpulseCurve = curve;
			if (curve == null)
			{
				ImpulseCurve = DefaultCurve;
			}
			YAxisMultiplyCurve = DefaultCurve11;
			AlignDesired = alignWithDesiredDir;
		}

		public void Update(float delta)
		{
			Elapsed += delta;
		}
	}

	public enum EHipsAdjustStyle
	{
		SmoothDamp,
		FollowLegHeight
	}

	public enum EHipsHubsHandling
	{
		[Tooltip("Applying hips movement offset to the selected hub, in order to fix disconnected hips bones (rare case)")]
		FixDisconnected,
		[Tooltip("Detailed mode is computing hips hub offsets individually, giving more realistic effect but costs a bit more")]
		Detailed
	}

	[Serializable]
	public class HipsReference
	{
		public class HipsHubBackbone
		{
			public Transform frontBone;

			private Vector3 _dir = Vector3.zero;

			private Vector3 _sd_dir = Vector3.zero;

			private FMuscle_Vector3 _FMuscle;

			public LegsAnimator Owner { get; private set; }

			public Transform bone { get; private set; }

			public Quaternion initialLocalRotation { get; private set; }

			public Vector3 keyframePosition { get; private set; }

			public Quaternion TargetRotation { get; internal set; }

			public HipsHubBackbone(LegsAnimator owner, Transform b)
			{
				Owner = owner;
				bone = b;
				initialLocalRotation = b.localRotation;
				_FMuscle = new FMuscle_Vector3();
				_FMuscle.Initialize(Vector3.zero);
			}

			public void PreCalibrate()
			{
				bone.localRotation = initialLocalRotation;
			}

			public void Calibrate()
			{
				keyframePosition = bone.position;
			}

			public Vector3 AnimateTargetDirection(Vector3 toHubNewB)
			{
				if (Owner.HubBackBonesElasticity < 0.0001f)
				{
					return toHubNewB;
				}
				if (Owner.HubBackBonesElasticity <= 0.1f)
				{
					_dir = Vector3.SmoothDamp(_dir, toHubNewB, ref _sd_dir, 0.001f + Owner.HubBackBonesElasticity, 10000000f, Owner.DeltaTime);
				}
				else
				{
					_dir = Vector3.LerpUnclamped(toHubNewB, _FMuscle.Update(Owner.DeltaTime, toHubNewB), Owner.HubBackBonesElasticity);
				}
				return _dir;
			}
		}

		[Tooltip("Applying elasticity algorithm on the pelvis bone align motion, to make it look more organic.")]
		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float HipsElasticityBlend = 1f;

		public FMuscle_Vector3 HipsMuscle;

		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float HipsRotElasticityBlend;

		public FMuscle_Quaternion HipsRotMuscle;

		[NonSerialized]
		public Vector3 LastKeyframePosition;

		[NonSerialized]
		public Vector3 LastKeyframeLocalPosition;

		[NonSerialized]
		public Quaternion LastKeyframeRotation;

		[NonSerialized]
		public Quaternion LastKeyframeLocalRotation;

		[NonSerialized]
		public Vector3 LastRootLocalPos;

		[NonSerialized]
		public float LastHipsHeightDiff;

		[NonSerialized]
		public Vector3 InitHipsPositionRootSpace;

		[NonSerialized]
		public float InitialHipsHeightLocal;

		[NonSerialized]
		internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

		private Transform root;

		private Vector3 initLocalPos;

		private Quaternion initLocalRot;

		private Vector3 _Hips_StabilityLocalAdjustement = Vector3.zero;

		private Vector3 _Hips_sd_StabilAdjustm = Vector3.zero;

		private Vector3 _stretchPreventerOff = Vector3.zero;

		private float _sd_Hips_StepHeightAdjustOffset;

		private int _h_lowestHitLeg = -1;

		private Vector3 _reAdjustLocal = Vector3.zero;

		private Vector3 _sd_readj = Vector3.zero;

		private Vector3 _pushSmoothed = Vector3.zero;

		private Vector3 _sd_pushSmoothed = Vector3.zero;

		public LegsAnimator Owner { get; private set; }

		public List<Leg> ChildLegs { get; private set; }

		public Transform bone { get; private set; }

		public UniRotateBone UniRotate { get; private set; }

		public List<HipsHubBackbone> HubBackBones { get; private set; }

		public Vector3 _Get_Hips_StabilityLocalAdjustement => _Hips_StabilityLocalAdjustement;

		public float _Hips_LastHipsOffset { get; private set; }

		public float _Hips_StepHeightAdjustOffset { get; private set; }

		public Vector3 ExtraNonElasticOffset { get; internal set; }

		public Vector3 _PreHipsAdjustPosition { get; internal set; }

		public void Initialize(LegsAnimator owner, Transform bone, Transform root)
		{
			Owner = owner;
			this.bone = bone;
			this.root = root;
			initLocalPos = bone.localPosition;
			initLocalRot = bone.localRotation;
			ExtraNonElasticOffset = Vector3.zero;
			_Hips_StabilityLocalAdjustement = Vector3.zero;
			_Hips_sd_StabilAdjustm = Vector3.zero;
			InitHipsPositionRootSpace = root.InverseTransformPoint(bone.position);
			InitialHipsHeightLocal = InitHipsPositionRootSpace.y;
			if (HipsMuscle == null)
			{
				HipsMuscle = new FMuscle_Vector3();
			}
			if (HipsRotMuscle == null)
			{
				HipsRotMuscle = new FMuscle_Quaternion();
			}
			HipsMuscle.Initialize(Vector3.zero);
			HipsRotMuscle.Initialize(Quaternion.identity);
			UniRotate = new UniRotateBone(bone, root);
			Calibrate();
		}

		internal void PrepareLegs()
		{
			ChildLegs = new List<Leg>();
			if (!Owner._hipsHubs_using)
			{
				ChildLegs = Owner.Legs;
			}
			else
			{
				for (int i = 0; i < Owner.Legs.Count; i++)
				{
					bool? flag = IsFirstParent(Owner.Legs[i], bone);
					if (flag == true)
					{
						ChildLegs.Add(Owner.Legs[i]);
					}
					else if (!flag.HasValue && this == Owner.HipsSetup)
					{
						ChildLegs.Add(Owner.Legs[i]);
					}
				}
			}
			for (int j = 0; j < ChildLegs.Count; j++)
			{
				ChildLegs[j].AssignParentHub(this);
			}
		}

		internal void PrepareHubBones()
		{
			PrepareLegs();
			HubBackBones = new List<HipsHubBackbone>();
			Transform frontBone = bone;
			Transform parent = bone.parent;
			while (parent != null)
			{
				bool flag = false;
				for (int i = 0; i < Owner.HipsHubs.Count; i++)
				{
					if (parent == Owner.HipsHubs[i].bone)
					{
						flag = true;
						break;
					}
				}
				if (!flag)
				{
					HipsHubBackbone hipsHubBackbone = new HipsHubBackbone(Owner, parent);
					hipsHubBackbone.frontBone = frontBone;
					HubBackBones.Add(hipsHubBackbone);
					if (!(parent == Owner.HipsSetup.bone))
					{
						frontBone = parent;
						parent = parent.parent;
						continue;
					}
					break;
				}
				break;
			}
		}

		private bool? IsFirstParent(Leg leg, Transform hub)
		{
			if (leg.BoneStart == null)
			{
				return false;
			}
			Transform transform = leg.BoneStart;
			while (transform != null)
			{
				if (transform == hub)
				{
					return true;
				}
				if (transform == Owner.Hips)
				{
					return false;
				}
				for (int i = 0; i < Owner.ExtraHipsHubs.Count; i++)
				{
					if (transform == Owner.ExtraHipsHubs[i])
					{
						return false;
					}
				}
				transform = transform.parent;
			}
			return null;
		}

		public void Reset()
		{
			Calibrate();
			_Hips_LastHipsOffset = 0f;
		}

		public void PreCalibrate()
		{
			UniRotate.PreCalibrate();
			if (Owner.Calibrate != ECalibrateMode.FixedCalibrate)
			{
				UniRotate.PreCalibrate();
			}
			else
			{
				bone.localPosition = LastKeyframeLocalPosition;
				bone.localRotation = LastKeyframeLocalRotation;
			}
			if (HubBackBones != null)
			{
				for (int i = 0; i < HubBackBones.Count; i++)
				{
					HubBackBones[i].PreCalibrate();
				}
			}
		}

		public void Calibrate()
		{
			LastKeyframePosition = bone.position;
			LastKeyframeLocalPosition = bone.localPosition;
			LastKeyframeLocalRotation = bone.localRotation;
			LastKeyframeRotation = bone.rotation;
			LastRootLocalPos = Owner.ToRootLocalSpace(LastKeyframePosition);
			LastHipsHeightDiff = GetHeightDiff(LastRootLocalPos.y);
			if (HubBackBones != null)
			{
				for (int i = 0; i < HubBackBones.Count; i++)
				{
					HubBackBones[i].Calibrate();
				}
			}
		}

		public float GetHeightDiff(float rootSpaceHeight)
		{
			return Mathf.InverseLerp(0f, InitialHipsHeightLocal, rootSpaceHeight);
		}

		public void CopyMuscleSettingsFrom(HipsReference hipsSetup)
		{
			HipsMuscle.Acceleration = hipsSetup.HipsMuscle.Acceleration;
			HipsMuscle.AccelerationLimit = hipsSetup.HipsMuscle.AccelerationLimit;
			HipsMuscle.Damping = hipsSetup.HipsMuscle.Damping;
			HipsMuscle.BrakePower = hipsSetup.HipsMuscle.BrakePower;
		}

		public Vector3 CalculateCenterOfMassStability(float stabilizingMultiplier)
		{
			if (Owner.StabilizeCenterOfMass > 0f)
			{
				Vector3 vector = new Vector3(0f, 0f, 0f);
				float num = ChildLegs.Count;
				if (Owner.StabilityAlgorithm == EStabilityMode.Biped_Deprecated)
				{
					for (int i = 0; i < ChildLegs.Count; i++)
					{
						Leg leg = ChildLegs[i];
						Vector3 vector2 = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd * 0.6f);
						Vector3 previousFinalIKPosForStability = leg._PreviousFinalIKPosForStability;
						Vector3 vector3 = Owner.ToRootLocalSpace(previousFinalIKPosForStability + vector2);
						Vector3 initialPosInRootSpace = leg.InitialPosInRootSpace;
						initialPosInRootSpace.y += _Hips_LastHipsOffset;
						Vector3 vector4 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace, leg.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace) : leg.AnkleH.LastKeyframeRootPos);
						Vector3 vector5 = vector3 - vector4;
						vector5.y *= 0.25f;
						vector += vector5 * leg.BlendWeight * 0.5f * (stabilizingMultiplier * Owner.StabilizeCenterOfMass);
					}
					vector.y /= num;
				}
				else if (Owner.StabilityAlgorithm == EStabilityMode.Universal)
				{
					Vector3 lastRootLocalPos = LastRootLocalPos;
					for (int j = 0; j < ChildLegs.Count; j++)
					{
						Leg leg2 = ChildLegs[j];
						Vector3 initialPosInRootSpace2 = leg2.InitialPosInRootSpace;
						initialPosInRootSpace2.y += _Hips_LastHipsOffset;
						Vector3 vector6 = ((!(Owner.AnimationIsStablePose >= 1f)) ? ((!(Owner.AnimationIsStablePose <= 0f)) ? Vector3.LerpUnclamped(initialPosInRootSpace2, leg2.AnkleH.LastKeyframeRootPos, Owner.AnimationIsStablePose) : initialPosInRootSpace2) : leg2.AnkleH.LastKeyframeRootPos);
						Vector3 vector7 = lastRootLocalPos - vector6;
						Vector3 vector8 = Owner.ToRootLocalSpace(leg2._PreviousFinalIKPosForStability);
						Vector3 vector9 = lastRootLocalPos - vector8;
						Vector3 vector10 = vector7 - vector9;
						vector10.y *= 0.25f;
						vector += vector10 * leg2.BlendWeight * (stabilizingMultiplier * Owner.StabilizeCenterOfMass) / num;
					}
				}
				if (vector.y > 0f)
				{
					vector.y = 0f;
				}
				if (Owner.StabilizingSpeed < 1f)
				{
					float duration = 0f;
					if (Owner.StabilizingSpeed < 1f)
					{
						duration = 0.001f + (1f - Owner.StabilizingSpeed) * 0.4f;
					}
					Owner.ValueTowards(ref _Hips_StabilityLocalAdjustement, vector, ref _Hips_sd_StabilAdjustm, duration);
				}
				else
				{
					_Hips_StabilityLocalAdjustement = vector;
				}
			}
			else
			{
				_Hips_StabilityLocalAdjustement = Vector3.zero;
			}
			return _Hips_StabilityLocalAdjustement;
		}

		public Vector3 CalculateStretchPreventerOffset()
		{
			if (Owner.HipsStretchPreventer < 0.0001f)
			{
				return Vector3.zero;
			}
			Vector3 zero = Vector3.zero;
			float num = 0f;
			Vector3 lastRootLocalPos = LastRootLocalPos;
			lastRootLocalPos.y = 0f;
			lastRootLocalPos = Owner.baseTransform.TransformPoint(lastRootLocalPos);
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				float stretchValue = leg.IKProcessor.GetStretchValue(leg._PreviousFinalIKPosForStability);
				if (stretchValue > Owner.LimitLegStretch * 0.975f)
				{
					num += 1f;
					float num2 = stretchValue - Owner.LimitLegStretch * 0.975f;
					Vector3 vec = lastRootLocalPos - leg._PreviousFinalIKPosForStability;
					vec = Owner.ToRootLocalSpaceVec(vec);
					if (vec.y > 0f)
					{
						vec.y = 0f;
					}
					vec.x *= -0.6f;
					vec.z *= -0.6f;
					zero += vec * Mathf.Clamp(num2 * 3f, 0f, 0.5f);
				}
			}
			if (Owner.StretchPreventerSpeed < 1f)
			{
				float num3 = Mathf.Lerp(8f, 40f, Owner.StretchPreventerSpeed) * Owner.DeltaTime;
				if (num > 0f)
				{
					_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, zero / num, num3);
				}
				else
				{
					_stretchPreventerOff = Vector3.Lerp(_stretchPreventerOff, Vector3.zero, num3 * 0.7f);
				}
			}
			else
			{
				_stretchPreventerOff = zero;
			}
			return _stretchPreventerOff;
		}

		public Vector3 CalculateGlueMovePush()
		{
			Vector3 zero = Vector3.zero;
			if (Owner.GlueBlend < 0.0001f)
			{
				return zero;
			}
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				if ((leg.G_Attached || leg.G_DuringLegAdjustMovement) && leg.G_LastLegMoveDistanceFactor > 0.055f && leg.G_GlueInternalTransition > 0f && leg.G_GlueInternalTransition < 1f && leg.G_HandlerExecutingLegAnimationMode == EGlueMode.Idle)
				{
					Vector3 vector = leg.AnkleH.Bone.TransformVector(leg.AnkleToFeetEnd);
					Vector3 vector2 = Owner.ToRootLocalSpace(leg._PreviousFinalIKPosForStability + vector);
					vector2.z = 0f - vector2.z;
					float num = Owner.BaseLegAnimating.PushHipsOnMoveCurve.Evaluate(leg.G_GlueInternalTransition);
					Vector3 vector3 = -vector2 * num * 1f;
					vector3.y -= num * leg.G_LastLegMoveDistanceFactor * Owner.ScaleReferenceNoScale * 0.75f;
					Vector3 vector4;
					if (Owner.NormalizePush)
					{
						float num2 = Mathf.Min(1f, vector3.magnitude / (Owner.ScaleReferenceNoScale * 0.33f));
						num2 *= num2;
						vector4 = vector3.normalized * Owner.ScaleReferenceNoScale * 0.33f * num2;
					}
					else
					{
						vector4 = vector3;
					}
					vector4.y *= Owner.PushYBlend;
					zero += vector4 * leg.BlendWeight;
				}
			}
			return zero;
		}

		private void AnimateStepAdjustTo(float yOffset)
		{
			if (Owner.HipsHeightStepSpeed >= 1f)
			{
				_Hips_StepHeightAdjustOffset = yOffset;
				return;
			}
			float landingBoost = Owner.GetLandingBoost();
			if (Owner.HipsAdjustStyle == EHipsAdjustStyle.FollowLegHeight && yOffset < _Hips_StepHeightAdjustOffset && _h_lowestHitLeg != -1)
			{
				Vector3 previousFinalIKPos = Owner.Legs[_h_lowestHitLeg]._PreviousFinalIKPos;
				previousFinalIKPos = Owner.ToRootLocalSpace(previousFinalIKPos);
				previousFinalIKPos.y -= Owner.ScaleReferenceNoScale * 0.325f;
				if (previousFinalIKPos.y > yOffset)
				{
					yOffset = previousFinalIKPos.y;
				}
			}
			_Hips_StepHeightAdjustOffset = Mathf.SmoothDamp(_Hips_StepHeightAdjustOffset, yOffset, ref _sd_Hips_StepHeightAdjustOffset, Mathf.LerpUnclamped(0.4f, 0.01f, landingBoost), 1000000f, Owner.DeltaTime);
			_h_lowestHitLeg = -1;
		}

		public float CalculateBodyAdjust()
		{
			_Hips_LastHipsOffset = 0f;
			if (Owner.HipsHeightStepBlend <= 0f)
			{
				return 0f;
			}
			if (Owner.IsGrounded)
			{
				Vector3 vector = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
				Vector3 vector2 = new Vector3(float.MaxValue, float.MaxValue, float.MaxValue);
				for (int i = 0; i < ChildLegs.Count; i++)
				{
					Leg leg = ChildLegs[i];
					if (!leg.RaycastHitted)
					{
						continue;
					}
					Vector3 point = leg.LastGroundHit.point;
					point = Owner.ToRootLocalSpace(point);
					if (point.y <= 0f)
					{
						if (0f - point.y < Owner.BodyStepDown * Owner.ScaleReferenceNoScale && point.y < vector.y)
						{
							vector = point;
							_h_lowestHitLeg = i;
						}
					}
					else if (point.y < Owner.MaxBodyStepUp * Owner.ScaleReferenceNoScale && point.y < vector.y)
					{
						vector2 = point;
					}
				}
				bool flag = false;
				if (vector.x != float.MaxValue && Owner.BodyStepDown > 0f && vector.y <= 0f)
				{
					AnimateStepAdjustTo(vector.y);
					flag = true;
				}
				if (!flag && Owner.MaxBodyStepUp > 0f && vector2.x != float.MaxValue)
				{
					AnimateStepAdjustTo(vector2.y);
					flag = true;
				}
				if (!flag)
				{
					AnimateStepAdjustTo(0f);
				}
			}
			else
			{
				AnimateStepAdjustTo(0f);
			}
			float num = Owner.HipsBlendWeight * Owner._MainBlend * Owner.IsGroundedBlend * Owner.RagdolledDisablerBlend;
			_Hips_LastHipsOffset = _Hips_StepHeightAdjustOffset * Owner.baseTransform.lossyScale.y * num;
			return _Hips_LastHipsOffset;
		}

		public Vector3 CalculateStretchReadjust()
		{
			Vector3 zero = Vector3.zero;
			for (int i = 0; i < ChildLegs.Count; i++)
			{
				Leg leg = ChildLegs[i];
				Vector3 vector = leg._FinalIKPos - zero;
				if (leg.IKProcessor.GetStretchValue(vector) > Owner.LimitLegStretch)
				{
					Vector3 notStretchedPositionTowards = leg.IKProcessor.GetNotStretchedPositionTowards(vector, Owner.LimitLegStretch);
					Vector3 vector2 = vector - notStretchedPositionTowards;
					zero += vector2;
				}
			}
			zero = Owner.ToRootLocalSpaceVec(zero);
			_reAdjustLocal = Vector3.SmoothDamp(_reAdjustLocal, zero, ref _sd_readj, 0.1f, 10000000f, Owner.DeltaTime);
			return _reAdjustLocal;
		}

		public Vector3 SmoothPushOffset(Vector3 pushLocalOffset, float pushDuration)
		{
			Owner.ValueTowards(ref _pushSmoothed, pushLocalOffset, ref _sd_pushSmoothed, pushDuration);
			return _pushSmoothed;
		}

		public Vector3 AnimateOffset(Vector3 hubOffset)
		{
			return hubOffset;
		}
	}

	public enum EStabilityMode
	{
		Biped_Deprecated,
		Universal
	}

	[Serializable]
	public class Leg
	{
		private struct GlueAttachement
		{
			public RaycastHit AttachHit;

			public Transform AttachedTo;

			public Vector3 PosInAttachementLocal;

			public Vector3 NormalInAttachementLocal;

			public Quaternion RotInAttachementLocal;

			public bool NoTransform { get; private set; }

			public GlueAttachement(Leg leg, RaycastHit legGroundHit)
			{
				AttachHit = legGroundHit;
				AttachedTo = legGroundHit.transform;
				if (legGroundHit.transform == null)
				{
					NoTransform = true;
					PosInAttachementLocal = legGroundHit.point;
					NormalInAttachementLocal = legGroundHit.normal;
					RotInAttachementLocal = leg._PreviousFinalIKRot;
					return;
				}
				NoTransform = false;
				PosInAttachementLocal = legGroundHit.transform.InverseTransformPoint(legGroundHit.point);
				NormalInAttachementLocal = legGroundHit.transform.InverseTransformDirection(legGroundHit.normal);
				if (!leg.Owner.AnimateFeet)
				{
					RotInAttachementLocal = Quaternion.identity;
				}
				else
				{
					RotInAttachementLocal = FEngineering.QToLocal(AttachedTo.rotation, leg.GetAlignedOnGroundHitRot(leg._SourceIKRot, legGroundHit.normal));
				}
			}

			internal Vector3 GetRelevantAlignedHitPoint(Leg leg)
			{
				Vector3 relevantHitPoint = GetRelevantHitPoint();
				return leg.GetAlignedOnGroundHitPos(leg.ToRootLocalSpace(relevantHitPoint), relevantHitPoint, GetRelevantNormal());
			}

			internal Vector3 GetRelevantHitPoint()
			{
				if (NoTransform || AttachedTo == null)
				{
					return PosInAttachementLocal;
				}
				return AttachedTo.TransformPoint(PosInAttachementLocal);
			}

			internal Vector3 GetRelevantNormal()
			{
				if (NoTransform)
				{
					return NormalInAttachementLocal;
				}
				return AttachedTo.TransformDirection(NormalInAttachementLocal);
			}

			internal Quaternion GetRelevantAttachementRotation()
			{
				if (NoTransform)
				{
					return RotInAttachementLocal;
				}
				return FEngineering.QToWorld(AttachedTo.rotation, RotInAttachementLocal);
			}

			internal void OverwritePosition(Vector3 legAnimPos)
			{
				if (AttachedTo == null)
				{
					PosInAttachementLocal = legAnimPos;
				}
				else
				{
					PosInAttachementLocal = AttachedTo.transform.InverseTransformPoint(legAnimPos);
				}
			}
		}

		private class GlueAttachementHandler
		{
			public class LegTransitionAnimation
			{
				private enum EMoveType
				{
					FromAnimation,
					FromLastAttachement
				}

				private GlueAttachementHandler handler;

				public float LegAdjustementYOffset;

				public float LegAdjustementFootAngleOffset;

				private Vector3 _legSpherizeLocalVector = Vector3.zero;

				private float _legMoveDurMul = 1f;

				private Quaternion baseRotationOnStepUp;

				public float legMoveDistanceFactor;

				private float sd_trProgress;

				private Vector3 previousPositionLocal;

				private Vector3 previousPositionWorld;

				private Quaternion previousRotationWorld;

				private Vector3 lastAppliedGluePosition;

				private Vector3 lastAppliedGluePositionLocal;

				private Quaternion lastAppliedGlueRotation;

				private float lastSpeedup;

				private EMoveType animationMoveType;

				private bool _instantTransition;

				private bool _wasAnimatingLeg;

				private LegsAnimator Owner => handler.Owner;

				private Leg leg => handler.leg;

				public bool duringLegAdjustMovement { get; private set; }

				public bool wasAttaching { get; private set; }

				public bool attached { get; private set; }

				public float transitionProgress { get; private set; }

				public float lastAttachCompleteTime { get; private set; }

				public float transitionProgressLastFrame { get; private set; }

				public EGlueMode LastAnimationGlueMode
				{
					get
					{
						if (animationMoveType != 0)
						{
							return EGlueMode.Idle;
						}
						return EGlueMode.Moving;
					}
				}

				public LegTransitionAnimation(GlueAttachementHandler glueTransitionHelper)
				{
					handler = glueTransitionHelper;
					Reset();
				}

				public void Reset()
				{
					animationMoveType = EMoveType.FromAnimation;
					transitionProgress = 0f;
					transitionProgressLastFrame = 0f;
					baseRotationOnStepUp = Owner.BaseTransform.rotation;
					duringLegAdjustMovement = false;
					wasAttaching = false;
					attached = false;
					_legSpherizeLocalVector = Vector3.zero;
					ReInitialize();
				}

				public void ReInitialize()
				{
					lastAppliedGluePosition = leg._SourceIKPos;
					lastAppliedGlueRotation = leg._SourceIKRot;
					previousPositionWorld = leg._SourceIKPos;
					previousRotationWorld = leg._SourceIKRot;
					previousPositionLocal = leg.ToRootLocalSpace(leg._SourceIKPos);
				}

				internal void ScheduleInstantTransition()
				{
					_instantTransition = true;
				}

				internal void DoAttaching(bool canAttach)
				{
					if (canAttach != wasAttaching)
					{
						wasAttaching = canAttach;
						if (canAttach)
						{
							OnChangeTargetPosition();
						}
						else
						{
							attached = false;
							if (transitionProgress != 0f)
							{
								OnChangeTargetPosition();
							}
						}
					}
					if (duringLegAdjustMovement && transitionProgress >= 1f)
					{
						duringLegAdjustMovement = false;
					}
				}

				internal Vector3 EnsureAnkleNotOverlappingGroundLevel(Vector3 legAnimPos)
				{
					if (leg.A_PreWasAligning && leg.A_WasAligningFrameBack)
					{
						Vector3 localPos = Owner.ToRootLocalSpace(legAnimPos);
						Vector3 vector = ((!(Owner.SmoothSuddenSteps < 0.0001f)) ? (leg.A_WasSmoothing ? leg.A_LastSmoothTargetedPosLocal : leg.ankleAlignedOnGroundHitRootLocal) : leg.ankleAlignedOnGroundHitRootLocal);
						if (localPos.y < vector.y)
						{
							localPos.y = vector.y;
							legAnimPos = Owner.RootToWorldSpace(localPos);
						}
					}
					return legAnimPos;
				}

				public Vector3 CalculateAnimatedLegPosition(Vector3 a, Vector3 b)
				{
					LegStepAnimatingParameters legAnimatingSettings = leg.LegAnimatingSettings;
					Vector3 result = Vector3.LerpUnclamped(a, b, legAnimatingSettings.MoveToGoalCurve.Evaluate(transitionProgress));
					if (legAnimatingSettings.SpherizeTrack.length > 1)
					{
						float num = legAnimatingSettings.SpherizeTrack.Evaluate(transitionProgress) * legAnimatingSettings.SpherizePower * Owner.BaseTransform.lossyScale.x;
						result += leg.RootSpaceToWorldVec(_legSpherizeLocalVector * (num * 12f));
					}
					if (Owner.AnimateFeet)
					{
						LegAdjustementFootAngleOffset = legAnimatingSettings.FootRotationCurve.Evaluate(transitionProgress) * 90f * Mathf.Min(0.5f, legMoveDistanceFactor * 1.1f);
						LegAdjustementFootAngleOffset /= lastSpeedup;
					}
					float num2 = Owner.ScaleReferenceNoScale * 0.75f;
					float num3 = Mathf.Lerp(legAnimatingSettings.MinFootRaise, legAnimatingSettings.MaxFootRaise, legMoveDistanceFactor);
					num3 *= num2;
					LegAdjustementYOffset = num3 * legAnimatingSettings.RaiseYAxisCurve.Evaluate(transitionProgress);
					_wasAnimatingLeg = true;
					return result;
				}

				internal Vector3 GetTargetPosition()
				{
					float glueAnimationBlend = handler.glueAnimationBlend;
					if (animationMoveType == EMoveType.FromAnimation)
					{
						if (glueAnimationBlend < 0.0001f)
						{
							return Owner.RootToWorldSpace(previousPositionLocal);
						}
						Vector3 vector = Owner.RootToWorldSpace(previousPositionLocal);
						if (transitionProgress < 0.0001f)
						{
							return vector;
						}
						Vector3 vector2 = ((!attached) ? leg.ankleAlignedOnGroundHitWorldPos : ((glueAnimationBlend > 0.9995f) ? leg._GlueLastAttachPosition : ((!leg.Owner.OnlyLocalAnimation) ? Vector3.LerpUnclamped(leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal), leg._GlueLastAttachPosition, glueAnimationBlend) : leg.RootSpaceToWorld(leg._GlueLastAttachPositionRootLocal))));
						if (transitionProgress > 0.9995f)
						{
							return vector2;
						}
						return Vector3.LerpUnclamped(vector, vector2, transitionProgress);
					}
					Vector3 vector3;
					if (leg.Owner.OnlyLocalAnimation)
					{
						vector3 = Owner.RootToWorldSpace(previousPositionLocal);
						if (transitionProgress < 0.0001f)
						{
							return vector3;
						}
					}
					else
					{
						vector3 = previousPositionWorld;
						if (transitionProgress < 0.0001f)
						{
							return vector3;
						}
						vector3 = Vector3.LerpUnclamped(previousPositionWorld, Owner.RootToWorldSpace(previousPositionLocal), transitionProgress);
					}
					Vector3 vector4 = ((!(transitionProgress > 0.9995f)) ? CalculateAnimatedLegPosition(vector3, leg.ankleAlignedOnGroundHitWorldPos) : leg._GlueLastAttachPosition);
					if (transitionProgress >= 1f)
					{
						return vector4;
					}
					float num = 1f - transitionProgress;
					return Vector3.LerpUnclamped(vector3, vector4, 1f - num * num);
				}

				internal void RequireRepose()
				{
					if (attached)
					{
						attached = false;
						OnChangeTargetPosition();
					}
				}

				internal Quaternion GetTargetRotation()
				{
					Quaternion quaternion = previousRotationWorld;
					if (transitionProgress < 0.001f)
					{
						return quaternion;
					}
					Quaternion quaternion2 = ((!attached) ? leg.ankleAlignedOnGroundHitRotation : leg._GlueLastAttachRotation);
					if (transitionProgress > 0.9995f)
					{
						return quaternion2;
					}
					return Quaternion.LerpUnclamped(quaternion, quaternion2, transitionProgress);
				}

				internal void OnChangeTargetPosition()
				{
					handler.lasGlueModeOnAttaching = Owner._glueModeExecuted;
					baseRotationOnStepUp = Owner.BaseTransform.rotation;
					if (handler.glueAnimationBlend < 0.2f)
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					else if (handler.lasGlueModeOnAttaching == EGlueMode.Moving)
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					else if (animationMoveType == EMoveType.FromLastAttachement)
					{
						animationMoveType = EMoveType.FromLastAttachement;
					}
					else if (handler.glueAnimationBlend > 0.75f)
					{
						if (transitionProgress < 0.1f || transitionProgress > 0.9f)
						{
							animationMoveType = EMoveType.FromLastAttachement;
						}
						else
						{
							animationMoveType = EMoveType.FromAnimation;
						}
					}
					else
					{
						animationMoveType = EMoveType.FromAnimation;
					}
					if (leg.Owner.OnlyLocalAnimation)
					{
						previousPositionWorld = leg.RootSpaceToWorld(lastAppliedGluePositionLocal);
					}
					else
					{
						previousPositionWorld = lastAppliedGluePosition;
					}
					previousRotationWorld = lastAppliedGlueRotation;
					previousPositionLocal = Owner.ToRootLocalSpace(previousPositionWorld);
					if (animationMoveType == EMoveType.FromLastAttachement)
					{
						if (!(transitionProgress > 0.1f) || !(transitionProgress < 0.9f))
						{
							transitionProgress = 0f;
						}
						Vector3 vector = previousPositionWorld;
						Vector3 vector2 = leg.ankleAlignedOnGroundHitWorldPos - vector;
						float magnitude = vector2.magnitude;
						legMoveDistanceFactor = magnitude / (Owner.ScaleReference * 0.6f);
						legMoveDistanceFactor = Mathf.Clamp(legMoveDistanceFactor, 0.05f, 1f);
						Vector3 normalized = vector2.normalized;
						normalized = Vector3.ProjectOnPlane(normalized, Owner.Up);
						normalized.Normalize();
						leg.SendRaiseEvent(magnitude);
						if (legMoveDistanceFactor > 0.0401f)
						{
							_legMoveDurMul = Mathf.Lerp(1.55f, 0.85f, legMoveDistanceFactor * 2f);
							Vector3 worldDir = Vector3.Cross(normalized, Owner.Up);
							worldDir.Normalize();
							_legSpherizeLocalVector = leg.ToRootLocalSpaceDir(worldDir) * Owner.ScaleReferenceNoScale * -0.03f;
							duringLegAdjustMovement = true;
						}
						else
						{
							animationMoveType = EMoveType.FromAnimation;
							_legSpherizeLocalVector = Vector3.zero;
							duringLegAdjustMovement = false;
						}
					}
					else
					{
						duringLegAdjustMovement = false;
						transitionProgress = 0f;
					}
				}

				public void UpdateAnimation()
				{
					float num = (Owner.JustGrounded ? 0.2f : 1f);
					float num2 = (Owner.JustGrounded ? 5f : 1f);
					transitionProgressLastFrame = transitionProgress;
					if (_instantTransition)
					{
						_instantTransition = false;
						transitionProgress = 1f;
						lastAttachCompleteTime = Time.time;
					}
					if (!Owner.IsGrounded)
					{
						return;
					}
					if (animationMoveType == EMoveType.FromLastAttachement)
					{
						float num3 = 1f / (leg.LegAnimatingSettings.StepMoveDuration * 0.8f);
						float num4 = 1f;
						lastSpeedup = 1f;
						if (leg.LegAnimatingSettings.AllowSpeedups > 0f)
						{
							if (leg.hasOppositeleg)
							{
								Leg oppositeLeg = leg.GetOppositeLeg();
								Vector3 targetPos = oppositeLeg._PreviousFinalIKPos;
								if (leg.Owner.OnlyLocalAnimation)
								{
									targetPos = leg.RootSpaceToWorld(oppositeLeg._PreviousFinalIKPosRootLocal);
								}
								float stretchValue = oppositeLeg.IKProcessor.GetStretchValue(targetPos);
								if (stretchValue > leg.LegStretchLimit * 0.95f)
								{
									float num5 = (stretchValue - leg.LegStretchLimit * 0.95f) * 2f;
									if (num5 < 0f)
									{
										num5 = 0f;
									}
									num4 += num5;
								}
								if (!oppositeLeg._UsingCustomRaycast && oppositeLeg.G_AttachementHandler.legMoveAnimation.attached)
								{
									float magnitude = (leg.RootSpaceToWorld(oppositeLeg.AnkleH.LastKeyframeRootPos) - oppositeLeg.G_Attachement.GetRelevantHitPoint()).magnitude;
									float num6 = Owner.ScaleReference * 0.4f;
									if (magnitude > num6)
									{
										float num7 = magnitude - num6;
										num4 += num7 / num6 * 2f;
									}
								}
							}
							if (leg.LegAnimatingSettings.AllowSpeedups > 0.25f)
							{
								float num8 = Quaternion.Angle(baseRotationOnStepUp, Owner.BaseTransform.rotation);
								if (num8 > 12f)
								{
									float t = Mathf.InverseLerp(30f, 135f, num8);
									t = Mathf.LerpUnclamped(0.5f, 2f, t) * (0.4f + leg.LegAnimatingSettings.AllowSpeedups * 0.6f);
									transitionProgress += Owner.DeltaTime * t * num2;
								}
							}
							num4 = Mathf.LerpUnclamped(1f, num4, leg.LegAnimatingSettings.AllowSpeedups);
						}
						lastSpeedup = num4;
						transitionProgress = Mathf.MoveTowards(transitionProgress, 1f, num3 * num4 * _legMoveDurMul * leg.LegMoveSpeedMultiplier * Owner.DeltaTime * num2);
						if (transitionProgress > 0.9995f && duringLegAdjustMovement)
						{
							TriggerAttach();
						}
					}
					else if (transitionProgress > 0.9995f && handler.glueAnimationBlend > 0.95f)
					{
						TriggerAttach();
					}
					else
					{
						transitionProgress = Mathf.SmoothDamp(transitionProgress, 1.001f, ref sd_trProgress, (0.01f + Mathf.LerpUnclamped(0.225f, 0.01f, wasAttaching ? Owner.GlueFadeInSpeed : Owner.GlueFadeOutSpeed)) * num, 10000000f, Owner.DeltaTime);
					}
				}

				private void TriggerAttach()
				{
					if (!attached)
					{
						transitionProgress = 1f;
						lastAttachCompleteTime = Time.time;
						attached = leg.Glue_TriggerFinalAttach();
						duringLegAdjustMovement = false;
					}
				}

				public void PostUpdate()
				{
					lastAppliedGluePosition = leg._GluePosition;
					lastAppliedGluePositionLocal = leg.ToRootLocalSpace(lastAppliedGluePosition);
					lastAppliedGlueRotation = leg._GlueRotation;
					if (!_wasAnimatingLeg)
					{
						LegAdjustementFootAngleOffset = Mathf.MoveTowards(LegAdjustementFootAngleOffset, 0f, leg.DeltaTime * 20f);
						LegAdjustementYOffset = Mathf.MoveTowards(LegAdjustementYOffset, 0f, leg.DeltaTime * 20f);
					}
					else
					{
						_wasAnimatingLeg = false;
					}
				}
			}

			private LegsAnimator Owner;

			private Leg ParentLeg;

			private float _sd_glueAnimationBlend;

			private bool _instantTransition;

			private Vector3 lastGluePosition = Vector3.zero;

			private Quaternion lastGlueRotation = Quaternion.identity;

			public LegTransitionAnimation legMoveAnimation { get; private set; }

			private Leg leg => ParentLeg;

			public float glueAnimationBlend { get; private set; }

			public float attachTransitionProgress => legMoveAnimation.transitionProgress;

			public float attachTransitionProgressLastFrame => legMoveAnimation.transitionProgressLastFrame;

			public float legMoveDistanceFactor => legMoveAnimation.legMoveDistanceFactor;

			public EGlueMode lasGlueModeOnAttaching { get; private set; }

			public GlueAttachementHandler(Leg leg)
			{
				ParentLeg = leg;
				Owner = leg.Owner;
				legMoveAnimation = new LegTransitionAnimation(this);
				lasGlueModeOnAttaching = Owner._glueModeExecuted;
				Reset(initializing: true);
			}

			public void Reset(bool initializing)
			{
				glueAnimationBlend = 0f;
				_sd_glueAnimationBlend = 0f;
				if (initializing)
				{
					lastGluePosition = leg.BoneEnd.position;
					lastGlueRotation = leg.BoneEnd.rotation;
				}
				legMoveAnimation.Reset();
			}

			public void SheduleInstantTransition()
			{
				_instantTransition = true;
				legMoveAnimation.ScheduleInstantTransition();
			}

			public void TransitionToGlueAnimation()
			{
				legMoveAnimation.DoAttaching(canAttach: true);
				ChangeGlueAnimationBlendTo(1f, Owner.GlueFadeInSpeed);
			}

			public void TransitionToDisableGlueAnimation()
			{
				legMoveAnimation.DoAttaching(canAttach: false);
				ChangeGlueAnimationBlendTo(0f, Owner.GlueFadeOutSpeed);
			}

			public Vector3 GetGluePosition()
			{
				if (glueAnimationBlend > 0.9995f)
				{
					lastGluePosition = legMoveAnimation.GetTargetPosition();
				}
				else if (glueAnimationBlend < 0.0001f)
				{
					lastGluePosition = leg.A_PreIKPosForGluing;
				}
				else
				{
					lastGluePosition = Vector3.LerpUnclamped(leg.A_PreIKPosForGluing, legMoveAnimation.GetTargetPosition(), glueAnimationBlend);
				}
				return lastGluePosition;
			}

			public Quaternion GetGlueRotation()
			{
				if (glueAnimationBlend > 0.999f)
				{
					lastGlueRotation = legMoveAnimation.GetTargetRotation();
				}
				else if (glueAnimationBlend < 0f)
				{
					lastGlueRotation = leg._FinalIKRot;
				}
				else
				{
					lastGlueRotation = Quaternion.LerpUnclamped(leg._FinalIKRot, legMoveAnimation.GetTargetRotation(), glueAnimationBlend);
				}
				return lastGlueRotation;
			}

			public void UpdateTransitioning(bool attaching)
			{
				legMoveAnimation.UpdateAnimation();
			}

			public void PostUpdate()
			{
				legMoveAnimation.PostUpdate();
			}

			internal void OnLegRequireRepose()
			{
				legMoveAnimation.RequireRepose();
			}

			private void ChangeGlueAnimationBlendTo(float target, float speed)
			{
				if (Owner.GroundedTime < 0f)
				{
					speed = 0.99f;
				}
				if (_instantTransition && target > 0f)
				{
					glueAnimationBlend = target;
					_instantTransition = false;
					return;
				}
				if (speed >= 1f)
				{
					glueAnimationBlend = target;
					return;
				}
				if (leg.G_JustLanded)
				{
					glueAnimationBlend = Mathf.MoveTowards(glueAnimationBlend, target, Owner.DeltaTime * 3f);
				}
				glueAnimationBlend = Mathf.SmoothDamp(glueAnimationBlend, target, ref _sd_glueAnimationBlend, Mathf.LerpUnclamped(0.2f, 0.005f, speed), 100000f, Owner.DeltaTime);
				if (float.IsNaN(_sd_glueAnimationBlend))
				{
					_sd_glueAnimationBlend = 0f;
				}
			}
		}

		public enum GlueReposeRequest
		{
			None,
			Repose,
			ReposeIfFar
		}

		public class LegHelper
		{
			public Transform Bone;

			public LegHelper Child;

			public Vector3 InitPositionRootSpace;

			public Vector3 LastKeyframeRootPos;

			public LegHelper(Leg leg, Transform bone)
			{
				Bone = bone;
				InitPositionRootSpace = leg.ToRootLocalSpace(bone.position);
			}

			public void Calibrate(Leg leg, Vector3 wPos)
			{
				LastKeyframeRootPos = leg.ToRootLocalSpace(wPos);
			}
		}

		private GlueAttachement G_Attachement;

		public bool G_CustomForceAttach;

		public bool G_CustomForceNOTDetach;

		public bool G_CustomForceDetach;

		public bool G_CustomForceNOTAttach;

		private float lastFootForwardAngleDiffABS;

		private GlueAttachementHandler G_AttachementHandler;

		private Vector3 A_PreviousRelevantAnklePos;

		private Vector3 A_LastApppliedAlignPos;

		private Vector3 A_LastApppliedAlignPosLocal;

		private Vector3 A_PreIKPosForGluing;

		private Quaternion A_LastApppliedAlignRot;

		private Quaternion A_LastTargetAlignRot;

		private bool A_WasFullAlign;

		private float A_aligningBlendByGluing = 1f;

		private Vector3 A_LastElevation;

		private float A_LastElevateH;

		private float _sd_A_Elev;

		[NonSerialized]
		public float Adj_A_ElevateLerpSpeedStart = 8f;

		[NonSerialized]
		public float Adj_A_ElevateLerpSpeedAfter = 5f;

		[NonSerialized]
		public float Adj_A_ElevateSpeedupMargin = 0.014f;

		private float A_AligningFor;

		private Vector3 A_LastAlignRootSpacePos;

		private Vector3 A_LastSmoothTargetedPosLocal;

		private float A_LastSuddenSmoothYOffset;

		private float A_SuddenSmoothing;

		private float A_lastSuddenSmoothingDiff;

		private bool A_WasSmoothing;

		private bool A_WasAligningFrameBack;

		private Vector3 A_SmoothedIKPos;

		[NonSerialized]
		public bool G_InstantReglue;

		private float _glueTargetBlend = 1f;

		private float _gluingCulldown;

		protected bool G_JustLanded;

		[NonSerialized]
		public float ExtraGluingBlend = 1f;

		private Vector3 _GlueLastAttachPosition;

		private Vector3 _GlueLastAttachPositionRootLocal;

		private Quaternion _GlueLastAttachRotation;

		private Vector3 _GluePosition;

		private Quaternion _GlueRotation;

		private Vector3 _G_LastPreGlueSourceLocalIKPos;

		private Vector3 _G_PreGlueSourceLocalIKPos;

		private Vector3 _G_sd_RefSwing = Vector3.zero;

		private bool _G_WasDisabled = true;

		[NonSerialized]
		public GlueReposeRequest G_RequestRepose;

		private bool _G_WasGrounded = true;

		private Vector3 _G_LasGroundedPosLocal;

		private Quaternion _G_LasGroundedRotLocal;

		private Vector3 G_GlueDragOffset = Vector3.zero;

		private LegHelper _h_boneStart;

		private LegHelper _h_boneMid;

		private LegHelper _h_boneEnd;

		private Vector3 C_AnkleToHeelRootSpace = Vector3.one;

		private Vector3 C_LastHeelWorldPos;

		private Vector3 C_LastHeelRootSpacePos;

		private Vector3 C_LastFootEndWorldPos;

		private Vector3 C_LastFootEndRootSpacePos;

		private Vector3 C_Local_AnkleToHeelRotated;

		private float _C_DynamicYScale = 1f;

		public LegsAnimator Owner;

		[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
		public float LegBlendWeight = 1f;

		internal float InternalModuleBlendWeight = 1f;

		private float finalBoneBlend = 1f;

		[Tooltip("Make idle glue animation motion faster for this single leg")]
		public float LegMoveSpeedMultiplier = 1f;

		public float LegRaiseMultiplier = 1f;

		[Space(3f)]
		public float GlueThresholdMultiplier = 1f;

		public Vector2 GluePointOffset = Vector2.zero;

		[Range(0f, 1f)]
		[Space(3f)]
		public float LegStretchMultiplier = 1f;

		[Tooltip("Motion preset for the leg to be animated with different character than the other legs ('Idle Glue Motion' settings)")]
		public LegMotionSettingsPreset CustomLegAnimating;

		[Range(-40f, 40f)]
		public float FootPitchOffset;

		public Transform BoneStart;

		public Transform BoneMid;

		public Transform BoneEnd;

		public ELegSide Side;

		public int OppositeLegIndex = -1;

		public ERaycastPrecision RaycastPrecision;

		[Tooltip("(Experimental) If you want to animate in additional feet bone which in some cases can add nice animation feeling")]
		public bool UseFeet;

		public Transform BoneFeet;

		[Tooltip("Defining how quick heel should get up if leg gets stretched (change max stretching param under IK tab to be lower value that 1.1)")]
		[Range(0f, 1f)]
		public float FeetSensitivity = 0.5f;

		private bool hasOppositeleg;

		private LegStepAnimatingParameters targetLegAnimating;

		[Tooltip("Apply IK hint inversion, in case leg is bending in wrong direction.")]
		public bool InverseHint;

		public Vector3 AnkleToHeel = Vector3.zero;

		public Vector3 AnkleToFeetEnd = Vector3.zero;

		public Vector3 AnkleRight = Vector3.right;

		public Vector3 AnkleUp = Vector3.up;

		public Vector3 AnkleForward = Vector3.forward;

		[Range(0f, 1.001f)]
		public float FootMiddlePosition = 0.5f;

		[Space(5f)]
		[FPD_Suffix(-45f, 45f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "°", true, 0)]
		public float AnkleYawCorrection;

		private bool _StepSent = true;

		private float _StepSentAt = -100f;

		private float _RaiseSentAt = -100f;

		private bool _OppositeLegStepped = true;

		private float _ToConfirmStepEvent;

		private Vector3 _SourceIKPosUnchangedY;

		private Vector3 _SourceIKPos;

		public Vector3 _FinalIKPos;

		private Quaternion _SourceIKRot;

		private Quaternion _FinalIKRot;

		private bool customOverwritingIKPos;

		private Vector3 customOverwritePos = Vector3.zero;

		private bool customOverwritingIKRot;

		private Quaternion customOverwriteRot = Quaternion.identity;

		private bool _wasFixedCalibrateAnimationCaptured;

		private bool _wasGrounded = true;

		private Vector3 _ungroundLocalIKCache;

		private bool _overwrittenSourceIKPos;

		public RaycastHit legGroundHit;

		public RaycastHit lastGroundHitWithTarget;

		private Vector3 previousAnkleAlignedOnGroundHitWorldPos;

		private Vector3 ankleAlignedOnGroundHitRootLocal;

		private Quaternion ankleAlignedOnGroundHitRotation;

		private RaycastHit replacementHit;

		private bool _UsingEmptyRaycast;

		private bool _UsingCustomRaycast;

		private bool _disableSourceRaycast;

		private float _CustomRaycastBlendIn;

		private RaycastHit _CustomRaycastHit;

		private Vector3 _PreviousCustomRaycastingStartIKPos;

		private Vector3 _PreviousCustomRaycastingIKPos;

		private bool _noRaycast_skipFeetCalcs;

		public bool G_AttachPossible
		{
			get
			{
				if (RaycastHitted)
				{
					return C_Local_MidFootPosVsGroundHit.y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel;
				}
				return false;
			}
		}

		public bool _Glue_AskingForDetach { get; private set; }

		public float BelowFootRange => ScaleRef * _C_DynamicYScale * 0.2f;

		private GlueAttachementHandler.LegTransitionAnimation G_LegAnimation => G_AttachementHandler.legMoveAnimation;

		public Vector3 G_GluePosition => _GluePosition;

		public float G_GlueAnimationBlend => G_AttachementHandler.glueAnimationBlend;

		public float G_GlueInternalTransition => G_AttachementHandler.attachTransitionProgress;

		public float G_LastAttachCompleteTime => G_AttachementHandler.legMoveAnimation.lastAttachCompleteTime;

		public float G_GlueInternalTransitionLastFrame => G_AttachementHandler.attachTransitionProgressLastFrame;

		public float G_LastLegMoveDistanceFactor => G_AttachementHandler.legMoveDistanceFactor;

		public bool G_DuringLegAdjustMovement => G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement;

		public EGlueMode G_HandlerExecutingLegAnimationMode => G_AttachementHandler.legMoveAnimation.LastAnimationGlueMode;

		public bool A_PreWasAligning { get; private set; }

		public bool A_PreWasAligningNearGround { get; private set; }

		public bool A_WasAligning { get; private set; }

		public float A_AligningHelperBlend { get; private set; }

		public float A_LastAlignHeightDiff { get; private set; }

		public float A_LastAlignHeightCompareValue { get; private set; }

		public bool G_Attached { get; private set; }

		public bool G_DuringAttaching => G_LegAnimation.duringLegAdjustMovement;

		public bool G_FadingIn => G_LegAnimation.duringLegAdjustMovement;

		public Vector3 _G_RefernceSwing { get; private set; }

		private float G_GlueTesholdRange => Owner.ScaleReferenceNoScale * GlueThresholdMultiplier * Owner.GlueRangeThreshold * 0.5f;

		private Transform Root => Owner.BaseTransform;

		private float ScaleRef => Owner.ScaleReference;

		private float FloorLevel => Owner._glueingFloorLevel;

		private float DeltaTime => Owner.DeltaTime;

		public LegHelper ThighH => _h_boneStart;

		private FimpIK_Limb.IKBone ThighIK => IKProcessor.StartIKBone;

		public LegHelper LowerLegH => _h_boneMid;

		private FimpIK_Limb.IKBone LowerLegIK => IKProcessor.MiddleIKBone;

		public LegHelper AnkleH => _h_boneEnd;

		public FimpIK_Limb.IKBone AnkleIK => IKProcessor.EndIKBone;

		public Vector3 C_LastMidRefFootWorldPos { get; private set; }

		public Vector3 C_LastMidRefFootRootSpacePos { get; private set; }

		public Vector3 C_Local_MidFootPosVsGroundHit { get; private set; }

		public float C_Local_FootElevateInAnimation { get; private set; }

		public float C_AnkleToHeelWorldHeight { get; private set; }

		public float C_AnimatedAnkleFlatHeight { get; private set; }

		public int PlaymodeIndex { get; private set; }

		public float BlendWeight { get; private set; }

		[field: NonSerialized]
		public Leg NextLeg { get; private set; }

		[field: NonSerialized]
		public HipsReference ParentHub { get; private set; }

		public LegStepAnimatingParameters LegAnimatingSettings => targetLegAnimating;

		public float LegStretchLimit { get; private set; } = 1f;

		public FimpIK_Limb IKProcessor { get; private set; }

		public Vector3 _PreviousFinalIKPos { get; private set; }

		public Vector3 _PreviousFinalIKPosRootLocal { get; private set; }

		public Vector3 _PreviousFinalIKPosForStability { get; private set; }

		public Quaternion _PreviousFinalIKRot { get; private set; }

		public Vector3 _AnimatorStartBonePos { get; private set; }

		public Vector3 _AnimatorMidBonePos { get; private set; }

		public Vector3 _AnimatorEndBonePos { get; private set; }

		public Quaternion _AnimatorStartBoneLocRot { get; private set; }

		public Quaternion _AnimatorMidBoneLocRot { get; private set; }

		public Quaternion _AnimatorEndBoneLocRot { get; private set; }

		public bool RaycastHitted { get; private set; }

		public RaycastHit LastGroundHit => legGroundHit;

		public Vector3 groundHitRootSpacePos { get; private set; }

		public Vector3 lastRaycastingOrigin { get; private set; }

		public Vector3 lastRaycastingEndPoint { get; private set; }

		public Vector3 ankleAlignedOnGroundHitWorldPos { get; private set; }

		public bool User_RaycastHittedSource { get; private set; }

		public float raycastSlopeAngle { get; private set; }

		public Vector3 InitialPosInRootSpace { get; private set; }

		public List<Leg> Legs => Owner.Legs;

		public bool Glue_CheckDetachement()
		{
			bool flag = Glue_Conditions_Detach();
			if (!flag)
			{
				flag = Glue_Conditions_DetachForced();
			}
			_Glue_AskingForDetach = flag;
			return flag;
		}

		public bool Glue_CheckIdleDetachementConfirm()
		{
			if (Owner._glueModeExecuted != 0)
			{
				return true;
			}
			if (hasOppositeleg)
			{
				Leg oppositeLeg = GetOppositeLeg();
				if (Glue_CheckOppositeLegMovementRestriction(oppositeLeg))
				{
					return false;
				}
			}
			return true;
		}

		private bool Glue_Conditions_Attach()
		{
			if (!Owner.IsGrounded)
			{
				return false;
			}
			if (_glueTargetBlend < 0.0001f)
			{
				return false;
			}
			if (!RaycastHitted)
			{
				return false;
			}
			if (G_CustomForceNOTDetach)
			{
				return true;
			}
			if (_gluingCulldown > 0f)
			{
				return false;
			}
			if (G_CustomForceAttach)
			{
				return true;
			}
			if (Owner.DontGlueAttachIfTooNearOppositeLeg > 0f && hasOppositeleg)
			{
				Vector3 vector = ToRootLocalSpace(_PreviousFinalIKPos);
				Leg oppositeLeg = GetOppositeLeg();
				Vector3 vector2 = ToRootLocalSpace(oppositeLeg._PreviousFinalIKPos);
				float num = Owner.DontGlueAttachIfTooNearOppositeLeg * Owner.ScaleReference;
				if (Vector2.Distance(new Vector2(vector.x, vector.z), new Vector2(vector2.x, vector2.z)) < num)
				{
					return false;
				}
			}
			if (G_HandlerExecutingLegAnimationMode == EGlueMode.Moving)
			{
				bool flag = false;
				float y = C_Local_MidFootPosVsGroundHit.y;
				if (y > FloorLevel)
				{
					if (y < BelowFootRange * Owner.AllowGlueBelowFoot + FloorLevel)
					{
						flag = true;
					}
				}
				else
				{
					flag = true;
				}
				if (!flag)
				{
					return false;
				}
			}
			if (G_CustomForceNOTAttach)
			{
				return false;
			}
			if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f && Owner.DesiredMovementDirection != Vector3.zero)
			{
				Vector3 vector3 = ToRootLocalSpaceDir(Owner.DesiredMovementDirection);
				Vector3 g_RefernceSwing = _G_RefernceSwing;
				if (Vector3.Dot(vector3.normalized, g_RefernceSwing.normalized) > 1f - Owner.SwingHelper)
				{
					return false;
				}
			}
			return true;
		}

		private bool Glue_CheckOppositeLegMovementRestriction(Leg oppositeLeg)
		{
			if (!RaycastHitted)
			{
				return false;
			}
			if (!Owner.IsGrounded)
			{
				return false;
			}
			if (C_Local_MidFootPosVsGroundHit.y > BelowFootRange)
			{
				return false;
			}
			if (G_CustomForceNOTDetach)
			{
				return true;
			}
			if (!oppositeLeg.RaycastHitted)
			{
				return false;
			}
			if (oppositeLeg.C_Local_MidFootPosVsGroundHit.y > oppositeLeg.BelowFootRange)
			{
				return false;
			}
			if (oppositeLeg.G_GlueInternalTransition < LegAnimatingSettings.AllowDetachBefore)
			{
				return true;
			}
			return false;
		}

		private Leg GetOppositeLeg()
		{
			if (OppositeLegIndex < 0)
			{
				return null;
			}
			if (OppositeLegIndex >= Owner.Legs.Count)
			{
				return null;
			}
			return Owner.Legs[OppositeLegIndex];
		}

		private void Gluing_SetCulldown(float minDuration = 0.01f)
		{
			_gluingCulldown = Mathf.Max(_gluingCulldown, minDuration + (0.02f - Owner.GlueFadeOutSpeed * 0.03f));
		}

		public bool Glue_Conditions_Detach()
		{
			bool flag = false;
			if (G_CustomForceNOTDetach)
			{
				return flag;
			}
			if (G_AttachementHandler.legMoveAnimation.duringLegAdjustMovement)
			{
				return false;
			}
			if (!Glue_Conditions_Attach())
			{
				flag = true;
			}
			if (Owner.AnimateFeet && lastFootForwardAngleDiffABS > Owner.UnglueOn && !G_JustLanded)
			{
				if (Owner._glueModeExecuted != 0)
				{
					Gluing_SetCulldown();
				}
				flag = true;
			}
			if (!flag && !G_JustLanded)
			{
				Vector3 vector = Vector3.zero;
				if (GluePointOffset != Vector2.zero)
				{
					vector = -GetGluePointOffset();
				}
				if (Vector3.Distance(ankleAlignedOnGroundHitRootLocal + vector, _GlueLastAttachPositionRootLocal) > G_GlueTesholdRange)
				{
					if (Owner._glueModeExecuted != 0)
					{
						Gluing_SetCulldown();
					}
					flag = true;
				}
			}
			return flag;
		}

		public Vector3 GetGluePointOffset()
		{
			float num = Owner.ScaleReferenceNoScale * Owner.GlueRangeThreshold;
			return Owner.RootToWorldSpaceVec(new Vector3(GluePointOffset.x * num, 0f, GluePointOffset.y * num));
		}

		private bool Glue_Conditions_DetachForced()
		{
			if (G_CustomForceDetach)
			{
				return true;
			}
			if (G_RequestRepose != 0)
			{
				if (G_RequestRepose != GlueReposeRequest.ReposeIfFar)
				{
					G_RequestRepose = GlueReposeRequest.None;
					return true;
				}
				G_RequestRepose = GlueReposeRequest.None;
				if (G_Attached && Vector3.Distance(_GluePosition, ankleAlignedOnGroundHitWorldPos) > ScaleRef * 0.1f)
				{
					return true;
				}
			}
			return false;
		}

		private void ExtraProcessingApply()
		{
			if (G_LegAnimation.LegAdjustementYOffset != 0f)
			{
				_FinalIKPos += RootSpaceToWorldVec(new Vector3(0f, G_LegAnimation.LegAdjustementYOffset * LegRaiseMultiplier * _glueTargetBlend, 0f));
			}
			if (Owner.AnimateFeet)
			{
				PostCalculate_LimitFootYaw();
			}
		}

		private void ExtraIKPostProcessingApply()
		{
			if (Owner._stepPointsOverlapRadius > 0f)
			{
				PostCalculate_FeetOverlapRadius();
			}
			if (Owner.FeetYOffset != 0f)
			{
				PostCalculate_FeetYOffset();
			}
		}

		public void PostCalculate_LimitFootYaw()
		{
			Vector3 worldDir = ankleAlignedOnGroundHitRotation * AnkleIK.forward;
			worldDir = ToRootLocalSpaceDir(worldDir);
			worldDir.y = 0f;
			worldDir = RootSpaceToWorldVec(worldDir);
			Vector3 worldDir2 = _FinalIKRot * AnkleIK.forward;
			worldDir = ToRootLocalSpaceDir(worldDir);
			worldDir.y = 0f;
			worldDir2 = ToRootLocalSpaceDir(worldDir2);
			worldDir2.y = 0f;
			float num = (lastFootForwardAngleDiffABS = Mathf.Abs(Vector3.SignedAngle(worldDir.normalized, worldDir2.normalized, Vector3.up)));
			if (Owner.LimitFeetYaw > 0f && Owner.LimitFeetYaw < 90f && num > Owner.LimitFeetYaw)
			{
				float num2 = num - Owner.LimitFeetYaw;
				Quaternion a = (A_WasAligning ? ankleAlignedOnGroundHitRotation : AnkleIK.srcRotation);
				_FinalIKRot = Quaternion.LerpUnclamped(a, _FinalIKRot, 1f - num2 / (90f - Owner.LimitFeetYaw));
			}
		}

		private void PostCalculate_FeetOverlapRadius()
		{
			float num = Owner._stepPointsOverlapRadius * GlueThresholdMultiplier;
			Vector3 vector = ToRootLocalSpace(IKProcessor.IKTargetPosition);
			Leg leg = Owner.Legs[0];
			while (leg != null)
			{
				if (leg == this)
				{
					leg = leg.NextLeg;
					continue;
				}
				Vector3 vector2 = ToRootLocalSpace(leg.IKProcessor.IKTargetPosition);
				Vector2 vector3 = new Vector2(vector2.x, vector2.z) - new Vector2(vector.x, vector.z);
				float magnitude = vector3.magnitude;
				if (magnitude < num)
				{
					Vector2 vector4 = -vector3 * (num - magnitude) * 2f;
					IKProcessor.IKTargetPosition += RootSpaceToWorldVec(new Vector3(vector4.x, 0f, vector4.y));
				}
				leg = leg.NextLeg;
			}
		}

		private void PostCalculate_FeetYOffset()
		{
			IKProcessor.IKTargetPosition += _FinalIKRot * (Owner.FeetYOffset * Owner.Scale * A_AligningHelperBlend * AnkleIK.up);
		}

		private void AlignStep_Init()
		{
			A_PreWasAligning = false;
			A_PreWasAligningNearGround = false;
			A_WasAligning = false;
			A_AligningHelperBlend = 0f;
			A_LastTargetAlignRot = BoneEnd.rotation;
			A_LastApppliedAlignRot = BoneEnd.rotation;
			A_PreIKPosForGluing = _FinalIKPos;
		}

		private void AlignStep_CheckAlignStatePre()
		{
			A_PreIKPosForGluing = _FinalIKPos;
			if (_noRaycast_skipFeetCalcs)
			{
				return;
			}
			bool flag = false;
			A_PreWasAligningNearGround = false;
			if (RaycastHitted)
			{
				float hips_StepHeightAdjustOffset = ParentHub._Hips_StepHeightAdjustOffset;
				hips_StepHeightAdjustOffset = ((!(hips_StepHeightAdjustOffset < 0f)) ? 0f : (hips_StepHeightAdjustOffset * -0.03f));
				A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
				A_LastAlignHeightCompareValue = ScaleRef * (0.002f + Owner.AnimationFloorLevel) + hips_StepHeightAdjustOffset;
				if (Owner.FootAlignRapidity > 0.9999f)
				{
					if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
					{
						flag = true;
						A_PreWasAligningNearGround = true;
					}
				}
				else if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue + ScaleRef * (0.04f + (1f - Owner.FootAlignRapidity) * 0.04f))
				{
					A_PreWasAligningNearGround = true;
					if (A_LastAlignHeightDiff <= A_LastAlignHeightCompareValue)
					{
						flag = true;
					}
				}
			}
			else
			{
				A_LastAlignHeightDiff = 100f;
			}
			A_PreWasAligning = flag;
			if (flag)
			{
				Vector3 vector = ankleAlignedOnGroundHitWorldPos;
				if (A_AligningHelperBlend > 0.99f)
				{
					_FinalIKPos = vector;
				}
				else
				{
					_FinalIKPos = Vector3.Lerp(_FinalIKPos, vector, A_AligningHelperBlend * 8f);
				}
				A_PreIKPosForGluing = vector;
			}
			else if (A_AligningHelperBlend > 0.01f)
			{
				_FinalIKPos = Vector3.Lerp(_FinalIKPos, RootSpaceToWorld(A_LastApppliedAlignPosLocal), A_AligningHelperBlend);
			}
		}

		private void AlignStep_ValidateFootRotation()
		{
			if (!Owner.AnimateFeet || _noRaycast_skipFeetCalcs)
			{
				return;
			}
			if (A_PreWasAligningNearGround)
			{
				float num = Owner.FootRotationBlend * A_AligningHelperBlend;
				if (A_LastElevateH < 0.02f)
				{
					if (num >= 1f)
					{
						A_LastTargetAlignRot = ankleAlignedOnGroundHitRotation;
					}
					else
					{
						A_LastTargetAlignRot = Quaternion.LerpUnclamped(_FinalIKRot, ankleAlignedOnGroundHitRotation, num);
					}
				}
				else
				{
					float num2 = A_LastElevateH / (ScaleRef * 0.15f);
					if (A_LastElevateH > 1f)
					{
						A_LastElevateH = 1f;
					}
					A_LastTargetAlignRot = Quaternion.LerpUnclamped(ankleAlignedOnGroundHitRotation, _FinalIKRot, num2 * num);
				}
			}
			else if (A_AligningHelperBlend < 0.001f)
			{
				A_LastTargetAlignRot = _FinalIKRot;
			}
			else
			{
				A_LastTargetAlignRot = Quaternion.Lerp(_FinalIKRot, A_LastTargetAlignRot, A_AligningHelperBlend);
			}
			if (Owner.FootAlignRapidity >= 1f)
			{
				A_LastApppliedAlignRot = A_LastTargetAlignRot;
			}
			else
			{
				A_LastApppliedAlignRot = Quaternion.Lerp(A_LastApppliedAlignRot, A_LastTargetAlignRot, DeltaTime * (8f + Owner.FootAlignRapidity * 26f));
			}
			_FinalIKRot = A_LastApppliedAlignRot;
		}

		private void AlignStep_OnGroundAlign()
		{
			if (_noRaycast_skipFeetCalcs)
			{
				A_WasAligning = A_PreWasAligning;
				if (A_PreWasAligning)
				{
					if (A_AligningHelperBlend < 0.05f)
					{
						A_AligningHelperBlend = 0.05f;
					}
					A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
					if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
					{
						A_WasFullAlign = true;
						if (!Owner.UseGluing)
						{
							SendStepEvent();
						}
					}
				}
				else
				{
					if (A_AligningHelperBlend > 0.5f)
					{
						A_AligningHelperBlend = 0.5f;
					}
					A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 14f);
				}
				if (A_AligningHelperBlend < 0.65f)
				{
					A_WasFullAlign = false;
				}
				return;
			}
			A_aligningBlendByGluing = 1f;
			if (Owner.UseGluing)
			{
				A_aligningBlendByGluing = 1f - _glueTargetBlend * G_GlueAnimationBlend;
			}
			if (A_PreWasAligning)
			{
				if (A_WasAligning)
				{
					A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
				}
				float num = A_aligningBlendByGluing * A_AligningHelperBlend;
				if (num >= 1f)
				{
					_FinalIKPos = ankleAlignedOnGroundHitWorldPos;
				}
				else
				{
					_FinalIKPos = Vector3.LerpUnclamped(_FinalIKPos, ankleAlignedOnGroundHitWorldPos, num);
				}
				if (A_AligningHelperBlend < 0.05f)
				{
					A_AligningHelperBlend = 0.05f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 1f, Owner.DeltaTime * 8f);
				if (!A_WasFullAlign && A_AligningHelperBlend >= 1f - Owner.EventExecuteSooner)
				{
					A_WasFullAlign = true;
					if (!Owner.UseGluing)
					{
						SendStepEvent();
					}
				}
				A_LastApppliedAlignPosLocal = ToRootLocalSpace(_FinalIKPos);
			}
			else
			{
				A_PreviousRelevantAnklePos = _SourceIKPosUnchangedY;
				if (A_AligningHelperBlend > 0.75f)
				{
					A_AligningHelperBlend = 0.75f;
				}
				A_AligningHelperBlend = Mathf.MoveTowards(A_AligningHelperBlend, 0f, Owner.DeltaTime * 18f);
			}
			if (A_AligningHelperBlend < 0.6f)
			{
				A_WasFullAlign = false;
			}
			A_LastApppliedAlignPos = _FinalIKPos;
			A_WasAligning = A_PreWasAligning;
		}

		private void AlignStep_LegElevation()
		{
			if (Owner.LegElevateBlend < 0.001f)
			{
				return;
			}
			if (_noRaycast_skipFeetCalcs)
			{
				A_LastElevation = Vector3.zero;
				return;
			}
			float scaleRef = ScaleRef;
			float num = groundHitRootSpacePos.y - A_LastSuddenSmoothYOffset - ParentHub._Hips_StepHeightAdjustOffset;
			float num2 = Owner.AnimationFloorLevel * scaleRef;
			float c_Local_FootElevateInAnimation = C_Local_FootElevateInAnimation;
			if (c_Local_FootElevateInAnimation > num2 && num > 0.001f * scaleRef + num2 + 0.1f)
			{
				c_Local_FootElevateInAnimation -= num2;
				float num3 = c_Local_FootElevateInAnimation;
				float num4 = c_Local_FootElevateInAnimation - num;
				float num5 = scaleRef * 0.015f;
				float num6 = scaleRef * 0.35f;
				float value = num4 / num6;
				value = Mathf.Clamp01(value);
				if (num4 > num5)
				{
					num3 *= 1f - value;
					if (A_AligningFor < 0f)
					{
						A_AligningFor = DeltaTime;
					}
					if (A_AligningFor < 0.3f)
					{
						A_AligningFor += DeltaTime;
					}
					else
					{
						A_AligningFor = 0.3f;
					}
				}
				else if (A_AligningFor > 0f)
				{
					A_AligningFor -= DeltaTime;
				}
				else
				{
					A_AligningFor = 0f;
				}
				float num7 = num3;
				float num8 = scaleRef * Mathf.LerpUnclamped(0.1f, 0.9f, Owner.LegElevateHeightLimit);
				if (num7 > num8)
				{
					num7 = num8;
				}
				if (groundHitRootSpacePos.y > 0f)
				{
					float num9 = ScaleRef * 0.2f;
					if (num9 > 0f)
					{
						float num10 = groundHitRootSpacePos.y / num9;
						if (num10 > 0.8f)
						{
							num7 = Mathf.LerpUnclamped(num7, 0f, Mathf.InverseLerp(0.8f, 1.1f, num10));
						}
					}
				}
				if (Mathf.Abs(num7 - A_LastElevateH) > scaleRef * Adj_A_ElevateSpeedupMargin)
				{
					A_LastElevateH = Mathf.Lerp(A_LastElevateH, num7, DeltaTime * Adj_A_ElevateLerpSpeedAfter);
				}
				else
				{
					A_LastElevateH = Mathf.Lerp(A_LastElevateH, num7, DeltaTime * Adj_A_ElevateLerpSpeedStart);
				}
				if (A_LastElevateH < 0f)
				{
					A_LastElevateH = 0f;
				}
			}
			else
			{
				A_LastElevateH = Mathf.SmoothDamp(A_LastElevateH, 0f, ref _sd_A_Elev, 0.02f, 100000f, DeltaTime);
			}
			A_LastElevation = RootSpaceToWorldVec(new Vector3(0f, A_LastElevateH * Owner.LegElevateBlend * A_aligningBlendByGluing, 0f));
			_FinalIKPos += A_LastElevation;
		}

		private void AlignStep_SmoothSuddenSteps()
		{
			if (Owner.SmoothSuddenSteps < 0.0001f)
			{
				return;
			}
			if (_noRaycast_skipFeetCalcs || G_Attached)
			{
				A_WasAligningFrameBack = A_WasAligning;
				A_WasSmoothing = false;
				return;
			}
			float scaleRef = ScaleRef;
			if (A_WasAligning || A_WasAligningFrameBack)
			{
				if (!A_WasAligning)
				{
					A_PreviousRelevantAnklePos = previousAnkleAlignedOnGroundHitWorldPos;
				}
				Vector3 vector = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
				float f = ((!A_WasSmoothing) ? ToRootLocalSpace(A_PreviousRelevantAnklePos) : ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos)).y - vector.y;
				f = Mathf.Abs(f);
				float num = scaleRef * 0.006f;
				if ((raycastSlopeAngle < 17f || raycastSlopeAngle > 80f || Owner.RaycastShape == ERaycastMode.Spherecast) && f > num)
				{
					float num2 = f / (scaleRef * 0.275f);
					if (num2 > 1f)
					{
						num2 = 1f;
					}
					if (num2 > Mathf.LerpUnclamped(0.25f, 0.1f, Owner.SmoothSuddenSteps))
					{
						float num3 = Mathf.LerpUnclamped(0.3f, 0.1f, Owner.SmoothSuddenSteps);
						if (A_lastSuddenSmoothingDiff == 0f || A_SuddenSmoothing < num2)
						{
							A_lastSuddenSmoothingDiff = f;
							A_LastAlignRootSpacePos = ToRootLocalSpace(previousAnkleAlignedOnGroundHitWorldPos);
							num3 *= 0.7f;
						}
						else if (Owner.SmoothSuddenSteps < 0.5f)
						{
							float t = Mathf.LerpUnclamped(0.5f, 0f, Owner.SmoothSuddenSteps);
							A_lastSuddenSmoothingDiff = Mathf.LerpUnclamped(A_lastSuddenSmoothingDiff, f, t);
						}
						A_SuddenSmoothing += Mathf.Clamp01(A_lastSuddenSmoothingDiff / (scaleRef * num3));
						float num4 = 0.85f + Owner.SmoothSuddenSteps * 0.165f;
						if (A_SuddenSmoothing > num4)
						{
							A_SuddenSmoothing = num4;
						}
					}
				}
			}
			if (A_SuddenSmoothing > 0f)
			{
				Vector3 vector2 = ToRootLocalSpace(_FinalIKPos);
				A_LastSuddenSmoothYOffset = vector2.y;
				A_SuddenSmoothing -= Owner.DeltaTime * Mathf.LerpUnclamped(60f, 7.5f, Owner.SmoothSuddenSteps);
				vector2.y = Mathf.Lerp(vector2.y, A_LastAlignRootSpacePos.y, A_SuddenSmoothing);
				A_LastSuddenSmoothYOffset = vector2.y - A_LastSuddenSmoothYOffset;
				A_LastSmoothTargetedPosLocal = vector2;
				A_SmoothedIKPos = RootSpaceToWorld(vector2);
				_FinalIKPos = A_SmoothedIKPos;
				if (A_SuddenSmoothing < 0f)
				{
					A_SuddenSmoothing = 0f;
				}
				A_WasSmoothing = true;
			}
			else
			{
				A_LastSuddenSmoothYOffset = 0f;
				A_WasSmoothing = false;
			}
		}

		private void AlignStep_Complete()
		{
			A_WasAligningFrameBack = A_WasAligning;
		}

		private void Gluing_Init()
		{
			G_AttachementHandler = new GlueAttachementHandler(this);
			Glue_Reset(initializing: true);
		}

		public void Glue_Reset(bool initializing)
		{
			G_Attached = false;
			if (initializing)
			{
				_GlueLastAttachPosition = BoneEnd.position;
				_GlueLastAttachRotation = BoneEnd.rotation;
				_GluePosition = BoneEnd.position;
				_GlueLastAttachPositionRootLocal = ToRootLocalSpace(BoneEnd.position);
				_G_LastPreGlueSourceLocalIKPos = _GlueLastAttachPosition;
				_G_PreGlueSourceLocalIKPos = _SourceIKPos;
				A_PreIKPosForGluing = BoneEnd.position;
				_G_LasGroundedPosLocal = _GlueLastAttachPositionRootLocal;
			}
			GlueAttachement g_Attachement = default(GlueAttachement);
			g_Attachement.PosInAttachementLocal = _FinalIKPos;
			g_Attachement.RotInAttachementLocal = _FinalIKRot;
			G_Attachement = g_Attachement;
			_G_RefernceSwing = Vector3.zero;
			_G_WasDisabled = true;
			G_AttachementHandler.Reset(initializing);
		}

		private void Gluing_Update()
		{
			_glueTargetBlend = Owner.GlueBlend * ExtraGluingBlend * Owner.RagdolledDisablerBlend * Owner.NotSlidingBlend;
			if (Owner.GlueOnlyOnIdle)
			{
				_glueTargetBlend *= 1f - Owner.IsMovingBlend;
			}
			if (Owner.IsGrounded)
			{
				if (Owner.GroundedTime < 0.25f)
				{
					G_JustLanded = true;
					_glueTargetBlend *= 0.1f + Mathf.InverseLerp(0f, 0.25f, Owner.GroundedTime) * 0.9f;
				}
				else
				{
					G_JustLanded = false;
				}
			}
			else
			{
				G_JustLanded = false;
				_glueTargetBlend *= Owner.IsGroundedBlend;
			}
			if (_glueTargetBlend < 0.0001f)
			{
				_glueTargetBlend = 0f;
				_G_WasDisabled = true;
				return;
			}
			if (_G_WasDisabled)
			{
				Glue_Reset(initializing: false);
				_G_WasDisabled = false;
			}
			if (_gluingCulldown > 0f)
			{
				_gluingCulldown -= Owner.DeltaTime;
			}
			if (!Owner.IsGrounded)
			{
				if (_G_WasGrounded)
				{
					_G_WasGrounded = false;
					_G_LasGroundedPosLocal = ToRootLocalSpace(_GluePosition);
					_G_LasGroundedRotLocal = _GlueRotation;
					G_AttachementHandler.legMoveAnimation.Reset();
				}
				_GluePosition = RootSpaceToWorld(_G_LasGroundedPosLocal);
				_GlueRotation = _G_LasGroundedRotLocal;
				return;
			}
			_G_WasGrounded = true;
			if (Owner._glueModeExecuted == EGlueMode.Moving && Owner.SwingHelper > 0f)
			{
				Vector3 vector = AnkleH.LastKeyframeRootPos - _G_LastPreGlueSourceLocalIKPos;
				if (vector.magnitude > Owner.ScaleReferenceNoScale * 0.001f)
				{
					_G_LastPreGlueSourceLocalIKPos = _G_PreGlueSourceLocalIKPos;
				}
				_G_PreGlueSourceLocalIKPos = AnkleH.LastKeyframeRootPos;
				_G_RefernceSwing = Vector3.SmoothDamp(_G_RefernceSwing, vector * 2f, ref _G_sd_RefSwing, 0.04f, 100000f, Owner.DeltaTime);
			}
			else
			{
				_G_RefernceSwing = Vector3.zero;
				_G_sd_RefSwing = Vector3.zero;
			}
			_Glue_AskingForDetach = false;
			if (G_Attached)
			{
				bool flag = !Glue_CheckDetachement();
				if (!flag)
				{
					flag = !Glue_CheckIdleDetachementConfirm();
				}
				if (!flag)
				{
					G_Attached = flag;
					G_AttachementHandler.OnLegRequireRepose();
					flag = Glue_Conditions_Attach();
				}
				else if (!Glue_Conditions_Attach())
				{
					flag = false;
				}
				if (flag)
				{
					G_AttachementHandler.TransitionToGlueAnimation();
				}
				else
				{
					G_AttachementHandler.TransitionToDisableGlueAnimation();
				}
			}
			else if (Glue_Conditions_Attach())
			{
				G_AttachementHandler.TransitionToGlueAnimation();
			}
			else
			{
				G_AttachementHandler.TransitionToDisableGlueAnimation();
			}
			if (G_InstantReglue)
			{
				G_AttachementHandler.SheduleInstantTransition();
				G_InstantReglue = false;
			}
			G_AttachementHandler.UpdateTransitioning(G_DuringAttaching);
			Gluing_UpdateAttachement();
		}

		private bool Glue_TriggerFinalAttach()
		{
			if ((bool)legGroundHit.transform || _UsingEmptyRaycast)
			{
				G_Attached = true;
				G_Attachement = new GlueAttachement(this, legGroundHit);
				return true;
			}
			return false;
		}

		private void Gluing_UpdateAttachement()
		{
			if (!G_Attachement.NoTransform && G_Attachement.AttachedTo == null)
			{
				G_Attachement = default(GlueAttachement);
				G_AttachementHandler.OnLegRequireRepose();
				G_Attached = false;
			}
			if (!G_Attached)
			{
				_GluePosition = G_AttachementHandler.GetGluePosition();
				Gluing_DragStretchApply();
				if (Owner.AnimateFeet)
				{
					if (Owner.LimitFeetYaw > 0f)
					{
						_GlueRotation = G_AttachementHandler.GetGlueRotation();
					}
					else
					{
						_GlueRotation = A_LastApppliedAlignRot;
					}
				}
			}
			else
			{
				_GlueLastAttachPosition = G_Attachement.GetRelevantAlignedHitPoint(this);
				_GlueLastAttachPositionRootLocal = ToRootLocalSpace(_GlueLastAttachPosition);
				Quaternion relevantAttachementRotation = G_Attachement.GetRelevantAttachementRotation();
				_GlueLastAttachRotation = relevantAttachementRotation;
				_GluePosition = G_AttachementHandler.GetGluePosition();
				Gluing_DragStretchApply();
				if (Owner.AnimateFeet)
				{
					if (Owner.LimitFeetYaw > 0f)
					{
						_GlueRotation = G_AttachementHandler.GetGlueRotation();
					}
					else
					{
						_GlueRotation = A_LastApppliedAlignRot;
					}
				}
			}
			G_AttachementHandler.PostUpdate();
		}

		private void Gluing_DragStretchApply()
		{
			if (Owner.AllowGlueDrag > 0f)
			{
				float stretchValue = IKProcessor.GetStretchValue(_GluePosition - Owner._LastAppliedHipsStabilityOffset);
				float num = Mathf.LerpUnclamped(1f, 0.825f, Owner.AllowGlueDrag);
				float num2 = num * Mathf.LerpUnclamped(1f, LegStretchLimit, Owner.AllowGlueDrag);
				if (num2 > num)
				{
					num2 = num;
				}
				Vector3 vector = _GluePosition;
				if (stretchValue > num2 * 1.1f)
				{
					float t = (stretchValue - num2 * 1.1f) * 2f * Mathf.Min(1f, Owner.AllowGlueDrag);
					vector = ((!A_PreWasAligning) ? Vector3.Lerp(_GluePosition, A_PreIKPosForGluing, t) : Vector3.Lerp(_GluePosition, ankleAlignedOnGroundHitWorldPos, t));
				}
				Vector3 b = vector - _GluePosition;
				G_GlueDragOffset = Vector3.Lerp(G_GlueDragOffset, b, Owner.DeltaTime * 14f);
				if (float.IsNaN(G_GlueDragOffset.x) || float.IsNaN(G_GlueDragOffset.z))
				{
					G_GlueDragOffset = Vector3.zero;
				}
			}
		}

		private void Gluing_ApplyCoords()
		{
			if (_glueTargetBlend < 0.0001f)
			{
				return;
			}
			float num = _glueTargetBlend * G_AttachementHandler.glueAnimationBlend;
			if (num >= 1f)
			{
				_FinalIKPos = _GluePosition + G_GlueDragOffset;
				if (Owner.AnimateFeet)
				{
					_FinalIKRot = _GlueRotation;
				}
			}
			else
			{
				_FinalIKPos = Vector3.LerpUnclamped(A_PreIKPosForGluing, _GluePosition + G_GlueDragOffset, num);
				if (Owner.AnimateFeet)
				{
					_FinalIKRot = Quaternion.LerpUnclamped(_FinalIKRot, _GlueRotation, num);
				}
			}
		}

		private void Controll_Init()
		{
			C_AnkleToHeelRootSpace = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
			ThighH.Calibrate(this, ThighH.Bone.position);
			AnkleH.Calibrate(this, AnkleH.Bone.position);
		}

		private Vector3 TransformVectorAnkleWithAlignedRotation(Vector3 offset)
		{
			return ankleAlignedOnGroundHitRotation * Vector3.Scale(offset, BoneEnd.lossyScale);
		}

		private void Controll_Calibrate()
		{
			_C_DynamicYScale = Owner.DynamicYScale;
			ThighH.Calibrate(this, ThighH.Bone.position);
			AnkleH.Calibrate(this, _SourceIKPosUnchangedY);
			Vector3 ankleToHeel = AnkleToHeel;
			Vector3 vector = TransformVectorAnkleWithAlignedRotation(AnkleToHeel);
			C_LastFootEndWorldPos = _SourceIKPosUnchangedY + TransformVectorAnkleWithAlignedRotation(ankleToHeel);
			C_LastFootEndRootSpacePos = ToRootLocalSpace(C_LastFootEndWorldPos);
			C_AnimatedAnkleFlatHeight = ToRootLocalSpaceDir(vector).y;
			C_LastHeelWorldPos = _SourceIKPosUnchangedY + vector;
			C_LastHeelRootSpacePos = ToRootLocalSpace(C_LastHeelWorldPos);
			if (Owner.AnimateFeet)
			{
				C_LastMidRefFootWorldPos = Vector3.LerpUnclamped(C_LastFootEndWorldPos, C_LastHeelWorldPos, FootMiddlePosition);
				C_LastMidRefFootRootSpacePos = Vector3.LerpUnclamped(C_LastFootEndRootSpacePos, C_LastHeelRootSpacePos, FootMiddlePosition);
			}
			else
			{
				C_LastMidRefFootRootSpacePos = C_LastHeelRootSpacePos;
				C_LastMidRefFootWorldPos = C_LastHeelWorldPos;
			}
			C_Local_MidFootPosVsGroundHit = C_LastMidRefFootRootSpacePos - groundHitRootSpacePos;
			C_Local_FootElevateInAnimation = C_LastMidRefFootRootSpacePos.y - ParentHub._Hips_LastHipsOffset;
			C_Local_AnkleToHeelRotated = ToRootLocalSpace(Root.position + BoneEnd.TransformVector(AnkleToHeel));
			C_AnkleToHeelWorldHeight = BoneEnd.TransformVector(AnkleToHeel).magnitude;
		}

		private Vector3 RootSpaceToWorldVec(Vector3 localVec)
		{
			return Owner.RootToWorldSpaceVec(localVec);
		}

		private Vector3 RootSpaceToWorld(Vector3 rootLocal)
		{
			return Owner.RootToWorldSpace(rootLocal);
		}

		private Vector3 ToRootLocalSpaceDir(Vector3 worldDir)
		{
			return Owner.ToRootLocalSpaceVec(worldDir);
		}

		private Vector3 ToRootLocalSpace(Vector3 worldPos)
		{
			return Owner.ToRootLocalSpace(worldPos);
		}

		private Vector3 ChangeLocalY(Vector3 worldPos, float targetLocalY)
		{
			worldPos = ToRootLocalSpace(worldPos);
			worldPos.y = targetLocalY;
			return RootSpaceToWorld(worldPos);
		}

		private Vector3 ChangeLocalPosExceptY(Vector3 worldPos, Vector3 targetWorldPos)
		{
			worldPos = ToRootLocalSpace(worldPos);
			Vector3 vector = ToRootLocalSpace(targetWorldPos);
			worldPos.x = vector.x;
			worldPos.z = vector.z;
			return RootSpaceToWorld(worldPos);
		}

		private void Control_StepEventCalcs()
		{
			StepEventRestore();
			if (!Owner.UseGluing || _StepSent)
			{
				return;
			}
			if (Owner._glueModeExecuted == EGlueMode.Idle)
			{
				if (G_GlueInternalTransition >= 0.85f - Owner.EventExecuteSooner)
				{
					if (_ToConfirmStepEvent > 0.1f)
					{
						SendStepEvent(G_AttachementHandler.legMoveDistanceFactor);
						return;
					}
					float num = Mathf.InverseLerp(1f, 0f, LegAnimatingSettings.RaiseYAxisCurve.Evaluate(G_GlueInternalTransition));
					_ToConfirmStepEvent += DeltaTime * (3f + 3f * num);
				}
				else
				{
					_ToConfirmStepEvent = 0f;
				}
			}
			else
			{
				if (G_HandlerExecutingLegAnimationMode != EGlueMode.Moving || !Owner.SendOnMovingGlue || G_CustomForceNOTAttach)
				{
					return;
				}
				float num2 = FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.5f + A_LastAlignHeightCompareValue * (1.65f + Owner.EventExecuteSooner);
				if (G_CustomForceAttach)
				{
					_ToConfirmStepEvent += DeltaTime * 5f;
					num2 += ScaleRef * 0.1f;
				}
				if (A_LastAlignHeightDiff <= num2)
				{
					if (_ToConfirmStepEvent > 0.2f)
					{
						SendStepEvent(1f, EStepType.MovementGluing);
						_ToConfirmStepEvent = 0f;
						return;
					}
					_ToConfirmStepEvent += DeltaTime;
					if (A_LastAlignHeightDiff < num2 * 0.75f)
					{
						_ToConfirmStepEvent += DeltaTime * 1f;
					}
					if (A_LastAlignHeightDiff < num2 * 0.5f)
					{
						_ToConfirmStepEvent += DeltaTime * 1f;
					}
				}
				else
				{
					_ToConfirmStepEvent = 0f;
				}
			}
		}

		internal void StepEventSentInCustomWay()
		{
			_StepSent = true;
			_StepSentAt = Time.unscaledTime;
		}

		public void InitLegBasics(LegsAnimator creator, int index, Leg nextLeg)
		{
			if (creator != null)
			{
				Owner = creator;
			}
			PlaymodeIndex = index;
			NextLeg = nextLeg;
			LegStretchLimit = 1f;
			BlendWeight = 1f;
			InternalModuleBlendWeight = 1f;
			EnsureAxesNormalization();
			_h_boneStart = new LegHelper(this, BoneStart);
			_h_boneMid = new LegHelper(this, BoneMid);
			_h_boneEnd = new LegHelper(this, BoneEnd);
			_h_boneStart.Child = _h_boneMid;
			_h_boneMid.Child = _h_boneEnd;
			Gluing_Init();
			Reset();
			Controll_Init();
			Raycasting_Init();
			Stability_Init();
			AlignStep_Init();
			RefreshHasOppositeLeg();
			targetLegAnimating = (CustomLegAnimating ? CustomLegAnimating.Settings : creator.LegAnimatingSettings);
			ankleAlignedOnGroundHitWorldPos = _FinalIKPos;
		}

		public void RefreshHasOppositeLeg()
		{
			hasOppositeleg = false;
			if (GetOppositeLeg() != null)
			{
				hasOppositeleg = true;
			}
		}

		public void Leg_UpdateParams()
		{
			targetLegAnimating = (CustomLegAnimating ? CustomLegAnimating.Settings : Owner.LegAnimatingSettings);
			IK_UpdateParams();
		}

		internal void AssignParentHub(HipsReference hipsReference)
		{
			ParentHub = hipsReference;
		}

		internal void Reset()
		{
			_SourceIKPos = BoneEnd.position;
			_SourceIKRot = BoneEnd.rotation;
			_FinalIKPos = _SourceIKPos;
			_FinalIKRot = _SourceIKRot;
			_PreviousFinalIKPos = _FinalIKPos;
			_PreviousFinalIKRot = _FinalIKRot;
			legGroundHit = default(RaycastHit);
			legGroundHit.point = _FinalIKPos;
			legGroundHit.normal = Owner.Up;
			_PreviousFinalIKPosForStability = _SourceIKPos;
			ankleAlignedOnGroundHitRotation = _SourceIKRot;
			A_LastApppliedAlignRot = _SourceIKRot;
			A_LastTargetAlignRot = _SourceIKRot;
			groundHitRootSpacePos = ToRootLocalSpace(_SourceIKPos);
			_SourceIKPosUnchangedY = groundHitRootSpacePos;
			RaycastHit raycastHit = default(RaycastHit);
			raycastHit.point = _FinalIKPos;
			raycastHit.normal = Owner.Up;
			legGroundHit = raycastHit;
			Glue_Reset(initializing: true);
		}

		public void PreCalibrate()
		{
			BlendWeight *= InternalModuleBlendWeight;
			finalBoneBlend = BlendWeight * Owner._MainBlend;
			if (finalBoneBlend < 0.0001f)
			{
				if (!_G_WasDisabled)
				{
					G_Attached = false;
					G_AttachementHandler.Reset(initializing: false);
					G_Attachement = default(GlueAttachement);
					_G_WasDisabled = true;
					legGroundHit = default(RaycastHit);
					RaycastHitted = false;
				}
			}
			else if (Owner.Calibrate == ECalibrateMode.Calibrate)
			{
				IKProcessor.PreCalibrate();
			}
			else if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
			{
				if (!_wasFixedCalibrateAnimationCaptured)
				{
					IKProcessor.PreCalibrate();
					return;
				}
				BoneStart.localRotation = _AnimatorStartBoneLocRot;
				BoneMid.localRotation = _AnimatorMidBoneLocRot;
				BoneEnd.localRotation = _AnimatorEndBoneLocRot;
			}
		}

		public void CheckAnimatorPose()
		{
			_AnimatorStartBonePos = BoneStart.position;
			_AnimatorMidBonePos = BoneMid.position;
			_AnimatorEndBonePos = BoneEnd.position;
			if (Owner.Calibrate == ECalibrateMode.FixedCalibrate)
			{
				_wasFixedCalibrateAnimationCaptured = true;
				_AnimatorStartBoneLocRot = BoneStart.localRotation;
				_AnimatorMidBoneLocRot = BoneMid.localRotation;
				_AnimatorEndBoneLocRot = BoneEnd.localRotation;
			}
		}

		public void BeginLateUpdate()
		{
			if (!(finalBoneBlend < 0.0001f))
			{
				G_CustomForceAttach = false;
				G_CustomForceNOTDetach = false;
				G_CustomForceDetach = false;
				G_CustomForceNOTAttach = false;
				IK_PreUpdate();
				LegStretchLimit = Owner.LimitLegStretch * LegStretchMultiplier;
			}
		}

		public void PreLateUpdate()
		{
			if (!customOverwritingIKPos && (!_G_WasDisabled || !(finalBoneBlend < 0.0001f)))
			{
				Owner.Modules_LegBeforeRaycastingUpdate(this);
				Raycasting_PreLateUpdate();
				Controll_Calibrate();
			}
		}

		public void LateUpdate()
		{
			if (!(finalBoneBlend < 0.0001f) && !customOverwritingIKPos)
			{
				Owner.Modules_Leg_LateUpdate(this);
				AlignStep_CheckAlignStatePre();
				AlignStep_ValidateFootRotation();
				Gluing_Update();
				Gluing_ApplyCoords();
				AlignStep_OnGroundAlign();
				AlignStep_SmoothSuddenSteps();
				AlignStep_LegElevation();
				AlignStep_Complete();
				Control_StepEventCalcs();
				ExtraProcessingApply();
			}
		}

		public void LateUpdate_Apply()
		{
			IK_PostUpdate();
		}

		public void FixedUpdate()
		{
		}

		public float LegLimbLength()
		{
			if (BoneStart == null || BoneMid == null || BoneEnd == null)
			{
				return Owner.HipsToGroundDistance();
			}
			return 0f + Vector3.Distance(BoneStart.position, BoneMid.position) + Vector3.Distance(BoneEnd.position, BoneMid.position);
		}

		public bool HasAllBonesSet()
		{
			if (BoneStart == null)
			{
				return false;
			}
			if (BoneMid == null)
			{
				return false;
			}
			if (BoneEnd == null)
			{
				return false;
			}
			return true;
		}

		public float R(float toRound, int digits = 2)
		{
			return (float)Math.Round(toRound, digits);
		}

		private void SendStepEvent(float factor = 1f, EStepType type = EStepType.IdleGluing)
		{
			if (!_StepSent)
			{
				if (Owner.GroundedTime < 0.1f)
				{
					type = EStepType.OnLanding;
				}
				else if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
				{
					type = EStepType.OnStopping;
				}
				Owner.Events_OnStep(this, factor, type);
				_StepSent = true;
				_StepSentAt = Time.unscaledTime;
				if (hasOppositeleg)
				{
					_OppositeLegStepped = true;
					GetOppositeLeg()._OppositeLegStepped = !Owner.IsMoving;
				}
			}
		}

		private void SendRaiseEvent(float distanceToNew = 1f)
		{
			if (!(Time.unscaledTime - _RaiseSentAt < 0.05f))
			{
				_RaiseSentAt = Time.unscaledTime;
				EStepType type = EStepType.IdleGluing;
				if (!Owner.IsMoving && Owner.StoppedTime < 0.15f)
				{
					type = EStepType.OnStopping;
				}
				Owner.Events_OnRaise(this, distanceToNew, type);
			}
		}

		private void StepEventRestore()
		{
			if (!Owner.UseEvents || !_StepSent || Time.unscaledTime - _StepSentAt < 0.1f || Owner.GroundedTime < 0.1f)
			{
				return;
			}
			if (Owner.UseGluing)
			{
				if (G_AttachementHandler.glueAnimationBlend > 0.5f && G_GlueInternalTransition > 0.25f)
				{
					return;
				}
				if (Owner._glueModeExecuted == EGlueMode.Idle)
				{
					if (!G_DuringAttaching || (Owner.GlueMode == EGlueMode.Automatic && (Owner.IsMoving || Owner.Helper_WasMoving)) || (!Owner.SendOnStopping && Owner.StoppedTime < 0.155f) || G_AttachementHandler.lasGlueModeOnAttaching != 0 || G_AttachementHandler.legMoveDistanceFactor < 0.05f)
					{
						return;
					}
				}
				else
				{
					if ((Owner.GlueMode == EGlueMode.Automatic && !Owner.IsMoving) || Owner.MovingTime < 0.06f || A_PreWasAligning || A_AligningHelperBlend > 0.5f - Owner.EventExecuteSooner || (hasOppositeleg && !GetOppositeLeg()._OppositeLegStepped))
					{
						return;
					}
					float num = (0f - ScaleRef) * 0.2f + FloorLevel * Owner.BaseTransform.lossyScale.y + C_AnkleToHeelWorldHeight * 0.75f + A_LastAlignHeightCompareValue * (3f + Owner.EventExecuteSooner);
					if (A_LastAlignHeightDiff < num)
					{
						return;
					}
				}
			}
			else
			{
				if (A_PreWasAligning || A_AligningHelperBlend > 0.05f)
				{
					return;
				}
				if (Owner.IsMovingBlend < 0.05f)
				{
					_StepSent = true;
					return;
				}
				if (!Owner.Helper_WasMoving)
				{
					_StepSent = true;
					return;
				}
				if (!Owner.IsMoving)
				{
					_StepSent = true;
					return;
				}
			}
			_StepSent = false;
		}

		public void IK_Initialize(bool generateNew = true)
		{
			if (generateNew)
			{
				IKProcessor = new FimpIK_Limb();
			}
			if ((bool)BoneFeet)
			{
				IKProcessor.SetLegWithFeet(BoneStart, BoneMid, BoneEnd, BoneFeet);
			}
			else
			{
				IKProcessor.SetBones(BoneStart, BoneMid, BoneEnd);
			}
			IKProcessor.Init(Owner.BaseTransform);
			IKProcessor.UseEndBoneMapping = false;
			IKProcessor.IKWeight = 1f;
			IKProcessor.IKPositionWeight = 1f;
			IKProcessor.FootRotationWeight = 1f;
			IKProcessor.ManualHintPositionWeight = 0f;
			IKProcessor.FeetStretchSensitivity = 0.9f;
			IKProcessor.FeetFadeQuicker = 1.1f;
			IKProcessor.FeetStretchLimit = 0.8f;
			IKProcessor.HumanoidAnimator = Owner.Mecanim;
			IKProcessor.IsRight = Side == ELegSide.Right;
			_FinalIKPos = IKProcessor.EndIKBone.transform.position;
			_PreviousFinalIKPos = _FinalIKPos;
			_PreviousFinalIKPosForStability = _FinalIKPos;
			_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_FinalIKPos);
			IKProcessor.IKTargetPosition = _FinalIKPos;
			IKProcessor.IKTargetRotation = _FinalIKRot;
		}

		public void AssignCustomIKProcessor(FimpIK_Limb ik)
		{
			IKProcessor = ik;
			IK_Initialize(generateNew: false);
		}

		public void OverrideTargetIKPosition(Vector3? targetIKPos)
		{
			if (!targetIKPos.HasValue)
			{
				customOverwritingIKPos = false;
				return;
			}
			customOverwritingIKPos = true;
			customOverwritePos = targetIKPos.Value;
		}

		public void OverrideTargetIKRotation(Quaternion? targetIKRot)
		{
			if (!targetIKRot.HasValue)
			{
				if (customOverwritingIKRot)
				{
					IKProcessor.FootRotationWeight = 1f;
				}
				customOverwritingIKRot = false;
			}
			else
			{
				customOverwritingIKRot = true;
				customOverwriteRot = targetIKRot.Value;
			}
		}

		public void OverrideFinalIKPos(Vector3 pos)
		{
			_FinalIKPos = pos;
		}

		public void OverrideFinalAndSourceIKPos(Vector3 pos)
		{
			_FinalIKPos = pos;
			_SourceIKPos = pos;
		}

		public Vector3 GetFinalIKPos()
		{
			return _FinalIKPos;
		}

		public Vector3 GetSourceIKPos()
		{
			return _SourceIKPos;
		}

		public Quaternion GetFinalIKRot()
		{
			return _FinalIKRot;
		}

		public Quaternion GetSourceIKRot()
		{
			return _SourceIKRot;
		}

		public void OverrideFinalIKRot(Quaternion rot)
		{
			_FinalIKRot = rot;
		}

		public void IK_PreUpdate()
		{
			IKProcessor.CallPreCalibrate = Owner.Calibrate == ECalibrateMode.Calibrate;
			if (!Owner.IsGrounded)
			{
				if (_wasGrounded)
				{
					_ungroundLocalIKCache = ToRootLocalSpace(_PreviousFinalIKPos);
					_wasGrounded = false;
				}
				_SourceIKPos = RootSpaceToWorld(_ungroundLocalIKCache);
				_SourceIKPos = Vector3.Lerp(_SourceIKPos, IKProcessor.EndIKBone.transform.position, 1f - Owner.IsGroundedBlend);
				_ungroundLocalIKCache = ToRootLocalSpace(_SourceIKPos);
				_SourceIKRot = BoneEnd.rotation;
				_SourceIKPosUnchangedY = _SourceIKPos;
				_FinalIKPos = _SourceIKPos;
				_FinalIKRot = _SourceIKRot;
			}
			else
			{
				_wasGrounded = true;
				if (!_overwrittenSourceIKPos)
				{
					_SourceIKPos = IKProcessor.EndIKBone.transform.position;
				}
				else
				{
					_overwrittenSourceIKPos = false;
				}
				_SourceIKRot = BoneEnd.rotation;
				_SourceIKPosUnchangedY = _SourceIKPos;
				_FinalIKPos = _SourceIKPos;
				_FinalIKRot = _SourceIKRot;
			}
		}

		public void IK_PostUpdate()
		{
			if (customOverwritingIKPos)
			{
				_FinalIKPos = customOverwritePos;
				if (customOverwritingIKRot)
				{
					IKProcessor.FootRotationWeight = 1f;
					_FinalIKRot = customOverwriteRot;
				}
				else
				{
					IKProcessor.FootRotationWeight = 0f;
				}
			}
			else if (G_LegAnimation.LegAdjustementFootAngleOffset != 0f || FootPitchOffset != 0f)
			{
				_FinalIKRot = Quaternion.AngleAxis(G_LegAnimation.LegAdjustementFootAngleOffset + FootPitchOffset, _SourceIKRot * AnkleIK.right) * _FinalIKRot;
			}
			if (float.IsNaN(_FinalIKPos.x) || float.IsNaN(_FinalIKPos.y) || float.IsNaN(_FinalIKPos.z))
			{
				Reset();
				_FinalIKPos = RootSpaceToWorld(InitialPosInRootSpace);
				Gluing_Init();
			}
			_PreviousFinalIKPosForStability = _FinalIKPos;
			IKProcessor.IKTargetPosition = _FinalIKPos;
			IKProcessor.IKTargetRotation = _FinalIKRot;
			if (IKProcessor.IKWeight > 0f)
			{
				if (!Owner.UseCustomIK && LegStretchLimit < 1.1f)
				{
					IKProcessor.ApplyMaxStretchingPreprocessing(LegStretchLimit, 3f);
				}
				ExtraIKPostProcessingApply();
				if (!Owner.UseCustomIK)
				{
					IKProcessor.Update();
				}
			}
			_PreviousFinalIKPos = IKProcessor.IKTargetPosition;
			_PreviousFinalIKPosRootLocal = ToRootLocalSpace(_PreviousFinalIKPos);
			if (Owner.AnimateFeet)
			{
				_PreviousFinalIKRot = IKProcessor.IKTargetRotation;
			}
		}

		public void IK_UpdateParamsBase()
		{
			IKProcessor.IKWeight = Owner._MainBlend * LegBlendWeight * InternalModuleBlendWeight;
			BlendWeight = IKProcessor.IKWeight;
			IKProcessor.InverseHint = InverseHint;
		}

		public void IK_UpdateParams()
		{
			IK_UpdateParamsBase();
			IKProcessor.AutoHintMode = Owner.IKHintMode;
			IKProcessor.FeetStretchSensitivity = 0.7f + 0.6f * FeetSensitivity;
			IKProcessor.FeetFadeQuicker = 0.95f + 0.35f * FeetSensitivity;
			IKProcessor.FeetStretchLimit = 0.8f + 0.2f * FeetSensitivity;
			IKProcessor.disableFeet = !UseFeet;
		}

		public void RandomizeIndividualSettings(float from, float to)
		{
			GlueThresholdMultiplier = UnityEngine.Random.Range(Mathf.Lerp(from, to, 0.4f), to);
			LegMoveSpeedMultiplier = UnityEngine.Random.Range(from, to);
			LegRaiseMultiplier = UnityEngine.Random.Range(from, to);
		}

		public void OverrideAnimatorAnklePosition(Vector3 targetPos)
		{
			_overwrittenSourceIKPos = true;
			_AnimatorEndBonePos = targetPos + (Owner._LastAppliedHipsFinalPosition - ParentHub.LastKeyframePosition);
			_SourceIKPos = _AnimatorEndBonePos;
		}

		public void User_OverrideRaycastHit(Transform tr, bool disableSourceRaycast = true)
		{
			if (!_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 0f;
				_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
			}
			_disableSourceRaycast = disableSourceRaycast;
			_UsingCustomRaycast = true;
			RaycastHit hit = default(RaycastHit);
			hit.point = tr.position;
			hit.normal = tr.up;
			_CustomRaycastOnBlendIn(hit);
		}

		public void User_OverrideRaycastHit(RaycastHit hit, bool disableSourceRaycast = true)
		{
			if (!_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 0f;
				_PreviousCustomRaycastingStartIKPos = C_LastHeelWorldPos;
			}
			_disableSourceRaycast = disableSourceRaycast;
			_UsingCustomRaycast = true;
			_CustomRaycastOnBlendIn(hit);
		}

		public void User_RestoreRaycasting()
		{
			if (_UsingCustomRaycast)
			{
				_CustomRaycastBlendIn = 1f;
			}
			_UsingCustomRaycast = false;
			_disableSourceRaycast = false;
		}

		private void _CustomRaycastOnBlendIn(RaycastHit hit)
		{
			_CustomRaycastBlendIn += Owner.DeltaTime * 6f;
			if (_CustomRaycastBlendIn > 1f)
			{
				_CustomRaycastBlendIn = 1f;
			}
			hit.point = Vector3.LerpUnclamped(_PreviousCustomRaycastingStartIKPos, hit.point, _CustomRaycastBlendIn);
			_CustomRaycastHit = hit;
			_PreviousCustomRaycastingIKPos = hit.point;
		}

		private void _CustomRaycastOnBlendOut()
		{
			if (!_UsingCustomRaycast && !(_CustomRaycastBlendIn <= 0f))
			{
				_CustomRaycastBlendIn -= Owner.DeltaTime * 8f;
				if (_CustomRaycastBlendIn < 0f)
				{
					_CustomRaycastBlendIn = 0f;
				}
				if (!RaycastHitted)
				{
					legGroundHit = _CustomRaycastHit;
					return;
				}
				RaycastHit raycastHit = legGroundHit;
				raycastHit.point = Vector3.LerpUnclamped(raycastHit.point, _PreviousCustomRaycastingIKPos, _CustomRaycastBlendIn);
				raycastHit.normal = Vector3.SlerpUnclamped(raycastHit.normal, _CustomRaycastHit.normal, _CustomRaycastBlendIn);
				legGroundHit = raycastHit;
			}
		}

		private void Raycasting_Init()
		{
			ankleAlignedOnGroundHitWorldPos = BoneEnd.position;
			raycastSlopeAngle = 0f;
		}

		public void OverrideControlPositionsWithCurrentIKState()
		{
			AnkleH.LastKeyframeRootPos = ToRootLocalSpace(_FinalIKPos);
			_AnimatorEndBonePos = _FinalIKPos;
		}

		public void OverrideSourceIKPos()
		{
			OverrideSourceIKPos(_FinalIKPos);
		}

		public void OverrideSourceIKPos(Vector3 newSrc)
		{
			_SourceIKPos = newSrc;
		}

		public void Raycasting_PreLateUpdate()
		{
			RaycastHitted = false;
			_noRaycast_skipFeetCalcs = false;
			if (!_disableSourceRaycast)
			{
				if (Owner.RaycastStyle == ERaycastStyle.NoRaycasting)
				{
					GenerateZeroFloorRaycastHit();
					CustomRaycastValidate();
					_noRaycast_skipFeetCalcs = true;
					_UsingEmptyRaycast = true;
					ankleAlignedOnGroundHitRotation = _SourceIKRot;
				}
				else
				{
					_UsingEmptyRaycast = false;
					if (Owner.RaycastStyle == ERaycastStyle.StraightDown)
					{
						Raycast_StraightDown();
					}
					else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot)
					{
						Raycast_OriginToFoot();
					}
					else if (Owner.RaycastStyle == ERaycastStyle.OriginToFoot_DownOnNeed)
					{
						Raycast_OriginToFoot();
						if (!RaycastHitted)
						{
							Raycast_StraightDown();
						}
					}
					else if (Owner.RaycastStyle == ERaycastStyle.AlongBones)
					{
						Raycast_AlongBones();
						if (!RaycastHitted)
						{
							Raycast_StraightDown();
						}
					}
					if (!RaycastHitted)
					{
						NoRaycastBehaviour();
					}
				}
				User_RaycastHittedSource = RaycastHitted;
				_CustomRaycastOnBlendOut();
			}
			if (_UsingCustomRaycast)
			{
				RaycastHitted = true;
				legGroundHit = _CustomRaycastHit;
				groundHitRootSpacePos = ToRootLocalSpace(legGroundHit.point);
				_UsingEmptyRaycast = true;
				_noRaycast_skipFeetCalcs = true;
				_Raycasting_CalculateBasis();
				ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, legGroundHit.normal);
			}
			if (!_noRaycast_skipFeetCalcs)
			{
				if (RaycastHitted)
				{
					lastGroundHitWithTarget = legGroundHit;
					ankleAlignedOnGroundHitRotation = GetAlignedOnGroundHitRot(_SourceIKRot, legGroundHit.normal);
				}
				else
				{
					ankleAlignedOnGroundHitRotation = _SourceIKRot;
				}
			}
		}

		private void NoRaycastBehaviour()
		{
			if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.Detach)
			{
				return;
			}
			if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.ZeroFloorSteps)
			{
				_noRaycast_skipFeetCalcs = true;
				_UsingEmptyRaycast = true;
				GenerateZeroFloorRaycastHit();
				ankleAlignedOnGroundHitRotation = _SourceIKRot;
			}
			else if (Owner.NoRaycastGroundBehaviour == ENoRaycastBehviour.KeepAttached)
			{
				if (IKProcessor.GetStretchValue(_PreviousFinalIKPos) > Owner.NoRaycast_KeepAttachedUntilStretch)
				{
					lastGroundHitWithTarget = default(RaycastHit);
				}
				else if ((bool)lastGroundHitWithTarget.transform)
				{
					_noRaycast_skipFeetCalcs = true;
					legGroundHit = lastGroundHitWithTarget;
					RaycastHitted = true;
					_Raycasting_CalculateBasis();
					Vector3 vector = ToRootLocalSpace(lastGroundHitWithTarget.point);
					vector.y = 0f;
					groundHitRootSpacePos = vector;
				}
			}
		}

		private void GenerateZeroFloorRaycastHit()
		{
			RaycastHit raycastHit = default(RaycastHit);
			Vector3 rootLocal = (ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(_SourceIKPos));
			rootLocal.y = 0f;
			Vector3 point = RootSpaceToWorld(rootLocal);
			raycastHit.point = point;
			raycastHit.normal = Owner.Up;
			legGroundHit = raycastHit;
			RaycastHitted = true;
			groundHitRootSpacePos = rootLocal;
		}

		private void CustomRaycastValidate()
		{
			_Raycasting_CalculateBasis();
			raycastSlopeAngle = 0f;
			A_WasAligning = true;
			A_WasAligningFrameBack = true;
			A_LastTargetAlignRot = _SourceIKRot;
			A_LastApppliedAlignRot = _SourceIKRot;
			A_PreviousRelevantAnklePos = _SourceIKPos;
			A_LastAlignHeightDiff = C_Local_MidFootPosVsGroundHit.y;
			A_LastAlignHeightCompareValue = ScaleRef * 0.002f + ParentHub._Hips_StepHeightAdjustOffset;
		}

		private Vector3 Raycast_RefreshOrigin()
		{
			Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
			return lastRaycastingOrigin = RootSpaceToWorld(lastRootLocalPos);
		}

		private void Raycast_OriginToFoot()
		{
			Vector3 vector = Raycast_RefreshOrigin();
			Vector3 vector2 = RootSpaceToWorld(AnkleH.LastKeyframeRootPos) - Owner.Up * C_AnkleToHeelWorldHeight - vector;
			float num = vector2.magnitude * 1.05f;
			vector2.Normalize();
			Vector3 end = vector + vector2 * num;
			if (Physics.Linecast(vector, end, out legGroundHit, Owner.GroundMask, Owner.RaycastHitTrigger))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		private void Raycast_AlongBones()
		{
			Raycast_RefreshOrigin();
			if (DoRaycasting(_AnimatorStartBonePos, _AnimatorMidBonePos))
			{
				CaptureRaycastHitForLeg();
				return;
			}
			Vector3 rayEnd = _AnimatorEndBonePos + (_AnimatorEndBonePos - _AnimatorMidBonePos) * 0.1f;
			if (DoRaycasting(_AnimatorMidBonePos, rayEnd))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		private void Raycast_StraightDown()
		{
			Vector3 lastKeyframeRootPos = AnkleH.LastKeyframeRootPos;
			Vector3 lastRootLocalPos = ParentHub.LastRootLocalPos;
			float num;
			if (Owner.RaycastStartHeight == ERaycastStartHeight.FirstBone)
			{
				lastRootLocalPos = BoneStart.position;
				num = IKProcessor.fullLength;
			}
			else
			{
				lastRootLocalPos.x = lastKeyframeRootPos.x;
				lastRootLocalPos.z = lastKeyframeRootPos.z;
				num = Owner.ScaleReference * (Owner.RaycastStartHeightMul / Root.lossyScale.y);
				if (Owner.RaycastStartHeight == ERaycastStartHeight.StaticScaleReference)
				{
					lastRootLocalPos.y = num;
				}
				lastRootLocalPos = RootSpaceToWorld(lastRootLocalPos);
			}
			lastRaycastingOrigin = lastRootLocalPos;
			Vector3 vector = -Owner.Up;
			Vector3 vector2 = lastRootLocalPos + vector * num;
			float num2 = ScaleRef * Owner.CastDistance;
			Vector3 rayEnd = (lastRaycastingEndPoint = vector2 + vector * num2);
			if (DoRaycasting(lastRootLocalPos, rayEnd))
			{
				CaptureRaycastHitForLeg();
			}
			else
			{
				ankleAlignedOnGroundHitWorldPos = AnkleIK.srcPosition;
			}
		}

		internal bool DoRaycasting(Vector3 origin, Vector3 rayEnd)
		{
			bool flag;
			if (Owner.RaycastShape == ERaycastMode.Linecast)
			{
				flag = Physics.Linecast(origin, rayEnd, out legGroundHit, Owner.GroundMask, Owner.RaycastHitTrigger);
			}
			else
			{
				float num = Owner.ScaleReference * 0.065f * Owner.SpherecastResize;
				Vector3 vector = rayEnd - origin;
				float num2 = vector.magnitude - num;
				flag = Physics.SphereCast(origin, num, vector.normalized, out legGroundHit, num2 - num, Owner.GroundMask, Owner.RaycastHitTrigger);
				if (flag && Owner.SpherecastRealign > 0f)
				{
					Vector3 rootLocal = ToRootLocalSpace(legGroundHit.point);
					rootLocal.x = Mathf.LerpUnclamped(rootLocal.x, AnkleH.LastKeyframeRootPos.x, Owner.SpherecastRealign);
					rootLocal.z = Mathf.LerpUnclamped(rootLocal.z, AnkleH.LastKeyframeRootPos.z, Owner.SpherecastRealign);
					legGroundHit.point = RootSpaceToWorld(rootLocal);
				}
			}
			return flag;
		}

		private void CaptureRaycastHitForLeg()
		{
			RaycastHitted = true;
			groundHitRootSpacePos = ToRootLocalSpace(legGroundHit.point);
			raycastSlopeAngle = Vector3.Angle(Owner.Up, legGroundHit.normal);
			if (raycastSlopeAngle > 45f)
			{
				RaycastHit raycastHit = legGroundHit;
				raycastHit.normal = Vector3.Slerp(legGroundHit.normal, Owner.Up, Mathf.InverseLerp(45f, 90f, raycastSlopeAngle) * 0.5f);
				legGroundHit = raycastHit;
			}
			_Raycasting_CalculateBasis();
		}

		private void _Raycasting_CalculateBasis()
		{
			previousAnkleAlignedOnGroundHitWorldPos = ankleAlignedOnGroundHitWorldPos;
			ankleAlignedOnGroundHitWorldPos = GetAlignedOnGroundHitPos(groundHitRootSpacePos, legGroundHit.point, legGroundHit.normal);
			ankleAlignedOnGroundHitRootLocal = ToRootLocalSpace(ankleAlignedOnGroundHitWorldPos);
		}

		private Vector3 GetAlignedOnGroundHitPos(Vector3 rootSpaceHitPos, Vector3 worldHit, Vector3 normal)
		{
			Vector3 rootLocal = rootSpaceHitPos;
			rootLocal.y = ToRootLocalSpace(worldHit + normal * C_AnkleToHeelWorldHeight).y;
			return RootSpaceToWorld(rootLocal);
		}

		private Quaternion GetAlignedOnGroundHitRot(Quaternion sourceRotation, Vector3 normal)
		{
			return Quaternion.FromToRotation(sourceRotation * AnkleIK.up, normal) * sourceRotation;
		}

		private void Stability_Init()
		{
			Vector3 initialPosInRootSpace = ToRootLocalSpace(BoneEnd.position);
			InitialPosInRootSpace = initialPosInRootSpace;
		}

		public void DefineLegSide(LegsAnimator get, Leg knownOppositeLeg = null)
		{
			if (knownOppositeLeg != null && knownOppositeLeg.Side != 0)
			{
				if (knownOppositeLeg.Side == ELegSide.Left)
				{
					Side = ELegSide.Right;
				}
				else
				{
					Side = ELegSide.Left;
				}
			}
			else if (BoneStart != null)
			{
				if (get.Util_OnLeftSide(BoneStart))
				{
					Side = ELegSide.Left;
				}
				else
				{
					Side = ELegSide.Right;
				}
			}
		}

		public void AssignOppositeLegIndex(int oppositeIndex)
		{
			if (oppositeIndex != OppositeLegIndex)
			{
				if ((bool)Owner && FLogicMethods.ContainsIndex(Owner.Legs, oppositeIndex, falseIfNull: true))
				{
					Owner.Legs[oppositeIndex].OppositeLegIndex = Owner.Leg_GetIndex(this);
				}
				OppositeLegIndex = oppositeIndex;
			}
		}

		public Leg GetOppositeLegReference(LegsAnimator legs)
		{
			if (OppositeLegIndex < 0)
			{
				return null;
			}
			if (!FLogicMethods.ContainsIndex(legs.Legs, OppositeLegIndex, falseIfNull: true))
			{
				return null;
			}
			return legs.Legs[OppositeLegIndex];
		}

		public void RefreshLegAnkleToHeelAndFeetAndAxes(Transform baseT)
		{
			RefreshLegAnkleToHeelAndFeet(baseT);
			RefreshLegAnkleAxes(baseT);
		}

		public void RefreshLegAnkleToHeelAndFeet(Transform baseT)
		{
			if (!(BoneEnd == null))
			{
				Vector3 position = BoneEnd.position;
				position.y = baseT.position.y;
				AnkleToHeel = BoneEnd.InverseTransformPoint(position);
				AnkleToFeetEnd = BoneEnd.InverseTransformPoint(position + baseT.forward * ScaleRef * 0.15f);
			}
		}

		public void RefreshLegAnkleAxes(Transform baseT)
		{
			if ((bool)BoneEnd)
			{
				Quaternion quaternion = baseT.rotation * Quaternion.Euler(0f, AnkleYawCorrection, 0f);
				AnkleForward = BoneEnd.InverseTransformDirection(quaternion * Vector3.forward);
				AnkleUp = BoneEnd.InverseTransformDirection(quaternion * Vector3.up);
				AnkleRight = BoneEnd.InverseTransformDirection(quaternion * Vector3.right);
			}
		}

		private void EnsureAxesNormalization()
		{
			AnkleRight.Normalize();
			AnkleUp.Normalize();
			AnkleForward.Normalize();
		}
	}

	public enum ELegSide
	{
		Undefined,
		Left,
		Right
	}

	[Serializable]
	public class LegStepAnimatingParameters
	{
		[Range(0.1f, 1f)]
		[Tooltip("Average duration of the automatic leg animation")]
		public float StepMoveDuration = 0.375f;

		[Tooltip("Curve of ik point going towards desired position (just XZ movement, to Y - no leg rise curve)")]
		[FPD_FixedCurveWindow(0f, 0f, 1f, 1.25f, 0.4f, 0.5f, 1f, 1f)]
		public AnimationCurve MoveToGoalCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);

		[Tooltip("Making foot motion move towards target not in full linear straight towards target motion but adding a bit curve back (positive value) or forward (negative values) making movement a bit more natural")]
		[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0.4f, 0.6f, 0.9f, 1f)]
		public AnimationCurve SpherizeTrack = AnimationCurve.EaseInOut(0f, 0f, 1f, 0f);

		[Range(0f, 2f)]
		public float SpherizePower = 0.3f;

		[Range(0f, 1f)]
		[Tooltip("Minimum leg raise height. If distance of target step animation is small, then foot raise is smaller - down to this minimum raise value.")]
		public float MinFootRaise = 0.1f;

		[Tooltip("Maximum leg raise height. If distance of target step animation is very big, then foot raise is bigger - up to this maximum raise value.")]
		[Range(0f, 1f)]
		public float MaxFootRaise = 0.4f;

		[Tooltip("Raise height step animation curve evaluated on step animation duration.")]
		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 0.5f, 1f, 0.5f, 1f)]
		public AnimationCurve RaiseYAxisCurve;

		[Range(0f, 1f)]
		[Tooltip("Allowing to speed up leg adjusting animation when leg is getting stretched, when opposite leg is requesting adjustement or when main character is rotating in place quickly")]
		[Space(3f)]
		public float AllowSpeedups = 0.4f;

		[Range(0.1f, 1f)]
		[Tooltip("You can allow to use opposite leg before idle glue leg adjustement finishes")]
		public float AllowDetachBefore = 1f;

		[FPD_FixedCurveWindow(0f, 0f, 1f, 1f, 1f, 0.6f, 0.6f, 1f)]
		[Tooltip("Extra hips push power animation curve evaluated on step animation duration.")]
		public AnimationCurve PushHipsOnMoveCurve;

		[Tooltip("Extra foot ankle rotation animation curve evaluated on step animation duration.")]
		[FPD_FixedCurveWindow(0f, -1f, 1f, 1f, 0f, 1f, 1f, 1f)]
		public AnimationCurve FootRotationCurve;

		public void RefreshDefaultCurves()
		{
			Curves_RefreshMoveToGoalCurve();
			Curves_RefreshRaiseYAxisCurve();
			Curves_RefreshSpherizeTrack();
			Curves_RefreshFootRotationCurve();
			Curves_RefreshPushHipsOnMoveCurve();
		}

		public void Curves_RefreshRaiseYAxisCurve()
		{
			RaiseYAxisCurve = new AnimationCurve();
			RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.505118f, 0.5f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.9110107f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
		}

		public void Curves_RefreshRaiseYAxisCurveSpiderPreset()
		{
			RaiseYAxisCurve = new AnimationCurve();
			RaiseYAxisCurve.AddKey(new Keyframe(0f, 0f, 0.8504464f, 0.8504464f, 0f, 0.6517575f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.2731183f, 0.45f, 0.9770691f, 0.9770691f, 0.3333333f, 0.3387407f));
			RaiseYAxisCurve.AddKey(new Keyframe(0.5943514f, 0.7946472f, -0.2710344f, -0.2710344f, 0.3333333f, 0.3333333f));
			RaiseYAxisCurve.AddKey(new Keyframe(1f, 0f, -0.1500788f, -0.1500788f, 0.5409704f, 0f));
		}

		public void Curves_RefreshMoveToGoalCurve()
		{
			MoveToGoalCurve = new AnimationCurve();
			MoveToGoalCurve.AddKey(new Keyframe(0f, 0f, 0f, 0f, 0f, 0.1842105f));
			MoveToGoalCurve.AddKey(new Keyframe(0.4885197f, 0.8972011f, 1.38764f, 1.38764f, 0.3333333f, 0.3333333f));
			MoveToGoalCurve.AddKey(new Keyframe(1f, 1f, 0f, 0f, 0f, 0f));
		}

		public void Curves_RefreshFootRotationCurve()
		{
			FootRotationCurve = new AnimationCurve();
			FootRotationCurve.AddKey(new Keyframe(0f, 0f, 0.5764588f, 0.5764588f, 0f, 0.4956417f));
			FootRotationCurve.AddKey(new Keyframe(0.4378169f, 0.2035736f, -0.2411275f, -0.2411275f, 0.3333333f, 0.4033037f));
			FootRotationCurve.AddKey(new Keyframe(0.7841034f, -0.1339308f, 0.3331003f, 0.3331003f, 0.3333333f, 0.3333333f));
			FootRotationCurve.AddKey(new Keyframe(1f, 0f, 0.3498169f, 0.3498169f, 0.5534658f, 0f));
		}

		public void Curves_RefreshPushHipsOnMoveCurve()
		{
			PushHipsOnMoveCurve = new AnimationCurve();
			PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.383f, 0.3733972f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.7075226f, 0.1460427f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
		}

		public void Curves_RefreshPushHipsOnMoveCurveSpiderPreset()
		{
			PushHipsOnMoveCurve = new AnimationCurve();
			PushHipsOnMoveCurve.AddKey(new Keyframe(0f, 0f, 5.630541f, 5.630541f, 0f, 0.198735f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.320017f, 0.654645f, -0.1664574f, -0.1664574f, 0.333f, 0.2940554f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(0.6681702f, 0.2174691f, -1.565806f, -1.565806f, 0.3605607f, 0.3446763f));
			PushHipsOnMoveCurve.AddKey(new Keyframe(1f, 0f, 0f, 0f, 0.09374858f, 0f));
		}

		public void Curves_RefreshSpherizeTrack()
		{
			SpherizeTrack = new AnimationCurve();
			SpherizeTrack.AddKey(new Keyframe(0f, 0f, 0.6958197f, 0.6958197f, 0f, 0.460011f));
			SpherizeTrack.AddKey(new Keyframe(0.4f, 0.3f, -0.04204308f, -0.04204308f, 0.333f, 0.3410656f));
			SpherizeTrack.AddKey(new Keyframe(0.85f, 0f, -0.2721428f, -0.2721428f, 0.3953607f, 0f));
		}

		public void LogCurve(string name, AnimationCurve c)
		{
			string text = "";
			IFormatProvider invariantCulture = CultureInfo.InvariantCulture;
			for (int i = 0; i < c.keys.Length; i++)
			{
				Keyframe keyframe = c.keys[i];
				text = text + "\n" + name + ".AddKey(new Keyframe(" + keyframe.time.ToString(invariantCulture) + "f, " + keyframe.value.ToString(invariantCulture) + "f, " + keyframe.inTangent.ToString(invariantCulture) + "f, " + keyframe.outTangent.ToString(invariantCulture) + "f, " + keyframe.inWeight.ToString(invariantCulture) + "f, " + keyframe.outWeight.ToString(invariantCulture) + "f));";
			}
			Debug.Log(text);
		}
	}

	public enum EGlueMode
	{
		[Tooltip("Idle Mode is applying leg animation with extra motion and is checking some extra conditions like opposite leg grounded state etc.")]
		Idle,
		[Tooltip("Moving Mode is dedicated to be applied during playing animations with dynamic legs, it's checking less conditions than Idle Mode and is snapping glue points in a more straight forward slide animation.")]
		Moving,
		[Tooltip("Automatic mode is syncing with IsMoving/IsIdling LegsAnimator flags.")]
		Automatic
	}

	[Serializable]
	public class Variable
	{
		public enum EVariableType
		{
			Number,
			Bool,
			Vector2,
			Vector3,
			String,
			Curve,
			UnityObject,
			CustomObject
		}

		public string VariableName = "Variable";

		[SerializeField]
		private string Tooltip = "";

		private bool _tooltipWasSet;

		[SerializeField]
		private Vector4 _value = Vector4.zero;

		[SerializeField]
		private string _string = "";

		[SerializeField]
		private AnimationCurve _curve;

		[SerializeField]
		private UnityEngine.Object _uObject;

		[SerializeField]
		private object _object;

		[NonSerialized]
		private int nameHash;

		public EVariableType VariableType;

		[SerializeField]
		private Vector4 _rangeHelper = Vector4.zero;

		public bool TooltipAssigned => _tooltipWasSet;

		public int GetNameHash
		{
			get
			{
				if (nameHash == 0)
				{
					nameHash = VariableName.GetHashCode();
				}
				return nameHash;
			}
		}

		public void AssignTooltip(string tooltip)
		{
			if (!_tooltipWasSet)
			{
				Tooltip = tooltip;
				_tooltipWasSet = true;
			}
		}

		public Variable(string name, object value)
		{
			VariableName = name;
			SetValue(value);
		}

		public void SetValue(object o)
		{
			if (o is int)
			{
				_value = new Vector4((int)o, 0f, 0f, 1f);
				VariableType = EVariableType.Number;
			}
			else if (o is float)
			{
				_value = new Vector4((float)o, 0f, 0f, 0f);
				VariableType = EVariableType.Number;
			}
			else if (o is bool)
			{
				if ((bool)o)
				{
					_value.x = 1f;
				}
				else
				{
					_value.x = 0f;
				}
				VariableType = EVariableType.Bool;
			}
			else if (o is Vector2 vector)
			{
				_value = vector;
				VariableType = EVariableType.Vector2;
			}
			else if (o is Vector3 vector2)
			{
				_value = vector2;
				VariableType = EVariableType.Vector3;
			}
			else if (o is string)
			{
				_string = o as string;
				VariableType = EVariableType.String;
			}
			else if (o is AnimationCurve)
			{
				_curve = o as AnimationCurve;
				VariableType = EVariableType.Curve;
			}
			else if (o is UnityEngine.Object)
			{
				_uObject = o as UnityEngine.Object;
				VariableType = EVariableType.UnityObject;
			}
			else
			{
				_object = o;
				VariableType = EVariableType.CustomObject;
			}
		}

		public int GetInt()
		{
			return (int)_value.x;
		}

		public float GetFloat()
		{
			return _value.x;
		}

		public bool GetBool()
		{
			return _value.x == 1f;
		}

		public Vector2 GetVector2()
		{
			return new Vector2(_value.x, _value.y);
		}

		public Vector3 GetVector3()
		{
			return new Vector3(_value.x, _value.y, _value.z);
		}

		public string GetString()
		{
			return _string;
		}

		public AnimationCurve GetCurve()
		{
			return _curve;
		}

		public UnityEngine.Object GetUnityObject()
		{
			return _uObject;
		}

		public object GetObject()
		{
			return _object;
		}

		public void SetMinMaxSlider(float min, float max)
		{
			_rangeHelper = new Vector4(min, max, 0f, 0f);
		}

		public void SetCurveFixedRange(float startTime, float startValue, float endTime, float endValue)
		{
			_rangeHelper = new Vector4(startTime, startValue, endTime, endValue);
		}

		public bool Editor_DisplayVariableGUI()
		{
			return false;
		}
	}

	[Serializable]
	public class ReferencePose
	{
		[Serializable]
		public class LegPoseReference
		{
			public BonePoseReference UpperLegPose = new BonePoseReference();

			public BonePoseReference LowerLegPose = new BonePoseReference();

			public BonePoseReference AnklePose = new BonePoseReference();

			public BonePoseReference FeetPose = new BonePoseReference();

			public void SaveLegPose(Leg leg, LegsAnimator animator)
			{
				UpperLegPose.SavePose(leg.BoneStart, animator);
				LowerLegPose.SavePose(leg.BoneMid, animator);
				AnklePose.SavePose(leg.BoneEnd, animator);
				FeetPose.SavePose(leg.BoneFeet, animator);
			}

			public void RestoreLegPose(LegsAnimator animator)
			{
				UpperLegPose.RestorePose(animator);
				LowerLegPose.RestorePose(animator);
				AnklePose.RestorePose(animator);
				FeetPose.RestorePose(animator);
			}
		}

		[Serializable]
		public class BonePoseReference
		{
			public Transform SourceTransform;

			public Quaternion RotationInRoot;

			public Vector3 PositionInRoot;

			public void SavePose(Transform transform, LegsAnimator animator)
			{
				if (!(animator == null) && !(transform == null))
				{
					SourceTransform = transform;
					PositionInRoot = animator.BaseTransform.InverseTransformPoint(transform.position);
					RotationInRoot = FEngineering.QToLocal(animator.BaseTransform.rotation, transform.rotation);
				}
			}

			public void RestorePose(LegsAnimator animator)
			{
				if (!(animator == null) && !(SourceTransform == null))
				{
					SourceTransform.position = animator.BaseTransform.TransformPoint(PositionInRoot);
					SourceTransform.rotation = FEngineering.QToWorld(animator.BaseTransform.rotation, RotationInRoot);
				}
			}
		}

		public BonePoseReference MainHipsPose = new BonePoseReference();

		public List<BonePoseReference> HipsPoses = new List<BonePoseReference>();

		public List<LegPoseReference> LegPoses = new List<LegPoseReference>();

		public bool IsSet(LegsAnimator animator)
		{
			if (MainHipsPose.SourceTransform != null && HipsPoses.Count == animator.ExtraHipsHubs.Count)
			{
				return LegPoses.Count == animator.Legs.Count;
			}
			return false;
		}

		public void TweakListsFor(LegsAnimator animator)
		{
			while (HipsPoses.Count > animator.ExtraHipsHubs.Count)
			{
				HipsPoses.RemoveAt(HipsPoses.Count - 1);
			}
			while (HipsPoses.Count < animator.ExtraHipsHubs.Count)
			{
				HipsPoses.Add(new BonePoseReference());
			}
			while (LegPoses.Count > animator.Legs.Count)
			{
				LegPoses.RemoveAt(LegPoses.Count - 1);
			}
			while (LegPoses.Count < animator.Legs.Count)
			{
				LegPoses.Add(new LegPoseReference());
			}
		}

		public void Clear()
		{
			MainHipsPose.SourceTransform = null;
			HipsPoses.Clear();
			LegPoses.Clear();
		}
	}

	public enum ELegsScaleReference
	{
		PelvisToGroundDistance,
		FirstLegLength,
		Custom,
		PelvisLegAverage
	}

	public enum ECalibrateMode
	{
		[Tooltip("No Extra overhead")]
		None,
		[Tooltip("Resetting bones local rotations to the initialized state")]
		Calibrate,
		[Tooltip("Resetting bones local rotations to the captured animator state (can fix trigger colliders detection when colliders added on legs)")]
		FixedCalibrate
	}

	public enum ERaycastPrecision
	{
		Linecast,
		BoxcastPrecision
	}

	public enum ERaycastStartHeight
	{
		[Tooltip("Casting ray starting from current hips height position of the character. Can be bad for insect creatures!")]
		Hips,
		[Tooltip("Good for spiders! Casting raycast on defined height of the character")]
		StaticScaleReference,
		[Tooltip("Casting ray starting from first bone of the leg (it's affecting height + start raycast position).")]
		FirstBone
	}

	public enum ERaycastStyle
	{
		[Tooltip("Launching raycast from foot above origin point. Good for bipeds with whole body step down/up features.")]
		StraightDown,
		[Tooltip("Launching raycast from pelvis towards foot, good for spider like creatures to detect steep ground more effectively. Body step down/up will not work as precise with this option.")]
		OriginToFoot,
		[Tooltip("Doing raycast like OriginToFoot : but if no ground is found - using another raycast in StraightDown style to find ground below and allow to execute body step down/up feature.")]
		OriginToFoot_DownOnNeed,
		[Tooltip("Doing raycasts per bone : from start bone towards mid bone, mid bone towards end bone, then down. Best precision for insect creatures.")]
		AlongBones,
		[Tooltip("No Raycasting : provide raycast hits custom using code, or leave it custom for just gluing legs animation.")]
		NoRaycasting
	}

	public enum ERaycastMode
	{
		Linecast,
		Spherecast
	}

	public enum ENoRaycastBehviour
	{
		[Tooltip("If ground raycast is lost, leg will detach and switch to ungrounded state")]
		Detach,
		[Tooltip("If no raycast hit detected, should character still animate leg steps in air on zero height floor level? (fake floor)")]
		ZeroFloorSteps,
		[Tooltip("If ground raycast is lost, leg will stick to lastest found raycast hit until leg get stretched")]
		KeepAttached
	}

	[Tooltip("Optional reference to unity's Animator. Legs Animator can use animator's variables to read state of your character movement, like IsGrounded or IsMoving + other extra helpers for custom modules and special calculations.")]
	public Animator Mecanim;

	[Tooltip("Animator parameter to read value for auto-define grounded state of the character (you can use LegAnimator.User_SetIsGrounded() through code instead)")]
	public string GroundedParameter = "";

	[Tooltip("Animator parameter (bool or float - Bool recommended for quicker Not-Moving reaction) to read value for auto-define movement state of the character (you can use LegAnimator.User_SetIsMoving() through code instead)")]
	public string MovingParameter = "";

	private int _hash_Grounded = -1;

	private int _hash_Moving = -1;

	private bool _hash_MovingIsFloat;

	[HideInInspector]
	[Range(0f, 0.5f)]
	public float User_IsMovingMecanim_NotMovingFloat_Threshold = 0.1f;

	private int _hash_Sliding = -1;

	[Tooltip("Optional Rigidbody which is used for few helper calculations. If rigidbody is assigned, then rigidbody velocity will drive 'Desired Move Direction' value (! only if .IsMoving is true !), unless you use 'User_SetDesiredMovementDirection'")]
	public Rigidbody Rigidbody;

	[Tooltip("Use rigidboy velocity state to automatically drive Leg Animator's helper 'IsMoving' flag")]
	public bool UseRigidbodyVelocityForIsMoving;

	[Tooltip("Use leg raycasts to automatically define Leg Animator's helper 'IsGrounded' flag")]
	public bool UseRaycastsForIsGrounded;

	[Tooltip("Animator parameter to read value for auto-define sliding state of the character - auto fading off gluing (you can use LegAnimator.User_SetIsSliding() through code instead)")]
	public string SlidingParameter = "";

	[Tooltip("Optional bone for modules if needed")]
	public Transform SpineBone;

	[Tooltip("Optional bone for modules if needed")]
	public Transform ChestBone;

	private CalibrateTransform _spineBoneCalibrate;

	private CalibrateTransform _ChestBoneCalibrate;

	[Tooltip("Animator parameter to read value for auto-define calculations state of the character. The ragdolled parameter is disabling legs, and other algorithms which can conflict with physical animations. (you can use LegAnimator.User_SetIsRagdolled() through code instead)")]
	public string RagdolledParameter = "";

	private int _hash_Ragdolled = -1;

	private bool _ragdolled;

	[NonSerialized]
	public float MinNonRagdolledForBlendOut;

	[Range(0f, 1f)]
	[Space(5f)]
	[Tooltip("Calculating leg swing velocity in order to prevent gluing foot when swinging forward during movement forward (during forward swing, foot sometimes is touching ground which can result in gluing foot too soon, especially with ground level increased)\nWhen this value is high, foot will detect gluing less oftem.")]
	public float SwingHelper;

	[Tooltip("Local height value for the glue algorithm. You can try adjusting it's value during character movement and idling, to detect glue more effectively.")]
	public float GluingFloorLevel = 0.05f;

	public bool GluingFloorLevelUseOnMoving;

	public float GluingFloorLevelOnMoving;

	private float _glueingFloorLevel;

	[Tooltip("If you want to push out legs out of each other if their IK points are overlapping in one placement")]
	[Space(5f)]
	public float StepPointsOverlapRadius;

	public bool UseStepPointsOverlapRadiusOnMoving;

	public float StepPointsOverlapRadiusOnMoving;

	public MotionInfluenceProcessor MotionInfluence = new MotionInfluenceProcessor();

	public UnityEvent Event_OnStep = new UnityEvent();

	[Range(0f, 0.3f)]
	[Tooltip("Increase to execute step event sooner (speed up step confirmation). Useful if step events are executed too late.")]
	public float EventExecuteSooner = 0.05f;

	[Tooltip("If you want to send step events also during movement idle (in case you already use animation clip events for it)")]
	public bool SendOnMovingGlue;

	[Tooltip("When false, it will not allow to send step event when character is stopped")]
	public bool SendOnStopping;

	[Tooltip("Enabling triggering step events when character just switched grounded state")]
	public bool StepEventOnLanding;

	[Space(5f)]
	[Tooltip("Game Object with attached component implementing LegsAnimator.ILegStepInfoReceiver interface to receiver detailed info about leg step")]
	public Transform StepInfoReceiver;

	private ILegStepReceiver _StepReceiver;

	private ILegRaiseReceiver _RaiseReceiver;

	[Tooltip("Additional pelvis position push in local space. Can be accesed for custom pelvis offset animation or for constant model pose correction.")]
	public Vector3 ExtraPelvisOffset = Vector3.zero;

	[Tooltip("Time which needs to elapse after character stop, to trigger legs repose to most relevant pose in comparison to played idle animation")]
	[FPD_Suffix(0f, 2f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "sec", true, 0)]
	public float ReposeGluingAfter;

	[Tooltip("Enable if you want to use gluing only when character is idling. Useful when it's too much work needed to setup dynamic gluing during movement for your character. (it will still use feet ground align)")]
	public bool GlueOnlyOnIdle;

	[Tooltip("Raycasting down direction will be synced with base transform up axis when this feature is enabled.")]
	public bool LocalWorldUp = true;

	private float reposeGluingTimer;

	private bool reposedGluing;

	private Quaternion IK_UseIKRotatorQuat = Quaternion.identity;

	[Tooltip("Completely turning off all custom modules scripts execution.")]
	public bool DisableCustomModules;

	[Tooltip("Custom coded legs animator modules to change component behaviour without affecting core code")]
	public List<LegsAnimatorCustomModuleHelper> CustomModules = new List<LegsAnimatorCustomModuleHelper>();

	private bool UsingControlModules;

	[Tooltip("Power multiplier for pelvis push events")]
	public float ImpulsesPowerMultiplier = 1f;

	public float ImpulsesDurationMultiplier = 1f;

	[Range(0f, 1f)]
	[Tooltip("Damping impulses which are pushing body above ground level")]
	public float ImpulsesDampUpPushes;

	public PelvisImpulseSettings DebugPushHipsImpulse = new PelvisImpulseSettings(Vector3.down, 0.6f, 1f);

	protected List<ImpulseExecutor> Impulses = new List<ImpulseExecutor>();

	private bool _ImpulsesDoWorld;

	private bool _ImpulsesDoLocal;

	private bool _ImpulsesDoHips;

	private Vector3 _ImpulsesWorldPush = Vector3.zero;

	private Vector3 _ImpulsesWorldPushInherit = Vector3.zero;

	private Vector3 _ImpulsesLocalPush = Vector3.zero;

	private Vector3 _ImpulsesLocalPushInherit = Vector3.zero;

	private Vector3 _ImpulsesHipsRotation = Vector3.zero;

	private Vector3 _ImpulsesRotationElastic = Vector3.zero;

	private Vector3 _Hips_RotationElasticLocalOffset = Vector3.zero;

	[Tooltip("Use hips step adjustements and the stability algorithms")]
	public bool UseHips = true;

	[Tooltip("Whole body lift effect blend")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float HipsHeightStepBlend = 1f;

	[Range(0f, 1f)]
	[Tooltip("How fast body should adjust up/down")]
	public float HipsHeightStepSpeed = 0.7f;

	public EHipsAdjustStyle HipsAdjustStyle;

	[Tooltip("Adjusting hips to keep body balance pose")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float StabilizeCenterOfMass = 0.45f;

	[Range(0f, 1f)]
	[Tooltip("Blend stability pose reference from: initial pose to: current animator pose")]
	public float AnimationIsStablePose = 0.75f;

	[Range(0f, 1f)]
	[Tooltip("How fast body should adjust to the stability pose / to stretch preventer pose")]
	public float StabilizingSpeed = 0.375f;

	[Tooltip("Simulating body behaviour when doing leg steps")]
	[Range(0f, 1f)]
	public float PushHipsOnLegMove = 0.1f;

	[Tooltip("If your setup contains more than 2 legs it can be helpful to prevent overlapping pushes of multiple legs")]
	public bool NormalizePush;

	[Tooltip("Related with 'Push Hips On Leg Move' parameter above. How rapidly the pelvis push effect should be animated.")]
	[Range(0f, 1f)]
	public float PushReactionSpeed = 0.3f;

	[Tooltip("If Push in Y axis seems to be too strong, you can calm it down with this parameter")]
	[Range(0f, 2f)]
	public float PushYBlend = 1f;

	[Space(3f)]
	[Tooltip("Auto adjust hips to prevent leg stretching poses")]
	[Range(0f, 1f)]
	public float HipsStretchPreventer = 0.15f;

	public float StretchPreventerSpeed = 0.8f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Space(7f)]
	[Tooltip("Some of the stabilizing features may be not wanted when your character is running, you can blend them automatically to desired amount with this slider (you need to implement IsGrounded/IsMoving controls to give Legs Animator information about your character movement state)")]
	public float StabilizeOnIsMoving = 0.5f;

	private Vector3 _LastAppliedHipsStabilityOffset = Vector3.zero;

	internal Vector3 _LastAppliedHipsFinalPosition = Vector3.zero;

	internal Vector3 _LastAppliedHipsFinalOffset = Vector3.zero;

	internal Quaternion _LastAppliedHipsFinalRotationOffset = Quaternion.identity;

	internal Quaternion _LastHipsRotationOffsetOutsideInfo = Quaternion.identity;

	public Vector3 _Hips_Modules_ExtraWOffset = Vector3.zero;

	public Vector3 _Hips_Modules_ExtraRotOffset = Vector3.zero;

	private bool _updateHipsAdjustements = true;

	[Tooltip("If this model is created out of multiple leg bones hubs, you can define it here")]
	public List<Transform> ExtraHipsHubs = new List<Transform>();

	[Tooltip("Enter on the selected option on the right to see description")]
	public EHipsHubsHandling HipsHubsHandling = EHipsHubsHandling.Detailed;

	[Range(0f, 1f)]
	public float HipsHubsBlend = 1f;

	[FPD_FixedCurveWindow(0f, 0f, 1f, 3f, 0f, 1f, 1f, 1f)]
	[Tooltip("If leg hub is having backbones to compensate target rotation, you can controll the spine bend style with this curve")]
	public AnimationCurve HubsBackBonesBlend = AnimationCurve.Linear(0f, 1f, 1f, 1f);

	[Range(0f, 1f)]
	[Tooltip("Adding elasticity effect to the hub spine backbones adjustement animation")]
	public float HubBackBonesElasticity = 0.1f;

	private bool _hipsHubs_using;

	public HipsReference HipsSetup = new HipsReference();

	public EStabilityMode StabilityAlgorithm = EStabilityMode.Universal;

	private Vector3 _Hips_StabilityLocalOffset = Vector3.zero;

	private FMuscle_Eulers _Hips_RotationMuscle;

	private Vector3 _Hips_FinalStabilityOffset = Vector3.zero;

	public List<Leg> Legs = new List<Leg>();

	public LegStepAnimatingParameters BaseLegAnimating = new LegStepAnimatingParameters();

	[Tooltip("Using algorithm responsive for attaching feet to the ground when detected grounded foot in the played animation.")]
	public bool UseGluing = true;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	[Tooltip("You can smoothly change Glue Blend down to transition into sliding if your character is walking on ice or sliding on steep ground.")]
	public float MainGlueBlend = 1f;

	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float AdditionalGlueBlend = 1f;

	[Range(0f, 1f)]
	[Tooltip("If distance from the last attach point exceeds this distance (check scene gizmos) the leg will be detached.")]
	[Space(3f)]
	public float GlueRangeThreshold = 0.375f;

	[Range(0f, 1f)]
	[Tooltip("How quickly leg attachement transition should be proceeded.")]
	public float GlueFadeInSpeed = 0.85f;

	[Range(0f, 1f)]
	[Tooltip("If foot animation in original played clip is not reaching floor soon enough, increase it to attach for position slightly below current foot positioning.")]
	public float AllowGlueBelowFoot = 0.2f;

	[Range(0f, 1f)]
	[Tooltip("How quickly leg detachement transition should be proceeded.")]
	public float GlueFadeOutSpeed = 0.5f;

	[Space(5f)]
	[Tooltip("If leg rotation exceeds this angle during being attach, the leg will be detached.")]
	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMaxRounded, "°", true, 0)]
	public float UnglueOn = 30f;

	[Range(0f, 1f)]
	[Tooltip("When leg glue target position is stretching leg too much it will shift leg target towards source animation leg position.")]
	[Space(1f)]
	public float AllowGlueDrag = 0.7f;

	[NonSerialized]
	public float DontGlueAttachIfTooNearOppositeLeg;

	[Tooltip("Enter on the value field on the right to see tooltip.")]
	public EGlueMode GlueMode = EGlueMode.Automatic;

	[Tooltip("Making Gluing animations only local space, which can be helpful when character is standing on the moving platform.")]
	public bool OnlyLocalAnimation;

	[Range(0f, 1f)]
	[Tooltip("Smoothing leg align motion when sudden uneven terrain step occurs")]
	public float SmoothSuddenSteps = 0.85f;

	[Tooltip("Making leg rise a bit over ground when character leg overlaps collision (it's mostly visible on steep slopes)")]
	[Space(3f)]
	[Range(0f, 2f)]
	public float LegElevateBlend = 0.7f;

	[Range(0f, 1f)]
	public float LegElevateHeightLimit = 0.6f;

	[Space(6f)]
	[Tooltip("Overall foot rotation blend on the slope step align.")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float FootRotationBlend = 1f;

	[Tooltip("How quickly foot should align it's rotation to the slopes")]
	[Range(0f, 1f)]
	[Space(4f)]
	public float FootAlignRapidity = 0.75f;

	[Tooltip("If it's human leg limb with foot, then turn it on for the foot bone animation and alignments. But if it's something like spider leg, then disable it")]
	public bool AnimateFeet = true;

	[Tooltip("If feet rotation is above this value, feet rotation will be limited to avoid weird foot rotation pose")]
	[FPD_Suffix(0f, 90f, FPD_SuffixAttribute.SuffixMode.FromMinToMax, "°", true, 0)]
	public float LimitFeetYaw = 30f;

	[Tooltip("Local space ANKLE-step height detection level. It's detail parameter to adjust feet aligning sooner/later when foot is near to ground.")]
	[Range(-0.05f, 0.15f)]
	public float AnimationFloorLevel = 0.001f;

	public static LegsAnimator _Editor_LastSelectedLA;

	private bool _wasInstantTriggered = true;

	[SerializeField]
	[HideInInspector]
	private ReferencePose setupPose = new ReferencePose();

	[SerializeField]
	[HideInInspector]
	public List<ReferencePose> ExtraSetupPoses = new List<ReferencePose>();

	private bool _grounded = true;

	private bool _moving;

	private bool _sliding;

	protected float NotSlidingBlend = 1f;

	private bool? _wasFadingOn;

	protected bool legsWasDisabled;

	[Tooltip("Algorithm selector which controls how leg is bent - knee hint.")]
	public FimpIK_Limb.FIK_HintMode IKHintMode;

	[Range(0.4f, 1.1f)]
	[Tooltip("Dragging Leg if stretched too much, for humanoids this vlaue should be high (around 0.9 - 1.1) for spider or similar creatures it should be lower.\nUsing feet bones can be really helpful to enchance the leg stretch length range!")]
	public float LimitLegStretch = 0.99f;

	[Tooltip("Pushing feet up/down if required for model correction.")]
	public float FeetYOffset;

	[Range(-1f, 1f)]
	[Tooltip("Adjust the visual size of feet in order to make foot aligning calculations more precise.")]
	public float FeetLengthAdjust;

	[Tooltip("When not assigned, component will use this transform as 'Base Transform', but if your movement controller core is located in different transform, assign it here to be fully synchronized.")]
	[SerializeField]
	private Transform baseTransform;

	[Tooltip("The anchor bone for all other limbs.\n! It needs to be parent of Leg Bones !")]
	public Transform Hips;

	private Vector3 InitialBaseScale = Vector3.one;

	[Tooltip("Define helper value for the algorithm, to define raycasting distance - scale for the algorithms to animate model in the correct way.\n\nCheck scene gizmos to adjust this value.")]
	public ELegsScaleReference ScaleReferenceMode = ELegsScaleReference.PelvisLegAverage;

	[SerializeField]
	private float finalScaleReference = 0.5f;

	[SerializeField]
	private float finalScaleReferenceSqrt = 0.1f;

	[SerializeField]
	private float customScaleReferenceValue = 0.5f;

	[Tooltip("Do component init after few frames of the game (can be useful when waiting for some of the components to be generated, or to initialize component not during T-pose)")]
	public bool DelayedInitialization;

	[Tooltip("Hard refresh bones on update: it's required when any of procedurally animated bones is not handled by keyframe animation.\nIf you're sure, your animations are always keyframe animated, you can disable this feature for small performance boost.")]
	public ECalibrateMode Calibrate = ECalibrateMode.Calibrate;

	[Tooltip("If your Unity Animator is using 'Animate Physics' update mode, you should enable this parameter.")]
	public bool AnimatePhysics;

	[Tooltip("If time.scale should or shouldn't affect legs animation")]
	public bool UnscaledDeltaTime;

	[Tooltip("Disable Legs Animator calculations when this renderer is not seen by any camera (including scene view camera!)")]
	public Renderer DisableIfInvisible;

	public List<Renderer> DisableIfInvisibleExtraRenderers = new List<Renderer>();

	[Tooltip("Smoothly fade out Legs Animator when far from the camera")]
	public float FadeOffAtDistance;

	[NonSerialized]
	public Transform FadeOff_DistanceToCamera;

	private Vector3 _worldUpAxisVector = Vector3.up;

	[Tooltip("Physics layer mask for leg raycasting. Which objects should be considered as steps.")]
	public LayerMask GroundMask = 1;

	public QueryTriggerInteraction RaycastHitTrigger = QueryTriggerInteraction.Ignore;

	[Tooltip("Maximum raycasting check range. Check Gizmos on the scene view")]
	[Range(0f, 2f)]
	public float CastDistance = 1f;

	public ERaycastStartHeight RaycastStartHeight;

	[Tooltip("Origin height point for raycasts. Check Gizmos on the scene view")]
	[Range(0.5f, 2.5f)]
	public float RaycastStartHeightMul = 1f;

	[Tooltip("How physical raycasting should be done. Enter on the selected style to see tooltip.")]
	public ERaycastStyle RaycastStyle;

	[Tooltip("Physics detection ray volume size. Sphere Cast can provide more smooth transitions on the edges but costs a bit more.")]
	public ERaycastMode RaycastShape;

	[Range(0f, 1f)]
	[Tooltip("Shift spherecast hit point result towards original XZ position instead of hit position. Can be helpful to prevent spider legs from being bent too much in narrow spaces.")]
	public float SpherecastRealign;

	[Tooltip("Shift spherecast hit point result towards original XZ position instead of hit position. Can be helpful to prevent spider legs from being bent too much in narrow spaces.")]
	public float SpherecastResize = 1f;

	[Tooltip("If foot will not find ground beneath, you can trigger different leg behavior in such scenario")]
	public ENoRaycastBehviour NoRaycastGroundBehaviour;

	[Tooltip("DEPRECATED - Used just for back compatibility - if true, switching NoRaycastGroundBehaviour to ZeroFloorSteps and changing this value to false.")]
	public bool ZeroStepsOnNoRaycast;

	public float NoRaycast_KeepAttachedUntilStretch = 1.1f;

	[Range(0f, 1f)]
	[Tooltip("How low whole body can be pulled down when one of the legs raycast hit is lower than default object position.")]
	public float BodyStepDown = 0.5f;

	[Tooltip("How high whole body can be pulled up when all legs raycast hits are higher than default object position. (rare case for special character controllers).\nIt can also help out extra spine hubs to adjust on higher steps (for quadrupeds).")]
	[Range(0f, 1f)]
	[Space(3f)]
	public float MaxBodyStepUp;

	[Space(3f)]
	[Tooltip("How fast should be applied fade-out when character starts being ungrounded. (jumping/falling)")]
	[Range(0f, 1f)]
	public float UngroundFadeSpeed = 0.1f;

	[Range(0f, 1f)]
	public float IsMovingFadeSpeed = 0.4f;

	private float _calc_rayGrounding;

	private float _calc_lastGrounded = -1f;

	private float _lastMainBlend = 1f;

	[Tooltip("Total blend of the plugin effects. When zero it disables most of the calculations (but not all)")]
	[FPD_Suffix(0f, 1f, FPD_SuffixAttribute.SuffixMode.From0to100, "%", true, 0)]
	public float LegsAnimatorBlend = 1f;

	protected float cullingBlend = 1f;

	protected float protectedBlend = 1f;

	protected bool AllowUpdate;

	protected bool _started;

	private bool _fixedUpdated;

	public Vector3 DesiredMovementDirection { get; private set; }

	public bool usingCustomDesiredMovementDirection { get; private set; }

	public bool IsRagdolled => _ragdolled;

	public float RagdolledTime { get; private set; }

	public bool Helper_WasMoving { get; private set; }

	public float _stepPointsOverlapRadius { get; private set; }

	protected bool UseEvents { get; private set; }

	public bool JustGrounded { get; private set; }

	public Vector3 IK_CustomIKRotatorVector { get; private set; } = Vector3.zero;

	private float HipsBlendWeight => _MainBlend * HipsAdjustingBlend * HipsHeightStepBlend;

	public float HipsAdjustingBlend
	{
		get
		{
			if (!UseHips)
			{
				return 0f;
			}
			return 1f;
		}
	}

	public List<HipsReference> HipsHubs { get; private set; }

	public Vector3 _Get_Hips_StabilityLocalOffset => _Hips_StabilityLocalOffset;

	public Vector3 _Get_Hips_StabilityLocalAdjustement => HipsSetup._Get_Hips_StabilityLocalAdjustement;

	public LegStepAnimatingParameters LegAnimatingSettings => BaseLegAnimating;

	public float GlueBlend
	{
		get
		{
			if (!UseGluing)
			{
				return 0f;
			}
			return _MainBlend * MainGlueBlend * AdditionalGlueBlend;
		}
	}

	public EGlueMode _glueModeExecuted { get; set; }

	protected virtual bool UseCustomIK => false;

	public virtual string EditorIconPath
	{
		get
		{
			if (PlayerPrefs.GetInt("AnimsH", 1) == 0)
			{
				return "";
			}
			return "Legs Animator/SPR_LegsCrop";
		}
	}

	public bool LegsInitialized { get; private set; }

	public ReferencePose SetupPose => setupPose;

	public bool IsGrounded => _grounded;

	public bool IsInAir => !_grounded;

	public float IsGroundedBlend { get; private set; }

	public float RagdolledDisablerBlend { get; protected set; } = 1f;

	public bool IsMoving => _moving;

	public bool IsIdling => !_moving;

	public float IsMovingBlend { get; private set; }

	public bool IsSliding => _sliding;

	public float IsSlidingBlend => 1f - NotSlidingBlend;

	public float DeltaTime { get; private set; }

	public float Scale { get; private set; }

	public Matrix4x4 CastMx { get; private set; }

	public Matrix4x4 InvCastMx { get; private set; }

	public float DynamicYScale => BaseTransform.lossyScale.y / InitialBaseScale.y;

	public float ScaleReference => finalScaleReference * BaseTransform.lossyScale.x;

	public float ScaleReferenceNoScale => finalScaleReference;

	public float ScaleReferenceSqrt => finalScaleReferenceSqrt;

	public float FadeOff_lastCameraDistance { get; protected set; }

	public Vector3 Up
	{
		get
		{
			return _worldUpAxisVector;
		}
		set
		{
			_worldUpAxisVector = value;
		}
	}

	public float GroundedTime { get; private set; }

	public float InAirTime => 0f - GroundedTime;

	public float MovingTime { get; private set; }

	public float StoppedTime => 0f - MovingTime;

	public Transform BaseTransform => baseTransform;

	public float _MainBlend { get; protected set; }

	protected bool _lastMainBlendChanged { get; private set; }

	public float _MainBlendNoRagdolling { get; protected set; }

	public float _MainBlendPlusGrounded { get; protected set; }

	public void User_SetIsRagdolled(bool isRagdolled)
	{
		if (isRagdolled != _ragdolled)
		{
			if (_ragdolled)
			{
				OnLegsReactivate();
			}
			_ragdolled = isRagdolled;
		}
	}

	public void User_SetDesiredMovementDirection(Vector3 worldDirection)
	{
		usingCustomDesiredMovementDirection = true;
		DesiredMovementDirection = worldDirection;
	}

	public void User_SetDesiredMovementDirection(Vector3 worldDirection, bool removeYspeed)
	{
		if (removeYspeed)
		{
			worldDirection = ToRootLocalSpaceVec(worldDirection);
			worldDirection.y = 0f;
			worldDirection = RootToWorldSpaceVec(worldDirection);
		}
		User_SetDesiredMovementDirection(worldDirection);
	}

	public void User_SetDesiredMovementDirectionOff()
	{
		usingCustomDesiredMovementDirection = false;
	}

	public virtual void Controll_DefineHashes()
	{
		if (Mecanim == null)
		{
			return;
		}
		if (!string.IsNullOrWhiteSpace(GroundedParameter))
		{
			_hash_Grounded = Animator.StringToHash(GroundedParameter);
		}
		else
		{
			_hash_Grounded = -1;
		}
		if (!string.IsNullOrWhiteSpace(MovingParameter))
		{
			_hash_Moving = Animator.StringToHash(MovingParameter);
			if (Mecanim.runtimeAnimatorController != null)
			{
				for (int i = 0; i < Mecanim.parameterCount; i++)
				{
					if (Mecanim.GetParameter(i).nameHash == _hash_Moving && Mecanim.GetParameter(i).type == AnimatorControllerParameterType.Float)
					{
						_hash_MovingIsFloat = true;
						break;
					}
				}
			}
		}
		else
		{
			_hash_Moving = -1;
		}
		if (!string.IsNullOrWhiteSpace(SlidingParameter))
		{
			_hash_Sliding = Animator.StringToHash(SlidingParameter);
		}
		else
		{
			_hash_Sliding = -1;
		}
		if (!string.IsNullOrWhiteSpace(RagdolledParameter))
		{
			_hash_Ragdolled = Animator.StringToHash(RagdolledParameter);
		}
		else
		{
			_hash_Ragdolled = -1;
		}
	}

	protected virtual void Controll_Update()
	{
		if (_hash_Ragdolled != -1)
		{
			User_SetIsRagdolled(Mecanim.GetBool(_hash_Ragdolled));
		}
		if (IsRagdolled)
		{
			if (RagdolledTime < 0f)
			{
				RagdolledTime = 0f;
			}
			RagdolledTime += DeltaTime;
			RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 0f, DeltaTime * 6f);
			UpdateBeingRagdolled();
		}
		else
		{
			if (RagdolledTime > 0f)
			{
				RagdolledTime = 0f;
			}
			RagdolledTime -= DeltaTime;
			bool flag = false;
			if (MinNonRagdolledForBlendOut > 0f)
			{
				if (0f - RagdolledTime > MinNonRagdolledForBlendOut)
				{
					flag = true;
				}
			}
			else
			{
				flag = true;
			}
			if (flag)
			{
				float ragdolledDisablerBlend = RagdolledDisablerBlend;
				RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 1f, DeltaTime * 4f);
				if (ragdolledDisablerBlend != RagdolledDisablerBlend)
				{
					UpdateBeingRagdolled();
				}
			}
			else
			{
				RagdolledDisablerBlend = Mathf.MoveTowards(RagdolledDisablerBlend, 0f, DeltaTime * 6f);
			}
		}
		if (IsMoving || IsMovingBlend > 0.5f)
		{
			Helper_WasMoving = true;
		}
		else
		{
			Helper_WasMoving = false;
		}
		if (_hash_Grounded != -1)
		{
			User_SetIsGrounded(Mecanim.GetBool(_hash_Grounded));
		}
		if (_hash_Moving != -1)
		{
			if (_hash_MovingIsFloat)
			{
				User_SetIsMoving(Mecanim.GetFloat(_hash_Moving) > ScaleReference * User_IsMovingMecanim_NotMovingFloat_Threshold);
			}
			else
			{
				User_SetIsMoving(Mecanim.GetBool(_hash_Moving));
			}
		}
		if (_hash_Sliding != -1)
		{
			User_SetIsSliding(Mecanim.GetBool(_hash_Sliding));
		}
		if (GlueMode == EGlueMode.Automatic)
		{
			if (GroundedTime < 0.1f)
			{
				_glueModeExecuted = EGlueMode.Moving;
			}
			else if (IsMoving)
			{
				_glueModeExecuted = EGlueMode.Moving;
			}
			else
			{
				_glueModeExecuted = EGlueMode.Idle;
			}
		}
		else
		{
			_glueModeExecuted = GlueMode;
		}
		if (IsGrounded && GroundedTime < 0.2f)
		{
			_glueModeExecuted = EGlueMode.Moving;
		}
		if (IsGrounded)
		{
			if (GroundedTime < 0f)
			{
				GroundedTime = 0f;
			}
			GroundedTime += DeltaTime;
		}
		else
		{
			if (GroundedTime > 0f)
			{
				GroundedTime = 0f;
			}
			GroundedTime -= DeltaTime;
		}
		if (IsMoving)
		{
			if (MovingTime < 0f)
			{
				MovingTime = 0f;
			}
			MovingTime += DeltaTime;
		}
		else
		{
			if (MovingTime > 0f)
			{
				MovingTime = 0f;
			}
			MovingTime -= DeltaTime;
		}
		if (GluingFloorLevelUseOnMoving)
		{
			_glueingFloorLevel = Mathf.LerpUnclamped(GluingFloorLevel, GluingFloorLevelOnMoving, IsMovingBlend);
		}
		else
		{
			_glueingFloorLevel = GluingFloorLevel;
		}
		if (UseStepPointsOverlapRadiusOnMoving)
		{
			_stepPointsOverlapRadius = Mathf.LerpUnclamped(StepPointsOverlapRadius, StepPointsOverlapRadiusOnMoving, IsMovingBlend);
		}
		else
		{
			_stepPointsOverlapRadius = StepPointsOverlapRadius;
		}
	}

	private void BaseObject_MotionUpdate()
	{
		MotionInfluence.Update();
	}

	private void MotionInfluence_Init()
	{
		MotionInfluence.Init(BaseTransform);
	}

	protected virtual void Control_OnLand()
	{
		if (!StepEventOnLanding)
		{
			return;
		}
		float num = float.MaxValue;
		Leg leg = null;
		for (int i = 0; i < Legs.Count; i++)
		{
			float y = ToRootLocalSpace(Legs[i]._PreviousFinalIKPos).y;
			if (y < num)
			{
				num = y;
				leg = Legs[i];
				Legs[i].StepEventSentInCustomWay();
			}
		}
		if (leg != null)
		{
			Events_OnStep(leg, 1f, EStepType.OnLanding);
		}
	}

	protected virtual void Control_OnLooseGround()
	{
	}

	protected virtual void Control_OnStopMoving()
	{
	}

	protected virtual void Control_OnStartMoving()
	{
	}

	private void RefreshTargetMovementDirectionHelper()
	{
		if (usingCustomDesiredMovementDirection)
		{
			return;
		}
		if (!IsMoving)
		{
			DesiredMovementDirection = Vector3.zero;
		}
		else if ((bool)Rigidbody)
		{
			if (Rigidbody.velocity.magnitude < ScaleReference * 0.1f)
			{
				DesiredMovementDirection = Vector3.zero;
			}
			else
			{
				DesiredMovementDirection = Rigidbody.velocity.normalized;
			}
		}
	}

	private void UpdateBeingRagdolled()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Leg_UpdateParams();
		}
	}

	private void Events_TriggerStepUnityEvent()
	{
		Event_OnStep.Invoke();
	}

	private void Events_OnStep(Leg leg, float stepFactor = 1f, EStepType type = EStepType.IdleGluing)
	{
		if (StepEventOnLanding || !(IsGroundedBlend * RagdolledDisablerBlend < 0.99f))
		{
			Events_TriggerStepUnityEvent();
			if (_StepReceiver != null)
			{
				Vector3 position = leg._PreviousFinalIKPos + leg.BoneEnd.TransformVector((leg.AnkleToFeetEnd + leg.AnkleToHeel) * 0.5f);
				Quaternion rotation = Quaternion.LookRotation(leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.forward, leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.up);
				_StepReceiver.LegAnimatorStepEvent(leg, stepFactor, leg.Side == ELegSide.Right, position, rotation, type);
			}
		}
	}

	private void Events_OnRaise(Leg leg, float distanceToNewLegPosition = 1f, EStepType type = EStepType.IdleGluing)
	{
		if ((StepEventOnLanding || !(IsGroundedBlend * RagdolledDisablerBlend < 0.99f)) && _RaiseReceiver != null)
		{
			Vector3 position = leg._PreviousFinalIKPos + leg.BoneEnd.TransformVector((leg.AnkleToFeetEnd + leg.AnkleToHeel) * 0.5f);
			Quaternion rotation = Quaternion.LookRotation(leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.forward, leg._PreviousFinalIKRot * leg.IKProcessor.EndIKBone.up);
			_RaiseReceiver.LegAnimatorRaiseEvent(leg, distanceToNewLegPosition, leg.Side == ELegSide.Right, position, rotation, type);
		}
	}

	private void ExtraControls_Update()
	{
		if (IsGrounded && GroundedTime < 0.2f)
		{
			JustGrounded = true;
		}
		else
		{
			JustGrounded = false;
		}
		if (ReposeGluingAfter > 0f)
		{
			if (MotionInfluence.rootOffset.magnitude > ScaleReference * 0.05f || IsMoving)
			{
				reposeGluingTimer = 0f;
				reposedGluing = false;
			}
			else
			{
				reposeGluingTimer += DeltaTime;
			}
			if (!reposedGluing && reposeGluingTimer > ReposeGluingAfter)
			{
				IK_TriggerReglue();
				reposedGluing = true;
			}
		}
	}

	public void DisableCustomIKRotatorVector()
	{
	}

	public void SetCustomIKRotatorVector(Vector3 localVector)
	{
		IK_CustomIKRotatorVector = localVector;
	}

	private void InitializeModules()
	{
		bool usingControlModules = false;
		if (CustomModules == null)
		{
			return;
		}
		for (int num = CustomModules.Count - 1; num >= 0; num--)
		{
			if (CustomModules[num] == null)
			{
				CustomModules.RemoveAt(num);
			}
			else if (CustomModules[num].ModuleReference == null)
			{
				CustomModules.RemoveAt(num);
			}
			else
			{
				CustomModules[num].PreparePlaymodeModule(this);
				usingControlModules = true;
			}
		}
		UsingControlModules = usingControlModules;
	}

	private void DisposeModules()
	{
		if (CustomModules == null)
		{
			return;
		}
		for (int num = CustomModules.Count - 1; num >= 0; num--)
		{
			if (CustomModules[num] == null)
			{
				CustomModules.RemoveAt(num);
			}
			else if (CustomModules[num].ModuleReference == null)
			{
				CustomModules.RemoveAt(num);
			}
			else
			{
				CustomModules[num].DisposeModule();
			}
		}
	}

	public T GetModule<T>() where T : LegsAnimatorControlModuleBase
	{
		if (CustomModules == null)
		{
			return null;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].ModuleReference is T)
			{
				return CustomModules[i].PlaymodeModule as T;
			}
		}
		return null;
	}

	public LegsAnimatorCustomModuleHelper GetModuleHelper<T>() where T : LegsAnimatorControlModuleBase
	{
		if (CustomModules == null)
		{
			return null;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].ModuleReference is T)
			{
				return CustomModules[i];
			}
		}
		return null;
	}

	private void Modules_OnReInitialize()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnReInitialize(CustomModules[i]);
			}
		}
	}

	private void Modules_Update()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_UpdateAfterManualChanges()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnValidateAfterManualChanges(CustomModules[i]);
			}
		}
	}

	private void Modules_LegBeforeRaycastingUpdate(Leg leg)
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.Leg_LatePreRaycastingUpdate(CustomModules[i], leg);
			}
		}
	}

	private void Modules_AfterAnimatorCaptureUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnAfterAnimatorCaptureUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_PreLateUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnPreLateUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_LateUpdatePreApply()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnLateUpdatePreApply(CustomModules[i]);
			}
		}
	}

	private void Modules_PostLateUpdate()
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.OnPostLateUpdate(CustomModules[i]);
			}
		}
	}

	private void Modules_Leg_LateUpdate(Leg leg)
	{
		if (!UsingControlModules || DisableCustomModules)
		{
			return;
		}
		for (int i = 0; i < CustomModules.Count; i++)
		{
			if (CustomModules[i].Enabled)
			{
				CustomModules[i].PlaymodeModule.Leg_LateUpdate(CustomModules[i], leg);
			}
		}
	}

	private void Hips_Calc_UpdateImpulses()
	{
		_ImpulsesDoLocal = false;
		_ImpulsesDoWorld = false;
		_ImpulsesDoHips = false;
		if (Impulses.Count == 0)
		{
			return;
		}
		if ((double)ImpulsesDurationMultiplier < 0.001)
		{
			ImpulsesDurationMultiplier = 1f;
		}
		_ImpulsesWorldPush = Vector3.zero;
		_ImpulsesWorldPushInherit = Vector3.zero;
		_ImpulsesLocalPush = Vector3.zero;
		_ImpulsesLocalPushInherit = Vector3.zero;
		_ImpulsesHipsRotation = Vector3.zero;
		Vector3 normalized = DesiredMovementDirection.normalized;
		for (int i = 0; i < Impulses.Count; i++)
		{
			ImpulseExecutor value = Impulses[i];
			value.Update(DeltaTime / ImpulsesDurationMultiplier);
			if (value.WorldTranslation != Vector3.zero)
			{
				Vector3 vector = value.CurrentWorldOffset * ImpulsesPowerMultiplier;
				if (value.Elastic <= 0f)
				{
					_ImpulsesWorldPush += vector;
				}
				else if (value.Elastic >= 1f)
				{
					_ImpulsesWorldPushInherit += vector;
				}
				else
				{
					_ImpulsesWorldPush += (1f - value.Elastic) * vector;
					_ImpulsesWorldPushInherit += value.Elastic * vector;
				}
			}
			if (value.LocalTranslation != Vector3.zero)
			{
				Vector3 vector2 = value.CurrentLocalOffset * (ImpulsesPowerMultiplier * ScaleReferenceNoScale);
				vector2.y *= value.CurrentLocalYAxisMultiplier;
				bool flag = true;
				if (value.AlignDesired && DesiredMovementDirection != Vector3.zero)
				{
					flag = false;
					vector2 = BaseTransform.rotation * Quaternion.FromToRotation(BaseTransform.forward.normalized, normalized) * vector2;
					if (value.Elastic <= 0f)
					{
						_ImpulsesWorldPush += vector2;
					}
					else if (value.Elastic >= 1f)
					{
						_ImpulsesWorldPushInherit += vector2;
					}
					else
					{
						_ImpulsesWorldPush += (1f - value.Elastic) * vector2;
						_ImpulsesWorldPushInherit += value.Elastic * vector2;
					}
				}
				if (flag)
				{
					if (value.Elastic <= 0f)
					{
						_ImpulsesLocalPush += vector2;
					}
					else if (value.Elastic >= 1f)
					{
						_ImpulsesLocalPushInherit += vector2;
					}
					else
					{
						_ImpulsesLocalPush += (1f - value.Elastic) * vector2;
						_ImpulsesLocalPushInherit += value.Elastic * vector2;
					}
				}
			}
			if (value.HipsRotation != Vector3.zero)
			{
				Vector3 hipsRotation = value.HipsRotation;
				if (value.AlignDesired && Vector3.Dot(BaseTransform.forward.normalized, normalized) < 0f)
				{
					hipsRotation.z = 0f - hipsRotation.z;
				}
				_ImpulsesHipsRotation += hipsRotation * (ImpulsesPowerMultiplier * value.Evaluation * value.Power);
			}
			Impulses[i] = value;
		}
		for (int num = Impulses.Count - 1; num >= 0; num--)
		{
			if (Impulses[num].Finished)
			{
				Impulses.RemoveAt(num);
			}
		}
		if (_ImpulsesWorldPush != Vector3.zero || _ImpulsesWorldPushInherit != Vector3.zero)
		{
			_ImpulsesDoWorld = true;
		}
		if (_ImpulsesLocalPush != Vector3.zero || _ImpulsesLocalPushInherit != Vector3.zero)
		{
			_ImpulsesDoLocal = true;
		}
		if (_ImpulsesHipsRotation != Vector3.zero)
		{
			_ImpulsesDoHips = true;
		}
	}

	private void Hips_Calc_ApplyImpulsesInherit()
	{
		if (_ImpulsesDoLocal)
		{
			_Hips_StabilityLocalOffset += _ImpulsesLocalPushInherit * _MainBlend;
		}
		if (_ImpulsesDoWorld)
		{
			_Hips_StabilityLocalOffset += ToRootLocalSpaceVec(_ImpulsesWorldPushInherit * _MainBlend);
		}
		if (_ImpulsesDoHips || _ImpulsesRotationElastic != Vector3.zero)
		{
			_Hips_RotationMuscle.Update(DeltaTime, _ImpulsesHipsRotation);
			_ImpulsesRotationElastic = _Hips_RotationMuscle.ProceduralEulerAngles;
			_Hips_Modules_ExtraRotOffset += _ImpulsesRotationElastic;
		}
	}

	private void Hips_Calc_ApplyImpulses()
	{
		if (_ImpulsesDoLocal)
		{
			_LastAppliedHipsFinalPosition += RootToWorldSpaceVec(_ImpulsesLocalPush * _MainBlend);
		}
		if (_ImpulsesDoWorld)
		{
			_LastAppliedHipsFinalPosition += _ImpulsesWorldPush * _MainBlend;
		}
	}

	public float GetLandingBoost()
	{
		float result = HipsHeightStepSpeed;
		if (IsGrounded && GroundedTime < 0.2f)
		{
			result = Mathf.Max(HipsHeightStepSpeed, Mathf.LerpUnclamped(HipsHeightStepSpeed, 0.95f, 0.9f));
		}
		return result;
	}

	private void Hips_Calc_BodyAdjust()
	{
		if (HipsHeightStepBlend <= 0f)
		{
			return;
		}
		float num = HipsSetup.CalculateBodyAdjust();
		Vector3 vector = Vector3.zero;
		if (num != 0f && !float.IsNaN(num))
		{
			vector = Up * num;
			Hips.position += vector;
		}
		if (!_hipsHubs_using || HipsHubsBlend < 0.0001f)
		{
			return;
		}
		for (int i = 0; i < HipsHubs.Count; i++)
		{
			HipsHubs[i]._PreHipsAdjustPosition = HipsHubs[i].bone.position;
			float num2 = HipsHubs[i].CalculateBodyAdjust();
			if (num2 != 0f && !float.IsNaN(num2))
			{
				Vector3 vector2 = Up * num2;
				vector2 -= vector;
				HipsHubs[i].bone.position += vector2;
			}
		}
	}

	public void Hips_PreLateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			HipsSetup.Calibrate();
			HipsHubs_CaptureAnimation();
		}
	}

	public void Hips_LateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			Hips_Calc_BodyAdjust();
		}
	}

	public void Hips_PostLateUpdate()
	{
		if (_updateHipsAdjustements)
		{
			Hips_Calc_Stabilize();
			Hips_Calc_UpdateImpulses();
			Hips_Calc_ApplyImpulsesInherit();
			Hips_Calc_Elasticity();
			Hips_Calc_Apply();
			Hips_Calc_ApplyImpulses();
			Hips_ApplyTransformations();
		}
	}

	protected virtual void Hips_ApplyTransformations()
	{
		if (float.IsNaN(_LastAppliedHipsFinalPosition.x) || float.IsNaN(_LastAppliedHipsFinalPosition.y) || float.IsNaN(_LastAppliedHipsFinalPosition.z))
		{
			_LastAppliedHipsFinalPosition = RootToWorldSpace(HipsSetup.InitHipsPositionRootSpace);
			if (float.IsNaN(_LastAppliedHipsFinalPosition.x) || float.IsNaN(_LastAppliedHipsFinalPosition.y) || float.IsNaN(_LastAppliedHipsFinalPosition.z))
			{
				_LastAppliedHipsFinalPosition = Vector3.zero;
			}
		}
		if (_Hips_Modules_ExtraRotOffset != Vector3.zero)
		{
			float num = _MainBlend * ImpulsesPowerMultiplier;
			Vector3 hips_Modules_ExtraRotOffset = _Hips_Modules_ExtraRotOffset;
			Quaternion identity = Quaternion.identity;
			if (hips_Modules_ExtraRotOffset.z != 0f)
			{
				identity *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.z * num, BaseTransform.right);
			}
			if (hips_Modules_ExtraRotOffset.x != 0f)
			{
				identity *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.x * num, BaseTransform.forward);
			}
			if (hips_Modules_ExtraRotOffset.y != 0f)
			{
				identity *= Quaternion.AngleAxis(hips_Modules_ExtraRotOffset.y * num, BaseTransform.up);
			}
			_LastAppliedHipsFinalRotationOffset = identity;
			Quaternion rotation = identity * Hips.rotation;
			Hips.SetPositionAndRotation(_LastAppliedHipsFinalPosition, rotation);
		}
		else
		{
			Hips.position = _LastAppliedHipsFinalPosition;
		}
		_LastAppliedHipsFinalOffset = _LastAppliedHipsFinalPosition - HipsSetup.LastKeyframePosition;
		HipsHubs_ApplyTransformations();
		Hips_Finalize();
	}

	protected virtual void Hips_Finalize()
	{
		_LastHipsRotationOffsetOutsideInfo = Quaternion.identity;
	}

	private void Hips_Calc_Apply()
	{
		_LastAppliedHipsFinalOffset = Vector3.zero;
		_LastAppliedHipsFinalRotationOffset = Quaternion.identity;
		_LastAppliedHipsFinalPosition = Hips.position;
		_LastAppliedHipsStabilityOffset = _Hips_FinalStabilityOffset * _MainBlendPlusGrounded * HipsAdjustingBlend;
		_LastAppliedHipsFinalPosition += _LastAppliedHipsStabilityOffset;
		_LastAppliedHipsFinalPosition += _Hips_Modules_ExtraWOffset;
		_Hips_Modules_ExtraWOffset = Vector3.zero;
	}

	protected void Hips_PreCalibrate()
	{
		_updateHipsAdjustements = true;
		HipsSetup.PreCalibrate();
		if (Calibrate != 0 && SpineBone != null)
		{
			if (_spineBoneCalibrate.Transform == null)
			{
				_spineBoneCalibrate = new CalibrateTransform(SpineBone);
			}
			_spineBoneCalibrate.Calibrate();
			if (ChestBone != null)
			{
				if (_ChestBoneCalibrate.Transform == null)
				{
					_ChestBoneCalibrate = new CalibrateTransform(ChestBone);
				}
				_ChestBoneCalibrate.Calibrate();
			}
		}
		Hips_Calc_PreRefreshVariables();
		HipsHubs_PreCalibrate();
	}

	private void Hips_Calc_Elasticity()
	{
		if (HipsSetup.HipsElasticityBlend > 0f)
		{
			Vector3 vector = HipsSetup.HipsMuscle.Update(DeltaTime, _Hips_StabilityLocalOffset);
			if (vector.y > 0f)
			{
				vector.y *= 1f - ImpulsesDampUpPushes;
			}
			if (HipsSetup.HipsElasticityBlend < 1f)
			{
				_Hips_FinalStabilityOffset = Vector3.LerpUnclamped(_Hips_StabilityLocalOffset, vector, HipsSetup.HipsElasticityBlend);
			}
			else
			{
				_Hips_FinalStabilityOffset = vector;
			}
		}
		else
		{
			_Hips_FinalStabilityOffset = _Hips_StabilityLocalOffset;
		}
		_Hips_FinalStabilityOffset = RootToWorldSpaceVec(_Hips_FinalStabilityOffset);
	}

	private void HipsHubs_Init()
	{
		_hipsHubs_using = false;
		HipsHubs = new List<HipsReference>();
		for (int i = 0; i < ExtraHipsHubs.Count; i++)
		{
			if (!(ExtraHipsHubs[i] == null))
			{
				HipsReference hipsReference = new HipsReference();
				hipsReference.Initialize(this, ExtraHipsHubs[i], BaseTransform);
				hipsReference.CopyMuscleSettingsFrom(HipsSetup);
				HipsHubs.Add(hipsReference);
			}
		}
		if (ExtraHipsHubs.Count > 0)
		{
			_hipsHubs_using = true;
		}
		HipsSetup.PrepareLegs();
		for (int j = 0; j < HipsHubs.Count; j++)
		{
			HipsHubs[j].PrepareHubBones();
		}
	}

	private void HipsHubs_PreCalibrate()
	{
		if (_hipsHubs_using)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs[i].PreCalibrate();
			}
		}
	}

	private void HipsHubs_CaptureAnimation()
	{
		if (_hipsHubs_using)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs[i].Calibrate();
			}
		}
	}

	private void HipsHubs_ApplyTransformations()
	{
		if (!_hipsHubs_using)
		{
			return;
		}
		if (HipsHubsHandling == EHipsHubsHandling.FixDisconnected)
		{
			for (int i = 0; i < HipsHubs.Count; i++)
			{
				HipsHubs_ApplyBasic(HipsHubs[i]);
			}
		}
		else
		{
			for (int j = 0; j < HipsHubs.Count; j++)
			{
				HipsHubs_ApplyDetailed(HipsHubs[j]);
			}
		}
	}

	private void HipsHubs_ApplyBasic(HipsReference hub)
	{
		hub.bone.position += _LastAppliedHipsFinalOffset * HipsHubsBlend;
		Quaternion quaternion = _LastAppliedHipsFinalRotationOffset * _LastHipsRotationOffsetOutsideInfo * hub.bone.rotation;
		if (HipsHubsBlend > 0.999f)
		{
			hub.bone.rotation = quaternion;
		}
		else
		{
			hub.bone.rotation = Quaternion.Lerp(hub.bone.rotation, quaternion, HipsHubsBlend);
		}
	}

	private void HipsHubs_ApplyDetailed(HipsReference hub)
	{
		if (HipsHubsBlend < 0.0001f)
		{
			return;
		}
		float num = HipsHubsBlend * _MainBlend * IsGroundedBlend;
		float num2 = Mathf.LerpUnclamped(1f, StabilizeOnIsMoving, IsMovingBlend);
		Vector3 zero = Vector3.zero;
		zero += hub.CalculateCenterOfMassStability(num2);
		Vector3 pushLocalOffset = hub.CalculateGlueMovePush() * PushHipsOnLegMove;
		pushLocalOffset = hub.SmoothPushOffset(pushLocalOffset, Mathf.LerpUnclamped(0.125f, 0.025f, PushReactionSpeed));
		zero += _MainBlendPlusGrounded * RootToWorldSpaceVec(pushLocalOffset);
		Vector3 vector = hub.CalculateStretchPreventerOffset();
		zero += _MainBlendPlusGrounded * vector * HipsStretchPreventer * num2;
		zero = hub.AnimateOffset(zero);
		hub.HipsMuscle.Update(DeltaTime, zero);
		zero = hub.HipsMuscle.ProceduralPosition;
		zero += hub.ExtraNonElasticOffset;
		hub.ExtraNonElasticOffset = Vector3.zero;
		Vector3 zero2 = Vector3.zero;
		if (HipsSetup._Hips_LastHipsOffset > 0f)
		{
			zero2.y -= HipsSetup._Hips_LastHipsOffset * 0.1f;
		}
		if (hub._Hips_LastHipsOffset < 0f)
		{
			zero2.y += hub._Hips_LastHipsOffset * 0.1f;
		}
		Vector3 vector2 = hub.CalculateStretchReadjust();
		Vector3 vector3 = RootToWorldSpaceVec(zero + zero2 + vector2);
		Vector3 vector4 = hub.bone.position + vector3;
		hub.bone.localPosition = hub.LastKeyframeLocalPosition;
		hub.bone.position += RootToWorldSpaceVec(zero2);
		Quaternion rotation = hub.bone.rotation;
		float num3 = 1f;
		if (num3 > 0f && hub.HubBackBones.Count > 0)
		{
			float num4 = (float)hub.HubBackBones.Count - 1f;
			if (num4 == 0f)
			{
				num4 = 1f;
			}
			float num5 = 0f;
			for (int num6 = hub.HubBackBones.Count - 1; num6 >= 0; num6--)
			{
				HipsReference.HipsHubBackbone hipsHubBackbone = hub.HubBackBones[num6];
				Vector3 normalized = (hipsHubBackbone.frontBone.position - hipsHubBackbone.bone.position).normalized;
				Vector3 vector5 = (vector4 - hipsHubBackbone.bone.position).normalized;
				float num7 = Vector3.Dot(normalized, vector5);
				float num8 = 0f;
				if (num7 < 0.985f)
				{
					Vector3 vector6 = ToRootLocalSpaceVec(normalized);
					Vector3 vector7 = ToRootLocalSpaceVec(vector5);
					vector6.y = 0f;
					vector7.y = 0f;
					float value = Vector3.Dot(vector6.normalized, vector7.normalized);
					num8 = Mathf.InverseLerp(0.985f, 0.5f, value);
					vector5 = Vector3.Slerp(vector5, normalized, num8);
				}
				vector5 = hipsHubBackbone.AnimateTargetDirection(vector5);
				Vector3 toDirection = Vector3.LerpUnclamped(normalized, vector5, num3 * num / num4 * HubsBackBonesBlend.Evaluate(num5 / num4) * (1f - num8));
				Quaternion quaternion = Quaternion.FromToRotation(normalized, toDirection);
				hipsHubBackbone.bone.rotation = quaternion * hipsHubBackbone.bone.rotation;
				num5 += 1f;
			}
		}
		Quaternion quaternion2 = Quaternion.Inverse(hub._LastHipsRotationOffsetOutsideInfo);
		hub.bone.rotation = quaternion2 * Quaternion.SlerpUnclamped(hub.bone.rotation, rotation, 0.75f * HipsHubsBlend);
		hub._LastHipsRotationOffsetOutsideInfo = Quaternion.identity;
	}

	private void Initialize_Stability()
	{
		_Hips_RotationMuscle = new FMuscle_Eulers();
		_Hips_RotationMuscle.Initialize(Vector3.zero);
	}

	private void Hips_Calc_PreRefreshVariables()
	{
		_Hips_StabilityLocalOffset = Vector3.zero;
		_Hips_Modules_ExtraRotOffset = Vector3.zero;
	}

	private void Hips_Calc_Stabilize()
	{
		float mainBlendPlusGrounded = _MainBlendPlusGrounded;
		float num = Mathf.LerpUnclamped(1f, StabilizeOnIsMoving, IsMovingBlend);
		HipsSetup.CalculateCenterOfMassStability(num);
		float pushDuration = 0f;
		if (PushReactionSpeed < 1f)
		{
			pushDuration = Mathf.LerpUnclamped(0.125f, 0.025f, PushReactionSpeed);
		}
		Vector3 pushLocalOffset = HipsSetup.CalculateGlueMovePush();
		Vector3 vector = HipsSetup.SmoothPushOffset(pushLocalOffset, pushDuration);
		if (HipsStretchPreventer > 0f)
		{
			Vector3 vector2 = HipsSetup.CalculateStretchPreventerOffset();
			_Hips_StabilityLocalOffset += _MainBlendPlusGrounded * vector2 * HipsStretchPreventer * num;
		}
		if (MotionInfluence.AdvancedInfluence || MotionInfluence.AxisMotionInfluence.x > 0f)
		{
			_Hips_StabilityLocalOffset += MotionInfluence.CalculateInversedInfluence();
		}
		_Hips_StabilityLocalOffset += _Get_Hips_StabilityLocalAdjustement;
		_Hips_StabilityLocalOffset += vector * PushHipsOnLegMove;
		if (ExtraPelvisOffset != Vector3.zero && IsGroundedBlend > 0f)
		{
			Hips.position += RootToWorldSpaceVec(ExtraPelvisOffset * mainBlendPlusGrounded);
		}
	}

	private void ValueTowards(ref Vector3 value, Vector3 target, ref Vector3 sd, float duration)
	{
		ValueTowards(ref value, target, ref sd, duration, DeltaTime);
	}

	private void ValueTowards(ref Vector3 value, Vector3 target, ref Vector3 sd, float duration, float delta)
	{
		if (duration < 1f)
		{
			value = Vector3.SmoothDamp(value, target, ref sd, duration, 10000000f, delta);
		}
		else
		{
			value = target;
		}
	}

	public Leg Setup_TryAutoLegSetup(Leg scheme, Transform toSetup, bool apply = true)
	{
		if (scheme == null)
		{
			return null;
		}
		if (toSetup == null)
		{
			return null;
		}
		Transform bottomMostChildTransform = SkeletonRecognize.GetBottomMostChildTransform(scheme.BoneStart);
		int depth = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneStart);
		Transform bottomMostChildTransform2 = SkeletonRecognize.GetBottomMostChildTransform(toSetup);
		int depth2 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform2, toSetup);
		if (bottomMostChildTransform2 == null)
		{
			return null;
		}
		if (bottomMostChildTransform == null)
		{
			return null;
		}
		if (depth2 != depth)
		{
			return null;
		}
		if (depth == 0)
		{
			return null;
		}
		if (depth2 == 0)
		{
			return null;
		}
		int depth3 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneEnd);
		Transform transform = bottomMostChildTransform2;
		for (int i = 0; i < depth3; i++)
		{
			if (transform.parent == null)
			{
				return null;
			}
			transform = transform.parent;
		}
		depth3 = SkeletonRecognize.SkeletonInfo.GetDepth(bottomMostChildTransform, scheme.BoneMid);
		Transform transform2 = bottomMostChildTransform2;
		for (int j = 0; j < depth3; j++)
		{
			if (transform.parent == null)
			{
				return null;
			}
			transform2 = transform2.parent;
		}
		if (toSetup == transform2)
		{
			return null;
		}
		if (toSetup == transform)
		{
			return null;
		}
		if (transform2 == transform)
		{
			return null;
		}
		float num = scheme.LegLimbLength();
		Leg leg = new Leg();
		leg.BoneStart = toSetup;
		leg.BoneMid = transform2;
		leg.BoneEnd = transform;
		leg.Owner = this;
		if (leg.LegLimbLength() < num * 0.2f)
		{
			return null;
		}
		bool flag = true;
		for (int k = 0; k < Legs.Count; k++)
		{
			if (Legs[k].BoneStart == leg.BoneStart)
			{
				flag = false;
				break;
			}
			if (Legs[k].BoneStart == leg.BoneMid)
			{
				flag = false;
				break;
			}
			if (Legs[k].BoneMid == leg.BoneStart)
			{
				flag = false;
				break;
			}
			if (Legs[k].BoneMid == leg.BoneMid)
			{
				flag = false;
				break;
			}
		}
		if (!flag)
		{
			return null;
		}
		if (apply)
		{
			Legs.Add(leg);
			leg.DefineLegSide(this);
			leg.RefreshLegAnkleToHeelAndFeetAndAxes(BaseTransform);
		}
		return leg;
	}

	public void Setup_TryAutoLegsSetup(Leg scheme, Transform parentOfLegs)
	{
		if (!(parentOfLegs == null))
		{
			for (int i = 0; i < parentOfLegs.childCount; i++)
			{
				Setup_TryAutoLegSetup(scheme, parentOfLegs.GetChild(i));
			}
		}
	}

	public void Legs_AddNewLeg()
	{
		Leg leg = new Leg();
		leg.Owner = this;
		Legs.Add(leg);
	}

	public void Legs_RefreshLegsOwner()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Owner = this;
		}
	}

	public int Leg_GetIndex(Leg leg)
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			if (leg == Legs[i])
			{
				return i;
			}
		}
		return -1;
	}

	public Leg Leg_GetLeg(int index)
	{
		if (index < 0)
		{
			return null;
		}
		if (index >= Legs.Count)
		{
			return null;
		}
		return Legs[index];
	}

	protected virtual void Finder_EnsureLegsCount(int legsCount)
	{
		for (int i = 0; i < legsCount; i++)
		{
			if (Legs.Count <= i)
			{
				Legs_AddNewLeg();
			}
		}
	}

	public virtual void Finder_AutoFindLegsIfHuman(Animator anim)
	{
		if ((bool)anim && anim.isHuman)
		{
			Finder_EnsureLegsCount(2);
			if (Legs[0].BoneStart == null)
			{
				Legs[0].BoneStart = anim.GetBoneTransform(HumanBodyBones.LeftUpperLeg);
				Legs[0].Side = ELegSide.Left;
			}
			if (Legs[0].BoneMid == null)
			{
				Legs[0].BoneMid = anim.GetBoneTransform(HumanBodyBones.LeftLowerLeg);
			}
			if (Legs[0].BoneEnd == null)
			{
				Legs[0].BoneEnd = anim.GetBoneTransform(HumanBodyBones.LeftFoot);
			}
			if (Legs[1].BoneStart == null)
			{
				Legs[1].BoneStart = anim.GetBoneTransform(HumanBodyBones.RightUpperLeg);
				Legs[1].Side = ELegSide.Right;
			}
			if (Legs[1].BoneMid == null)
			{
				Legs[1].BoneMid = anim.GetBoneTransform(HumanBodyBones.RightLowerLeg);
			}
			if (Legs[1].BoneEnd == null)
			{
				Legs[1].BoneEnd = anim.GetBoneTransform(HumanBodyBones.RightFoot);
			}
			if (Legs[0].OppositeLegIndex < 0)
			{
				Legs[1].AssignOppositeLegIndex(0);
			}
			if (Legs[0].Side == ELegSide.Undefined)
			{
				Legs[0].Side = ELegSide.Left;
			}
			if (Legs[1].Side == ELegSide.Undefined)
			{
				Legs[1].Side = ELegSide.Right;
			}
			if (SpineBone == null)
			{
				SpineBone = anim.GetBoneTransform(HumanBodyBones.Spine);
			}
			Finders_RefreshAllLegsAnkleAxes();
			User_RefreshHelperVariablesOnParametersChange();
		}
	}

	public Animator Finding_TryFindMecanim()
	{
		if (!Mecanim)
		{
			Mecanim = FTransformMethods.FindComponentInAllChildren<Animator>(BaseTransform);
			if (!Mecanim)
			{
				Mecanim = BaseTransform.GetComponentInParent<Animator>();
			}
		}
		return Mecanim;
	}

	public virtual void Finder_AutoDefineOppositeLegs()
	{
		List<Vector3> list = new List<Vector3>();
		for (int i = 0; i < Legs.Count; i++)
		{
			if (Legs[i].BoneEnd == null)
			{
				return;
			}
			list.Add(BaseTransform.InverseTransformPoint(Legs[i].BoneEnd.position));
		}
		for (int j = 0; j < Legs.Count; j++)
		{
			if (Legs[j].OppositeLegIndex > -1)
			{
				continue;
			}
			int num = -1;
			float num2 = float.MaxValue;
			for (int k = 0; k < Legs.Count; k++)
			{
				if (j == k || Mathf.Sign(list[j].x) == Mathf.Sign(list[k].x))
				{
					continue;
				}
				float num3 = Mathf.Abs(list[j].z - list[k].z);
				if (Legs[k].Side == ELegSide.Undefined)
				{
					if (list[k].x < 0f)
					{
						Legs[k].Side = ELegSide.Left;
					}
					else
					{
						Legs[k].Side = ELegSide.Right;
					}
				}
				if (num3 < num2)
				{
					num2 = num3;
					num = k;
				}
			}
			if (num != -1)
			{
				Legs[j].AssignOppositeLegIndex(num);
			}
		}
	}

	public virtual void Finding_LegBonesByNamesAndParenting()
	{
		Finding_TryFindMecanim();
		if (Legs == null)
		{
			Legs = new List<Leg>();
		}
		if ((bool)Mecanim && Mecanim.isHuman)
		{
			Finder_AutoFindLegsIfHuman(Mecanim);
		}
		else if (Legs.Count < 2)
		{
			Finder_EnsureLegsCount(2);
		}
	}

	public virtual void Finding_SearchForHips()
	{
		if (!Hips)
		{
			Finding_TryFindMecanim();
			if ((bool)Mecanim && Mecanim.isHuman)
			{
				Hips = Mecanim.GetBoneTransform(HumanBodyBones.Hips);
			}
		}
	}

	public Transform Finders_QuickHipsSearch()
	{
		Transform transform = BaseTransform;
		Animator animator = FTransformMethods.FindComponentInAllChildren<Animator>(transform);
		if ((bool)animator && animator.isHuman)
		{
			Finder_AutoFindLegsIfHuman(animator);
			return animator.GetBoneTransform(HumanBodyBones.Hips);
		}
		Transform transform2 = FTransformMethods.FindChildByNameInDepth("pelv", transform);
		if ((bool)transform2)
		{
			SkinnedMeshRenderer componentInChildren = transform.GetComponentInChildren<SkinnedMeshRenderer>();
			if (!componentInChildren)
			{
				return transform2;
			}
			if (transform2 == componentInChildren.rootBone || componentInChildren.bones.Contains(transform2) || transform2.childCount >= 3)
			{
				return transform2;
			}
		}
		transform2 = FTransformMethods.FindChildByNameInDepth("hips", transform);
		if ((bool)transform2)
		{
			if (transform2.childCount >= 3)
			{
				return transform2;
			}
			if (transform2.parent != null)
			{
				transform2 = transform2.parent;
				if (transform2.childCount >= 3)
				{
					return transform2;
				}
				if (transform2.parent != null)
				{
					transform2 = transform2.parent;
					if (transform2.childCount >= 3)
					{
						return transform2;
					}
				}
			}
		}
		return null;
	}

	private void Finding_UpperLegsWithPelvis()
	{
		if (!Hips)
		{
			return;
		}
		Finder_EnsureLegsCount(2);
		Leg leg = Legs[0];
		Leg leg2 = Legs[1];
		if (Legs[0].Side == ELegSide.Right)
		{
			leg = Legs[1];
			leg2 = Legs[0];
		}
		if (leg == null)
		{
			return;
		}
		if (leg.BoneStart == null)
		{
			Transform transform = null;
			Vector3 vector = BaseTransform.InverseTransformPoint(Hips.position);
			for (int i = 0; i < Hips.childCount; i++)
			{
				if ((bool)transform)
				{
					break;
				}
				Vector3 vector2 = BaseTransform.InverseTransformPoint(Hips.GetChild(i).position);
				if (vector2.x < vector.x && vector2.y < vector.y)
				{
					transform = Hips.GetChild(i);
				}
			}
			leg.BoneStart = transform;
		}
		if (leg2 == null || !(leg2.BoneStart == null))
		{
			return;
		}
		Transform transform2 = null;
		Vector3 vector3 = BaseTransform.InverseTransformPoint(Hips.position);
		for (int j = 0; j < Hips.childCount; j++)
		{
			if ((bool)transform2)
			{
				break;
			}
			Vector3 vector4 = BaseTransform.InverseTransformPoint(Hips.GetChild(j).position);
			if (vector4.x > vector3.x && vector4.y < vector3.y)
			{
				transform2 = Hips.GetChild(j);
			}
		}
		leg2.BoneStart = transform2;
	}

	private Transform Finding_FindUpperLeg(Transform foot)
	{
		Transform result = null;
		if (!Hips)
		{
			Transform transform = null;
			Transform parent = foot.parent;
			if ((bool)parent && (bool)parent.parent)
			{
				parent = parent.parent;
				if ((bool)parent)
				{
					if (parent.childCount > 2)
					{
						transform = parent;
					}
					if (!transform && (bool)parent.parent)
					{
						parent = parent.parent;
						if (parent.childCount > 2)
						{
							transform = parent;
						}
						if (!transform && (bool)parent.parent)
						{
							parent = parent.parent;
							if (parent.childCount > 2)
							{
								transform = parent;
							}
							if (!transform && (bool)parent.parent)
							{
								parent = parent.parent;
								if (parent.childCount > 2)
								{
									transform = parent;
								}
							}
						}
					}
				}
			}
			result = parent;
			if ((bool)transform)
			{
				Hips = transform;
			}
		}
		return result;
	}

	private void Finding_FindLowerLegsWithUpper()
	{
		Finder_EnsureLegsCount(2);
		Leg leg = Legs[0];
		Leg leg2 = Legs[1];
		if (Legs[0].Side == ELegSide.Right)
		{
			leg = Legs[1];
			leg2 = Legs[0];
		}
		if (leg.BoneStart != null)
		{
			if (leg.BoneStart.childCount > 0 && !leg.BoneMid)
			{
				leg.BoneMid = Finders_GetRelevantChildOf(leg.BoneStart);
			}
			if ((bool)leg.BoneMid && leg.BoneMid.childCount > 0 && leg.BoneEnd == null)
			{
				leg.BoneEnd = Finders_GetRelevantChildOf(leg.BoneMid);
			}
		}
		if (leg2.BoneStart != null)
		{
			if (leg2.BoneStart.childCount > 0 && !leg2.BoneMid)
			{
				leg2.BoneMid = Finders_GetRelevantChildOf(leg2.BoneStart);
			}
			if ((bool)leg2.BoneMid && leg2.BoneMid.childCount > 0 && leg2.BoneEnd == null)
			{
				leg2.BoneEnd = Finders_GetRelevantChildOf(leg2.BoneMid);
			}
		}
	}

	public Transform Finders_GetRelevantChildOf(Transform parent)
	{
		Transform transform = null;
		for (int i = 0; i < parent.childCount; i++)
		{
			Transform child = parent.GetChild(i);
			if (transform == null)
			{
				transform = child;
			}
			else if (child.childCount > transform.childCount)
			{
				transform = child;
			}
		}
		return transform;
	}

	protected static bool? Finders_IsRightOrLeft(Transform child, Transform itsRoot)
	{
		Vector3 vector = itsRoot.InverseTransformPoint(child.position);
		if (vector.x < 0f)
		{
			return false;
		}
		if (vector.x > 0f)
		{
			return true;
		}
		return null;
	}

	public void Finders_RefreshAllLegsAnkleAxes()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].RefreshLegAnkleToHeelAndFeetAndAxes(BaseTransform);
		}
	}

	protected virtual void CustomIK_Initialize()
	{
	}

	protected virtual void CustomIK_ApplyIK()
	{
	}

	public void OnDrop(PointerEventData data)
	{
	}

	private void MeasurePerformanceUpdate(bool start)
	{
	}

	private void MeasurePerformancePreLateUpdate(bool start)
	{
	}

	private void MeasurePerformanceMain(bool start)
	{
	}

	protected virtual void Initialize()
	{
		if (LegsInitialized)
		{
			return;
		}
		ReferencePose referencePose = null;
		if (SetupPose != null && SetupPose.IsSet(this))
		{
			referencePose = new ReferencePose();
			StoreSetupPose(referencePose);
			RestoreSetupPose(SetupPose);
		}
		GroundedTime = 0f;
		MovingTime = 0f;
		IsMovingBlend = 0f;
		IsGroundedBlend = 1f;
		RagdolledDisablerBlend = 1f;
		_MainBlendNoRagdolling = 1f;
		DeltaTime = 0.05f;
		usingCustomDesiredMovementDirection = false;
		RagdolledDisablerBlend = 1f;
		RagdolledTime = -100f;
		DoBackCompatibilityChecks();
		Initialize_BaseTransform();
		RefreshMatrices();
		_wasInstantTriggered = true;
		Legs_RefreshLegsOwner();
		User_RefreshHelperVariablesOnParametersChange();
		Controll_DefineHashes();
		Initialize_Stability();
		finalScaleReferenceSqrt = ScaleReference * ScaleReference;
		HipsSetup.Initialize(this, Hips, BaseTransform);
		_LastAppliedHipsFinalPosition = Hips.position;
		HipsHubs_Init();
		if (CheckIfSomeOfTheLegsHasNullBone())
		{
			Debug.LogError("[Legs Animator] One of the legs has unassigned bone! (" + base.name + ")");
			AllowUpdate = false;
			LegsInitialized = false;
			return;
		}
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].InitLegBasics(this, i, (i + 1 < Legs.Count) ? Legs[i + 1] : null);
		}
		IK_Initialize();
		LegsInitialized = true;
		AllowUpdate = true;
		InitializeGetStepInfoReceiver();
		if ((bool)Mecanim)
		{
			AnimatePhysics = Mecanim.updateMode == AnimatorUpdateMode.AnimatePhysics;
		}
		InitializeModules();
		PrepareValues(Time.deltaTime);
		User_UpdateParametersAfterManualChange();
		User_RefreshHelperVariablesOnParametersChange();
		if (referencePose != null)
		{
			RestoreSetupPose(referencePose);
		}
	}

	public void InitializeGetStepInfoReceiver()
	{
		if (StepInfoReceiver != null)
		{
			_StepReceiver = StepInfoReceiver.GetComponent<ILegStepReceiver>();
			_RaiseReceiver = StepInfoReceiver.GetComponent<ILegRaiseReceiver>();
		}
	}

	public void Initialize_BaseTransform()
	{
		if (baseTransform == null)
		{
			baseTransform = base.transform;
		}
		InitialBaseScale = baseTransform.lossyScale;
		if (InitialBaseScale.y == 0f)
		{
			InitialBaseScale = Vector3.one;
		}
		User_RefreshHelperVariablesOnParametersChange();
		MotionInfluence_Init();
	}

	public void Initialize_BaseTransform(Transform newTransform)
	{
		baseTransform = newTransform;
		Initialize_BaseTransform();
	}

	public bool IsSetupValid()
	{
		if (Legs.Count == 0)
		{
			return false;
		}
		if (Hips == null)
		{
			return false;
		}
		bool result = true;
		for (int i = 0; i < Legs.Count; i++)
		{
			if (Legs[i].BoneStart == null)
			{
				result = false;
				break;
			}
			if (Legs[i].BoneEnd == null)
			{
				result = false;
				break;
			}
		}
		return result;
	}

	protected virtual void OnLegsReactivate()
	{
		RefreshMatrices();
		MotionInfluence.Reset();
		Modules_OnReInitialize();
		HipsSetup.HipsMuscle.OverrideProceduralPosition(Vector3.zero);
		HipsSetup.HipsRotMuscle.OverrideProceduralRotation(Quaternion.identity);
		_LastAppliedHipsStabilityOffset = Vector3.zero;
		_LastAppliedHipsFinalPosition = Hips.position;
		_Hips_StabilityLocalOffset = Vector3.zero;
		_Hips_FinalStabilityOffset = Vector3.zero;
		HipsSetup.Reset();
		_glueModeExecuted = EGlueMode.Moving;
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Reset();
		}
	}

	public void StoreSetupPose()
	{
		StoreSetupPose(setupPose);
	}

	public void StoreSetupPose(ReferencePose referencePose)
	{
		referencePose.TweakListsFor(this);
		referencePose.MainHipsPose.SavePose(Hips.transform, this);
		for (int i = 0; i < referencePose.HipsPoses.Count; i++)
		{
			referencePose.HipsPoses[i].SavePose(ExtraHipsHubs[i], this);
		}
		for (int j = 0; j < referencePose.LegPoses.Count; j++)
		{
			referencePose.LegPoses[j].SaveLegPose(Legs[j], this);
		}
	}

	public void RestoreSetupPose()
	{
		RestoreSetupPose(setupPose);
	}

	public void RestoreSetupPose(ReferencePose referencePose)
	{
		referencePose.MainHipsPose.RestorePose(this);
		for (int i = 0; i < referencePose.HipsPoses.Count; i++)
		{
			referencePose.HipsPoses[i].RestorePose(this);
		}
		for (int j = 0; j < referencePose.LegPoses.Count; j++)
		{
			referencePose.LegPoses[j].RestoreLegPose(this);
		}
	}

	public void ApplyCustomReferencePose(ReferencePose pose)
	{
		if (pose != null && pose.IsSet(this))
		{
			ReferencePose referencePose = new ReferencePose();
			StoreSetupPose(referencePose);
			RestoreSetupPose(pose);
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].IKProcessor.Init(BaseTransform);
			}
			RestoreSetupPose(referencePose);
		}
	}

	public void User_SetIsGrounded(bool grounded)
	{
		if (grounded != _grounded)
		{
			if (grounded)
			{
				Control_OnLand();
			}
			else
			{
				Control_OnLooseGround();
			}
		}
		_grounded = grounded;
	}

	public void User_SetIsMoving(bool moving)
	{
		if (moving != _moving)
		{
			if (moving)
			{
				Control_OnStartMoving();
			}
			else
			{
				Control_OnStopMoving();
			}
		}
		_moving = moving;
	}

	public void User_SetIsSliding(bool moving)
	{
		_sliding = moving;
	}

	public void User_FadeLeg(int legIndex, float blend, float duration)
	{
		if (FLogicMethods.ContainsIndex(Legs, legIndex, falseIfNull: true))
		{
			StartCoroutine(IEFadeLegTo(Legs[legIndex], 0f, duration));
		}
	}

	public void User_FadeToDisabled(float duration)
	{
		StopAllCoroutines();
		if (duration <= 0f)
		{
			LegsAnimatorBlend = 0f;
			base.enabled = false;
		}
		else
		{
			_wasFadingOn = false;
			StartCoroutine(IEFadeLegsAnimatorTo(0f, duration));
		}
	}

	public void User_FadeEnabled(float duration)
	{
		if (!base.enabled)
		{
			base.enabled = true;
		}
		StopAllCoroutines();
		if (duration <= 0f)
		{
			LegsAnimatorBlend = 1f;
		}
		else
		{
			_wasFadingOn = true;
			StartCoroutine(IEFadeLegsAnimatorTo(1f, duration));
		}
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].LegBlendWeight = 1f;
		}
	}

	public void User_MoveLegTo(int legIndex, Transform transform)
	{
		if (FLogicMethods.ContainsIndex(Legs, legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_OverrideRaycastHit(transform);
		}
	}

	public void User_MoveLegTo(int legIndex, Vector3 position, Vector3 normal)
	{
		RaycastHit hit = default(RaycastHit);
		hit.point = position;
		hit.normal = normal;
		User_MoveLegTo(legIndex, hit);
	}

	public void User_MoveLegTo(int legIndex, RaycastHit hit)
	{
		if (FLogicMethods.ContainsIndex(Legs, legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_OverrideRaycastHit(hit);
		}
	}

	public void User_MoveLegTo_Restore(int legIndex)
	{
		if (FLogicMethods.ContainsIndex(Legs, legIndex, falseIfNull: true))
		{
			Legs[legIndex].User_RestoreRaycasting();
		}
	}

	protected IEnumerator IEFadeLegsAnimatorTo(float blend, float duration)
	{
		float startBlend = LegsAnimatorBlend;
		float elapsed = 0f;
		while (elapsed < duration)
		{
			elapsed += DeltaTime;
			LegsAnimatorBlend = Mathf.Lerp(startBlend, blend, elapsed / duration);
			yield return null;
			if (blend == 0f)
			{
				if (_wasFadingOn == true)
				{
					_wasFadingOn = null;
					yield break;
				}
			}
			else if (blend == 1f && _wasFadingOn == false)
			{
				_wasFadingOn = null;
				yield break;
			}
		}
		LegsAnimatorBlend = blend;
		if (blend <= 0f)
		{
			base.enabled = false;
		}
	}

	protected IEnumerator IEFadeLegTo(Leg leg, float blend, float duration)
	{
		float startBlend = leg.LegBlendWeight;
		float elapsed = 0f;
		while (elapsed < duration)
		{
			elapsed += DeltaTime;
			leg.LegBlendWeight = Mathf.Lerp(startBlend, blend, elapsed / duration);
			yield return null;
		}
		leg.LegBlendWeight = blend;
	}

	public void User_Teleport(Vector3 toPosition)
	{
		base.enabled = false;
		base.transform.position = toPosition;
		base.enabled = true;
		CheckActivation();
		PrepareValues(1f);
		UpdateStack(1f);
	}

	public void User_HipsPushDown(float power)
	{
		User_AddImpulse(new ImpulseExecutor(Vector3.down * power, 0.3f + power * 0.3f));
	}

	public void User_HipsPushDownLong(float power)
	{
		User_AddImpulse(new ImpulseExecutor(Vector3.down * power, 0.5f + power * 0.5f));
	}

	protected void OnDisable()
	{
		legsWasDisabled = true;
	}

	public void User_OverwriteCastMatrix(Matrix4x4 mx)
	{
		Up = mx.MultiplyVector(Vector3.up).normalized;
		CastMx = mx;
		InvCastMx = mx.inverse;
	}

	private void RefreshMatrices()
	{
		if (LocalWorldUp)
		{
			Up = BaseTransform.up;
			CastMx = baseTransform.localToWorldMatrix;
			InvCastMx = baseTransform.worldToLocalMatrix;
		}
		else
		{
			Quaternion q = Quaternion.FromToRotation(Vector3.ProjectOnPlane(baseTransform.forward, Up), Vector3.forward);
			CastMx = Matrix4x4.TRS(BaseTransform.position, q, BaseTransform.lossyScale);
			InvCastMx = CastMx.inverse;
		}
	}

	public bool Util_OnLeftSide(Transform t)
	{
		return BaseTransform.InverseTransformPoint(t.position).x < 0f;
	}

	public float Util_SideMul(Transform t)
	{
		if (!Util_OnLeftSide(t))
		{
			return 1f;
		}
		return -1f;
	}

	public float HipsToGroundDistance()
	{
		if (Hips == null)
		{
			return 0.1f;
		}
		return Vector3.Distance(BaseTransform.position, Hips.position);
	}

	public float HipsToGroundDistanceLocal()
	{
		if (Hips == null)
		{
			return 0.1f;
		}
		return BaseTransform.InverseTransformPoint(Hips.position).y;
	}

	private void UpdateGroundedBlend()
	{
		if (IsGrounded)
		{
			if (UngroundFadeSpeed >= 1f)
			{
				IsGroundedBlend = 1f;
			}
			else
			{
				IsGroundedBlend = Mathf.MoveTowards(IsGroundedBlend, 1f, DeltaTime * Mathf.LerpUnclamped(20f, 60f, UngroundFadeSpeed));
			}
			return;
		}
		if (UngroundFadeSpeed >= 1f)
		{
			IsGroundedBlend = 0f;
			return;
		}
		IsGroundedBlend = Mathf.Lerp(IsGroundedBlend, -0.01f, DeltaTime * Mathf.LerpUnclamped(6f, 20f, UngroundFadeSpeed));
		if (IsGroundedBlend < 0f)
		{
			IsGroundedBlend = 0f;
		}
	}

	private void UpdateMovingBlend()
	{
		if (IsMoving)
		{
			if (IsMovingFadeSpeed >= 1f)
			{
				IsMovingBlend = 1f;
			}
			else
			{
				IsMovingBlend = Mathf.MoveTowards(IsMovingBlend, 1f, DeltaTime * Mathf.LerpUnclamped(5f, 60f, IsMovingFadeSpeed));
			}
		}
		else if (IsMovingFadeSpeed >= 1f)
		{
			IsMovingBlend = 0f;
		}
		else
		{
			IsMovingBlend = Mathf.MoveTowards(IsMovingBlend, 0f, DeltaTime * Mathf.LerpUnclamped(5f, 60f, IsMovingFadeSpeed));
		}
	}

	private void UpdateSlidingBlend()
	{
		if (IsSliding)
		{
			NotSlidingBlend = Mathf.MoveTowards(NotSlidingBlend, 0f, DeltaTime * 6f);
		}
		else
		{
			NotSlidingBlend = Mathf.MoveTowards(NotSlidingBlend, 1f, DeltaTime * 6f);
		}
	}

	public Vector3 ToRootLocalSpaceVec(Vector3 vec)
	{
		return InvCastMx.MultiplyVector(vec);
	}

	internal float User_GetLocalRotationAngle(Vector3 worldMoveDirection, Vector3 currentWorldLookForwardDirection)
	{
		Vector3 from = ToRootLocalSpaceVec(worldMoveDirection);
		from.y = 0f;
		Vector3 to = ToRootLocalSpaceVec(currentWorldLookForwardDirection);
		to.y = 0f;
		from.Normalize();
		to.Normalize();
		return 0f - Vector3.SignedAngle(from, to, Vector3.up);
	}

	public Vector3 ToRootLocalSpace(Vector3 worldPos)
	{
		return InvCastMx.MultiplyPoint3x4(worldPos);
	}

	public Vector3 RootToWorldSpaceVec(Vector3 vec)
	{
		return CastMx.MultiplyVector(vec);
	}

	public void User_AddImpulse(PelvisImpulseSettings debugPushHipsImpulse, float multiplyPower = 1f, float multiplyDuration = 1f)
	{
		User_AddImpulse(new ImpulseExecutor(debugPushHipsImpulse, multiplyPower, multiplyDuration));
	}

	public void User_AddImpulse(ImpulseExecutor newImpulse)
	{
		if (!(newImpulse.ImpulseDuration <= 0f))
		{
			Impulses.Add(newImpulse);
		}
	}

	public Vector3 RootToWorldSpace(Vector3 localPos)
	{
		return CastMx.MultiplyPoint3x4(localPos);
	}

	public void User_OverwriteIKCoords(int legID, Vector3? position, Quaternion? rotation = null)
	{
		if (FLogicMethods.ContainsIndex(Legs, legID, falseIfNull: true))
		{
			Legs[legID].OverrideTargetIKPosition(position);
			Legs[legID].OverrideTargetIKRotation(rotation);
		}
	}

	public void DoBackCompatibilityChecks()
	{
		if (ZeroStepsOnNoRaycast)
		{
			ZeroStepsOnNoRaycast = false;
			NoRaycastGroundBehaviour = ENoRaycastBehviour.ZeroFloorSteps;
		}
	}

	public bool CheckIfSomeOfTheLegsHasNullBone()
	{
		bool result = false;
		for (int i = 0; i < Legs.Count; i++)
		{
			Leg leg = Legs[i];
			if (leg.BoneStart == null || leg.BoneMid == null || leg.BoneEnd == null)
			{
				result = true;
				break;
			}
		}
		return result;
	}

	private void IK_Initialize()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].IK_Initialize();
		}
		if (UseCustomIK)
		{
			CustomIK_Initialize();
		}
	}

	private void IK_TriggerGlueReinitialize()
	{
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].Glue_Reset(initializing: true);
		}
	}

	private void IK_TriggerGlueInstantTransition()
	{
		_wasInstantTriggered = true;
		for (int i = 0; i < Legs.Count; i++)
		{
			Legs[i].G_InstantReglue = true;
		}
	}

	public void IK_TriggerReglue(bool onlyIfFar = true)
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.G_RequestRepose = ((!onlyIfFar) ? Leg.GlueReposeRequest.Repose : Leg.GlueReposeRequest.ReposeIfFar);
		}
	}

	public void User_RefreshHelperVariablesOnParametersChange()
	{
		if (!IsSetupValid())
		{
			return;
		}
		if (ScaleReferenceMode == ELegsScaleReference.PelvisToGroundDistance)
		{
			finalScaleReference = HipsToGroundDistanceLocal();
		}
		else if (ScaleReferenceMode == ELegsScaleReference.FirstLegLength)
		{
			finalScaleReference = Legs[0].LegLimbLength() / Mathf.Max(0.001f, BaseTransform.lossyScale.x);
		}
		else if (ScaleReferenceMode == ELegsScaleReference.Custom)
		{
			if (customScaleReferenceValue < 0f)
			{
				customScaleReferenceValue = 0.2f;
			}
			finalScaleReference = customScaleReferenceValue;
		}
		else if (ScaleReferenceMode == ELegsScaleReference.PelvisLegAverage)
		{
			finalScaleReference = HipsToGroundDistanceLocal();
			finalScaleReference = Mathf.LerpUnclamped(finalScaleReference, Legs[0].LegLimbLength() / Mathf.Max(0.001f, BaseTransform.lossyScale.x), 0.5f);
		}
	}

	protected void Legs_PreCalibrate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.PreCalibrate();
		}
	}

	private void Legs_CheckAnimatorPose()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.CheckAnimatorPose();
		}
	}

	private void Legs_BeginLateUpdate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.BeginLateUpdate();
		}
	}

	private void Legs_LateUpdate()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.LateUpdate();
		}
	}

	private void Legs_LateUpdate_Apply()
	{
		for (Leg leg = Legs[0]; leg != null; leg = leg.NextLeg)
		{
			leg.LateUpdate_Apply();
		}
		if (UseCustomIK)
		{
			CustomIK_ApplyIK();
		}
	}

	private void Legs_MidLateUpdateAndRaycasting()
	{
		if (UseRaycastsForIsGrounded)
		{
			bool flag = false;
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].PreLateUpdate();
				if (!flag)
				{
					if (Legs[i].A_PreWasAligning)
					{
						flag = true;
					}
					else if (Legs[i].RaycastHitted && Legs[i].groundHitRootSpacePos.y > (0f - ScaleReference) * 0.05f)
					{
						flag = true;
					}
				}
			}
			if (!flag)
			{
				RaycastHit legGroundHit = Legs[0].legGroundHit;
				if (Legs[0].DoRaycasting(_LastAppliedHipsFinalPosition, _LastAppliedHipsFinalPosition - Up * (HipsSetup.LastHipsHeightDiff * BaseTransform.lossyScale.y * 1.01f + ScaleReference * 0.075f)))
				{
					flag = true;
				}
				Legs[0].legGroundHit = legGroundHit;
			}
			if (flag)
			{
				if (_calc_rayGrounding < 0f)
				{
					_calc_rayGrounding = 0f;
				}
				_calc_rayGrounding += DeltaTime;
				if (_calc_rayGrounding < 0.05f)
				{
					flag = _grounded;
				}
			}
			else
			{
				if (_calc_rayGrounding > 0f)
				{
					_calc_rayGrounding = 0f;
				}
				_calc_rayGrounding -= DeltaTime;
				if (_calc_rayGrounding > 0.005f)
				{
					flag = _grounded;
				}
			}
			if (flag == _grounded)
			{
				return;
			}
			if (flag)
			{
				if (!(Time.time - _calc_lastGrounded > 0.05f))
				{
					return;
				}
				_calc_lastGrounded = Time.time;
			}
			User_SetIsGrounded(flag);
		}
		else
		{
			for (int j = 0; j < Legs.Count; j++)
			{
				Legs[j].PreLateUpdate();
			}
		}
	}

	public float GetCurrentCullingBlend()
	{
		return cullingBlend;
	}

	private void Start()
	{
		_started = true;
		AllowUpdate = false;
		if (!DelayedInitialization)
		{
			Initialize();
		}
		StartCoroutine(IEStart());
	}

	private IEnumerator IEStart()
	{
		yield return null;
		yield return null;
		if (Rigidbody == null)
		{
			Rigidbody = BaseTransform.GetComponent<Rigidbody>();
			if (!Rigidbody)
			{
				Rigidbody = BaseTransform.GetComponentInChildren<Rigidbody>();
			}
			if (!Rigidbody)
			{
				Rigidbody = BaseTransform.GetComponentInParent<Rigidbody>();
			}
		}
		Initialize();
	}

	private void OnEnable()
	{
		if (_started)
		{
			if (!LegsInitialized)
			{
				Initialize();
			}
			else
			{
				_wasInstantTriggered = false;
			}
		}
	}

	private void ReInitialize()
	{
		LegsInitialized = false;
		DisposeModules();
		Start();
	}

	private void CheckActivation()
	{
		if (FadeOffAtDistance < 0.01f)
		{
			cullingBlend = 1f;
		}
		else
		{
			bool flag = true;
			if (FadeOff_DistanceToCamera == null && Camera.main != null)
			{
				FadeOff_DistanceToCamera = Camera.main.transform;
			}
			if (FadeOff_DistanceToCamera != null)
			{
				FadeOff_lastCameraDistance = Vector3.Distance(BaseTransform.position, FadeOff_DistanceToCamera.position);
				if (FadeOff_lastCameraDistance > FadeOffAtDistance)
				{
					flag = false;
				}
			}
			if (flag)
			{
				if (cullingBlend < 1f)
				{
					cullingBlend = Mathf.Min(1f, Mathf.Lerp(cullingBlend, 1.05f, Time.unscaledDeltaTime * 6f));
					cullingBlend = Mathf.MoveTowards(cullingBlend, 1f, Time.unscaledDeltaTime);
				}
			}
			else
			{
				cullingBlend = Mathf.MoveTowards(cullingBlend, 0f, Time.unscaledDeltaTime * 1.5f);
			}
		}
		if (DisableIfInvisible != null)
		{
			bool flag2 = !DisableIfInvisible.isVisible;
			for (int i = 0; i < DisableIfInvisibleExtraRenderers.Count; i++)
			{
				if (DisableIfInvisibleExtraRenderers[i].isVisible)
				{
					flag2 = false;
					break;
				}
			}
			if (flag2)
			{
				legsWasDisabled = true;
				return;
			}
		}
		if (legsWasDisabled && _MainBlendNoRagdolling > 0f && LegsInitialized)
		{
			OnLegsReactivate();
			legsWasDisabled = false;
		}
	}

	private void Update()
	{
		if (LegsInitialized)
		{
			CheckActivation();
			float delta = (UnscaledDeltaTime ? Time.unscaledDeltaTime : Time.deltaTime);
			PrepareValues(delta);
			if (AllowUpdate && !AnimatePhysics && !legsWasDisabled)
			{
				UpdateStack(delta);
			}
		}
	}

	protected virtual void ExtraFixedUpdate()
	{
		if (UseRigidbodyVelocityForIsMoving && (bool)Rigidbody)
		{
			Vector3 vector = ToRootLocalSpaceVec(Rigidbody.velocity);
			vector.y = 0f;
			bool moving = vector.magnitude > ScaleReferenceNoScale * 0.02f;
			User_SetIsMoving(moving);
		}
	}

	private void LateUpdate()
	{
		if (!AllowUpdate || legsWasDisabled)
		{
			return;
		}
		if (AnimatePhysics)
		{
			if (!_fixedUpdated)
			{
				return;
			}
			_fixedUpdated = false;
		}
		PreLateUpdateStack();
		LateUpdateStack();
	}

	protected virtual void PrepareValues(float delta)
	{
		_MainBlendNoRagdolling = LegsAnimatorBlend * cullingBlend * protectedBlend;
		_MainBlend = _MainBlendNoRagdolling * RagdolledDisablerBlend;
		_MainBlendPlusGrounded = _MainBlend * IsGroundedBlend;
		if (Mecanim != null)
		{
			AnimatePhysics = Mecanim.updateMode == AnimatorUpdateMode.AnimatePhysics;
		}
		if (_lastMainBlend != _MainBlend)
		{
			_lastMainBlendChanged = true;
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].IK_UpdateParamsBase();
			}
		}
		else
		{
			_lastMainBlendChanged = false;
		}
		_lastMainBlend = _MainBlend;
	}

	protected virtual void UpdateStack(float delta)
	{
		MeasurePerformanceUpdate(start: true);
		DeltaTime = delta;
		Scale = baseTransform.lossyScale.y;
		if (_MainBlend > 0f)
		{
			if (!_wasInstantTriggered)
			{
				IK_TriggerGlueInstantTransition();
			}
			RefreshTargetMovementDirectionHelper();
			Controll_Update();
			UpdateGroundedBlend();
			UpdateMovingBlend();
			UpdateSlidingBlend();
			Hips_PreCalibrate();
			Legs_PreCalibrate();
			ExtraControls_Update();
			Modules_Update();
		}
		else
		{
			Controll_Update();
			Legs_PreCalibrate();
			legsWasDisabled = true;
		}
		MeasurePerformanceUpdate(start: false);
	}

	protected virtual void PreLateUpdateStack()
	{
		MeasurePerformancePreLateUpdate(start: true);
		RefreshMatrices();
		Legs_CheckAnimatorPose();
		Modules_AfterAnimatorCaptureUpdate();
		BaseObject_MotionUpdate();
		Hips_PreLateUpdate();
		Hips_LateUpdate();
		Legs_BeginLateUpdate();
		MeasurePerformancePreLateUpdate(start: false);
	}

	protected virtual void LateUpdateStack()
	{
		MeasurePerformanceMain(start: true);
		if (_MainBlend > 0.001f)
		{
			Legs_MidLateUpdateAndRaycasting();
		}
		Modules_PreLateUpdate();
		Legs_LateUpdate();
		Hips_PostLateUpdate();
		Modules_LateUpdatePreApply();
		Legs_LateUpdate_Apply();
		Modules_PostLateUpdate();
		MeasurePerformanceMain(start: false);
	}

	public virtual void User_UpdateParametersAfterManualChange()
	{
		if (AllowUpdate)
		{
			Modules_UpdateAfterManualChanges();
			for (int i = 0; i < Legs.Count; i++)
			{
				Legs[i].Leg_UpdateParams();
			}
			if (Event_OnStep.GetPersistentEventCount() > 0 || (bool)StepInfoReceiver)
			{
				UseEvents = true;
			}
			else
			{
				UseEvents = false;
			}
		}
	}

	public void OnAddedReset()
	{
		MotionInfluence = new MotionInfluenceProcessor();
		MotionInfluence.AxisMotionInfluence.x = 0f;
		BaseLegAnimating = new LegStepAnimatingParameters();
		LegAnimatingSettings.RefreshDefaultCurves();
		CustomModules = new List<LegsAnimatorCustomModuleHelper>();
	}
}
