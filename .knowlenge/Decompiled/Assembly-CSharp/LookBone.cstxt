using System;
using UnityEngine;

[Serializable]
public class LookBone
{
	public Transform Transform;

	public Quaternion animatedStaticRotation;

	public Quaternion targetStaticRotation;

	public Quaternion localStaticRotation;

	public Quaternion animatedTargetRotation;

	public Quaternion targetRotation;

	public Vector3 correctionOffset;

	public Quaternion finalRotation;

	public Quaternion lastKeyframeRotation;

	public Quaternion lastFinalLocalRotation;

	public Vector3 forward;

	public Vector3 right;

	public Vector3 up;

	public Vector3 initLocalPos = Vector3.zero;

	public Quaternion initLocalRot = Quaternion.identity;

	public Vector3 targetDelayPosition;

	public Vector3 animatedDelayPosition;

	public float lookWeight = 1f;

	public float lookWeightB = 1f;

	public float motionWeight = 1f;

	public Quaternion correctionOffsetQ => Quaternion.Euler(correctionOffset);

	public LookBone(Transform t)
	{
		Transform = t;
		correctionOffset = Vector3.zero;
		if (t != null)
		{
			initLocalPos = t.localPosition;
			initLocalRot = t.localRotation;
		}
	}

	public void RefreshBoneDirections(Transform baseTransform)
	{
		if (!(Transform == null))
		{
			forward = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.forward), Vector3.forward) * Vector3.forward;
			up = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.up), Vector3.up) * Vector3.up;
			right = Quaternion.FromToRotation(Transform.InverseTransformDirection(baseTransform.right), Vector3.right) * Vector3.right;
		}
	}

	public void RefreshStaticRotation(bool hard = true)
	{
		targetStaticRotation = Transform.rotation;
		if (initLocalPos == Vector3.zero)
		{
			initLocalPos = Transform.localPosition;
		}
		if (hard)
		{
			animatedStaticRotation = targetStaticRotation;
		}
		localStaticRotation = Transform.localRotation;
	}

	internal void CalculateMotion(Quaternion targetLook, float overallWeightMultiplier, float delta, float mainWeight)
	{
		targetRotation = GetTargetRot(targetLook, motionWeight * overallWeightMultiplier);
		if (delta < 1f)
		{
			animatedTargetRotation = Quaternion.LerpUnclamped(animatedTargetRotation, targetRotation, delta);
		}
		else
		{
			animatedTargetRotation = targetRotation;
		}
		finalRotation = Quaternion.LerpUnclamped(Transform.rotation, animatedTargetRotation * Transform.rotation, mainWeight);
	}

	internal Quaternion GetTargetRot(Quaternion targetLook, float weight)
	{
		return Quaternion.LerpUnclamped(Quaternion.identity, targetLook, weight);
	}
}
