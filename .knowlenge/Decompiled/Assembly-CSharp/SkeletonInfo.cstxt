using System.Collections.Generic;
using UnityEngine;

public class SkeletonInfo
{
	public Transform AnimatorTransform;

	public float LowestVsHighestLen;

	public float MostLeftVsMostRightLen;

	public float MostForwVsMostBackLen;

	public float AverageLen;

	public Transform ProbablyRootBone;

	public Transform ProbablyHips;

	public Transform ProbablyChest;

	public Transform ProbablyHead;

	public List<Transform> TrReachingGround = new List<Transform>();

	public List<Transform> TrReachingSides = new List<Transform>();

	public List<Transform> TrEnds = new List<Transform>();

	public List<Transform> ProbablySpineChain = new List<Transform>();

	public List<Transform> ProbablySpineChainShort = new List<Transform>();

	public List<List<Transform>> ProbablyRightArms = new List<List<Transform>>();

	public List<List<Transform>> ProbablyLeftArms = new List<List<Transform>>();

	public List<List<Transform>> ProbablyLeftLegs = new List<List<Transform>>();

	public List<Transform> ProbablyLeftLegRoot = new List<Transform>();

	public List<List<Transform>> ProbablyRightLegs = new List<List<Transform>>();

	public List<Transform> ProbablyRightLegRoot = new List<Transform>();

	public Vector3 LocalSpaceHighest = Vector3.zero;

	public Vector3 LocalSpaceMostRight = Vector3.zero;

	public Vector3 LocalSpaceMostForward = Vector3.zero;

	public Vector3 LocalSpaceMostBack = Vector3.zero;

	public Vector3 LocalSpaceMostLeft = Vector3.zero;

	public Vector3 LocalSpaceLowest = Vector3.zero;

	public EWhatIsIt WhatIsIt;

	public int SpineChainLength => ProbablySpineChain.Count;

	public int LeftArms => ProbablyLeftArms.Count;

	public int LeftLegs => ProbablyLeftLegs.Count;

	public int RightArms => ProbablyRightArms.Count;

	public int RightLegs => ProbablyRightLegs.Count;

	public int Legs => RightLegs + LeftLegs;

	public int Arms => LeftArms + RightArms;

	public SkeletonInfo(Transform t, List<Transform> checkOnly = null, Transform pelvisHelp = null)
	{
		AnimatorTransform = t;
		Transform[] array;
		if (checkOnly != null)
		{
			array = new Transform[checkOnly.Count];
			for (int i = 0; i < checkOnly.Count; i++)
			{
				array[i] = checkOnly[i];
			}
		}
		else
		{
			array = AnimatorTransform.GetComponentsInChildren<Transform>(includeInactive: true);
		}
		if (array.Length != 0)
		{
			LocalSpaceLowest = (LocalSpaceMostLeft = (LocalSpaceMostBack = (LocalSpaceMostForward = (LocalSpaceMostRight = (LocalSpaceHighest = AnimatorTransform.InverseTransformPoint(array[0].position))))));
		}
		List<Transform> list = new List<Transform>();
		foreach (Transform transform in array)
		{
			if (!(transform.GetComponentInChildren<SkinnedMeshRenderer>() != null))
			{
				list.Add(transform);
			}
		}
		for (int k = 0; k < list.Count; k++)
		{
			Transform transform2 = list[k];
			if (!transform2.GetComponent<SkinnedMeshRenderer>())
			{
				Vector3 vector = AnimatorTransform.InverseTransformPoint(transform2.position);
				if (vector.x > LocalSpaceMostRight.x)
				{
					LocalSpaceMostRight = vector;
				}
				else if (vector.x < LocalSpaceMostLeft.x)
				{
					LocalSpaceMostLeft = vector;
				}
				if (vector.z > LocalSpaceMostForward.z)
				{
					LocalSpaceMostForward = vector;
				}
				else if (vector.z < LocalSpaceMostBack.z)
				{
					LocalSpaceMostBack = vector;
				}
				if (vector.y > LocalSpaceHighest.y)
				{
					LocalSpaceHighest = vector;
				}
				else if (vector.y < LocalSpaceLowest.y)
				{
					LocalSpaceLowest = vector;
				}
			}
		}
		LowestVsHighestLen = Mathf.Abs(LocalSpaceLowest.y - LocalSpaceHighest.y);
		MostLeftVsMostRightLen = Mathf.Abs(LocalSpaceMostLeft.x - LocalSpaceMostRight.x);
		MostForwVsMostBackLen = Mathf.Abs(LocalSpaceMostForward.z - LocalSpaceMostBack.z);
		AverageLen = (LowestVsHighestLen + MostLeftVsMostRightLen + MostForwVsMostBackLen) / 3f;
		_ = LowestVsHighestLen;
		for (int l = 0; l < list.Count; l++)
		{
			Transform transform3 = list[l];
			if (NameContains(transform3.name, ShouldersNames))
			{
				Transform bottomMostChildTransform = GetBottomMostChildTransform(transform3);
				if (NotContainedYetByLimbs(bottomMostChildTransform))
				{
					TrReachingSides.Add(bottomMostChildTransform);
				}
			}
			else if (NameContains(transform3.name, ElbowNames))
			{
				Transform bottomMostChildTransform2 = GetBottomMostChildTransform(transform3);
				if (NotContainedYetByLimbs(bottomMostChildTransform2))
				{
					TrReachingSides.Add(bottomMostChildTransform2);
				}
			}
		}
		for (int m = 0; m < list.Count; m++)
		{
			Transform transform4 = list[m];
			if (NameContains(transform4.name, UpperLegNames))
			{
				Transform bottomMostChildTransform3 = GetBottomMostChildTransform(transform4);
				if (NotContainedYetByLimbs(bottomMostChildTransform3))
				{
					TrReachingGround.Add(bottomMostChildTransform3);
				}
			}
			else if (NameContains(transform4.name, KneeNames))
			{
				Transform bottomMostChildTransform4 = GetBottomMostChildTransform(transform4);
				if (NotContainedYetByLimbs(bottomMostChildTransform4))
				{
					TrReachingGround.Add(bottomMostChildTransform4);
				}
			}
		}
		bool flag = false;
		for (int n = 0; n < list.Count; n++)
		{
			Transform transform5 = list[n];
			if (NameContains(transform5.name, PelvisNames))
			{
				flag = true;
				ProbablyHips = transform5;
				break;
			}
		}
		bool flag2 = false;
		for (int num = 0; num < list.Count; num++)
		{
			Transform transform6 = list[num];
			if (NameContains(transform6.name, ChestNames))
			{
				flag2 = true;
				ProbablyChest = transform6;
				break;
			}
		}
		bool flag3 = false;
		for (int num2 = 0; num2 < list.Count; num2++)
		{
			Transform transform7 = list[num2];
			if (NameContains(transform7.name, HeadNames))
			{
				flag3 = true;
				ProbablyHead = transform7;
				break;
			}
		}
		if (ProbablyHead != null && ProbablyHips != null && !IsChildOf(ProbablyHead, ProbablyHips))
		{
			ProbablyHead = null;
		}
		for (int num3 = 0; num3 < list.Count; num3++)
		{
			Transform transform8 = list[num3];
			if (NameContains(transform8.name, RootNames))
			{
				ProbablyRootBone = transform8;
				break;
			}
		}
		if (list.Count > 2)
		{
			for (int num4 = 1; num4 < list.Count; num4++)
			{
				Transform transform9 = list[num4];
				if (transform9.childCount != 0)
				{
					continue;
				}
				TrEnds.Add(transform9);
				Vector3 vector2 = Loc(transform9);
				if (vector2.y < LocalSpaceLowest.y + LowestVsHighestLen * 0.1f)
				{
					if (NotContainedYetByLimbs(transform9))
					{
						TrReachingGround.Add(transform9);
					}
				}
				else if (vector2.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.2f && (vector2.x < MostLeftVsMostRightLen * -0.1f || vector2.x > MostLeftVsMostRightLen * 0.1f) && NotContainedYetByLimbs(transform9))
				{
					TrReachingSides.Add(transform9);
				}
			}
		}
		if (!flag2)
		{
			List<Transform> list2 = new List<Transform>();
			for (int num5 = 0; num5 < TrReachingSides.Count; num5++)
			{
				if ((bool)list[num5].GetComponent<SkinnedMeshRenderer>())
				{
					continue;
				}
				Transform parent = TrReachingSides[num5].parent;
				while (parent != null)
				{
					if (parent.childCount > 2)
					{
						Vector3 vector3 = Loc(parent);
						if (vector3.x > (0f - MostLeftVsMostRightLen) * 0.03f && vector3.x < MostLeftVsMostRightLen * 0.03f)
						{
							list2.Add(parent);
							break;
						}
					}
					parent = parent.parent;
				}
			}
			if (list2.Count == 1)
			{
				ProbablyChest = list2[0];
			}
			else if (list2.Count > 1 && list2[0] == list2[1])
			{
				ProbablyChest = list2[0];
			}
		}
		if (!flag)
		{
			List<Transform> list3 = new List<Transform>();
			for (int num6 = 0; num6 < TrReachingGround.Count; num6++)
			{
				Transform parent2 = TrReachingGround[num6].parent;
				while (parent2 != null)
				{
					if (parent2.childCount > 2)
					{
						Vector3 vector4 = Loc(parent2);
						if (vector4.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.04f && vector4.x > (0f - MostLeftVsMostRightLen) * 0.02f && vector4.x < MostLeftVsMostRightLen * 0.02f)
						{
							list3.Add(parent2);
							break;
						}
					}
					parent2 = parent2.parent;
				}
			}
			if (list3.Count == 1)
			{
				ProbablyChest = list3[0];
			}
			else if (list3.Count > 1 && list3[0] == list3[1])
			{
				ProbablyHips = list3[0];
			}
		}
		if (ProbablyHips == null)
		{
			ProbablyHips = pelvisHelp;
		}
		if ((ProbablyChest == null || ProbablyChest == ProbablyHips || (ProbablyHips != null && !IsChildOf(ProbablyChest, ProbablyHips))) && (bool)ProbablyHips && (bool)ProbablyHead)
		{
			Transform parent3 = ProbablyHead.parent;
			bool flag4 = false;
			while (parent3.parent != null && parent3.parent != ProbablyHips)
			{
				if (parent3.childCount > 2)
				{
					for (int num7 = 0; num7 < TrReachingSides.Count; num7++)
					{
						if (IsChildOf(TrReachingSides[num7], parent3))
						{
							flag4 = true;
							break;
						}
					}
				}
				if (flag4)
				{
					break;
				}
				parent3 = parent3.parent;
			}
			if (flag4)
			{
				ProbablyChest = parent3;
			}
		}
		if (ProbablyHips == null)
		{
			ProbablyHips = pelvisHelp;
		}
		if ((bool)ProbablyChest && (bool)ProbablyHips)
		{
			if (MostForwVsMostBackLen > LowestVsHighestLen * 0.9f && Loc(ProbablyChest).z < Loc(ProbablyHips).z)
			{
				Transform probablyChest = ProbablyChest;
				ProbablyChest = ProbablyHips;
				ProbablyHips = probablyChest;
				Debug.Log("Hips - Chest - Reversed Detection Swap!");
			}
			if (!flag3)
			{
				Vector3 vector5 = Vector3.zero;
				for (int num8 = 0; num8 < ProbablyChest.childCount; num8++)
				{
					Transform child = ProbablyChest.GetChild(num8);
					Vector3 vector6;
					if (child.childCount > 0)
					{
						for (int num9 = 0; num9 < child.childCount; num9++)
						{
							Transform child2 = child.GetChild(num9);
							vector6 = Loc(child2);
							if (vector6.x > (0f - MostLeftVsMostRightLen) * 0.04f && vector6.x < MostLeftVsMostRightLen * 0.04f && Loc(child2).y > vector5.y)
							{
								vector5 = Loc(child2);
								ProbablyHead = child2;
							}
						}
					}
					vector6 = Loc(child);
					if (vector6.x > (0f - MostLeftVsMostRightLen) * 0.04f && vector6.x < MostLeftVsMostRightLen * 0.04f && vector6.y > vector5.y)
					{
						vector5 = Loc(child);
						ProbablyHead = child;
					}
				}
				if ((bool)ProbablyChest && (bool)ProbablyHead && (bool)ProbablyHips)
				{
					float num10 = Vector3.Distance(Loc(ProbablyChest), Loc(ProbablyHips));
					if ((ProbablyChest.childCount < 3 || num10 < AverageLen * 0.12f) && ProbablyHead.childCount > 1)
					{
						ProbablyChest = ProbablyHead;
						ProbablyHead = GetHighestChild(ProbablyHead, AnimatorTransform, MostLeftVsMostRightLen * 0.05f);
						if (ProbablyHead == ProbablyChest)
						{
							ProbablyHead = ProbablyChest.GetChild(0);
						}
					}
				}
			}
			if ((bool)ProbablyHead)
			{
				for (int num11 = TrReachingSides.Count - 1; num11 >= 0; num11--)
				{
					if (IsChildOf(TrReachingSides[num11], ProbablyHead))
					{
						TrReachingSides.RemoveAt(num11);
					}
				}
			}
			for (int num12 = TrReachingSides.Count - 1; num12 >= 0; num12--)
			{
				if (GetDepth(TrReachingSides[num12], AnimatorTransform) < 5)
				{
					TrReachingSides.RemoveAt(num12);
				}
			}
			Transform transform10 = null;
			if ((bool)ProbablyHead)
			{
				ProbablySpineChain.Add(ProbablyHead);
				transform10 = ProbablyHead.parent;
			}
			while (transform10 != null && transform10 != ProbablyHips)
			{
				ProbablySpineChain.Add(transform10);
				transform10 = transform10.parent;
			}
			ProbablySpineChain.Reverse();
			for (int num13 = 0; num13 < Mathf.Min(4, ProbablySpineChain.Count); num13++)
			{
				ProbablySpineChainShort.Add(ProbablySpineChain[num13]);
			}
			List<Transform> list4 = new List<Transform>();
			for (int num14 = 0; num14 < TrReachingGround.Count; num14++)
			{
				Transform transform11 = TrReachingGround[num14];
				Vector3 vector7 = Loc(transform11);
				List<Transform> list5 = new List<Transform>();
				Transform transform12 = transform11;
				while (transform12 != null && transform12 != ProbablyHips && transform12 != ProbablyChest)
				{
					list5.Add(transform12);
					transform12 = transform12.parent;
				}
				if (list5.Count >= 3)
				{
					List<Transform> item = new List<Transform>
					{
						list5[list5.Count - 1],
						list5[list5.Count - 2],
						list5[list5.Count - 3]
					};
					list4.Add(transform11);
					if (vector7.x < MostLeftVsMostRightLen * 0.02f)
					{
						ProbablyLeftLegs.Add(item);
						ProbablyLeftLegRoot.Add(transform12);
					}
					else
					{
						ProbablyRightLegs.Add(item);
						ProbablyRightLegRoot.Add(transform12);
					}
				}
			}
			for (int num15 = 0; num15 < TrReachingSides.Count; num15++)
			{
				Transform transform13 = TrReachingSides[num15];
				Vector3 vector8 = Loc(transform13);
				List<Transform> list6 = new List<Transform>();
				Transform transform14 = transform13;
				while (transform14 != null && transform14 != ProbablyChest)
				{
					list6.Add(transform14);
					transform14 = transform14.parent;
				}
				if (list6.Count >= 4)
				{
					List<Transform> item2 = new List<Transform>
					{
						list6[list6.Count - 1],
						list6[list6.Count - 2],
						list6[list6.Count - 3],
						list6[list6.Count - 4]
					};
					if (vector8.x < MostLeftVsMostRightLen * 0.02f)
					{
						ProbablyLeftArms.Add(item2);
					}
					else
					{
						ProbablyRightArms.Add(item2);
					}
				}
			}
			ClearDuplicates(ProbablyLeftArms, null);
			ClearDuplicates(ProbablyRightArms, null);
			ClearDuplicates(ProbablyLeftLegs, ProbablyLeftLegRoot);
			ClearDuplicates(ProbablyRightLegs, ProbablyRightLegRoot);
			if (Legs == 2 && Arms == 2)
			{
				WhatIsIt = EWhatIsIt.Humanoidal;
			}
			else if (Legs == 4 && Arms == 0)
			{
				WhatIsIt = EWhatIsIt.Quadroped;
			}
			else if (Legs > 0 || Arms > 0)
			{
				WhatIsIt = EWhatIsIt.Creature;
			}
			else
			{
				WhatIsIt = EWhatIsIt.Unknown;
			}
		}
		float y = Mathf.Lerp(LocalSpaceLowest.y, LocalSpaceHighest.y, 0.5f);
		Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceHighest.y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceLowest.y, LocalSpaceMostForward.z)), Color.green, 12f);
		Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, y, LocalSpaceMostForward.z)), Color.red, 12f);
		Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostRight.x, y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, y, LocalSpaceMostBack.z)), Color.blue, 12f);
	}

	private bool NotContainedYetByAny(Transform t)
	{
		if (!TrReachingSides.Contains(t) && !TrReachingGround.Contains(t) && !TrEnds.Contains(t) && t != ProbablyChest && t != ProbablyHips && t != ProbablyHead && t != ProbablyChest && t != ProbablyRootBone)
		{
			return t != AnimatorTransform;
		}
		return false;
	}

	private bool NotContainedYetByLimbs(Transform t)
	{
		if (!TrReachingSides.Contains(t))
		{
			return !TrReachingGround.Contains(t);
		}
		return false;
	}

	public Transform GetHighestChild(Transform t, Transform root, float inCenterRangeFactor)
	{
		if (t == null)
		{
			return null;
		}
		Transform result = t;
		Vector3 vector = root.InverseTransformPoint(t.position);
		Transform[] componentsInChildren = t.GetComponentsInChildren<Transform>(includeInactive: true);
		foreach (Transform transform in componentsInChildren)
		{
			Vector3 vector2 = root.InverseTransformPoint(transform.position);
			if (vector2.x > 0f - inCenterRangeFactor && vector2.x < inCenterRangeFactor && vector2.y > vector.y)
			{
				vector.y = vector2.y;
				result = transform;
			}
		}
		return result;
	}

	private void ClearDuplicates(List<List<Transform>> limbs, List<Transform> roots)
	{
		if (limbs.Count <= 1)
		{
			return;
		}
		for (int i = 0; i < limbs.Count && i < limbs.Count; i++)
		{
			List<Transform> list = limbs[i];
			for (int num = limbs.Count - 1; num >= 0; num--)
			{
				if (num != i)
				{
					List<Transform> list2 = limbs[num];
					bool flag = false;
					for (int j = 0; j < list2.Count; j++)
					{
						if (list.Contains(list2[j]))
						{
							flag = true;
							break;
						}
					}
					if (flag)
					{
						limbs.RemoveAt(num);
					}
				}
			}
		}
	}

	private Vector3 Loc(Transform t)
	{
		return AnimatorTransform.InverseTransformPoint(t.position);
	}

	public string GetLog()
	{
		string text = "< " + AnimatorTransform.name + " >\n";
		text += "\nGenerate Guides:\n";
		string text2 = text;
		Vector3 localSpaceHighest = LocalSpaceHighest;
		text = text2 + "Highest: " + localSpaceHighest.ToString() + "     ";
		string text3 = text;
		localSpaceHighest = LocalSpaceLowest;
		text = text3 + "Lowest: " + localSpaceHighest.ToString() + "     ";
		string text4 = text;
		localSpaceHighest = LocalSpaceMostLeft;
		text = text4 + "Left: " + localSpaceHighest.ToString() + "     ";
		string text5 = text;
		localSpaceHighest = LocalSpaceMostRight;
		text = text5 + "Right: " + localSpaceHighest.ToString() + "     ";
		string text6 = text;
		localSpaceHighest = LocalSpaceMostForward;
		text = text6 + "Forward: " + localSpaceHighest.ToString() + "     ";
		string text7 = text;
		localSpaceHighest = LocalSpaceMostBack;
		text = text7 + "Back: " + localSpaceHighest.ToString() + "     ";
		text += "\n\nGenerated Helper Measurements: \n";
		text = text + "UpDown: " + LowestVsHighestLen + "     ";
		text = text + "LeftRight: " + MostLeftVsMostRightLen + "     ";
		text = text + "ForwBack: " + MostForwVsMostBackLen + "     ";
		text = text + "Avr: " + AverageLen + "     ";
		text += "\n\nDetected Propabilities: \n";
		text = text + "ProbablyHips: " + ProbablyHips?.ToString() + "     ";
		text = text + "ProbablyChest: " + ProbablyChest?.ToString() + "     ";
		text = text + "ProbablyHead: " + ProbablyHead?.ToString() + "     ";
		text += "\n\nLimb End Detections: \n";
		text = text + "Reaching Ground: " + TrReachingGround.Count + "     ";
		text = text + "Reaching Sides: " + TrReachingSides.Count + "     ";
		text = text + "Spine Chain Length: " + ProbablySpineChain.Count + " (" + ProbablySpineChainShort.Count + ")     ";
		text += "\n\nDetected Propabilities: \n";
		text = text + "Probably Left Arms: " + ProbablyLeftArms.Count + "     ";
		text = text + "Probably Right Arms: " + ProbablyRightArms.Count + "     ";
		text = text + "Probably Left Legs: " + ProbablyLeftLegs.Count + "     ";
		text = text + "Probably Right Legs: " + ProbablyRightLegs.Count + "     ";
		text += "\n\n\nTr Ends: \n";
		for (int i = 0; i < TrEnds.Count; i++)
		{
			if (!(TrEnds[i] == null))
			{
				text = text + TrEnds[i].name + "     ";
			}
		}
		text += "\n\nTr Reaching Ground: \n";
		for (int j = 0; j < TrReachingGround.Count; j++)
		{
			if (!(TrReachingGround[j] == null))
			{
				text = text + TrReachingGround[j].name + "     ";
			}
		}
		text += "\n\nTr Reaching Sides: \n";
		for (int k = 0; k < TrReachingSides.Count; k++)
		{
			if (!(TrReachingSides[k] == null))
			{
				text = text + TrReachingSides[k].name + "     ";
			}
		}
		if (ProbablyLeftArms.Count > 0)
		{
			text += "\n\nDebug Left Arms: \n";
			for (int l = 0; l < ProbablyLeftArms.Count; l++)
			{
				if (ProbablyLeftArms[l] != null)
				{
					text = text + "[" + l + "] ";
					for (int m = 0; m < ProbablyLeftArms[l].Count; m++)
					{
						text = text + ProbablyLeftArms[l][m].name + "  ";
					}
					text += "\n";
				}
			}
		}
		if (ProbablySpineChainShort.Count > 0)
		{
			text += "\n\nDebug Spine Chain: \n";
			for (int n = 0; n < ProbablySpineChainShort.Count; n++)
			{
				if (!(ProbablySpineChainShort[n] == null))
				{
					text = text + ProbablySpineChainShort[n].name + "  ";
				}
			}
		}
		return text + "\n\n";
	}

	public static int GetDepth(Transform t, Transform skelRootBone)
	{
		int num = 0;
		if (t == skelRootBone)
		{
			return 0;
		}
		if (t == null)
		{
			return 0;
		}
		if (t.parent == null)
		{
			return 0;
		}
		while (t != null && t != skelRootBone)
		{
			t = t.parent;
			num++;
		}
		return num;
	}
}
