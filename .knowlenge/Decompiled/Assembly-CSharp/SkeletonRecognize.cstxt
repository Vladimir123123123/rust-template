using System.Collections.Generic;
using FIMSpace.AnimationTools;
using UnityEngine;

public static class SkeletonRecognize
{
	public enum EWhatIsIt
	{
		Unknown,
		Humanoidal,
		Quadroped,
		Creature
	}

	public class SkeletonInfo
	{
		public Transform AnimatorTransform;

		public float LowestVsHighestLen;

		public float MostLeftVsMostRightLen;

		public float MostForwVsMostBackLen;

		public float AverageLen;

		public Transform ProbablyRootBone;

		public Transform ProbablyHips;

		public Transform ProbablyChest;

		public Transform ProbablyHead;

		public List<Transform> TrReachingGround = new List<Transform>();

		public List<Transform> TrReachingSides = new List<Transform>();

		public List<Transform> TrEnds = new List<Transform>();

		public List<Transform> ProbablySpineChain = new List<Transform>();

		public List<Transform> ProbablySpineChainShort = new List<Transform>();

		public List<List<Transform>> ProbablyRightArms = new List<List<Transform>>();

		public List<List<Transform>> ProbablyLeftArms = new List<List<Transform>>();

		public List<List<Transform>> ProbablyLeftLegs = new List<List<Transform>>();

		public List<Transform> ProbablyLeftLegRoot = new List<Transform>();

		public List<List<Transform>> ProbablyRightLegs = new List<List<Transform>>();

		public List<Transform> ProbablyRightLegRoot = new List<Transform>();

		public Vector3 LocalSpaceHighest = Vector3.zero;

		public Vector3 LocalSpaceMostRight = Vector3.zero;

		public Vector3 LocalSpaceMostForward = Vector3.zero;

		public Vector3 LocalSpaceMostBack = Vector3.zero;

		public Vector3 LocalSpaceMostLeft = Vector3.zero;

		public Vector3 LocalSpaceLowest = Vector3.zero;

		public EWhatIsIt WhatIsIt;

		public int SpineChainLength => ProbablySpineChain.Count;

		public int LeftArms => ProbablyLeftArms.Count;

		public int LeftLegs => ProbablyLeftLegs.Count;

		public int RightArms => ProbablyRightArms.Count;

		public int RightLegs => ProbablyRightLegs.Count;

		public int Legs => RightLegs + LeftLegs;

		public int Arms => LeftArms + RightArms;

		public SkeletonInfo(Transform t, List<Transform> checkOnly = null, Transform pelvisHelp = null)
		{
			AnimatorTransform = t;
			Transform[] array;
			if (checkOnly != null)
			{
				array = new Transform[checkOnly.Count];
				for (int i = 0; i < checkOnly.Count; i++)
				{
					array[i] = checkOnly[i];
				}
			}
			else
			{
				array = AnimatorTransform.GetComponentsInChildren<Transform>(includeInactive: true);
			}
			if (array.Length != 0)
			{
				LocalSpaceLowest = (LocalSpaceMostLeft = (LocalSpaceMostBack = (LocalSpaceMostForward = (LocalSpaceMostRight = (LocalSpaceHighest = AnimatorTransform.InverseTransformPoint(array[0].position))))));
			}
			List<Transform> list = new List<Transform>();
			foreach (Transform transform in array)
			{
				if (!(transform.GetComponentInChildren<SkinnedMeshRenderer>() != null))
				{
					list.Add(transform);
				}
			}
			for (int k = 0; k < list.Count; k++)
			{
				Transform transform2 = list[k];
				if (!transform2.GetComponent<SkinnedMeshRenderer>())
				{
					Vector3 vector = AnimatorTransform.InverseTransformPoint(transform2.position);
					if (vector.x > LocalSpaceMostRight.x)
					{
						LocalSpaceMostRight = vector;
					}
					else if (vector.x < LocalSpaceMostLeft.x)
					{
						LocalSpaceMostLeft = vector;
					}
					if (vector.z > LocalSpaceMostForward.z)
					{
						LocalSpaceMostForward = vector;
					}
					else if (vector.z < LocalSpaceMostBack.z)
					{
						LocalSpaceMostBack = vector;
					}
					if (vector.y > LocalSpaceHighest.y)
					{
						LocalSpaceHighest = vector;
					}
					else if (vector.y < LocalSpaceLowest.y)
					{
						LocalSpaceLowest = vector;
					}
				}
			}
			LowestVsHighestLen = Mathf.Abs(LocalSpaceLowest.y - LocalSpaceHighest.y);
			MostLeftVsMostRightLen = Mathf.Abs(LocalSpaceMostLeft.x - LocalSpaceMostRight.x);
			MostForwVsMostBackLen = Mathf.Abs(LocalSpaceMostForward.z - LocalSpaceMostBack.z);
			AverageLen = (LowestVsHighestLen + MostLeftVsMostRightLen + MostForwVsMostBackLen) / 3f;
			_ = LowestVsHighestLen;
			for (int l = 0; l < list.Count; l++)
			{
				Transform transform3 = list[l];
				if (NameContains(transform3.name, ShouldersNames))
				{
					Transform bottomMostChildTransform = GetBottomMostChildTransform(transform3);
					if (NotContainedYetByLimbs(bottomMostChildTransform))
					{
						TrReachingSides.Add(bottomMostChildTransform);
					}
				}
				else if (NameContains(transform3.name, ElbowNames))
				{
					Transform bottomMostChildTransform2 = GetBottomMostChildTransform(transform3);
					if (NotContainedYetByLimbs(bottomMostChildTransform2))
					{
						TrReachingSides.Add(bottomMostChildTransform2);
					}
				}
			}
			for (int m = 0; m < list.Count; m++)
			{
				Transform transform4 = list[m];
				if (NameContains(transform4.name, UpperLegNames))
				{
					Transform bottomMostChildTransform3 = GetBottomMostChildTransform(transform4);
					if (NotContainedYetByLimbs(bottomMostChildTransform3))
					{
						TrReachingGround.Add(bottomMostChildTransform3);
					}
				}
				else if (NameContains(transform4.name, KneeNames))
				{
					Transform bottomMostChildTransform4 = GetBottomMostChildTransform(transform4);
					if (NotContainedYetByLimbs(bottomMostChildTransform4))
					{
						TrReachingGround.Add(bottomMostChildTransform4);
					}
				}
			}
			bool flag = false;
			for (int n = 0; n < list.Count; n++)
			{
				Transform transform5 = list[n];
				if (NameContains(transform5.name, PelvisNames))
				{
					flag = true;
					ProbablyHips = transform5;
					break;
				}
			}
			bool flag2 = false;
			for (int num = 0; num < list.Count; num++)
			{
				Transform transform6 = list[num];
				if (NameContains(transform6.name, ChestNames))
				{
					flag2 = true;
					ProbablyChest = transform6;
					break;
				}
			}
			bool flag3 = false;
			for (int num2 = 0; num2 < list.Count; num2++)
			{
				Transform transform7 = list[num2];
				if (NameContains(transform7.name, HeadNames))
				{
					flag3 = true;
					ProbablyHead = transform7;
					break;
				}
			}
			if (ProbablyHead != null && ProbablyHips != null && !IsChildOf(ProbablyHead, ProbablyHips))
			{
				ProbablyHead = null;
			}
			for (int num3 = 0; num3 < list.Count; num3++)
			{
				Transform transform8 = list[num3];
				if (NameContains(transform8.name, RootNames))
				{
					ProbablyRootBone = transform8;
					break;
				}
			}
			if (list.Count > 2)
			{
				for (int num4 = 1; num4 < list.Count; num4++)
				{
					Transform transform9 = list[num4];
					if (transform9.childCount != 0)
					{
						continue;
					}
					TrEnds.Add(transform9);
					Vector3 vector2 = Loc(transform9);
					if (vector2.y < LocalSpaceLowest.y + LowestVsHighestLen * 0.1f)
					{
						if (NotContainedYetByLimbs(transform9))
						{
							TrReachingGround.Add(transform9);
						}
					}
					else if (vector2.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.2f && (vector2.x < MostLeftVsMostRightLen * -0.1f || vector2.x > MostLeftVsMostRightLen * 0.1f) && NotContainedYetByLimbs(transform9))
					{
						TrReachingSides.Add(transform9);
					}
				}
			}
			if (!flag2)
			{
				List<Transform> list2 = new List<Transform>();
				for (int num5 = 0; num5 < TrReachingSides.Count; num5++)
				{
					if ((bool)list[num5].GetComponent<SkinnedMeshRenderer>())
					{
						continue;
					}
					Transform parent = TrReachingSides[num5].parent;
					while (parent != null)
					{
						if (parent.childCount > 2)
						{
							Vector3 vector3 = Loc(parent);
							if (vector3.x > (0f - MostLeftVsMostRightLen) * 0.03f && vector3.x < MostLeftVsMostRightLen * 0.03f)
							{
								list2.Add(parent);
								break;
							}
						}
						parent = parent.parent;
					}
				}
				if (list2.Count == 1)
				{
					ProbablyChest = list2[0];
				}
				else if (list2.Count > 1 && list2[0] == list2[1])
				{
					ProbablyChest = list2[0];
				}
			}
			if (!flag)
			{
				List<Transform> list3 = new List<Transform>();
				for (int num6 = 0; num6 < TrReachingGround.Count; num6++)
				{
					Transform parent2 = TrReachingGround[num6].parent;
					while (parent2 != null)
					{
						if (parent2.childCount > 2)
						{
							Vector3 vector4 = Loc(parent2);
							if (vector4.y > LocalSpaceLowest.y + LowestVsHighestLen * 0.04f && vector4.x > (0f - MostLeftVsMostRightLen) * 0.02f && vector4.x < MostLeftVsMostRightLen * 0.02f)
							{
								list3.Add(parent2);
								break;
							}
						}
						parent2 = parent2.parent;
					}
				}
				if (list3.Count == 1)
				{
					ProbablyChest = list3[0];
				}
				else if (list3.Count > 1 && list3[0] == list3[1])
				{
					ProbablyHips = list3[0];
				}
			}
			if (ProbablyHips == null)
			{
				ProbablyHips = pelvisHelp;
			}
			if ((ProbablyChest == null || ProbablyChest == ProbablyHips || (ProbablyHips != null && !IsChildOf(ProbablyChest, ProbablyHips))) && (bool)ProbablyHips && (bool)ProbablyHead)
			{
				Transform parent3 = ProbablyHead.parent;
				bool flag4 = false;
				while (parent3.parent != null && parent3.parent != ProbablyHips)
				{
					if (parent3.childCount > 2)
					{
						for (int num7 = 0; num7 < TrReachingSides.Count; num7++)
						{
							if (IsChildOf(TrReachingSides[num7], parent3))
							{
								flag4 = true;
								break;
							}
						}
					}
					if (flag4)
					{
						break;
					}
					parent3 = parent3.parent;
				}
				if (flag4)
				{
					ProbablyChest = parent3;
				}
			}
			if (ProbablyHips == null)
			{
				ProbablyHips = pelvisHelp;
			}
			if ((bool)ProbablyChest && (bool)ProbablyHips)
			{
				if (MostForwVsMostBackLen > LowestVsHighestLen * 0.9f && Loc(ProbablyChest).z < Loc(ProbablyHips).z)
				{
					Transform probablyChest = ProbablyChest;
					ProbablyChest = ProbablyHips;
					ProbablyHips = probablyChest;
					Debug.Log("Hips - Chest - Reversed Detection Swap!");
				}
				if (!flag3)
				{
					Vector3 vector5 = Vector3.zero;
					for (int num8 = 0; num8 < ProbablyChest.childCount; num8++)
					{
						Transform child = ProbablyChest.GetChild(num8);
						Vector3 vector6;
						if (child.childCount > 0)
						{
							for (int num9 = 0; num9 < child.childCount; num9++)
							{
								Transform child2 = child.GetChild(num9);
								vector6 = Loc(child2);
								if (vector6.x > (0f - MostLeftVsMostRightLen) * 0.04f && vector6.x < MostLeftVsMostRightLen * 0.04f && Loc(child2).y > vector5.y)
								{
									vector5 = Loc(child2);
									ProbablyHead = child2;
								}
							}
						}
						vector6 = Loc(child);
						if (vector6.x > (0f - MostLeftVsMostRightLen) * 0.04f && vector6.x < MostLeftVsMostRightLen * 0.04f && vector6.y > vector5.y)
						{
							vector5 = Loc(child);
							ProbablyHead = child;
						}
					}
					if ((bool)ProbablyChest && (bool)ProbablyHead && (bool)ProbablyHips)
					{
						float num10 = Vector3.Distance(Loc(ProbablyChest), Loc(ProbablyHips));
						if ((ProbablyChest.childCount < 3 || num10 < AverageLen * 0.12f) && ProbablyHead.childCount > 1)
						{
							ProbablyChest = ProbablyHead;
							ProbablyHead = GetHighestChild(ProbablyHead, AnimatorTransform, MostLeftVsMostRightLen * 0.05f);
							if (ProbablyHead == ProbablyChest)
							{
								ProbablyHead = ProbablyChest.GetChild(0);
							}
						}
					}
				}
				if ((bool)ProbablyHead)
				{
					for (int num11 = TrReachingSides.Count - 1; num11 >= 0; num11--)
					{
						if (IsChildOf(TrReachingSides[num11], ProbablyHead))
						{
							TrReachingSides.RemoveAt(num11);
						}
					}
				}
				for (int num12 = TrReachingSides.Count - 1; num12 >= 0; num12--)
				{
					if (GetDepth(TrReachingSides[num12], AnimatorTransform) < 5)
					{
						TrReachingSides.RemoveAt(num12);
					}
				}
				Transform transform10 = null;
				if ((bool)ProbablyHead)
				{
					ProbablySpineChain.Add(ProbablyHead);
					transform10 = ProbablyHead.parent;
				}
				while (transform10 != null && transform10 != ProbablyHips)
				{
					ProbablySpineChain.Add(transform10);
					transform10 = transform10.parent;
				}
				ProbablySpineChain.Reverse();
				for (int num13 = 0; num13 < Mathf.Min(4, ProbablySpineChain.Count); num13++)
				{
					ProbablySpineChainShort.Add(ProbablySpineChain[num13]);
				}
				List<Transform> list4 = new List<Transform>();
				for (int num14 = 0; num14 < TrReachingGround.Count; num14++)
				{
					Transform transform11 = TrReachingGround[num14];
					Vector3 vector7 = Loc(transform11);
					List<Transform> list5 = new List<Transform>();
					Transform transform12 = transform11;
					while (transform12 != null && transform12 != ProbablyHips && transform12 != ProbablyChest)
					{
						list5.Add(transform12);
						transform12 = transform12.parent;
					}
					if (list5.Count >= 3)
					{
						List<Transform> item = new List<Transform>
						{
							list5[list5.Count - 1],
							list5[list5.Count - 2],
							list5[list5.Count - 3]
						};
						list4.Add(transform11);
						if (vector7.x < MostLeftVsMostRightLen * 0.02f)
						{
							ProbablyLeftLegs.Add(item);
							ProbablyLeftLegRoot.Add(transform12);
						}
						else
						{
							ProbablyRightLegs.Add(item);
							ProbablyRightLegRoot.Add(transform12);
						}
					}
				}
				for (int num15 = 0; num15 < TrReachingSides.Count; num15++)
				{
					Transform transform13 = TrReachingSides[num15];
					Vector3 vector8 = Loc(transform13);
					List<Transform> list6 = new List<Transform>();
					Transform transform14 = transform13;
					while (transform14 != null && transform14 != ProbablyChest)
					{
						list6.Add(transform14);
						transform14 = transform14.parent;
					}
					if (list6.Count >= 4)
					{
						List<Transform> item2 = new List<Transform>
						{
							list6[list6.Count - 1],
							list6[list6.Count - 2],
							list6[list6.Count - 3],
							list6[list6.Count - 4]
						};
						if (vector8.x < MostLeftVsMostRightLen * 0.02f)
						{
							ProbablyLeftArms.Add(item2);
						}
						else
						{
							ProbablyRightArms.Add(item2);
						}
					}
				}
				ClearDuplicates(ProbablyLeftArms, null);
				ClearDuplicates(ProbablyRightArms, null);
				ClearDuplicates(ProbablyLeftLegs, ProbablyLeftLegRoot);
				ClearDuplicates(ProbablyRightLegs, ProbablyRightLegRoot);
				if (Legs == 2 && Arms == 2)
				{
					WhatIsIt = EWhatIsIt.Humanoidal;
				}
				else if (Legs == 4 && Arms == 0)
				{
					WhatIsIt = EWhatIsIt.Quadroped;
				}
				else if (Legs > 0 || Arms > 0)
				{
					WhatIsIt = EWhatIsIt.Creature;
				}
				else
				{
					WhatIsIt = EWhatIsIt.Unknown;
				}
			}
			float y = Mathf.Lerp(LocalSpaceLowest.y, LocalSpaceHighest.y, 0.5f);
			Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceHighest.y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, LocalSpaceLowest.y, LocalSpaceMostForward.z)), Color.green, 12f);
			Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostLeft.x, y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, y, LocalSpaceMostForward.z)), Color.red, 12f);
			Debug.DrawLine(t.TransformPoint(new Vector3(LocalSpaceMostRight.x, y, LocalSpaceMostForward.z)), t.TransformPoint(new Vector3(LocalSpaceMostRight.x, y, LocalSpaceMostBack.z)), Color.blue, 12f);
		}

		private bool NotContainedYetByAny(Transform t)
		{
			if (!TrReachingSides.Contains(t) && !TrReachingGround.Contains(t) && !TrEnds.Contains(t) && t != ProbablyChest && t != ProbablyHips && t != ProbablyHead && t != ProbablyChest && t != ProbablyRootBone)
			{
				return t != AnimatorTransform;
			}
			return false;
		}

		private bool NotContainedYetByLimbs(Transform t)
		{
			if (!TrReachingSides.Contains(t))
			{
				return !TrReachingGround.Contains(t);
			}
			return false;
		}

		public Transform GetHighestChild(Transform t, Transform root, float inCenterRangeFactor)
		{
			if (t == null)
			{
				return null;
			}
			Transform result = t;
			Vector3 vector = root.InverseTransformPoint(t.position);
			Transform[] componentsInChildren = t.GetComponentsInChildren<Transform>(includeInactive: true);
			foreach (Transform transform in componentsInChildren)
			{
				Vector3 vector2 = root.InverseTransformPoint(transform.position);
				if (vector2.x > 0f - inCenterRangeFactor && vector2.x < inCenterRangeFactor && vector2.y > vector.y)
				{
					vector.y = vector2.y;
					result = transform;
				}
			}
			return result;
		}

		private void ClearDuplicates(List<List<Transform>> limbs, List<Transform> roots)
		{
			if (limbs.Count <= 1)
			{
				return;
			}
			for (int i = 0; i < limbs.Count && i < limbs.Count; i++)
			{
				List<Transform> list = limbs[i];
				for (int num = limbs.Count - 1; num >= 0; num--)
				{
					if (num != i)
					{
						List<Transform> list2 = limbs[num];
						bool flag = false;
						for (int j = 0; j < list2.Count; j++)
						{
							if (list.Contains(list2[j]))
							{
								flag = true;
								break;
							}
						}
						if (flag)
						{
							limbs.RemoveAt(num);
						}
					}
				}
			}
		}

		private Vector3 Loc(Transform t)
		{
			return AnimatorTransform.InverseTransformPoint(t.position);
		}

		public string GetLog()
		{
			string text = "< " + AnimatorTransform.name + " >\n";
			text += "\nGenerate Guides:\n";
			string text2 = text;
			Vector3 localSpaceHighest = LocalSpaceHighest;
			text = text2 + "Highest: " + localSpaceHighest.ToString() + "     ";
			string text3 = text;
			localSpaceHighest = LocalSpaceLowest;
			text = text3 + "Lowest: " + localSpaceHighest.ToString() + "     ";
			string text4 = text;
			localSpaceHighest = LocalSpaceMostLeft;
			text = text4 + "Left: " + localSpaceHighest.ToString() + "     ";
			string text5 = text;
			localSpaceHighest = LocalSpaceMostRight;
			text = text5 + "Right: " + localSpaceHighest.ToString() + "     ";
			string text6 = text;
			localSpaceHighest = LocalSpaceMostForward;
			text = text6 + "Forward: " + localSpaceHighest.ToString() + "     ";
			string text7 = text;
			localSpaceHighest = LocalSpaceMostBack;
			text = text7 + "Back: " + localSpaceHighest.ToString() + "     ";
			text += "\n\nGenerated Helper Measurements: \n";
			text = text + "UpDown: " + LowestVsHighestLen + "     ";
			text = text + "LeftRight: " + MostLeftVsMostRightLen + "     ";
			text = text + "ForwBack: " + MostForwVsMostBackLen + "     ";
			text = text + "Avr: " + AverageLen + "     ";
			text += "\n\nDetected Propabilities: \n";
			text = text + "ProbablyHips: " + ProbablyHips?.ToString() + "     ";
			text = text + "ProbablyChest: " + ProbablyChest?.ToString() + "     ";
			text = text + "ProbablyHead: " + ProbablyHead?.ToString() + "     ";
			text += "\n\nLimb End Detections: \n";
			text = text + "Reaching Ground: " + TrReachingGround.Count + "     ";
			text = text + "Reaching Sides: " + TrReachingSides.Count + "     ";
			text = text + "Spine Chain Length: " + ProbablySpineChain.Count + " (" + ProbablySpineChainShort.Count + ")     ";
			text += "\n\nDetected Propabilities: \n";
			text = text + "Probably Left Arms: " + ProbablyLeftArms.Count + "     ";
			text = text + "Probably Right Arms: " + ProbablyRightArms.Count + "     ";
			text = text + "Probably Left Legs: " + ProbablyLeftLegs.Count + "     ";
			text = text + "Probably Right Legs: " + ProbablyRightLegs.Count + "     ";
			text += "\n\n\nTr Ends: \n";
			for (int i = 0; i < TrEnds.Count; i++)
			{
				if (!(TrEnds[i] == null))
				{
					text = text + TrEnds[i].name + "     ";
				}
			}
			text += "\n\nTr Reaching Ground: \n";
			for (int j = 0; j < TrReachingGround.Count; j++)
			{
				if (!(TrReachingGround[j] == null))
				{
					text = text + TrReachingGround[j].name + "     ";
				}
			}
			text += "\n\nTr Reaching Sides: \n";
			for (int k = 0; k < TrReachingSides.Count; k++)
			{
				if (!(TrReachingSides[k] == null))
				{
					text = text + TrReachingSides[k].name + "     ";
				}
			}
			if (ProbablyLeftArms.Count > 0)
			{
				text += "\n\nDebug Left Arms: \n";
				for (int l = 0; l < ProbablyLeftArms.Count; l++)
				{
					if (ProbablyLeftArms[l] != null)
					{
						text = text + "[" + l + "] ";
						for (int m = 0; m < ProbablyLeftArms[l].Count; m++)
						{
							text = text + ProbablyLeftArms[l][m].name + "  ";
						}
						text += "\n";
					}
				}
			}
			if (ProbablySpineChainShort.Count > 0)
			{
				text += "\n\nDebug Spine Chain: \n";
				for (int n = 0; n < ProbablySpineChainShort.Count; n++)
				{
					if (!(ProbablySpineChainShort[n] == null))
					{
						text = text + ProbablySpineChainShort[n].name + "  ";
					}
				}
			}
			return text + "\n\n";
		}

		public static int GetDepth(Transform t, Transform skelRootBone)
		{
			int num = 0;
			if (t == skelRootBone)
			{
				return 0;
			}
			if (t == null)
			{
				return 0;
			}
			if (t.parent == null)
			{
				return 0;
			}
			while (t != null && t != skelRootBone)
			{
				t = t.parent;
				num++;
			}
			return num;
		}
	}

	public static Component FoundAnimator;

	private static bool checkForAnim = true;

	private static int clicks = 0;

	public static readonly string[] SpineNames = new string[1] { "spine" };

	public static readonly string[] NeckNames = new string[1] { "neck" };

	public static readonly string[] HeadNames = new string[1] { "head" };

	public static readonly string[] RootNames = new string[3] { "root", "origin", "skel" };

	public static readonly string[] PelvisNames = new string[3] { "pelvis", "hips", "pelv" };

	public static readonly string[] ChestNames = new string[2] { "chest", "upperspine" };

	public static readonly string[] ShouldersNames = new string[3] { "shoulde", "collarbon", "clavicl" };

	public static readonly string[] UpperLegNames = new string[2] { "upperleg", "thigh" };

	public static readonly string[] KneeNames = new string[3] { "knee", "calf", "lowerleg" };

	public static readonly string[] ElbowNames = new string[2] { "elbow", "lowerarm" };

	public static bool IsChildOf(Transform child, Transform parent)
	{
		Transform transform = child;
		while (transform != null)
		{
			if (transform == parent)
			{
				return true;
			}
			transform = transform.parent;
		}
		return false;
	}

	public static Transform GetBottomMostChildTransform(Transform parent)
	{
		Transform[] componentsInChildren = parent.GetComponentsInChildren<Transform>(includeInactive: true);
		int num = 0;
		Transform result = parent;
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			if (!(componentsInChildren[i] == parent))
			{
				Transform transform = componentsInChildren[i];
				int num2 = 0;
				while (transform.parent != parent && transform.parent != null)
				{
					num2++;
					transform = transform.parent;
				}
				if (num2 > num)
				{
					num = num2;
					result = componentsInChildren[i];
				}
			}
		}
		return result;
	}

	public static Transform GetContinousChildTransform(Transform root)
	{
		Transform result = null;
		if (root.childCount > 0)
		{
			if (root.childCount == 1)
			{
				return root.GetChild(0);
			}
			int num = 0;
			Transform child = root.GetChild(0);
			for (int i = 0; i < root.childCount; i++)
			{
				int num2 = CountChildChainLength(root.GetChild(i));
				if (num2 > num)
				{
					num = num2;
					child = root.GetChild(i);
				}
			}
			result = child;
		}
		return result;
	}

	public static int CountChildChainLength(Transform root)
	{
		if (root == null)
		{
			return 0;
		}
		if (root.childCount == 0)
		{
			return 0;
		}
		return GetDepth(GetBottomMostChildTransform(root), root);
	}

	public static int GetDepth(Transform t, Transform skelRootBone)
	{
		int num = 0;
		if (t == skelRootBone)
		{
			return 0;
		}
		if (t == null)
		{
			return 0;
		}
		if (t.parent == null)
		{
			return 0;
		}
		while (t != null && t != skelRootBone)
		{
			t = t.parent;
			num++;
		}
		return num;
	}

	public static Transform GetParent(Transform start, int depth)
	{
		if (start == null)
		{
			return null;
		}
		Transform parent = start.parent;
		for (int i = 0; i < depth; i++)
		{
			if (parent == null)
			{
				break;
			}
			parent = parent.parent;
		}
		return parent;
	}

	public static Transform GetLastChild(Transform rootParent)
	{
		Transform transform = rootParent;
		while (transform.childCount > 0)
		{
			transform = transform.GetChild(0);
		}
		return transform;
	}

	public static bool? IsRightOrLeft(string name, bool includeNotSure = false)
	{
		string text = name.ToLower();
		if (text.Contains("right"))
		{
			return true;
		}
		if (text.Contains("left"))
		{
			return false;
		}
		if (text.StartsWith("r_"))
		{
			return true;
		}
		if (text.StartsWith("l_"))
		{
			return false;
		}
		if (text.EndsWith("_r"))
		{
			return true;
		}
		if (text.EndsWith("_l"))
		{
			return false;
		}
		if (text.StartsWith("r."))
		{
			return true;
		}
		if (text.StartsWith("l."))
		{
			return false;
		}
		if (text.EndsWith(".r"))
		{
			return true;
		}
		if (text.EndsWith(".l"))
		{
			return false;
		}
		if (includeNotSure)
		{
			if (text.Contains("r_"))
			{
				return true;
			}
			if (text.Contains("l_"))
			{
				return false;
			}
			if (text.Contains("_r"))
			{
				return true;
			}
			if (text.Contains("_l"))
			{
				return false;
			}
			if (text.Contains("r."))
			{
				return true;
			}
			if (text.Contains("l."))
			{
				return false;
			}
			if (text.Contains(".r"))
			{
				return true;
			}
			if (text.Contains(".l"))
			{
				return false;
			}
		}
		return null;
	}

	public static bool? IsRightOrLeft(Transform child, Transform itsRoot)
	{
		Vector3 vector = itsRoot.InverseTransformPoint(child.position);
		if (vector.x < 0f)
		{
			return false;
		}
		if (vector.x > 0f)
		{
			return true;
		}
		return null;
	}

	public static void ResetFinders(bool resetClicks = true)
	{
		checkForAnim = true;
		FoundAnimator = null;
		if (resetClicks)
		{
			clicks = 0;
		}
	}

	public static bool CheckForAnimator(GameObject root, bool needAnimatorBox = true, bool drawInactiveWarning = true, int clicksTohide = 1)
	{
		bool flag = false;
		if (checkForAnim)
		{
			FoundAnimator = SearchForParentWithAnimator(root);
		}
		if ((bool)FoundAnimator)
		{
			Animation animation = FoundAnimator as Animation;
			Animator animator = FoundAnimator as Animator;
			if ((bool)animation && animation.enabled)
			{
				flag = true;
			}
			if ((bool)animator)
			{
				if (animator.enabled)
				{
					flag = true;
				}
				if (animator.runtimeAnimatorController == null)
				{
					drawInactiveWarning = false;
					flag = false;
				}
			}
			if (needAnimatorBox && drawInactiveWarning && flag)
			{
			}
		}
		else if (needAnimatorBox)
		{
			_ = clicks;
		}
		checkForAnim = false;
		return flag;
	}

	public static Component SearchForParentWithAnimator(GameObject root)
	{
		Animation componentInChildren = root.GetComponentInChildren<Animation>();
		if ((bool)componentInChildren)
		{
			return componentInChildren;
		}
		Animator componentInChildren2 = root.GetComponentInChildren<Animator>();
		if ((bool)componentInChildren2)
		{
			return componentInChildren2;
		}
		if (root.transform.parent != null)
		{
			Transform parent = root.transform.parent;
			while (parent != null)
			{
				componentInChildren = parent.GetComponent<Animation>();
				if ((bool)componentInChildren)
				{
					return componentInChildren;
				}
				componentInChildren2 = parent.GetComponent<Animator>();
				if ((bool)componentInChildren2)
				{
					return componentInChildren2;
				}
				parent = parent.parent;
			}
		}
		return null;
	}

	public static SkinnedMeshRenderer GetBoneSearchArray(Transform root)
	{
		List<SkinnedMeshRenderer> list = new List<SkinnedMeshRenderer>();
		SkinnedMeshRenderer skinnedMeshRenderer = null;
		Transform[] componentsInChildren = root.GetComponentsInChildren<Transform>();
		for (int i = 0; i < componentsInChildren.Length; i++)
		{
			SkinnedMeshRenderer component = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
			if ((bool)component)
			{
				list.Add(component);
			}
		}
		if (list.Count == 0)
		{
			Transform transform = root;
			while (transform != null && !(transform.parent == null))
			{
				transform = transform.parent;
			}
			componentsInChildren = transform.GetComponentsInChildren<Transform>();
			for (int i = 0; i < componentsInChildren.Length; i++)
			{
				SkinnedMeshRenderer component2 = componentsInChildren[i].GetComponent<SkinnedMeshRenderer>();
				if (!list.Contains(component2) && (bool)component2)
				{
					list.Add(component2);
				}
			}
		}
		if (list.Count > 1)
		{
			skinnedMeshRenderer = list[0];
			for (int j = 1; j < list.Count; j++)
			{
				if (list[j].bones.Length > skinnedMeshRenderer.bones.Length)
				{
					skinnedMeshRenderer = list[j];
				}
			}
		}
		else if (list.Count > 0)
		{
			skinnedMeshRenderer = list[0];
		}
		if (skinnedMeshRenderer == null)
		{
			return null;
		}
		return skinnedMeshRenderer;
	}

	public static bool HaveKey(string text, string[] keys)
	{
		for (int i = 0; i < keys.Length; i++)
		{
			if (text.Contains(keys[i]))
			{
				return true;
			}
		}
		return false;
	}

	public static bool NameContains(string name, string[] names)
	{
		string text = name.ToLower();
		text = text.Replace("-", "");
		text = text.Replace(" ", "");
		text = text.Replace("_", "");
		text = text.Replace("|", "");
		text = text.Replace("@", "");
		for (int i = 0; i < names.Length; i++)
		{
			if (text.Contains(names[i]))
			{
				return true;
			}
		}
		return false;
	}
}
