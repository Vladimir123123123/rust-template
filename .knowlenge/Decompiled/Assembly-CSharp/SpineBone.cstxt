using System;
using System.Collections.Generic;
using UnityEngine;

[Serializable]
public class SpineBone
{
	public Transform transform;

	public Vector3 ProceduralPosition;

	public Quaternion ProceduralRotation;

	public Vector3 HelperDiffPosition;

	public Quaternion HelperDiffRoation;

	public Vector3 PreviousPosition;

	public Vector3 DefaultForward;

	public float StraightenFactor;

	public float TargetStraightenFactor;

	private float boneLengthB = 0.1f;

	private float boneLengthF = 0.1f;

	private Vector3 boneLocalOffsetB;

	private Vector3 boneLocalOffsetF;

	public float MotionWeight = 1f;

	public Quaternion FinalRotation;

	public Vector3 FinalPosition;

	public Vector3 ManualPosOffset;

	public Quaternion ManualRotOffset;

	public Vector3 ReferencePosition;

	public Vector3 PreviousReferencePosition;

	public Quaternion ReferenceRotation;

	private Quaternion lastKeyframeRotation;

	private Vector3 lastKeyframePosition;

	private Vector3 lastFinalLocalPosition;

	private Quaternion lastFinalLocalRotation;

	public Vector3 forward;

	public Vector3 right;

	public Vector3 up;

	public bool Collide = true;

	public float CollisionRadius = 1f;

	public Vector3 ColliderOffset = Vector3.zero;

	public float BoneLength { get; private set; }

	public Vector3 BoneLocalOffset { get; private set; }

	public Vector3 InitialLocalPosition { get; private set; }

	public Quaternion InitialLocalRotation { get; private set; }

	public void UpdateReferencePosition(Vector3 pos)
	{
		PreviousReferencePosition = ReferencePosition;
		ReferencePosition = pos;
	}

	public void ZeroKeyframeCheck()
	{
		if (FEngineering.QIsSame(lastFinalLocalRotation, transform.localRotation))
		{
			transform.localRotation = lastKeyframeRotation;
		}
		else
		{
			lastKeyframeRotation = transform.localRotation;
		}
		if (FEngineering.VIsSame(lastFinalLocalPosition, transform.localPosition))
		{
			transform.localPosition = lastKeyframePosition;
		}
		else
		{
			lastKeyframePosition = transform.localPosition;
		}
	}

	public void RefreshFinalLocalPose()
	{
		lastFinalLocalPosition = transform.localPosition;
		lastFinalLocalRotation = transform.localRotation;
	}

	public SpineBone(Transform t)
	{
		transform = t;
		ManualPosOffset = Vector3.zero;
		ColliderOffset = Vector3.zero;
		Collide = true;
		CollisionRadius = 1f;
	}

	public void PrepareBone(Transform baseTransform, List<SpineBone> bones, int index)
	{
		InitialLocalPosition = transform.localPosition;
		InitialLocalRotation = transform.localRotation;
		Vector3 vector = ((index != bones.Count - 1) ? bones[index + 1].transform.position : ((bones[index].transform.childCount <= 0) ? bones[index - 1].transform.position : bones[index].transform.GetChild(0).position));
		if (index == 0)
		{
			vector = bones[index + 1].transform.position;
		}
		if (Vector3.Distance(baseTransform.InverseTransformPoint(vector), baseTransform.InverseTransformPoint(bones[index].transform.position)) < 0.01f)
		{
			int num = index + 2;
			if (num < bones.Count)
			{
				DefaultForward = transform.InverseTransformPoint(bones[num].transform.position);
			}
			else
			{
				DefaultForward = transform.InverseTransformPoint(vector - baseTransform.position);
			}
		}
		else
		{
			DefaultForward = transform.InverseTransformPoint(vector);
		}
		boneLengthB = (baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(vector)).magnitude;
		boneLocalOffsetB = baseTransform.InverseTransformPoint(vector);
		boneLengthF = (baseTransform.InverseTransformPoint(transform.position) - baseTransform.InverseTransformPoint(vector)).magnitude;
		boneLocalOffsetF = baseTransform.InverseTransformPoint(vector);
		if (ManualPosOffset.sqrMagnitude == 0f)
		{
			ManualPosOffset = Vector3.zero;
		}
		if (ManualRotOffset.eulerAngles.sqrMagnitude == 0f)
		{
			ManualRotOffset = Quaternion.identity;
		}
		SetDistanceForFrameForward();
		PrepareAxes(baseTransform, bones, index);
	}

	public void SetDistanceForFrameForward()
	{
		BoneLength = boneLengthF;
		BoneLocalOffset = boneLocalOffsetF;
	}

	public void SetDistanceForFrameBackward()
	{
		BoneLength = boneLengthB;
		BoneLocalOffset = boneLocalOffsetB;
	}

	public float GetUnscalledBoneLength()
	{
		if (boneLengthF > boneLengthB)
		{
			return boneLengthF;
		}
		return boneLengthB;
	}

	private void PrepareAxes(Transform baseTransform, List<SpineBone> bonesList, int index)
	{
		Transform transform;
		Vector3 position;
		Vector3 position2;
		if (index == bonesList.Count - 1)
		{
			if (this.transform.childCount == 1)
			{
				transform = this.transform;
				Transform child = this.transform.GetChild(0);
				position = transform.position;
				position2 = child.position;
			}
			else
			{
				transform = this.transform;
				_ = this.transform;
				position = bonesList[index - 1].transform.position;
				position2 = this.transform.position;
			}
		}
		else
		{
			transform = this.transform;
			Transform obj = bonesList[index + 1].transform;
			position = transform.position;
			position2 = obj.position;
		}
		Vector3 direction = transform.InverseTransformDirection(position2) - transform.InverseTransformDirection(position);
		Vector3 normalized = Vector3.ProjectOnPlane(baseTransform.up, this.transform.TransformDirection(direction).normalized).normalized;
		Vector3 direction2 = transform.InverseTransformDirection(position + normalized) - transform.InverseTransformDirection(position);
		Vector3 vector = Vector3.Cross(this.transform.TransformDirection(direction), this.transform.TransformDirection(direction2));
		right = (transform.InverseTransformDirection(position + vector) - transform.InverseTransformDirection(position)).normalized;
		up = direction2.normalized;
		forward = direction.normalized;
	}

	internal void CalculateDifferencePose(Vector3 upAxis, Vector3 rightAxis)
	{
		HelperDiffPosition = ProceduralPosition - ReferencePosition;
		Quaternion quaternion = ProceduralRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
		Quaternion rotation = ReferenceRotation * Quaternion.FromToRotation(up, upAxis) * Quaternion.FromToRotation(right, rightAxis);
		HelperDiffRoation = quaternion * Quaternion.Inverse(rotation);
	}

	internal void ApplyDifferencePose()
	{
		FinalPosition = transform.position + HelperDiffPosition;
		FinalRotation = HelperDiffRoation * transform.rotation;
	}

	public void Editor_SetLength(float length)
	{
		if (!Application.isPlaying)
		{
			BoneLength = length;
		}
	}

	public float GetCollisionRadiusScaled()
	{
		return CollisionRadius * transform.lossyScale.x;
	}
}
