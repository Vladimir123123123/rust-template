using System;
using Unity.Mathematics;
using UnityEngine;

public readonly struct SubGrid : IEquatable<SubGrid>
{
	public readonly int x;

	public readonly int y;

	public readonly int z;

	public const float Resolution = 2f;

	public const float HalfResolution = 1f;

	public SubGrid(int x, int y, int z)
	{
		this.x = x;
		this.y = y;
		this.z = z;
	}

	public SubGrid(int3 p)
	{
		x = p.x;
		y = p.y;
		z = p.z;
	}

	public int GetOffset(float axis)
	{
		return Mathf.RoundToInt(axis / 2f / 2f);
	}

	public Vector3 GetCenterPoint()
	{
		return new Vector3((float)(x - GetOffset(TerrainMeta.Size.x)) * 2f, (float)(y - GetOffset(MaxY)) * 2f, (float)(z - GetOffset(TerrainMeta.Size.z)) * 2f);
	}

	public override string ToString()
	{
		return $"(x: {x}, y: {y}, z: {z}) - {GetCenterPoint()}, {IsBlocked()}";
	}

	public bool Equals(SubGrid other)
	{
		if (x == other.x && y == other.y)
		{
			return z == other.z;
		}
		return false;
	}

	public override int GetHashCode()
	{
		return HashCode.Combine(x, y, z);
	}

	public bool IsBlocked()
	{
		bool flag = false;
		for (int i = 0; i < GridOffsets.Length; i++)
		{
			Vector3 pos = GetCenterPoint() + GridOffsets[i];
			flag = false;
			if (OcclusionIncludeRocks)
			{
				flag = AntiHack.IsInsideMesh(pos);
			}
			if (!flag && !AntiHack.TestInsideTerrain(pos))
			{
				return false;
			}
		}
		if (flag)
		{
			return AntiHack.isInsideRayHit.collider.gameObject.HasCustomTag(GameObjectTag.AllowBarricadePlacement);
		}
		return true;
	}

	public int GetIndex()
	{
		return GetSubGridIndex(x, y, z);
	}

	public int GetDistance(SubGrid other)
	{
		return Mathf.Abs(x - other.x) + Mathf.Abs(y - other.y) + Mathf.Abs(z - other.z);
	}
}
