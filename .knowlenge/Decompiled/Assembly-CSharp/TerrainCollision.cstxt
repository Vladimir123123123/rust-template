using System;
using System.Collections.Generic;
using Facepunch;
using Unity.Collections;
using UnityEngine;

public class TerrainCollision : TerrainExtension
{
	public TerrainIgnoreGrid TerrainIgnoreGrid;

	public ListDictionary<Collider, List<Collider>> ignoredColliders;

	public TerrainCollider terrainCollider;

	public const float IgnoreRadius = 0.01f;

	public override void Setup()
	{
		ignoredColliders = new ListDictionary<Collider, List<Collider>>();
		terrainCollider = terrain.GetComponent<TerrainCollider>();
		TerrainIgnoreGrid = new TerrainIgnoreGrid();
	}

	private void OnDestroy()
	{
		TerrainIgnoreGrid.Dispose();
	}

	public void Clear()
	{
		if (!terrainCollider)
		{
			return;
		}
		foreach (Collider key in ignoredColliders.Keys)
		{
			Physics.IgnoreCollision(key, terrainCollider, ignore: false);
		}
		ignoredColliders.Clear();
	}

	public void Reset(Collider collider)
	{
		if ((bool)terrainCollider && (bool)collider)
		{
			Physics.IgnoreCollision(collider, terrainCollider, ignore: false);
			ignoredColliders.Remove(collider);
		}
	}

	public bool GetIgnore(Vector3 pos, float radius = 0.01f)
	{
		using (TimeWarning.New("TerrainCollision.GetIgnore"))
		{
			if (!TerrainIgnoreGrid.Check(pos, radius))
			{
				return false;
			}
			return GamePhysics.CheckSphere<TerrainCollisionTrigger>(pos, radius, 262144, QueryTriggerInteraction.Collide);
		}
	}

	public void GetIgnore(Span<bool> results, ReadOnlySpan<Vector3> positions, ReadOnlySpan<float> radii)
	{
		BufferList<int> obj = Pool.Get<BufferList<int>>();
		for (int i = 0; i < positions.Length; i++)
		{
			if (TerrainIgnoreGrid.Check(positions[i], radii[i]))
			{
				obj.Add(i);
			}
			else
			{
				results[i] = false;
			}
		}
		NativeArray<Vector3> source = new NativeArray<Vector3>(obj.Count, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
		NativeArray<float> source2 = new NativeArray<float>(obj.Count, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
		for (int j = 0; j < obj.Count; j++)
		{
			int index = obj[j];
			source[j] = positions[index];
			source2[j] = radii[index];
		}
		GamePhysics.CheckSphere<TerrainCollisionTrigger>(results, source, source2, 262144, QueryTriggerInteraction.Collide);
		CollectionUtil.ScatterOutInplace(results, obj.ContentReadOnlySpan(), defValue: false);
		Pool.FreeUnmanaged(ref obj);
	}

	public bool GetIgnore(RaycastHit hit)
	{
		using (TimeWarning.New("TerrainCollision.GetIgnore"))
		{
			if (!(hit.collider is TerrainCollider))
			{
				return false;
			}
			if (!TerrainIgnoreGrid.Check(hit.point))
			{
				return false;
			}
			return hit.collider is TerrainCollider && GetIgnore(hit.point);
		}
	}

	public bool GetIgnore(Collider collider)
	{
		if (!terrainCollider || !collider)
		{
			return false;
		}
		return ignoredColliders.Contains(collider);
	}

	public void SetIgnore(Collider collider, Collider trigger, bool ignore = true)
	{
		if (!terrainCollider || !collider)
		{
			return;
		}
		if (!GetIgnore(collider))
		{
			if (ignore)
			{
				List<Collider> val = new List<Collider> { trigger };
				Physics.IgnoreCollision(collider, terrainCollider, ignore: true);
				ignoredColliders.Add(collider, val);
			}
			return;
		}
		List<Collider> list = ignoredColliders[collider];
		if (ignore)
		{
			if (!list.Contains(trigger))
			{
				list.Add(trigger);
			}
		}
		else if (list.Contains(trigger))
		{
			list.Remove(trigger);
		}
	}

	protected void LateUpdate()
	{
		if (ignoredColliders == null)
		{
			return;
		}
		for (int i = 0; i < ignoredColliders.Count; i++)
		{
			KeyValuePair<Collider, List<Collider>> byIndex = ignoredColliders.GetByIndex(i);
			Collider key = byIndex.Key;
			List<Collider> value = byIndex.Value;
			if (key == null)
			{
				ignoredColliders.RemoveAt(i--);
			}
			else if (value.Count == 0)
			{
				Physics.IgnoreCollision(key, terrainCollider, ignore: false);
				ignoredColliders.RemoveAt(i--);
			}
		}
	}
}
