using System;
using System.Collections.Generic;
using Facepunch;
using Unity.Collections;
using Unity.Mathematics;
using UnityEngine;

public static class WaterLevel
{
	public struct WaterInfo
	{
		public bool isValid;

		public float currentDepth;

		public float overallDepth;

		public float surfaceLevel;

		public float terrainHeight;

		public bool artificalWater;

		public int topology;
	}

	public static float Factor(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.Factor"))
		{
			return Factor(GetWaterInfo(start, end, radius, waves, volumes, forEntity), start, end, radius);
		}
	}

	public static float Factor(in WaterInfo info, Vector3 start, Vector3 end, float radius)
	{
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(Mathf.Min(start.y, end.y) - radius, Mathf.Max(start.y, end.y) + radius, info.surfaceLevel);
	}

	public static float Factor(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.Factor"))
		{
			if (bounds.size == Vector3.zero)
			{
				bounds.size = new Vector3(0.1f, 0.1f, 0.1f);
			}
			WaterInfo waterInfo = GetWaterInfo(bounds, waves, volumes, forEntity);
			return waterInfo.isValid ? Mathf.InverseLerp(bounds.min.y, bounds.max.y, waterInfo.surfaceLevel) : 0f;
		}
	}

	public static float Factor(in WaterInfo info, Bounds bounds)
	{
		if (bounds.size == Vector3.zero)
		{
			bounds.size = new Vector3(0.1f, 0.1f, 0.1f);
		}
		if (!info.isValid)
		{
			return 0f;
		}
		return Mathf.InverseLerp(bounds.min.y, bounds.max.y, info.surfaceLevel);
	}

	public static bool Test(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.Test"))
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).isValid;
		}
	}

	public static bool Test(in WaterInfo info, bool volumes, Vector3 pos, BaseEntity forEntity = null)
	{
		bool flag = pos.y >= info.terrainHeight - 1f && pos.y <= info.surfaceLevel;
		if (!flag && volumes)
		{
			flag = GetWaterInfoFromVolumes(pos, forEntity).isValid;
		}
		return flag;
	}

	public static (float, float) GetWaterAndTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterDepth"))
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return (waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
	}

	public static float GetWaterOrTerrainSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterDepth"))
		{
			WaterInfo waterInfo = GetWaterInfo(pos, waves, volumes, forEntity);
			return Mathf.Max(waterInfo.surfaceLevel, waterInfo.terrainHeight);
		}
	}

	public static float GetWaterSurface(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterDepth"))
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).surfaceLevel;
		}
	}

	public static float GetWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterDepth"))
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).currentDepth;
		}
	}

	public static float GetOverallWaterDepth(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetOverallWaterDepth"))
		{
			return GetWaterInfo(pos, waves, volumes, forEntity).overallDepth;
		}
	}

	public static Vector3 GetWaterFlowDirection(Vector3 worldPosition)
	{
		if (TerrainMeta.WaterFlowMap == null)
		{
			return Vector3.zero;
		}
		return TerrainMeta.WaterFlowMap.GetFlowDirection(worldPosition);
	}

	public static Vector3 GetWaterNormal(Vector3 pos)
	{
		return Vector3.up;
	}

	public static WaterInfo GetBuoyancyWaterInfo(Vector3 pos, Vector2 posUV, float terrainHeight, float waterHeight, bool doDeepwaterChecks, BaseEntity forEntity)
	{
		using (TimeWarning.New("WaterLevel.GetWaterInfo"))
		{
			WaterInfo result = default(WaterInfo);
			if (pos.y > waterHeight)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag = pos.y < terrainHeight - 1f;
			if (flag)
			{
				return GetWaterInfoFromVolumes(pos, forEntity);
			}
			bool flag2 = doDeepwaterChecks && (pos.y < waterHeight - 10f || TerrainMeta.OutOfBounds(pos));
			int num = (TerrainMeta.TopologyMap ? TerrainMeta.TopologyMap.GetTopologyFast(posUV) : 0);
			if ((flag || flag2 || (num & 0x3C180) == 0) && (bool)WaterSystem.Collision && WaterSystem.Collision.GetIgnore(pos))
			{
				return result;
			}
			if (flag2 && Physics.Raycast(pos, Vector3.up, out var hitInfo, 5f, 16, QueryTriggerInteraction.Collide))
			{
				waterHeight = Mathf.Min(waterHeight, hitInfo.collider.bounds.max.y);
			}
			result.isValid = true;
			result.currentDepth = Mathf.Max(0f, waterHeight - pos.y);
			result.overallDepth = Mathf.Max(0f, waterHeight - terrainHeight);
			result.surfaceLevel = waterHeight;
			result.terrainHeight = terrainHeight;
			result.topology = num;
			return result;
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 pos, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterInfo"))
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(pos, waves);
			float num2 = (((bool)TerrainMeta.HeightMap && TerrainMeta.HeightMap.isInitialized) ? TerrainMeta.HeightMap.GetHeight(pos) : 0f);
			result.isValid = true;
			if (pos.y > num)
			{
				result.isValid = false;
			}
			else if (pos.y < num2 - 1f)
			{
				result.isValid = false;
			}
			bool flag = false;
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(pos, forEntity);
				if (result.isValid)
				{
					flag = true;
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && (bool)WaterSystem.Collision && WaterSystem.Collision.GetIgnore(pos))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - pos.y);
			if (!flag)
			{
				result.overallDepth = Mathf.Max(0f, num - num2);
			}
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
	}

	public static WaterInfo GetWaterInfo(Bounds bounds, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterInfo"))
		{
			WaterInfo result = default(WaterInfo);
			float num = GetWaterLevel(bounds.center, waves);
			float num2 = (TerrainMeta.HeightMap ? TerrainMeta.HeightMap.GetHeight(bounds.center) : 0f);
			result.isValid = true;
			if (bounds.min.y > num)
			{
				result.isValid = false;
			}
			else if (bounds.max.y < num2 - 1f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(bounds, forEntity);
				if (result.isValid)
				{
					num = result.surfaceLevel;
				}
			}
			if (result.isValid && (bool)WaterSystem.Collision && WaterSystem.Collision.GetIgnore(bounds))
			{
				result.isValid = false;
				num = -1000f;
			}
			result.currentDepth = Mathf.Max(0f, num - bounds.min.y);
			result.overallDepth = Mathf.Max(0f, num - num2);
			result.surfaceLevel = num;
			result.terrainHeight = num2;
			return result;
		}
	}

	public static void GetWaterInfos(ReadOnlySpan<Vector3> starts, ReadOnlySpan<Vector3> ends, ReadOnlySpan<float> radii, ReadOnlySpan<BaseEntity> entities, bool waves, bool volumes, Span<WaterInfo> results)
	{
		using (TimeWarning.New("WaterLevel.GetWaterInfos"))
		{
			NativeArray<Vector3> source = new NativeArray<Vector3>(starts.Length, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			for (int i = 0; i < starts.Length; i++)
			{
				Vector3 value = (starts[i] + ends[i]) * 0.5f;
				source[i] = value;
			}
			NativeArray<float> heights = new NativeArray<float>(starts.Length, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			GetWaterLevels(source, waves, heights);
			NativeArray<float> nativeArray = new NativeArray<float>(starts.Length, Allocator.Temp, (!TerrainMeta.HeightMap) ? NativeArrayOptions.ClearMemory : NativeArrayOptions.UninitializedMemory);
			if ((bool)TerrainMeta.HeightMap)
			{
				for (int j = 0; j < starts.Length; j++)
				{
					nativeArray[j] = TerrainMeta.HeightMap.GetHeight(source[j]);
				}
			}
			BufferList<int> obj = null;
			BufferList<Vector3> obj2 = null;
			BufferList<Vector3> obj3 = null;
			BufferList<float> obj4 = null;
			BufferList<BaseEntity> obj5 = null;
			if (volumes)
			{
				obj = Pool.Get<BufferList<int>>();
				obj2 = Pool.Get<BufferList<Vector3>>();
				obj3 = Pool.Get<BufferList<Vector3>>();
				obj4 = Pool.Get<BufferList<float>>();
				obj5 = Pool.Get<BufferList<BaseEntity>>();
			}
			for (int k = 0; k < starts.Length; k++)
			{
				ref WaterInfo reference = ref results[k];
				reference.isValid = true;
				Vector3 element = starts[k];
				Vector3 element2 = ends[k];
				float num = radii[k];
				float num2 = Mathf.Min(element.y, element2.y) - num;
				float num3 = Mathf.Max(element.y, element2.y) + num;
				float num4 = heights[k];
				float num5 = nativeArray[k];
				if (num2 > num4)
				{
					reference.isValid = false;
				}
				else if (num3 < num5 - 1f)
				{
					reference.isValid = false;
				}
				if (volumes && !reference.isValid)
				{
					obj.Add(k);
					obj2.Add(element);
					obj3.Add(element2);
					obj4.Add(num);
					obj5.Add(entities[k]);
				}
			}
			if (volumes && obj5 != null && obj5.Count > 0)
			{
				BufferList<WaterInfo> bufferList = new BufferList<WaterInfo>();
				bufferList.Resize(obj5.Count);
				BaseEntity.WaterTestFromVolumes(obj5.ContentReadOnlySpan(), obj2.ContentReadOnlySpan(), obj3.ContentReadOnlySpan(), obj4.ContentReadOnlySpan(), bufferList.Buffer);
				for (int l = 0; l < obj.Count; l++)
				{
					int index = obj[l];
					WaterInfo waterInfo = bufferList[l];
					results[index] = waterInfo;
					if (waterInfo.isValid)
					{
						heights[index] = waterInfo.surfaceLevel;
					}
				}
				Pool.FreeUnmanaged(ref obj);
				Pool.FreeUnmanaged(ref obj2);
				Pool.FreeUnmanaged(ref obj3);
				Pool.FreeUnmanaged(ref obj4);
				Pool.FreeUnmanaged(ref obj5);
			}
			if ((bool)WaterSystem.Collision)
			{
				obj = Pool.Get<BufferList<int>>();
				obj2 = Pool.Get<BufferList<Vector3>>();
				obj3 = Pool.Get<BufferList<Vector3>>();
				obj4 = Pool.Get<BufferList<float>>();
				for (int m = 0; m < starts.Length; m++)
				{
					if (results[m].isValid)
					{
						obj.Add(m);
						obj2.Add(starts[m]);
						obj3.Add(ends[m]);
						obj4.Add(radii[m]);
					}
				}
				BufferList<bool> bufferList2 = Pool.Get<BufferList<bool>>();
				bufferList2.Resize(obj.Count);
				WaterSystem.Collision.GetIgnore(bufferList2.Buffer, obj2.ContentReadOnlySpan(), obj3.ContentReadOnlySpan(), obj4.ContentReadOnlySpan());
				BufferList<int> obj6 = Pool.Get<BufferList<int>>();
				obj2.Clear();
				obj4.Clear();
				for (int n = 0; n < obj.Count; n++)
				{
					if (bufferList2[n])
					{
						int num6 = obj[n];
						Vector3 vector = starts[num6];
						Vector3 vector2 = ends[num6];
						float num7 = radii[num6];
						float a = Mathf.Min(vector.y, vector2.y) - num7;
						float b = Mathf.Max(vector.y, vector2.y) + num7;
						Vector3 element3 = source[num6].WithY(Mathf.Lerp(a, b, 0.75f));
						obj6.Add(num6);
						obj2.Add(element3);
						obj4.Add(0.01f);
					}
				}
				WaterSystem.Collision.GetIgnore(bufferList2.Buffer, obj2.ContentReadOnlySpan(), obj4.ContentReadOnlySpan());
				for (int num8 = 0; num8 < obj6.Count; num8++)
				{
					int index2 = obj6[num8];
					float a2 = heights[index2];
					if (bufferList2[num8])
					{
						results[index2].isValid = false;
						a2 = -1000f;
					}
					else
					{
						a2 = Mathf.Min(a2, obj2[num8].y);
					}
					heights[index2] = a2;
				}
				Pool.FreeUnmanaged(ref obj6);
				Pool.FreeUnmanaged(ref obj);
				Pool.FreeUnmanaged(ref obj2);
				Pool.FreeUnmanaged(ref obj3);
				Pool.FreeUnmanaged(ref obj4);
			}
			for (int num9 = 0; num9 < starts.Length; num9++)
			{
				ref WaterInfo reference2 = ref results[num9];
				Vector3 vector3 = starts[num9];
				Vector3 vector4 = ends[num9];
				float num10 = radii[num9];
				float num11 = Mathf.Min(vector3.y, vector4.y) - num10;
				float num12 = heights[num9];
				float num13 = nativeArray[num9];
				reference2.currentDepth = Mathf.Max(0f, num12 - num11);
				reference2.overallDepth = Mathf.Max(0f, num12 - num13);
				reference2.surfaceLevel = num12;
				reference2.terrainHeight = num13;
			}
			nativeArray.Dispose();
			heights.Dispose();
			source.Dispose();
		}
	}

	public static WaterInfo GetWaterInfo(Vector3 start, Vector3 end, float radius, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterInfo"))
		{
			WaterInfo result = default(WaterInfo);
			Vector3 vector = (start + end) * 0.5f;
			float num = Mathf.Min(start.y, end.y) - radius;
			float num2 = Mathf.Max(start.y, end.y) + radius;
			float num3 = GetWaterLevel(vector, waves);
			float num4 = (TerrainMeta.HeightMap ? TerrainMeta.HeightMap.GetHeight(vector) : 0f);
			result.isValid = true;
			if (num > num3)
			{
				result.isValid = false;
			}
			else if (num2 < num4 - 1f)
			{
				result.isValid = false;
			}
			if (!result.isValid && volumes)
			{
				result = GetWaterInfoFromVolumes(start, end, radius, forEntity);
				if (result.isValid)
				{
					num3 = result.surfaceLevel;
				}
			}
			if (result.isValid && (bool)WaterSystem.Collision && WaterSystem.Collision.GetIgnore(start, end, radius))
			{
				Vector3 pos = vector.WithY(Mathf.Lerp(num, num2, 0.75f));
				if (!WaterSystem.Collision.GetIgnore(pos))
				{
					num3 = Mathf.Min(num3, pos.y);
				}
				else
				{
					result.isValid = false;
					num3 = -1000f;
				}
			}
			result.currentDepth = Mathf.Max(0f, num3 - num);
			result.overallDepth = Mathf.Max(0f, num3 - num4);
			result.surfaceLevel = num3;
			result.terrainHeight = num4;
			return result;
		}
	}

	public static WaterInfo GetWaterInfo(Camera cam, bool waves, bool volumes, BaseEntity forEntity = null)
	{
		using (TimeWarning.New("WaterLevel.GetWaterInfo"))
		{
			waves = waves && WaterSystem.Instance != null;
			float num = WaterSystem.OceanLevel;
			if (waves)
			{
				num += WaterSystem.Instance.oceanSimulation.MinLevel();
			}
			if (cam.transform.position.y < num - 1f)
			{
				return GetWaterInfo(cam.transform.position, waves, volumes, forEntity);
			}
			return GetWaterInfo(cam.transform.position - Vector3.up, waves, volumes, forEntity);
		}
	}

	public static float GetWaterLevel(Vector3 pos, bool waves)
	{
		waves = waves && WaterSystem.Instance != null;
		float normX = TerrainMeta.NormalizeX(pos.x);
		float normZ = TerrainMeta.NormalizeZ(pos.z);
		float num = (TerrainMeta.WaterMap ? TerrainMeta.WaterMap.GetHeight(normX, normZ) : TerrainMeta.Position.y);
		float num2 = WaterSystem.OceanLevel;
		if (waves)
		{
			num2 += WaterSystem.Instance.oceanSimulation.MaxLevel();
		}
		if (num < num2 && (!TerrainMeta.TopologyMap || TerrainMeta.TopologyMap.GetTopology(normX, normZ, 384)))
		{
			float num3 = WaterSystem.OceanLevel;
			if (waves)
			{
				num3 += WaterSystem.Instance.oceanSimulation.GetHeight(pos);
			}
			return Mathf.Max(num, num3);
		}
		return num;
	}

	public static void GetWaterLevels(ReadOnlySpan<Vector3> positions, bool waves, NativeArray<float> heights)
	{
		waves = waves && WaterSystem.Instance != null;
		float num = WaterSystem.OceanLevel;
		if (waves)
		{
			num += WaterSystem.Instance.oceanSimulation.MaxLevel();
		}
		int num2 = 0;
		NativeArray<int> nativeArray = new NativeArray<int>(positions.Length, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
		for (int i = 0; i < positions.Length; i++)
		{
			float normX = TerrainMeta.NormalizeX(positions[i].x);
			float normZ = TerrainMeta.NormalizeZ(positions[i].z);
			heights[i] = (TerrainMeta.WaterMap ? TerrainMeta.WaterMap.GetHeight(normX, normZ) : TerrainMeta.Position.y);
			if (heights[i] < num && (!TerrainMeta.TopologyMap || TerrainMeta.TopologyMap.GetTopology(normX, normZ, 384)))
			{
				if (waves)
				{
					nativeArray[num2++] = i;
				}
				else
				{
					heights[i] = Mathf.Max(heights[i], WaterSystem.OceanLevel);
				}
			}
		}
		if (num2 == 0)
		{
			nativeArray.Dispose();
			return;
		}
		NativeArray<float> nativeArray2 = new NativeArray<float>(num2, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
		NativeArray<float3> positions2 = new NativeArray<float3>(num2, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
		NativeArray<float> nativeArray3 = new NativeArray<float>(num2, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
		NativeArray<float> nativeArray4 = new NativeArray<float>(num2, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
		for (int j = 0; j < num2; j++)
		{
			int index = nativeArray[j];
			float x = TerrainMeta.NormalizeX(positions[index].x);
			float y = TerrainMeta.NormalizeZ(positions[index].z);
			Vector2 uv = new Vector2(x, y);
			positions2[j] = positions[index];
			nativeArray3[j] = ((TerrainMeta.HeightMap != null) ? TerrainMeta.HeightMap.GetHeightFast(uv) : 0f);
			nativeArray4[j] = ((TerrainTexturing.Instance != null) ? TerrainTexturing.Instance.GetCoarseDistanceToShore(uv) : 0f);
		}
		WaterSystem.Instance.oceanSimulation.GetHeightBatch(positions2, nativeArray2.AsSpan(), nativeArray4.AsReadOnlySpan(), nativeArray3.AsReadOnlySpan());
		for (int k = 0; k < num2; k++)
		{
			int index2 = nativeArray[k];
			float b = WaterSystem.OceanLevel + nativeArray2[k];
			heights[index2] = Mathf.Max(heights[index2], b);
		}
		nativeArray.Dispose();
		nativeArray4.Dispose();
		nativeArray3.Dispose();
		positions2.Dispose();
		nativeArray2.Dispose();
	}

	private static WaterInfo GetWaterInfoFromVolumes(Bounds bounds, BaseEntity forEntity)
	{
		WaterInfo info = default(WaterInfo);
		if (forEntity == null)
		{
			List<WaterVolume> obj = Pool.Get<List<WaterVolume>>();
			Vis.Components(new OBB(bounds), obj, 262144);
			using (List<WaterVolume>.Enumerator enumerator = obj.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(bounds, out info))
				{
				}
			}
			Pool.FreeUnmanaged(ref obj);
			return info;
		}
		forEntity.WaterTestFromVolumes(bounds, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 pos, BaseEntity forEntity)
	{
		WaterInfo info = default(WaterInfo);
		if (forEntity == null)
		{
			List<WaterVolume> obj = Pool.Get<List<WaterVolume>>();
			Vis.Components(pos, 0.1f, obj, 262144);
			foreach (WaterVolume item in obj)
			{
				if (item.Test(pos, out info))
				{
					info.artificalWater = !item.naturalSource;
					break;
				}
			}
			Pool.FreeUnmanaged(ref obj);
			return info;
		}
		forEntity.WaterTestFromVolumes(pos, out info);
		return info;
	}

	private static WaterInfo GetWaterInfoFromVolumes(Vector3 start, Vector3 end, float radius, BaseEntity forEntity)
	{
		WaterInfo info = default(WaterInfo);
		if (forEntity == null)
		{
			List<WaterVolume> obj = Pool.Get<List<WaterVolume>>();
			Vis.Components(start, end, radius, obj, 262144);
			using (List<WaterVolume>.Enumerator enumerator = obj.GetEnumerator())
			{
				while (enumerator.MoveNext() && !enumerator.Current.Test(start, end, radius, out info))
				{
				}
			}
			Pool.FreeUnmanaged(ref obj);
			return info;
		}
		forEntity.WaterTestFromVolumes(start, end, radius, out info);
		return info;
	}

	private static void GetWaterInfoFromVolumes(ReadOnlySpan<Vector3> starts, ReadOnlySpan<Vector3> ends, ReadOnlySpan<float> radii, ReadOnlySpan<BaseEntity> entities, Span<WaterInfo> results)
	{
		BufferList<int> obj = Pool.Get<BufferList<int>>();
		BufferList<int> obj2 = Pool.Get<BufferList<int>>();
		BufferList<Vector3> obj3 = Pool.Get<BufferList<Vector3>>();
		BufferList<Vector3> obj4 = Pool.Get<BufferList<Vector3>>();
		BufferList<float> obj5 = Pool.Get<BufferList<float>>();
		BufferList<BaseEntity> obj6 = Pool.Get<BufferList<BaseEntity>>();
		for (int i = 0; i < entities.Length; i++)
		{
			BaseEntity baseEntity = entities[i];
			if (baseEntity != null)
			{
				obj3.Add(starts[i]);
				obj4.Add(ends[i]);
				obj5.Add(radii[i]);
				obj6.Add(baseEntity);
				obj.Add(i);
			}
			else
			{
				obj2.Add(i);
			}
		}
		for (int j = 0; j < obj2.Count; j++)
		{
			int num = obj2[j];
			obj3.Add(starts[num]);
			obj4.Add(ends[num]);
			obj5.Add(radii[num]);
			obj.Add(num);
		}
		int num2 = entities.Length - obj2.Count;
		int count = obj2.Count;
		if (num2 > 0)
		{
			BaseEntity.WaterTestFromVolumes(starts: new ReadOnlySpan<Vector3>(obj3.Buffer, 0, num2), ends: new ReadOnlySpan<Vector3>(obj4.Buffer, 0, num2), radii: new ReadOnlySpan<float>(obj5.Buffer, 0, num2), entities: obj6.ContentReadOnlySpan(), results: results);
		}
		if (count > 0)
		{
			ReadOnlySpan<Vector3> starts3 = new ReadOnlySpan<Vector3>(obj3.Buffer, num2, count);
			ReadOnlySpan<Vector3> ends3 = new ReadOnlySpan<Vector3>(obj4.Buffer, num2, count);
			ReadOnlySpan<float> radii3 = new ReadOnlySpan<float>(obj5.Buffer, num2, count);
			NativeArray<int> source = new NativeArray<int>(starts3.Length, Allocator.Temp, NativeArrayOptions.UninitializedMemory);
			for (int k = 0; k < starts3.Length; k++)
			{
				source[k] = 262144;
			}
			BufferList<WaterVolume> obj7 = Pool.Get<BufferList<WaterVolume>>();
			obj7.Resize(starts3.Length * 32);
			Vis.Components<WaterVolume>(starts3, ends3, radii3, source, obj7.Buffer);
			for (int l = 0; l < starts3.Length; l++)
			{
				Vector3 start = starts3[l];
				Vector3 end = ends3[l];
				float radius = radii3[l];
				ref WaterInfo reference = ref results[num2 + l];
				for (int m = 0; m < 32; m++)
				{
					int index = l * 32 + m;
					WaterVolume waterVolume = obj7[index];
					if (waterVolume != null)
					{
						if (waterVolume.Test(start, end, radius, out reference))
						{
							break;
						}
						continue;
					}
					reference.isValid = false;
					break;
				}
			}
			Pool.FreeUnmanaged(ref obj7);
		}
		if (num2 > 0 && count > 0)
		{
			CollectionUtil.SortInplace(results, obj.ContentSpan());
		}
		Pool.FreeUnmanaged(ref obj);
		Pool.FreeUnmanaged(ref obj2);
		Pool.FreeUnmanaged(ref obj3);
		Pool.FreeUnmanaged(ref obj4);
		Pool.FreeUnmanaged(ref obj5);
		Pool.FreeUnmanaged(ref obj6);
	}
}
