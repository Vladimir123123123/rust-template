using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Facepunch;
using Facepunch.Extend;
using Network;
using Newtonsoft.Json;
using Oxide.Core;
using UnityEngine;

public class ConsoleSystem
{
	public class Arg
	{
		public Option Option;

		public Command cmd;

		public string RawCommand;

		public string FullString = "";

		public string[] Args;

		public bool Invalid = true;

		public string Reply = "";

		public bool Silent;

		public bool IsClientside => Option.IsClient;

		public bool IsServerside => Option.IsServer;

		public Connection Connection => Option.Connection;

		public bool IsConnectionAdmin
		{
			get
			{
				if (Option.Connection != null && Option.Connection.connected && Option.Connection.authLevel != 0)
				{
					if (Option.Connection.encryptionLevel > 1)
					{
						return Option.Connection.trusted;
					}
					return true;
				}
				return false;
			}
		}

		public bool IsAdmin
		{
			get
			{
				if (!IsConnectionAdmin)
				{
					return IsRcon;
				}
				return true;
			}
		}

		public bool IsRcon => Option.FromRcon;

		public Arg(Option options, string rconCommand)
		{
			Option = options;
			BuildCommand(rconCommand);
		}

		internal void BuildCommand(string command)
		{
			RawCommand = command;
			if (string.IsNullOrEmpty(command))
			{
				Invalid = true;
				return;
			}
			if (command.IndexOf('.') <= 0 || command.IndexOf(' ', 0, command.IndexOf('.')) != -1)
			{
				command = "global." + command;
			}
			int num = command.IndexOf('.');
			if (num <= 0)
			{
				return;
			}
			string text = command.Substring(0, num);
			if (text.Length < 1)
			{
				return;
			}
			text = text.Trim().ToLower();
			string text2 = command.Substring(num + 1);
			if (text2.Length >= 1)
			{
				int num2 = text2.IndexOf(' ');
				if (num2 > 0)
				{
					FullString = text2.Substring(num2 + 1);
					FullString = FullString.Trim();
					Args = FullString.SplitQuotesStrings(16);
					text2 = text2.Substring(0, num2);
				}
				text2 = text2.Trim().ToLower();
				if (cmd == null && Option.IsClient)
				{
					cmd = Index.Client.Find(text + "." + text2);
				}
				if (cmd == null && Option.IsServer)
				{
					cmd = Index.Server.Find(text + "." + text2);
				}
				Invalid = cmd == null;
			}
		}

		internal bool HasPermission()
		{
			if (cmd == null)
			{
				return false;
			}
			if (Option.IsUnrestricted)
			{
				return true;
			}
			if (IsClientside)
			{
				if (cmd.ClientAdmin)
				{
					if (ClientCanRunAdminCommands != null)
					{
						return ClientCanRunAdminCommands();
					}
					return false;
				}
				if (Option.IsFromServer && !cmd.AllowRunFromServer)
				{
					Debug.Log("Server tried to run command \"" + FullString + "\", but we blocked it.");
					return false;
				}
				return cmd.Client;
			}
			if (cmd.ServerAdmin)
			{
				if (IsRcon)
				{
					return true;
				}
				if (IsAdmin)
				{
					return true;
				}
			}
			if (cmd.ServerUser && Connection != null)
			{
				return true;
			}
			return false;
		}

		internal bool CanSeeInFind(Command command)
		{
			if (command == null)
			{
				return false;
			}
			if (Option.IsUnrestricted)
			{
				return true;
			}
			if (IsClientside)
			{
				return command.Client;
			}
			if (IsServerside)
			{
				return command.Server;
			}
			return false;
		}

		public void ReplyWith(string strValue)
		{
			Reply = strValue;
		}

		public void ReplyWith(object obj)
		{
			Reply = JsonConvert.SerializeObject(obj, (Formatting)1);
		}

		public bool HasArgs(int iMinimum = 1)
		{
			if (Args == null)
			{
				return false;
			}
			return Args.Length >= iMinimum;
		}

		public bool HasArg(string value, bool remove = false)
		{
			if (Args == null)
			{
				return false;
			}
			if (Array.IndexOf(Args, value) == -1)
			{
				return false;
			}
			if (remove)
			{
				Args = Args.Where((string x) => x != value).ToArray();
			}
			return true;
		}

		public string GetString(int iArg, string def = "")
		{
			if (HasArgs(iArg + 1))
			{
				return Args[iArg];
			}
			return def;
		}

		public int GetInt(int iArg, int def = 0)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (int.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public long GetLong(int iArg, long def = 0L)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (long.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public ulong GetULong(int iArg, ulong def = 0uL)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (ulong.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public bool TryGetUInt(int iArg, out uint value)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				value = 0u;
				return false;
			}
			return uint.TryParse(@string, out value);
		}

		public uint GetUInt(int iArg, uint def = 0u)
		{
			if (!TryGetUInt(iArg, out var value))
			{
				return def;
			}
			return value;
		}

		public ulong GetUInt64(int iArg, ulong def = 0uL)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (ulong.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public float GetFloat(int iArg, float def = 0f)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (float.TryParse(@string, out var result))
			{
				return result;
			}
			return def;
		}

		public bool GetBool(int iArg, bool def = false)
		{
			string @string = GetString(iArg, null);
			if (@string == null)
			{
				return def;
			}
			if (@string == string.Empty || @string == "0")
			{
				return false;
			}
			if (@string.Equals("f", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("false", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("no", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("none", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			if (@string.Equals("null", StringComparison.InvariantCultureIgnoreCase))
			{
				return false;
			}
			return true;
		}

		public long GetTimestamp(int iArg, long def = 0L)
		{
			string text = GetString(iArg, null);
			if (text == null)
			{
				return def;
			}
			int num = 3600;
			if (text.Length > 1 && char.IsLetter(text[text.Length - 1]))
			{
				switch (text[text.Length - 1])
				{
				case 's':
					num = 1;
					break;
				case 'm':
					num = 60;
					break;
				case 'h':
					num = 3600;
					break;
				case 'd':
					num = 86400;
					break;
				case 'w':
					num = 604800;
					break;
				case 'M':
					num = 2592000;
					break;
				case 'Y':
					num = 31536000;
					break;
				}
				text = text.Substring(0, text.Length - 1);
			}
			if (long.TryParse(text, out var result))
			{
				if (result > 0 && result <= 315360000)
				{
					return DateTimeOffset.UtcNow.ToUnixTimeSeconds() + result * num;
				}
				return result;
			}
			return def;
		}

		public long GetTicks(int iArg, long def = 0L)
		{
			string text = GetString(iArg, null);
			if (text == null)
			{
				return def;
			}
			int num = 3600;
			if (text.Length > 1 && char.IsLetter(text[text.Length - 1]))
			{
				switch (text[text.Length - 1])
				{
				case 's':
					num = 1;
					break;
				case 'm':
					num = 60;
					break;
				case 'h':
					num = 3600;
					break;
				case 'd':
					num = 86400;
					break;
				case 'w':
					num = 604800;
					break;
				case 'M':
					num = 2592000;
					break;
				case 'Y':
					num = 31536000;
					break;
				}
				text = text.Substring(0, text.Length - 1);
			}
			if (long.TryParse(text, out var result))
			{
				return result * num * 10000000;
			}
			return def;
		}

		public void ReplyWithObject(object rval)
		{
			if (rval != null)
			{
				if (rval is string)
				{
					ReplyWith((string)rval);
					return;
				}
				string strValue = JsonConvert.SerializeObject(rval, (Formatting)1);
				ReplyWith(strValue);
			}
		}

		public Vector3 GetVector3(int iArg, Vector3 def = default(Vector3))
		{
			return GetString(iArg, null)?.ToVector3() ?? def;
		}

		public Color GetColor(int iArg, Color def = default(Color))
		{
			return GetString(iArg, null)?.ToColor() ?? def;
		}
	}

	public class Factory : Attribute
	{
		public string Name;

		public Factory(string systemName)
		{
			Name = systemName;
		}
	}

	public class Command
	{
		public string Name;

		public string Parent;

		public string FullName;

		public Func<string> GetOveride;

		public Action<string> SetOveride;

		public Action<Arg> Call;

		public bool Variable;

		public string Default;

		public string DefaultValue;

		public bool Saved;

		public bool ServerAdmin;

		public bool ServerUser;

		public bool Replicated;

		public bool ShowInAdminUI;

		public bool ClientAdmin;

		public bool Client;

		public bool ClientInfo;

		public bool AllowRunFromServer;

		public string Description = string.Empty;

		public string Arguments = string.Empty;

		public bool Server
		{
			get
			{
				if (!ServerAdmin)
				{
					return ServerUser;
				}
				return true;
			}
		}

		public string String => GetOveride?.Invoke() ?? "";

		public int AsInt => String.ToInt();

		public float AsFloat => String.ToFloat();

		public bool AsBool => String.ToBool();

		public Vector3 AsVector3 => String.ToVector3();

		public event Action<Command> OnValueChanged;

		public Command()
		{
			Call = DefaultCall;
		}

		private void ValueChanged()
		{
			if (Saved)
			{
				HasChanges = true;
			}
			if (ClientInfo)
			{
				SendToServer(BuildCommand("setinfo", FullName, String));
			}
			if (this.OnValueChanged != null)
			{
				this.OnValueChanged(this);
			}
		}

		private void DefaultCall(Arg arg)
		{
			if (SetOveride != null && arg.HasArgs())
			{
				if (arg.IsClientside && Replicated)
				{
					SendToServer(arg.RawCommand);
					arg.Silent = true;
					Debug.LogWarning("ConVar '" + Name + "' will be replicated to all other players on the server");
				}
				else
				{
					Set(arg.Args[0]);
				}
			}
		}

		public void Set(string value)
		{
			if (SetOveride != null)
			{
				string @string = String;
				SetOveride(value);
				if (@string != String)
				{
					ValueChanged();
				}
			}
		}

		public void Set(float f)
		{
			string text = f.ToString("0.00");
			if (!(String == text))
			{
				Set(text);
			}
		}

		public void Set(bool val)
		{
			if (AsBool != val)
			{
				Set(val ? "1" : "0");
			}
		}
	}

	public interface IConsoleCommand
	{
		void Call(Arg arg);
	}

	public interface IConsoleButton
	{
		bool IsPressed { get; set; }
	}

	public static class Index
	{
		public static class Server
		{
			public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static List<Command> Replicated = new List<Command>();

			public static Command Find(string strName)
			{
				if (!strName.Contains("."))
				{
					strName = "global." + strName;
				}
				if (Dict.TryGetValue(strName, out var value))
				{
					return value;
				}
				GlobalDict.TryGetValue(strName.Replace("global.", ""), out value);
				return value;
			}
		}

		public static class Client
		{
			public static Dictionary<string, Command> Dict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Dictionary<string, Command> GlobalDict = new Dictionary<string, Command>(StringComparer.OrdinalIgnoreCase);

			public static Command Find(string strName)
			{
				if (!strName.Contains("."))
				{
					strName = WithGlobal.Get(strName);
				}
				if (Dict.TryGetValue(strName, out var value))
				{
					return value;
				}
				GlobalDict.TryGetValue(WithoutGlobal.Get(strName), out value);
				return value;
			}
		}

		private static readonly Memoized<string, string> WithGlobal = new Memoized<string, string>((string s) => "global." + s);

		private static readonly Memoized<string, string> WithoutGlobal = new Memoized<string, string>((string s) => s.Replace("global.", ""));

		public static Command[] All { get; set; }

		public static void Initialize(Command[] Commands)
		{
			Command[] array = Commands;
			foreach (Command command2 in array)
			{
				if (command2.Variable && command2.GetOveride != null)
				{
					try
					{
						command2.DefaultValue = command2.GetOveride() ?? "";
					}
					catch
					{
					}
				}
			}
			All = Commands;
			Server.Dict = new Dictionary<string, Command>();
			Client.Dict = new Dictionary<string, Command>();
			array = All;
			foreach (Command command3 in array)
			{
				if (command3.Server)
				{
					if (Server.Dict.ContainsKey(command3.FullName))
					{
						Debug.LogWarning("Server Vars have multiple entries for " + command3.FullName);
					}
					else
					{
						Server.Dict.Add(command3.FullName, command3);
					}
					if (command3.Parent != "global" && !Server.GlobalDict.ContainsKey(command3.Name))
					{
						Server.GlobalDict.Add(command3.Name, command3);
					}
					if (command3.Replicated)
					{
						if (!command3.Variable || !command3.ServerAdmin)
						{
							Debug.LogWarning("Replicated server var " + command3.FullName + " has a bad config");
						}
						else
						{
							Server.Replicated.Add(command3);
							command3.OnValueChanged += delegate(Command command)
							{
								ConsoleSystem.OnReplicatedVarChanged?.Invoke(command.FullName, command.String);
							};
						}
					}
				}
				if (command3.Client)
				{
					if (Client.Dict.ContainsKey(command3.FullName))
					{
						Debug.LogWarning("Client Vars have multiple entries for " + command3.FullName);
					}
					else
					{
						Client.Dict.Add(command3.FullName, command3);
					}
					if (command3.Parent != "global" && !Client.GlobalDict.ContainsKey(command3.Name))
					{
						Client.GlobalDict.Add(command3.Name, command3);
					}
				}
			}
			Input.RunBind += delegate(string strCommand, bool pressed)
			{
				Command command4 = Client.Find(strCommand);
				if (command4 != null && command4.Variable && !command4.ClientAdmin && !command4.ServerAdmin && !command4.Replicated)
				{
					command4.Set(pressed);
				}
				else
				{
					Run(Option.Client, $"{strCommand} {pressed}");
				}
			};
		}

		public static void Reset()
		{
			if (All == null)
			{
				return;
			}
			Command[] all = All;
			foreach (Command command in all)
			{
				if (command.Variable && command.Default != null)
				{
					try
					{
						command.Set(command.Default);
					}
					catch (Exception message)
					{
						Debug.LogError(message);
					}
				}
			}
		}
	}

	public struct Option
	{
		public static Option Unrestricted
		{
			get
			{
				Option result = default(Option);
				result.IsServer = true;
				result.IsClient = true;
				result.ForwardtoServerOnMissing = true;
				result.PrintOutput = true;
				result.IsUnrestricted = true;
				return result;
			}
		}

		public static Option Client
		{
			get
			{
				Option result = default(Option);
				result.IsClient = true;
				result.ForwardtoServerOnMissing = true;
				result.PrintOutput = true;
				return result;
			}
		}

		public static Option Server
		{
			get
			{
				Option result = default(Option);
				result.IsServer = true;
				result.PrintOutput = true;
				result.FromRcon = true;
				return result;
			}
		}

		public bool IsServer { get; set; }

		public bool IsClient { get; set; }

		public bool ForwardtoServerOnMissing { get; set; }

		public bool PrintOutput { get; set; }

		public bool IsUnrestricted { get; set; }

		public bool FromRcon { get; set; }

		public bool PrintValueOnly { get; set; }

		public int RconConnectionId { get; set; }

		public bool IsFromServer { get; set; }

		public Connection Connection { get; set; }

		public Option Quiet()
		{
			PrintOutput = false;
			return this;
		}

		public Option WithRconId(int id)
		{
			RconConnectionId = id;
			return this;
		}

		public Option PrintValue()
		{
			PrintValueOnly = true;
			return this;
		}

		public Option FromServer()
		{
			IsFromServer = true;
			return this;
		}

		public Option FromConnection(Connection connection)
		{
			FromRcon = false;
			Connection = connection;
			return this;
		}
	}

	public static bool HasChanges = false;

	public static Func<bool> ClientCanRunAdminCommands;

	public static Func<string, bool> OnSendToServer;

	public static string LastError = null;

	public static Arg CurrentArgs = null;

	private static List<string> ignoredCommands = new List<string> { "projectpath", "useHub", "hubIPC", "cloudEnvironment", "licensingIpc", "hubSessionId", "accessToken" };

	public static event Action<string, string> OnReplicatedVarChanged;

	public static void UpdateValuesFromCommandLine()
	{
		if (Interface.CallHook("IOnRunCommandLine") != null)
		{
			return;
		}
		foreach (KeyValuePair<string, string> @switch in Facepunch.CommandLine.GetSwitches())
		{
			string text = @switch.Value;
			if (text == "")
			{
				text = "1";
			}
			string strCommand = @switch.Key.Substring(1);
			Run(Option.Unrestricted, strCommand, text);
		}
	}

	internal static bool SendToServer(string command)
	{
		if (OnSendToServer != null)
		{
			return OnSendToServer(command);
		}
		return false;
	}

	public static void RunFile(Option options, string strFile)
	{
		string[] array = strFile.Split(new char[1] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
		for (int i = 0; i < array.Length; i++)
		{
			string text = array[i].Trim();
			if (!string.IsNullOrWhiteSpace(text) && text[0] != '#')
			{
				Run(options, text);
			}
		}
		HasChanges = false;
	}

	public static string Run(Option options, string strCommand, params object[] args)
	{
		LastError = null;
		string text = BuildCommand(strCommand, args);
		Arg arg = new Arg(options, text);
		bool flag = arg.HasPermission();
		if (!arg.Invalid && flag)
		{
			Arg currentArgs = CurrentArgs;
			CurrentArgs = arg;
			bool flag2 = Internal(arg);
			CurrentArgs = currentArgs;
			if (options.PrintOutput && flag2 && arg.Reply != null && arg.Reply.Length > 0)
			{
				DebugEx.Log(arg.Reply);
			}
			return arg.Reply;
		}
		LastError = "Command not found";
		if (!flag)
		{
			LastError = "Permission denied";
		}
		if (!options.IsServer && (!options.ForwardtoServerOnMissing || !SendToServer(text)))
		{
			LastError = "Command '" + strCommand + "' not found";
			if (options.PrintOutput && !ignoredCommands.Contains(strCommand))
			{
				DebugEx.Log(LastError);
			}
			return null;
		}
		if (options.IsServer && options.PrintOutput)
		{
			LastError = "Command '" + strCommand + "' not found";
			if (!ignoredCommands.Contains(strCommand))
			{
				DebugEx.Log(LastError);
			}
		}
		return null;
	}

	private static bool Internal(Arg arg)
	{
		if (arg.Invalid)
		{
			return false;
		}
		object obj = Interface.CallHook("IOnServerCommand", arg);
		if (obj is bool)
		{
			return (bool)obj;
		}
		if (!arg.HasPermission())
		{
			arg.ReplyWith("You cannot run this command");
			return false;
		}
		try
		{
			using (TimeWarning.New("ConsoleSystem: " + arg.cmd.FullName))
			{
				arg.cmd.Call(arg);
			}
		}
		catch (Exception ex)
		{
			arg.ReplyWith("Error: " + arg.cmd.FullName + " - " + ex.Message + " (" + ex.Source + ")");
			Debug.LogException(ex);
			return false;
		}
		if (arg.cmd.Variable && arg.cmd.GetOveride != null && string.IsNullOrWhiteSpace(arg.Reply))
		{
			string @string = arg.cmd.String;
			string text = (arg.cmd.Variable ? arg.cmd.String : "");
			if (!arg.Silent)
			{
				if (arg.Option.PrintValueOnly)
				{
					arg.ReplyWith(@string);
				}
				else if (text != @string)
				{
					arg.ReplyWith($"{arg.cmd.FullName}: changed from {Facepunch.Extend.StringExtensions.QuoteSafe(text)} to {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
				}
				else
				{
					arg.ReplyWith($"{arg.cmd.FullName}: {Facepunch.Extend.StringExtensions.QuoteSafe(@string)}");
				}
			}
		}
		return true;
	}

	public static string BuildCommand(string strCommand, params object[] args)
	{
		if (args == null || args.Length == 0)
		{
			return strCommand;
		}
		StringBuilder obj = Pool.Get<StringBuilder>();
		obj.Clear();
		obj.Append(strCommand);
		foreach (object obj2 in args)
		{
			if (obj2 == null)
			{
				obj.Append(" \"\"");
			}
			else if (obj2 is Color color)
			{
				obj.Append(" \"").Append(color.r).Append(',')
					.Append(color.g)
					.Append(',')
					.Append(color.b)
					.Append(',')
					.Append(color.a)
					.Append('"');
			}
			else if (obj2 is Vector3 vector)
			{
				obj.Append(" \"").Append(vector.x).Append(',')
					.Append(vector.y)
					.Append(',')
					.Append(vector.z)
					.Append('"');
			}
			else if (obj2 is IEnumerable<string> enumerable)
			{
				foreach (string item in enumerable)
				{
					obj.Append(' ').QuoteSafe(item);
				}
			}
			else
			{
				obj.Append(' ').QuoteSafe(obj2.ToString());
			}
		}
		string result = obj.ToString();
		obj.Clear();
		Pool.FreeUnmanaged(ref obj);
		return result;
	}

	public static string SaveToConfigString(bool bServer)
	{
		string text = "";
		IEnumerable<Command> enumerable = ((!bServer) ? Index.All.Where((Command x) => x.Saved && x.Client && !x.Replicated) : Index.All.Where((Command x) => x.Saved && x.ServerAdmin));
		foreach (Command item in enumerable)
		{
			if (item.GetOveride != null)
			{
				text = text + item.FullName + " " + Facepunch.Extend.StringExtensions.QuoteSafe(item.String);
				text += Environment.NewLine;
			}
		}
		return text;
	}
}
