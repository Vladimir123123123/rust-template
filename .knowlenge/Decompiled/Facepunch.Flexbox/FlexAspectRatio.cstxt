using Facepunch.Flexbox;
using UnityEngine;

[ExecuteAlways]
[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
public class FlexAspectRatio : MonoBehaviour, IFlexNode
{
	[Tooltip("Controls the initial size of the element before factoring in grow/shrink.")]
	public FlexLength Basis;

	[Min(0f)]
	[Tooltip("How much this flex element should grow relative to its siblings.")]
	public int Grow = 1;

	[Min(0f)]
	[Tooltip("How much this flex element should shrink relative to its siblings.")]
	public int Shrink = 1;

	[Tooltip("Optionally override the parent's cross axis alignment for this element.")]
	public FlexAlignSelf AlignSelf;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MinWidth;

	[Tooltip("The minimum allowed dimensions of this flex element.")]
	public FlexLength MaxWidth;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MinHeight;

	[Tooltip("The maximum allowed dimensions of this flex element.")]
	public FlexLength MaxHeight;

	[Tooltip("The aspect ratio to constrain to - X:Y.")]
	public Vector2 AspectRatio = new Vector2(16f, 9f);

	private float _preferredWidth;

	private float _preferredHeight;

	RectTransform IFlexNode.Transform => (RectTransform)base.transform;

	bool IFlexNode.IsActive => base.isActiveAndEnabled;

	bool IFlexNode.IsAbsolute => false;

	bool IFlexNode.IsDirty => true;

	FlexLength IFlexNode.MinWidth => MinWidth;

	FlexLength IFlexNode.MaxWidth => MaxWidth;

	FlexLength IFlexNode.MinHeight => MinHeight;

	FlexLength IFlexNode.MaxHeight => MaxHeight;

	FlexLength IFlexNode.Basis => Basis;

	int IFlexNode.Grow => Grow;

	int IFlexNode.Shrink => Shrink;

	FlexAlignSelf IFlexNode.AlignSelf => AlignSelf;

	protected void OnEnable()
	{
		SetLayoutDirty();
	}

	protected void OnDisable()
	{
		SetLayoutDirty();
	}

	public void SetLayoutDirty()
	{
		Transform parent = base.transform.parent;
		if (parent != null && parent.TryGetComponent<IFlexNode>(out var component) && component.IsActive)
		{
			component.SetLayoutDirty();
		}
	}

	void IFlexNode.SetupTransform()
	{
		RectTransform obj = (RectTransform)base.transform;
		obj.localRotation = Quaternion.identity;
		obj.pivot = new Vector2(0f, 1f);
		obj.anchorMin = new Vector2(0f, 1f);
		obj.anchorMax = new Vector2(0f, 1f);
	}

	void IFlexNode.SetLayoutDirty(bool force)
	{
		if (force || base.isActiveAndEnabled)
		{
			SetLayoutDirty();
		}
	}

	void IFlexNode.MeasureHorizontal()
	{
		_preferredWidth = ((MinWidth.HasValue && MinWidth.Unit == FlexUnit.Pixels) ? MinWidth.Value : 1f);
		_preferredHeight = ((MinHeight.HasValue && MinHeight.Unit == FlexUnit.Pixels) ? MinHeight.Value : 1f);
	}

	void IFlexNode.LayoutHorizontal(float maxWidth, float maxHeight)
	{
	}

	void IFlexNode.MeasureVertical()
	{
		float num = ((AspectRatio.x > 0f && AspectRatio.y > 1f) ? (AspectRatio.x / AspectRatio.y) : 1f);
		_preferredHeight = ((RectTransform)base.transform).sizeDelta.x / num;
	}

	void IFlexNode.LayoutVertical(float maxWidth, float maxHeight)
	{
	}

	void IFlexNode.GetScale(out float scaleX, out float scaleY)
	{
		Vector3 localScale = ((RectTransform)base.transform).localScale;
		scaleX = localScale.x;
		scaleY = localScale.y;
	}

	void IFlexNode.GetPreferredSize(out float preferredWidth, out float preferredHeight)
	{
		preferredWidth = _preferredWidth;
		preferredHeight = _preferredHeight;
	}
}
