using System.Collections.Generic;
using Facepunch.Flexbox;
using TMPro;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[RequireComponent(typeof(RectTransform))]
[DisallowMultipleComponent]
[ExecuteAlways]
public class FlexGraphicTransform : UIBehaviour, IMeshModifier
{
	[Range(0f, 1f)]
	public float OriginX = 0.5f;

	[Range(0f, 1f)]
	public float OriginY = 0.5f;

	public float TranslateX;

	public float TranslateY;

	public float ScaleX = 1f;

	public float ScaleY = 1f;

	public float Rotate;

	private static readonly Dictionary<TextMeshProUGUI, FlexGraphicTransform> TextMeshProTransformers;

	private static readonly List<TMP_SubMeshUI> SubMeshUIs;

	private static readonly List<Mesh> Meshes;

	private static readonly VertexHelper VertexHelper;

	private static readonly List<Vector3> Vertices;

	private static readonly List<int> Indices;

	private static readonly List<Color32> Colors;

	private static readonly List<Vector2> Uv0;

	private static readonly List<Vector2> Uv1;

	private static readonly List<Vector3> Normals;

	private static readonly List<Vector4> Tangents;

	private FlexGraphicTransform _parent;

	private RectTransform _rt;

	private Graphic _graphic;

	private TextMeshProUGUI _textMeshPro;

	private CanvasRenderer _canvasRenderer;

	private Matrix4x4 transformationMatrix
	{
		get
		{
			Vector2 vector = (new Vector2(OriginX, OriginY) - _rt.pivot) * _rt.rect.size;
			Matrix4x4 matrix4x = Matrix4x4.Translate(new Vector3(vector.x, vector.y, 0f));
			Matrix4x4 matrix4x2 = Matrix4x4.TRS(new Vector3(TranslateX, TranslateY, 0f), Quaternion.Euler(0f, 0f, Rotate), new Vector3(ScaleX, ScaleY, 1f));
			Matrix4x4 matrix4x3 = matrix4x * matrix4x2 * matrix4x.inverse;
			if (!(_parent != null))
			{
				return matrix4x3;
			}
			return _parent.transformationMatrix * matrix4x3;
		}
	}

	static FlexGraphicTransform()
	{
		TextMeshProTransformers = new Dictionary<TextMeshProUGUI, FlexGraphicTransform>();
		SubMeshUIs = new List<TMP_SubMeshUI>();
		Meshes = new List<Mesh>();
		VertexHelper = new VertexHelper();
		Vertices = new List<Vector3>();
		Indices = new List<int>();
		Colors = new List<Color32>();
		Uv0 = new List<Vector2>();
		Uv1 = new List<Vector2>();
		Normals = new List<Vector3>();
		Tangents = new List<Vector4>();
		TMPro_EventManager.TEXT_CHANGED_EVENT.Add(delegate(Object obj)
		{
			if (obj is TextMeshProUGUI key && TextMeshProTransformers.TryGetValue(key, out var value))
			{
				value.ModifyTextMeshPro();
			}
		});
	}

	protected override void Awake()
	{
		base.Awake();
		UpdateParent();
		_rt = GetComponent<RectTransform>();
		_graphic = GetComponent<Graphic>();
		_textMeshPro = GetComponent<TextMeshProUGUI>();
		_canvasRenderer = GetComponent<CanvasRenderer>();
	}

	private void UpdateParent()
	{
		_parent = ((base.transform.parent != null) ? base.transform.parent.GetComponent<FlexGraphicTransform>() : null);
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		if (_textMeshPro != null)
		{
			TextMeshProTransformers.Add(_textMeshPro, this);
		}
		SetVerticesDirty();
	}

	protected override void OnDisable()
	{
		if (_textMeshPro != null)
		{
			TextMeshProTransformers.Remove(_textMeshPro);
		}
		SetVerticesDirty();
		base.OnDisable();
	}

	protected override void OnDidApplyAnimationProperties()
	{
		SetVerticesDirty();
		base.OnDidApplyAnimationProperties();
	}

	protected override void OnTransformParentChanged()
	{
		base.OnTransformParentChanged();
		UpdateParent();
	}

	public void SetVerticesDirty()
	{
		if (_textMeshPro != null && _textMeshPro.textInfo?.meshInfo != null)
		{
			TMP_MeshInfo[] meshInfo = _textMeshPro.textInfo.meshInfo;
			for (int i = 0; i < meshInfo.Length; i++)
			{
				TMP_MeshInfo tMP_MeshInfo = meshInfo[i];
				Mesh mesh = tMP_MeshInfo.mesh;
				if (mesh != null)
				{
					mesh.Clear();
					mesh.vertices = tMP_MeshInfo.vertices;
					mesh.uv = tMP_MeshInfo.uvs0;
					mesh.uv2 = tMP_MeshInfo.uvs2;
					mesh.colors32 = tMP_MeshInfo.colors32;
					mesh.normals = tMP_MeshInfo.normals;
					mesh.tangents = tMP_MeshInfo.tangents;
					mesh.triangles = tMP_MeshInfo.triangles;
				}
			}
			if (_canvasRenderer != null)
			{
				_canvasRenderer.SetMesh(_textMeshPro.mesh);
				_textMeshPro.GetComponentsInChildren(includeInactive: false, SubMeshUIs);
				foreach (TMP_SubMeshUI subMeshUI in SubMeshUIs)
				{
					subMeshUI.canvasRenderer.SetMesh(subMeshUI.mesh);
				}
				SubMeshUIs.Clear();
			}
			_textMeshPro.havePropertiesChanged = true;
		}
		else if (_graphic != null)
		{
			_graphic.SetVerticesDirty();
		}
		foreach (Transform item in base.transform)
		{
			if (item.TryGetComponent<FlexGraphicTransform>(out var component) && component.isActiveAndEnabled)
			{
				component.SetVerticesDirty();
			}
		}
	}

	public void ModifyMesh(Mesh mesh)
	{
		using VertexHelper vertexHelper = new VertexHelper(mesh);
		ModifyMesh(vertexHelper);
		vertexHelper.FillMesh(mesh);
	}

	public void ModifyMesh(VertexHelper vh)
	{
		Matrix4x4 matrix4x = transformationMatrix;
		UIVertex vertex = default(UIVertex);
		int currentVertCount = vh.currentVertCount;
		for (int i = 0; i < currentVertCount; i++)
		{
			vh.PopulateUIVertex(ref vertex, i);
			vertex.position = matrix4x.MultiplyPoint(vertex.position);
			vh.SetUIVertex(vertex, i);
		}
	}

	private void ModifyTextMeshPro()
	{
		if (_textMeshPro == null || !base.isActiveAndEnabled)
		{
			return;
		}
		Meshes.Clear();
		TMP_MeshInfo[] meshInfo = _textMeshPro.textInfo.meshInfo;
		for (int i = 0; i < meshInfo.Length; i++)
		{
			TMP_MeshInfo tMP_MeshInfo = meshInfo[i];
			Meshes.Add(tMP_MeshInfo.mesh);
		}
		foreach (Mesh mesh in Meshes)
		{
			if (mesh != null)
			{
				CopyIntoVertexHelper(mesh);
				ModifyMesh(VertexHelper);
				VertexHelper.FillMesh(mesh);
			}
		}
		if (_canvasRenderer != null)
		{
			_canvasRenderer.SetMesh(_textMeshPro.mesh);
			GetComponentsInChildren(includeInactive: false, SubMeshUIs);
			foreach (TMP_SubMeshUI subMeshUI in SubMeshUIs)
			{
				subMeshUI.canvasRenderer.SetMesh(subMeshUI.mesh);
			}
			SubMeshUIs.Clear();
		}
		Meshes.Clear();
	}

	private static void CopyIntoVertexHelper(Mesh mesh)
	{
		VertexHelper.Clear();
		mesh.GetVertices(Vertices);
		mesh.GetIndices(Indices, 0);
		mesh.GetColors(Colors);
		mesh.GetUVs(0, Uv0);
		mesh.GetUVs(1, Uv1);
		mesh.GetNormals(Normals);
		mesh.GetTangents(Tangents);
		for (int i = 0; i < Vertices.Count; i++)
		{
			VertexHelper.AddVert(Vertices[i], Colors[i], Uv0[i], Uv1[i], Normals[i], Tangents[i]);
		}
		for (int j = 0; j < Indices.Count; j += 3)
		{
			VertexHelper.AddTriangle(Indices[j], Indices[j + 1], Indices[j + 2]);
		}
	}
}
