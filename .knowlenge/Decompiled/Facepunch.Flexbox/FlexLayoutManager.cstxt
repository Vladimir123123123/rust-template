using System.Collections.Generic;
using Facepunch.Flexbox;
using UnityEngine;

[ExecuteAlways]
[DefaultExecutionOrder(-100)]
public class FlexLayoutManager : MonoBehaviour
{
	internal static readonly HashSet<FlexElementBase> ActiveScopedUpdates = new HashSet<FlexElementBase>();

	private static readonly List<FlexElementBase> DirtyElements = new List<FlexElementBase>();

	private static readonly List<FlexElementBase> UpdatingElements = new List<FlexElementBase>();

	public static FlexLayoutManager Instance { get; private set; }

	public void OnEnable()
	{
		if (Instance != null)
		{
			Debug.LogWarning("Cannot have multiple FlexLayoutManager!", this);
		}
		else
		{
			Instance = this;
		}
	}

	public void OnDisable()
	{
		if (Instance == this)
		{
			Instance = null;
		}
	}

	public void LateUpdate()
	{
		FlushQueue();
	}

	public static void EnqueueLayout(FlexElementBase element)
	{
		if (element == null)
		{
			return;
		}
		if (Instance == null)
		{
			Debug.LogWarning("There is no FlexLayoutManager!");
			return;
		}
		if (!Instance.isActiveAndEnabled)
		{
			Debug.LogWarning("FlexLayoutManager is not active!");
		}
		if (!DirtyElements.Contains(element) && !ActiveScopedUpdates.Contains(element))
		{
			DirtyElements.Add(element);
		}
	}

	internal static void LayoutImmediate(FlexElementBase element)
	{
		if (!(element == null) && element.IsAbsolute)
		{
			DirtyElements.Remove(element);
			element.PerformLayout();
		}
	}

	private static void FlushQueue()
	{
		if (DirtyElements.Count == 0)
		{
			return;
		}
		UpdatingElements.AddRange(DirtyElements);
		DirtyElements.Clear();
		try
		{
			foreach (FlexElementBase updatingElement in UpdatingElements)
			{
				if (updatingElement != null)
				{
					updatingElement.PerformLayout();
				}
			}
		}
		finally
		{
			UpdatingElements.Clear();
		}
	}
}
