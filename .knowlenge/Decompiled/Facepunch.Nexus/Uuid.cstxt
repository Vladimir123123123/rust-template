using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using Facepunch.Nexus;

public struct Uuid : IEquatable<Uuid>
{
	public static readonly Uuid Empty;

	private static readonly object _syncRoot;

	private static readonly int _nodeId;

	private static int _sequence;

	private static ulong _previousTimestamp;

	public int NodeId { get; set; }

	public int Sequence { get; set; }

	public ulong Timestamp { get; set; }

	public Uuid(int nodeId, int sequence, ulong timestamp)
	{
		NodeId = nodeId;
		Sequence = sequence;
		Timestamp = timestamp;
	}

	public override string ToString()
	{
		return $"{NodeId:X8}{Sequence:X8}{Timestamp:X16}";
	}

	public static implicit operator Uuid(Guid guid)
	{
		return Unsafe.As<Guid, Uuid>(ref guid);
	}

	public static implicit operator Guid(Uuid uuid)
	{
		return Unsafe.As<Uuid, Guid>(ref uuid);
	}

	public bool Equals(Uuid other)
	{
		if (NodeId == other.NodeId && Sequence == other.Sequence)
		{
			return Timestamp == other.Timestamp;
		}
		return false;
	}

	public override bool Equals(object obj)
	{
		if (obj is Uuid other)
		{
			return Equals(other);
		}
		return false;
	}

	public override int GetHashCode()
	{
		return (((NodeId * 397) ^ Sequence) * 397) ^ Timestamp.GetHashCode();
	}

	public static bool operator ==(Uuid left, Uuid right)
	{
		return left.Equals(right);
	}

	public static bool operator !=(Uuid left, Uuid right)
	{
		return !left.Equals(right);
	}

	static Uuid()
	{
		if (Marshal.SizeOf<Uuid>() != Marshal.SizeOf<Guid>())
		{
			throw new Exception("sizeof(Uuid) != sizeof(Guid)");
		}
		_syncRoot = new object();
		_nodeId = Environment.MachineName.GetHashCode();
		_sequence = Environment.TickCount;
	}

	public static Uuid Generate()
	{
		lock (_syncRoot)
		{
			ulong ticks = (ulong)DateTime.UtcNow.Ticks;
			if (ticks <= _previousTimestamp)
			{
				_sequence++;
			}
			_previousTimestamp = ticks;
			return new Uuid(_nodeId, _sequence, ticks);
		}
	}
}
