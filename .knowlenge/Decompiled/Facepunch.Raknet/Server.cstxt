using System;
using Facepunch;
using Facepunch.Network.Raknet;
using Network;
using UnityEngine;

public class Server : Network.Server
{
	private Peer peer;

	public override string ProtocolId => "rak";

	public override bool IsConnected()
	{
		return peer != null;
	}

	public override bool Start(IServerCallback callbacks)
	{
		lock (readLock)
		{
			lock (writeLock)
			{
				lock (decryptLock)
				{
					peer = Peer.CreateServer(ip, port, 1024);
					if (peer == null)
					{
						return false;
					}
					callbackHandler = callbacks;
					MultithreadingInit(callbacks);
					return true;
				}
			}
		}
	}

	public override void Stop(string shutdownMsg)
	{
		lock (readLock)
		{
			lock (writeLock)
			{
				lock (decryptLock)
				{
					if (peer == null)
					{
						return;
					}
					Console.WriteLine("[Raknet] Server Shutting Down (" + shutdownMsg + ")");
					using (TimeWarning.New("ServerStop"))
					{
						peer.Close();
						peer = null;
						base.Stop(shutdownMsg);
					}
				}
			}
		}
	}

	public override void Disconnect(Connection cn)
	{
		lock (readLock)
		{
			lock (writeLock)
			{
				lock (decryptLock)
				{
					if (peer != null)
					{
						peer.Kick(cn);
						OnDisconnected("Disconnected", cn);
					}
				}
			}
		}
	}

	public override void Kick(Connection cn, string message, bool logfile)
	{
		lock (readLock)
		{
			lock (writeLock)
			{
				lock (decryptLock)
				{
					if (peer != null)
					{
						NetWrite netWrite = StartWrite();
						netWrite.PacketID(Message.Type.DisconnectReason);
						netWrite.String(message);
						netWrite.SendImmediate(new SendInfo(cn)
						{
							method = SendMethod.ReliableUnordered,
							priority = Priority.Immediate
						});
						string text = cn.ToString() + " kicked: " + message;
						if (logfile)
						{
							DebugEx.LogWarning(text);
						}
						else
						{
							Console.WriteLine(text);
						}
						peer.Kick(cn);
						OnDisconnected("Kicked: " + message, cn);
					}
				}
			}
		}
	}

	internal bool HandleRaknetPacket(byte type, NetRead read)
	{
		if (type >= 140)
		{
			return false;
		}
		switch (type)
		{
		case 19:
			using (TimeWarning.New("OnNewConnection", 20))
			{
				OnNewConnection(read.guid, read.ipaddress);
			}
			return true;
		case 21:
			if (read.connection != null)
			{
				using (TimeWarning.New("OnDisconnected", 20))
				{
					OnDisconnected("Disconnected", read.connection);
				}
			}
			return true;
		case 22:
			if (read.connection != null)
			{
				using (TimeWarning.New("OnDisconnected (timed out)", 20))
				{
					OnDisconnected("Timed Out", read.connection);
				}
			}
			return true;
		default:
			return true;
		}
	}

	private void HandleMessage()
	{
		if (peer.incomingBytesUnread > 10000000)
		{
			return;
		}
		Connection connection = FindConnection(peer.incomingGUID);
		if (connection != null)
		{
			if (connection.GetPacketsPerSecond() >= Network.Server.MaxPacketsPerSecond)
			{
				Kick(connection, "Packet Flooding", connection.connected);
				return;
			}
			connection.AddPacketsPerSecond();
		}
		NetRead netRead = Pool.Get<NetRead>();
		if (connection != null)
		{
			netRead.Start(connection, peer.RawData(), peer.incomingBytesUnread);
		}
		else
		{
			netRead.Start(peer.incomingGUID, peer.incomingAddress, peer.RawData(), peer.incomingBytesUnread);
		}
		if (BaseNetwork.Multithreading)
		{
			EnqueueDecrypt(netRead);
		}
		else
		{
			ProcessDecrypt(netRead);
		}
	}

	public override void ProcessRead(NetRead read)
	{
		byte b = read.PacketID();
		if (HandleRaknetPacket(b, read))
		{
			read.RemoveReference();
			return;
		}
		if (read.connection != null)
		{
			b -= 140;
			Message obj = StartMessage((Message.Type)b, read);
			if (callbackHandler != null)
			{
				callbackHandler.OnNetworkMessage(obj);
			}
			Pool.Free(ref obj);
		}
		read.RemoveReference();
	}

	protected override bool Receive()
	{
		if (peer.Receive())
		{
			HandleMessage();
			return true;
		}
		return false;
	}

	public override string GetDebug(Connection connection)
	{
		if (peer == null)
		{
			return string.Empty;
		}
		if (connection == null)
		{
			return peer.GetStatisticsString(0uL);
		}
		return peer.GetStatisticsString(connection.guid);
	}

	public bool TryGetConnectionStats(Connection connection, out Native.RaknetStats stats)
	{
		if (peer == null)
		{
			stats = default(Native.RaknetStats);
			return false;
		}
		stats = peer.GetStatistics(connection.guid);
		return true;
	}

	public override int GetAveragePing(Connection connection)
	{
		if (peer == null)
		{
			return 0;
		}
		return peer.GetPingAverage(connection.guid);
	}

	public int GetLatestPing(Connection connection)
	{
		if (peer == null)
		{
			return 0;
		}
		return peer.GetPingLast(connection.guid);
	}

	public override ulong GetStat(Connection connection, StatTypeLong type)
	{
		if (peer == null)
		{
			return 0uL;
		}
		return peer.GetStat(connection, type);
	}

	public override void ProcessWrite(NetWrite write)
	{
		if (DemoConVars.ServerDemosEnabled)
		{
			EnqueueToDemoThread(new DemoQueueItem(write));
		}
		foreach (Connection connection in write.connections)
		{
			ProcessWrite(write, connection);
		}
		write.RemoveReference();
	}

	private void ProcessWrite(NetWrite write, Connection connection)
	{
		RecordReadForConnection(connection, write);
		ArraySegment<byte> arraySegment = Encrypt(connection, write);
		peer.SendStart();
		peer.WriteBytes(arraySegment.Array, 0, arraySegment.Offset + arraySegment.Count);
		peer.SendTo(connection.guid, write.priority, write.method, write.channel);
	}
}
