using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

[AddComponentMenu("Facepunch/Skeleton")]
public class Skeleton : MonoBehaviour
{
	public SkeletonDefinition Source;

	public GameObject[] Bones;

	public Transform GetTransform(int id)
	{
		if (id < 0)
		{
			return null;
		}
		if (!(Bones[id] != null))
		{
			return null;
		}
		return Bones[id].transform;
	}

	public Transform GetTransformSlow(string name)
	{
		SkeletonDefinition.Bone bone = Source.FindBone(name);
		if (!string.IsNullOrEmpty(bone.Name))
		{
			return GetTransform(bone.Id);
		}
		if (Bones != null && Bones.Length != 0)
		{
			for (int i = 0; i < Bones.Length; i++)
			{
				Transform transform = Bones[i].transform.FindChildRecursive(name);
				if (transform != null)
				{
					return transform;
				}
			}
		}
		return null;
	}

	public int GetBoneId(string boneName)
	{
		for (int i = 0; i < Source.Bones.Length; i++)
		{
			if (string.Equals(Source.Bones[i].Name, boneName, StringComparison.InvariantCultureIgnoreCase))
			{
				return Source.Bones[i].Id;
			}
		}
		return -1;
	}

	public IEnumerable<Transform> GetTransforms()
	{
		return Source.Bones.Select((SkeletonDefinition.Bone x) => GetTransform(x.Id));
	}

	public GameObject GetGameObject(int id)
	{
		if (id < 0)
		{
			return null;
		}
		return Bones[id];
	}

	public void CopyTo(Skeleton to)
	{
		if (to.Source != Source)
		{
			throw new ArgumentException("Trying to copy transforms between different skeletons, source :" + to.gameObject.name + " to :" + to.gameObject.name);
		}
		if (to.Bones.Length != Bones.Length)
		{
			throw new ArgumentException("Bone arrays are different sizes, skeleton might need rebuilding");
		}
		for (int i = 0; i < Bones.Length; i++)
		{
			if (!(Bones[i] == null) && !(to.Bones[i] == null))
			{
				Bones[i].transform.GetPositionAndRotation(out var position, out var rotation);
				to.Bones[i].transform.SetPositionAndRotation(position, rotation);
			}
		}
	}

	public void CopyFrom(Vector3[] sourceBonePos, Quaternion[] sourceBoneRot, bool localSpace)
	{
		if (sourceBonePos.Length != sourceBoneRot.Length)
		{
			throw new ArgumentException("Bone pos and rot arrays are different sizes");
		}
		if (sourceBonePos.Length != Bones.Length)
		{
			throw new ArgumentException("Bone arrays are different sizes, skeleton might need rebuilding");
		}
		for (int i = 0; i < sourceBonePos.Length; i++)
		{
			if (!(Bones[i] == null))
			{
				_ = ref sourceBonePos[i];
				if (localSpace)
				{
					Bones[i].transform.SetLocalPositionAndRotation(sourceBonePos[i], sourceBoneRot[i]);
				}
				else
				{
					Bones[i].transform.SetPositionAndRotation(sourceBonePos[i], sourceBoneRot[i]);
				}
			}
		}
	}

	public void CopySkeletonSkins(SkeletonSkin[] renderers, LODGroup lodGroup = null)
	{
		SkinnedMeshRenderer[] array = new SkinnedMeshRenderer[renderers.Length];
		for (int i = 0; i < renderers.Length; i++)
		{
			array[i] = CopySkin(renderers[i]);
		}
		if (lodGroup != null)
		{
			CopyLodGroup(lodGroup, renderers, array);
		}
	}

	private void CopyLodGroup(LODGroup lodGroup, SkeletonSkin[] renderers, SkinnedMeshRenderer[] created)
	{
		LOD[] lODs = lodGroup.GetLODs();
		for (int i = 0; i < lODs.Length; i++)
		{
			LOD lOD = lODs[i];
			for (int j = 0; j < lOD.renderers.Length; j++)
			{
				int num = LookupRendererIndex(renderers, lOD.renderers[j]);
				lOD.renderers[j] = ((num >= 0) ? created[num] : null);
			}
		}
		LODGroup lODGroup = base.gameObject.AddComponent<LODGroup>();
		lODGroup.size = lodGroup.size;
		lODGroup.animateCrossFading = lodGroup.animateCrossFading;
		lODGroup.fadeMode = lodGroup.fadeMode;
		lODGroup.enabled = lodGroup.enabled;
		lODGroup.SetLODs(lODs);
	}

	private int LookupRendererIndex(SkeletonSkin[] renderers, Renderer renderer)
	{
		for (int i = 0; i < renderers.Length; i++)
		{
			if (renderers[i].SkinnedMeshRenderer == renderer)
			{
				return i;
			}
		}
		return -1;
	}

	private SkinnedMeshRenderer CopySkin(SkeletonSkin renderer)
	{
		GameObject gameObject = new GameObject();
		gameObject.transform.parent = base.transform;
		gameObject.transform.localPosition = Vector3.zero;
		gameObject.transform.localRotation = Quaternion.identity;
		gameObject.transform.localScale = Vector3.one;
		gameObject.layer = base.gameObject.layer;
		return renderer.DuplicateAndRetarget(gameObject, this);
	}

	public void CopySkeletonAttachments(SkeletonAttachment[] attachments)
	{
		for (int i = 0; i < attachments.Length; i++)
		{
			CopyAttachment(attachments[i]);
		}
	}

	private void CopyAttachment(SkeletonAttachment skeletonAttachment)
	{
		Skeleton componentInParent = skeletonAttachment.GetComponentInParent<Skeleton>();
		if (componentInParent == null)
		{
			throw new Exception("SkeletonAttachment has no Skeleton");
		}
		if (Source != componentInParent.Source)
		{
			throw new Exception("SkeletonAttachment uses different Skeleton");
		}
		int num = componentInParent.ReverseLookupBone(skeletonAttachment.transform.parent.gameObject);
		if (num < 0)
		{
			throw new Exception("SkeletonAttachment attached to bone that isn't in skeleton");
		}
		skeletonAttachment.CopyTo(Bones[num]);
	}

	private int ReverseLookupBone(GameObject bone)
	{
		return Array.IndexOf(Bones, bone);
	}

	public void Rebuild()
	{
		Bones = GetBones(base.gameObject, Source);
	}

	public static GameObject[] GetBones(GameObject root, SkeletonDefinition skeletonDef)
	{
		Transform[] allChildren = root.GetComponentsInChildren<Transform>();
		return skeletonDef.Bones.Select((SkeletonDefinition.Bone bone) => FindBoneImpl(root, in bone, allChildren)).ToArray();
	}

	private static GameObject FindBoneImpl(GameObject root, in SkeletonDefinition.Bone bone, Transform[] allChildren)
	{
		int num = 0;
		Transform transform = null;
		foreach (Transform transform2 in allChildren)
		{
			if (string.Equals(transform2.name, bone.Name, StringComparison.OrdinalIgnoreCase))
			{
				num++;
				transform = transform2;
			}
		}
		if (num == 1)
		{
			return transform.gameObject;
		}
		if (num > 1)
		{
			Debug.LogWarning(root.name + ": Multiple bones named " + bone.Name, root);
			return null;
		}
		return null;
	}
}
