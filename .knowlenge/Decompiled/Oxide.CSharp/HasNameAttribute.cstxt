using System;
using System.Text.RegularExpressions;
using Mono.Cecil;
using Oxide.CSharp.Patching.Validation;

public class HasNameAttribute : PatchValidationAttribute
{
	public string ValidationRule { get; internal set; }

	public StringValidationType ValidationType { get; }

	public StringComparison ValidationComparison { get; }

	public HasNameAttribute(string rule, StringValidationType type = StringValidationType.StartsWith, StringComparison comparison = StringComparison.InvariantCultureIgnoreCase)
	{
		ValidationRule = rule;
		ValidationType = type;
		ValidationComparison = comparison;
	}

	protected override bool IsValid(object item)
	{
		string text = null;
		if (item is string text2)
		{
			text = text2;
		}
		else if (item is AssemblyDefinition assemblyDefinition)
		{
			text = assemblyDefinition.FullName;
		}
		else if (item is ModuleDefinition moduleDefinition)
		{
			text = moduleDefinition.Assembly.FullName;
		}
		else if (item is ModuleReference moduleReference)
		{
			text = moduleReference.Name;
		}
		else if (item is AssemblyNameReference assemblyNameReference)
		{
			text = assemblyNameReference.FullName;
		}
		else
		{
			if (!(item is MemberReference memberReference))
			{
				return false;
			}
			text = memberReference.FullName;
		}
		return ValidationType switch
		{
			StringValidationType.Equals => text.Equals(ValidationRule, ValidationComparison), 
			StringValidationType.Contains => text.IndexOf(ValidationRule, ValidationComparison) >= 0, 
			StringValidationType.EndsWith => text.EndsWith(ValidationRule, ValidationComparison), 
			StringValidationType.RegularExpression => Regex.IsMatch(text, ValidationRule, RegexOptions.Compiled), 
			_ => text.StartsWith(ValidationRule, ValidationComparison), 
		};
	}
}
