using System;
using System.Collections.Generic;
using System.Linq;
using Newtonsoft.Json;

public class KeyValuesConverter : JsonConverter
{
	public override bool CanConvert(Type objectType)
	{
		if (!(objectType == typeof(Dictionary<string, object>)))
		{
			return objectType == typeof(List<object>);
		}
		return true;
	}

	private void Throw(string message)
	{
		throw new Exception(message);
	}

	public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
	{
		if (objectType == typeof(Dictionary<string, object>))
		{
			Dictionary<string, object> dictionary = (existingValue as Dictionary<string, object>) ?? new Dictionary<string, object>();
			if (reader.TokenType == JsonToken.StartArray)
			{
				return dictionary;
			}
			while (reader.Read() && reader.TokenType != JsonToken.EndObject)
			{
				if (reader.TokenType != JsonToken.PropertyName)
				{
					Throw("Unexpected token: " + reader.TokenType);
				}
				string key = reader.Value as string;
				if (!reader.Read())
				{
					Throw("Unexpected end of json");
				}
				switch (reader.TokenType)
				{
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Null:
				case JsonToken.Date:
				case JsonToken.Bytes:
					dictionary[key] = reader.Value;
					break;
				case JsonToken.Integer:
				{
					string text = reader.Value.ToString();
					if (int.TryParse(text, out var result))
					{
						dictionary[key] = result;
					}
					else
					{
						dictionary[key] = text;
					}
					break;
				}
				case JsonToken.StartObject:
					dictionary[key] = serializer.Deserialize<Dictionary<string, object>>(reader);
					break;
				case JsonToken.StartArray:
					dictionary[key] = serializer.Deserialize<List<object>>(reader);
					break;
				default:
					Throw("Unexpected token: " + reader.TokenType);
					break;
				}
			}
			return dictionary;
		}
		if (objectType == typeof(List<object>))
		{
			List<object> list = (existingValue as List<object>) ?? new List<object>();
			while (reader.Read() && reader.TokenType != JsonToken.EndArray)
			{
				switch (reader.TokenType)
				{
				case JsonToken.Float:
				case JsonToken.String:
				case JsonToken.Boolean:
				case JsonToken.Null:
				case JsonToken.Date:
				case JsonToken.Bytes:
					list.Add(reader.Value);
					break;
				case JsonToken.Integer:
				{
					string text2 = reader.Value.ToString();
					if (int.TryParse(text2, out var result2))
					{
						list.Add(result2);
					}
					else
					{
						list.Add(text2);
					}
					break;
				}
				case JsonToken.StartObject:
					list.Add(serializer.Deserialize<Dictionary<string, object>>(reader));
					break;
				case JsonToken.StartArray:
					list.Add(serializer.Deserialize<List<object>>(reader));
					break;
				default:
					Throw("Unexpected token: " + reader.TokenType);
					break;
				}
			}
			return list;
		}
		return existingValue;
	}

	public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
	{
		if (value is Dictionary<string, object>)
		{
			Dictionary<string, object> source = (Dictionary<string, object>)value;
			writer.WriteStartObject();
			foreach (KeyValuePair<string, object> item in source.OrderBy((KeyValuePair<string, object> i) => i.Key))
			{
				writer.WritePropertyName(item.Key, escape: true);
				serializer.Serialize(writer, item.Value);
			}
			writer.WriteEndObject();
		}
		else
		{
			if (!(value is List<object>))
			{
				return;
			}
			List<object> obj = (List<object>)value;
			writer.WriteStartArray();
			foreach (object item2 in obj)
			{
				serializer.Serialize(writer, item2);
			}
			writer.WriteEndArray();
		}
	}
}
