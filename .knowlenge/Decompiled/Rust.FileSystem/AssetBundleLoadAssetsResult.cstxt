using System;
using System.Collections.Generic;
using Facepunch;
using UnityEngine;

internal class AssetBundleLoadAssetsResult : LoadAssetsResult
{
	private readonly AssetBundle _bundle;

	private readonly List<string> _filePaths;

	private readonly int _maxConcurrency;

	private readonly int _priority;

	private readonly List<AssetBundleRequest> _requests;

	private readonly List<(string AssetPath, AssetBundleRequest Request)> _pendingRequests;

	private int _index;

	public override int TotalCount => _filePaths.Count;

	public override bool keepWaiting => !Update();

	internal AssetBundleLoadAssetsResult(AssetBundle bundle, List<string> filePaths, int maxConcurrency, int priority)
	{
		if (bundle == null)
		{
			throw new ArgumentNullException("bundle");
		}
		if (filePaths == null)
		{
			throw new ArgumentNullException("filePaths");
		}
		foreach (string filePath in filePaths)
		{
			if (string.IsNullOrWhiteSpace(filePath))
			{
				throw new ArgumentException("Cannot load null or empty paths.", "filePaths");
			}
		}
		_bundle = bundle;
		_filePaths = filePaths;
		_maxConcurrency = Mathf.Clamp(maxConcurrency, 1, 64);
		_priority = priority;
		_requests = new List<AssetBundleRequest>(_filePaths.Count);
		_pendingRequests = new List<(string, AssetBundleRequest)>(_maxConcurrency);
		_index = 0;
	}

	private bool Update()
	{
		if (_requests.Count == _filePaths.Count && _pendingRequests.Count == 0)
		{
			return true;
		}
		if (_bundle == null)
		{
			CompletedCount = TotalCount;
			return true;
		}
		List<(string, AssetBundleRequest)> obj = Pool.Get<List<(string, AssetBundleRequest)>>();
		for (int i = 0; i < _pendingRequests.Count; i++)
		{
			var (item, assetBundleRequest) = _pendingRequests[i];
			if (assetBundleRequest.isDone)
			{
				CompletedCount++;
				_pendingRequests.RemoveAt(i);
				i--;
				obj.Add((item, assetBundleRequest));
			}
		}
		foreach (var (path, assetBundleRequest2) in obj)
		{
			try
			{
				OnAssetLoaded?.Invoke(path, assetBundleRequest2.asset);
			}
			catch (Exception exception)
			{
				Debug.LogException(exception);
			}
		}
		Pool.FreeUnmanaged(ref obj);
		while (_pendingRequests.Count < _maxConcurrency)
		{
			if (_index >= _filePaths.Count)
			{
				return false;
			}
			string text = _filePaths[_index++];
			AssetBundleRequest assetBundleRequest3 = _bundle.LoadAssetAsync(text);
			assetBundleRequest3.priority = _priority;
			_requests.Add(assetBundleRequest3);
			_pendingRequests.Add((text, assetBundleRequest3));
		}
		return false;
	}

	public override Dictionary<string, UnityEngine.Object> GetResult()
	{
		if (keepWaiting)
		{
			throw new InvalidOperationException("Cannot get results until the load is completed.");
		}
		Dictionary<string, UnityEngine.Object> dictionary = new Dictionary<string, UnityEngine.Object>();
		for (int i = 0; i < _filePaths.Count; i++)
		{
			dictionary.Add(_filePaths[i], _requests[i].asset);
		}
		return dictionary;
	}
}
