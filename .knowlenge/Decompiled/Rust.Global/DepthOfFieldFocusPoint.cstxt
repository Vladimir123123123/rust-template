using Rust.Components.Camera;
using UnityEngine;

public class DepthOfFieldFocusPoint : ListComponent<DepthOfFieldFocusPoint>
{
	private Renderer cachedRenderer;

	public Vector3 FocusPoint
	{
		get
		{
			Vector3 result = base.transform.position;
			if (cachedRenderer != null)
			{
				result = cachedRenderer.bounds.center;
			}
			return result;
		}
	}

	protected override void OnEnable()
	{
		base.OnEnable();
		cachedRenderer = GetComponentInChildren<MeshRenderer>(includeInactive: true);
		if (cachedRenderer == null)
		{
			cachedRenderer = GetComponentInChildren<SkinnedMeshRenderer>(includeInactive: true);
		}
	}

	public static DepthOfFieldFocusPoint Evaluate(Camera cam)
	{
		if (ListComponent<DepthOfFieldFocusPoint>.InstanceList == null || ListComponent<DepthOfFieldFocusPoint>.InstanceList.Count == 0)
		{
			return null;
		}
		DepthOfFieldFocusPoint result = null;
		float num = float.MaxValue;
		for (int i = 0; i < ListComponent<DepthOfFieldFocusPoint>.InstanceList.Count; i++)
		{
			float num2 = ListComponent<DepthOfFieldFocusPoint>.InstanceList[i].Score(cam);
			if (num2 < num)
			{
				num = num2;
				result = ListComponent<DepthOfFieldFocusPoint>.InstanceList[i];
			}
		}
		return result;
	}

	private float Score(Camera cam)
	{
		Vector3 vector = cam.WorldToScreenPoint(FocusPoint);
		if (vector.z < 0f)
		{
			return float.MaxValue;
		}
		return (new Vector2(vector.x, vector.y) - new Vector2(cam.pixelWidth / 2, cam.pixelHeight / 2)).sqrMagnitude + vector.z * 128f;
	}
}
