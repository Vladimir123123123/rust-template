using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch;
using Facepunch.Extend;
using UnityEngine;

public class MaterialReplacement : MonoBehaviour
{
	private bool initialized;

	public Material[] Default;

	public Material[] Override;

	public Renderer Renderer;

	public static void ReplaceRecursive(GameObject go, Material mat)
	{
		List<Renderer> obj = Pool.Get<List<Renderer>>();
		go.transform.GetComponentsInChildren(includeInactive: true, obj);
		foreach (Renderer item in obj)
		{
			if (!(item is ParticleSystemRenderer))
			{
				MaterialReplacement orAddComponent = item.transform.GetOrAddComponent<MaterialReplacement>();
				orAddComponent.Init();
				orAddComponent.Replace(mat);
			}
		}
		Pool.FreeUnmanaged(ref obj);
	}

	public static void ReplaceRecursive(GameObject obj, Material[] find, Material[] replace)
	{
		if (find.Length != replace.Length)
		{
			Debug.LogWarning($"Incorrect material array length: {find.Length} != {replace.Length} {obj.name}");
			return;
		}
		List<Renderer> obj2 = Pool.Get<List<Renderer>>();
		obj.GetComponentsInChildren(includeInactive: true, obj2);
		foreach (Renderer item in obj2)
		{
			if (!(item is ParticleSystemRenderer) && MaterialsContainAny(item.sharedMaterials, find))
			{
				MaterialReplacement orAddComponent = item.transform.GetOrAddComponent<MaterialReplacement>();
				orAddComponent.Init();
				orAddComponent.Revert();
				orAddComponent.Replace(find, replace);
			}
		}
		Pool.FreeUnmanaged(ref obj2);
	}

	public static void Prepare(GameObject go)
	{
		List<Renderer> obj = Pool.Get<List<Renderer>>();
		go.GetComponentsInChildren(includeInactive: true, obj);
		foreach (Renderer item in obj)
		{
			if (!(item is ParticleSystemRenderer))
			{
				item.transform.GetOrAddComponent<MaterialReplacement>().Init();
			}
		}
		Pool.FreeUnmanaged(ref obj);
	}

	public static bool MaterialsContainAny(Material[] source, Material[] find)
	{
		for (int i = 0; i < source.Length; i++)
		{
			if (find.Contains(source[i]))
			{
				return true;
			}
		}
		return false;
	}

	public static void Reset(GameObject go)
	{
		List<MaterialReplacement> obj = Pool.Get<List<MaterialReplacement>>();
		go.GetComponentsInChildren(includeInactive: true, obj);
		foreach (MaterialReplacement item in obj)
		{
			item.Revert();
		}
		Pool.FreeUnmanaged(ref obj);
	}

	public void Init()
	{
		if (!initialized)
		{
			initialized = true;
			Renderer = GetComponent<Renderer>();
			Default = Renderer.sharedMaterials;
			Override = new Material[Default.Length];
			Array.Copy(Default, Override, Default.Length);
		}
	}

	private void Replace(Material mat)
	{
		if ((bool)Renderer)
		{
			for (int i = 0; i < Override.Length; i++)
			{
				Override[i] = mat;
			}
			Renderer.sharedMaterials = Override;
		}
	}

	private void Replace(Material find, Material replace)
	{
		if (!Renderer)
		{
			return;
		}
		for (int i = 0; i < Default.Length; i++)
		{
			if (find == Default[i])
			{
				Override[i] = replace;
			}
		}
		Renderer.sharedMaterials = Override;
	}

	private void Replace(Material[] find, Material[] replace)
	{
		if (!Renderer)
		{
			return;
		}
		int num = Mathf.Min(find.Length, replace.Length);
		for (int i = 0; i < Default.Length; i++)
		{
			for (int j = 0; j < num; j++)
			{
				if (find[j] == Default[i])
				{
					Override[i] = replace[j];
				}
			}
		}
		Renderer.sharedMaterials = Override;
		if (Renderer.enabled)
		{
			Renderer.enabled = false;
			Renderer.enabled = true;
		}
	}

	private void Revert()
	{
		if ((object)Renderer != null)
		{
			Renderer.sharedMaterials = Default;
			Array.Copy(Default, Override, Default.Length);
		}
	}
}
