using UnityEngine;

public static class MathEx
{
	public static float SnapTo(this float val, float snapValue)
	{
		if (snapValue == 0f)
		{
			return val;
		}
		return Mathf.Round(val / snapValue) * snapValue;
	}

	public static bool QuadTest(this Ray ray, Vector3 planeCenter, Quaternion planeRot, Vector2 planeSize, out Vector3 hitPosition, float gridSize = 0f)
	{
		Plane plane = new Plane(planeRot * Vector3.forward, planeCenter);
		hitPosition = Vector3.zero;
		float enter = 0f;
		if (!plane.Raycast(ray, out enter))
		{
			return false;
		}
		hitPosition = ray.origin + ray.direction * enter;
		Vector3 lhs = hitPosition - planeCenter;
		float num = Vector3.Dot(lhs, planeRot * Vector3.left);
		float num2 = Vector3.Dot(lhs, planeRot * Vector3.up);
		if (Mathf.Abs(num) > planeSize.x / 2f)
		{
			num = ((num < 0f) ? (0f - planeSize.x) : planeSize.x) / 2f;
		}
		if (Mathf.Abs(num2) > planeSize.y / 2f)
		{
			num2 = ((num2 < 0f) ? (0f - planeSize.y) : planeSize.y) / 2f;
		}
		if (gridSize > 0f)
		{
			num = num.SnapTo(gridSize);
			num2 = num2.SnapTo(gridSize);
		}
		hitPosition = planeCenter;
		hitPosition += planeRot * Vector3.left * num;
		hitPosition += planeRot * Vector3.up * num2;
		return true;
	}

	public static float BiasedLerp(float x, float bias)
	{
		float num = ((!(bias <= 0.5f)) ? (1f - Bias(1f - Mathf.Abs(x), 1f - bias)) : Bias(Mathf.Abs(x), bias));
		if (!(x < 0f))
		{
			return num;
		}
		return 0f - num;
	}

	public static float Bias(float x, float bias)
	{
		if (x <= 0f || bias <= 0f)
		{
			return 0f;
		}
		if (x >= 1f || bias >= 1f)
		{
			return 1f;
		}
		if (bias == 0.5f)
		{
			return x;
		}
		float p = Mathf.Log(bias) * -1.4427f;
		return Mathf.Pow(x, p);
	}
}
