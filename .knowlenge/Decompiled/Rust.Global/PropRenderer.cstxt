using System;
using Facepunch.Extend;
using Rust;
using Rust.Components.Camera;
using Rust.ImageEffects;
using UnityEngine;
using UnityEngine.Rendering;

public class PropRenderer : MonoBehaviour, IClientComponent
{
	[Serializable]
	public class SkinViewerSettings
	{
		[Tooltip("If non-zero, will be used as a pivot point instead of the centre of the enclosing bounds")]
		public Vector3 customLocalPivot = Vector3.zero;

		[Tooltip("Additional camera offset only used in the skin viewer (as opposed to icon generation)")]
		public Vector3 camPosOffset;

		[Tooltip("For objects that rotate weirdly in other skin viewer pivot modes")]
		public bool forceCamUpPivot;

		public bool HasCustomPivot => customLocalPivot != Vector3.zero;
	}

	public delegate float LightIntensityScale(float intensity);

	public bool HideLowLods = true;

	public bool HideUnskinnable = true;

	public bool Outline = true;

	[Header("Rotation")]
	public Vector3 Rotation = Vector3.zero;

	public Vector3 PostRotation = Vector3.zero;

	[Header("Position Offset")]
	public Vector3 PositionalTweak = Vector3.zero;

	[Header("Misc")]
	public float FieldOfView = 40f;

	public float farClipPlane = 100f;

	public bool ForceLookAtProp;

	public Vector3 LookDirection = new Vector3(0.2f, 0.4f, 1f);

	public Vector3 UpDirection = Vector3.up;

	public GameObject[] HideDuringRender = new GameObject[0];

	public SkinViewerSettings skinViewerSettings;

	public void DebugAlign()
	{
		PreRender();
		Camera main = Camera.main;
		main.fieldOfView = FieldOfView;
		PositionCamera(main, isSkinViewer: true);
		PostRender();
	}

	public void PositionCamera(Camera cam, bool isSkinViewer = false)
	{
		Vector3 vector = Quaternion.Euler(Rotation) * LookDirection.normalized;
		Vector3 vector2 = Quaternion.Euler(Rotation) * UpDirection.normalized;
		vector = Quaternion.Euler(PostRotation) * vector;
		vector2 = Quaternion.Euler(PostRotation) * vector2;
		cam.fieldOfView = FieldOfView;
		cam.nearClipPlane = 0.01f;
		cam.farClipPlane = farClipPlane;
		cam.FocusOnRenderer(base.gameObject, vector, vector2, 2048);
		cam.transform.position += PositionalTweak.x * cam.transform.right * 0.01f;
		cam.transform.position += PositionalTweak.y * cam.transform.up * 0.01f;
		cam.transform.position += PositionalTweak.z * cam.transform.forward * 0.1f;
		if (isSkinViewer)
		{
			cam.transform.position += skinViewerSettings.camPosOffset.x * cam.transform.right * 0.01f;
			cam.transform.position += skinViewerSettings.camPosOffset.y * cam.transform.up * 0.01f;
			cam.transform.position += skinViewerSettings.camPosOffset.z * cam.transform.forward * 0.1f;
		}
	}

	public void PreRender()
	{
		PreRender(base.gameObject, HideLowLods, HideUnskinnable, HideDuringRender);
	}

	public static void PreRender(GameObject gameObject, bool hideLowLODs, bool hideUnskinnable, GameObject[] hideDuringRender = null)
	{
		Renderer[] componentsInChildren = gameObject.GetComponentsInChildren<Renderer>();
		foreach (Renderer renderer in componentsInChildren)
		{
			if (!(renderer is ParticleSystemRenderer) && !renderer.gameObject.CompareTag("StripFromStorePreview") && (!hideLowLODs || (!renderer.gameObject.name.EndsWith("lod01", StringComparison.InvariantCultureIgnoreCase) && !renderer.gameObject.name.EndsWith("lod02", StringComparison.InvariantCultureIgnoreCase) && !renderer.gameObject.name.EndsWith("lod03", StringComparison.InvariantCultureIgnoreCase) && !renderer.gameObject.name.EndsWith("lod04", StringComparison.InvariantCultureIgnoreCase) && !renderer.gameObject.name.EndsWith("lod1", StringComparison.InvariantCultureIgnoreCase) && !renderer.gameObject.name.EndsWith("lod2", StringComparison.InvariantCultureIgnoreCase) && !renderer.gameObject.name.EndsWith("lod3", StringComparison.InvariantCultureIgnoreCase) && !renderer.gameObject.name.EndsWith("lod4", StringComparison.InvariantCultureIgnoreCase))))
			{
				renderer.gameObject.layer = 11;
				SkinnedMeshRenderer skinnedMeshRenderer = renderer as SkinnedMeshRenderer;
				if ((bool)skinnedMeshRenderer)
				{
					skinnedMeshRenderer.updateWhenOffscreen = true;
				}
			}
		}
	}

	public void PostRender()
	{
		Renderer[] componentsInChildren = GetComponentsInChildren<Renderer>();
		foreach (Renderer renderer in componentsInChildren)
		{
			if (!(renderer is ParticleSystemRenderer))
			{
				renderer.gameObject.layer = 0;
				SkinnedMeshRenderer skinnedMeshRenderer = renderer as SkinnedMeshRenderer;
				if ((bool)skinnedMeshRenderer)
				{
					skinnedMeshRenderer.updateWhenOffscreen = false;
				}
			}
		}
	}

	[ContextMenu("Create 512x512 Icon")]
	public void CreateIcon()
	{
		GameObject gameObject = base.gameObject;
		Debug.Log("Saving To " + UnityEngine.Application.dataPath + "/" + gameObject.name + ".icon.png");
		CreateScreenshot(UnityEngine.Application.dataPath + "/" + gameObject.name + ".icon.png", 512, 512, 4);
	}

	[ContextMenu("Create Large Render")]
	public void CreateRender()
	{
		GameObject gameObject = base.gameObject;
		Debug.Log("Saving To " + UnityEngine.Application.dataPath + "/" + gameObject.name + ".large.png");
		CreateScreenshot(UnityEngine.Application.dataPath + "/" + gameObject.name + ".large.png", 4096, 4096);
	}

	private static float DefaultLightIntensityScale(float intensity)
	{
		return Mathf.GammaToLinearSpace(intensity) * MathF.PI;
	}

	public void CreateScreenshot(string filename, int width, int height, int SuperSampleSize = 1, LightIntensityScale lightIntensityScale = null)
	{
		if (lightIntensityScale == null)
		{
			lightIntensityScale = DefaultLightIntensityScale;
		}
		bool streamingTextureForceLoadAll = Texture.streamingTextureForceLoadAll;
		Texture.streamingTextureForceLoadAll = true;
		GameObject gameObject = new GameObject("Temporary Camera");
		Camera camera = gameObject.AddComponent<Camera>();
		camera.clearFlags = CameraClearFlags.Depth;
		camera.backgroundColor = new Color(1f, 1f, 1f, 0f);
		camera.allowHDR = true;
		camera.allowMSAA = false;
		gameObject.AddComponent<StreamingController>();
		Type type = Type.GetType("DeferredExtension,Assembly-CSharp");
		if (type != null)
		{
			gameObject.AddComponent(type);
		}
		Type type2 = Type.GetType("DeferredDecalRenderer,Assembly-CSharp");
		if (type != null)
		{
			gameObject.AddComponent(type2);
		}
		if (ReflectionProbe.defaultTexture != null)
		{
			Shader.SetGlobalTexture("global_SkyReflection", ReflectionProbe.defaultTexture);
			Shader.SetGlobalVector("global_SkyReflection_HDR", new Vector2(0.2f, 0.01f));
		}
		if (Outline)
		{
			gameObject.AddComponent<IconOutline>();
		}
		LightingOverride lightingOverride = gameObject.AddComponent<LightingOverride>();
		lightingOverride.overrideAmbientLight = true;
		lightingOverride.ambientMode = AmbientMode.Flat;
		lightingOverride.ambientLight = new Color(0.4f, 0.4f, 0.4f, 1f);
		lightingOverride.overrideSkyReflection = true;
		GameObject obj = new GameObject("Temporary Light");
		obj.transform.SetParent(camera.transform);
		obj.transform.localRotation = Quaternion.Euler(115f, 60f, 0f);
		Light light = obj.AddComponent<Light>();
		light.type = LightType.Directional;
		light.color = new Color(1f, 1f, 0.96f);
		light.intensity = 2f;
		light.cullingMask = 2048;
		light.shadows = LightShadows.Soft;
		light.shadowBias = 0.01f;
		light.shadowNormalBias = 0.01f;
		light.shadowStrength = 0.9f;
		if (lightIntensityScale != null)
		{
			light.intensity = lightIntensityScale(light.intensity);
		}
		GameObject obj2 = new GameObject("Temporary Light");
		obj2.transform.SetParent(camera.transform);
		obj2.transform.localRotation = Quaternion.Euler(5f, -35f, 0f);
		Light light2 = obj2.AddComponent<Light>();
		light2.type = LightType.Directional;
		light2.color = new Color(1f, 1f, 1f);
		light2.intensity = 1f;
		light2.cullingMask = 2048;
		light2.shadows = LightShadows.Soft;
		light2.shadowBias = 0.01f;
		light2.shadowNormalBias = 0.01f;
		light2.shadowStrength = 0.9f;
		if (lightIntensityScale != null)
		{
			light2.intensity = lightIntensityScale(light2.intensity);
		}
		PreRender();
		try
		{
			camera.cullingMask = 2048;
			PositionCamera(camera);
			camera.SaveScreenshot(filename, width, height, transparent: true, SuperSampleSize, camera.backgroundColor);
		}
		finally
		{
			Texture.streamingTextureForceLoadAll = streamingTextureForceLoadAll;
			UnityEngine.Object.DestroyImmediate(gameObject);
			PostRender();
		}
	}

	public static bool RenderScreenshot(GameObject prefab, string filename, int width, int height, int SuperSampleSize = 1)
	{
		if (prefab == null)
		{
			Debug.Log("RenderScreenshot - prefab is null", prefab);
			return false;
		}
		PropRenderer propRenderer = null;
		PropRenderer propRenderer2 = prefab.GetComponent<PropRenderer>();
		if (propRenderer2 == null)
		{
			propRenderer = prefab.AddComponent<PropRenderer>();
			propRenderer2 = propRenderer;
		}
		propRenderer2.CreateScreenshot(filename, width, height, SuperSampleSize);
		if (propRenderer != null)
		{
			UnityEngine.Object.DestroyImmediate(propRenderer);
		}
		return true;
	}
}
