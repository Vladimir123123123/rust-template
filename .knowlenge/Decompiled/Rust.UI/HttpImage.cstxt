using System.Collections;
using System.Collections.Generic;
using Rust;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.UI;

public class HttpImage : MonoBehaviour
{
	public static Dictionary<string, UnityWebRequest> RequestCache = new Dictionary<string, UnityWebRequest>();

	public static Dictionary<string, (Texture2D, Sprite)> TextureCache = new Dictionary<string, (Texture2D, Sprite)>();

	public Texture2D LoadingImage;

	public Texture2D MissingImage;

	public string Url = "";

	public bool AutosizeHeight;

	[Tooltip("Fill the RectTransform with the image without skewing when rendering in a RawImage and AutosizeHeight is disabled.")]
	public bool UseCoverFill;

	public bool GenerateMipmaps = true;

	public float MaxWidth;

	public float MaxHeight;

	public bool AllowDisablingImage = true;

	public RawImage rawImage;

	private Image image;

	private Sprite loadingSprite;

	private Sprite missingSprite;

	private bool didLoad;

	private void Init()
	{
		rawImage = GetComponent<RawImage>();
		image = GetComponent<Image>();
		if (LoadingImage != null)
		{
			loadingSprite = CreateSprite(LoadingImage);
		}
		if (MissingImage != null)
		{
			missingSprite = CreateSprite(MissingImage);
		}
		SetImageEnabled(enabled: false);
	}

	private void Start()
	{
		if (!didLoad)
		{
			Init();
			if (Url != string.Empty)
			{
				string url = Url;
				Url = string.Empty;
				Load(url);
			}
		}
	}

	private void OnDestroy()
	{
		if (loadingSprite != null)
		{
			Object.Destroy(loadingSprite);
		}
		if (missingSprite != null)
		{
			Object.Destroy(missingSprite);
		}
	}

	public bool Load(string url)
	{
		if (string.IsNullOrEmpty(url))
		{
			return false;
		}
		if (Url == url)
		{
			return false;
		}
		if (rawImage == null && image == null)
		{
			Init();
		}
		SetLoadingImage();
		Url = url;
		didLoad = true;
		if (TextureCache.TryGetValue(url, out var value))
		{
			UpdateImageTexture(value);
			return false;
		}
		if (RequestCache.ContainsKey(url))
		{
			SetImageEnabled(enabled: false);
			Global.Runner.StartCoroutine(WaitForLoad(url));
			return false;
		}
		SetImageEnabled(enabled: false);
		Global.Runner.StartCoroutine(StartAndWaitForLoad(url));
		return true;
	}

	public void Load(Sprite sprite)
	{
		if (rawImage == null && image == null)
		{
			Init();
		}
		Url = null;
		didLoad = true;
		UpdateImageTexture((sprite.texture, sprite));
	}

	private IEnumerator WaitForLoad(string url)
	{
		while (!TextureCache.ContainsKey(url) && url == Url)
		{
			yield return null;
		}
		if ((bool)this && url == Url && (rawImage != null || image != null))
		{
			UpdateImageTexture(TextureCache[url]);
		}
	}

	private void UpdateImageTexture((Texture2D, Sprite) tex)
	{
		if (!(tex.Item1 == null) && !(tex.Item2 == null) && (bool)this && (rawImage != null || image != null))
		{
			if (rawImage != null)
			{
				rawImage.texture = tex.Item1;
			}
			if (image != null)
			{
				image.sprite = tex.Item2;
			}
			SetImageEnabled(enabled: true);
			AutosizeForTexture(tex.Item1);
		}
	}

	public void SetMissingImage()
	{
		UpdateImageTexture((MissingImage, missingSprite));
		Url = "";
	}

	public void SetLoadingImage()
	{
		UpdateImageTexture((LoadingImage, loadingSprite));
		Url = "";
	}

	private IEnumerator StartAndWaitForLoad(string url)
	{
		UnityWebRequest request = new UnityWebRequest(url)
		{
			downloadHandler = new DownloadHandlerBuffer()
		};
		RequestCache.Add(url, request);
		yield return request.SendWebRequest();
		RequestCache.Remove(url);
		Texture2D texture2D = null;
		if (request.isDone && !request.isHttpError && !request.isNetworkError)
		{
			texture2D = (GenerateMipmaps ? new Texture2D(16, 16) : new Texture2D(16, 16, TextureFormat.ARGB32, mipChain: false));
			texture2D.name = url;
			texture2D.wrapMode = TextureWrapMode.Clamp;
			if (!texture2D.LoadImage(request.downloadHandler.data, markNonReadable: true))
			{
				Object.DestroyImmediate(texture2D);
				texture2D = null;
			}
			else if ((MaxWidth > 0f && (float)texture2D.width > MaxWidth) || (MaxHeight > 0f && (float)texture2D.height > MaxHeight))
			{
				Debug.Log("Texture from " + url + " was too big, ignoring");
				Object.DestroyImmediate(texture2D);
				texture2D = null;
			}
		}
		if (texture2D == null)
		{
			if (MissingImage != null)
			{
				texture2D = MissingImage;
			}
			if (texture2D == null)
			{
				texture2D = Texture2D.blackTexture;
			}
		}
		Sprite item = CreateSprite(texture2D);
		(Texture2D, Sprite) tuple = (texture2D, item);
		TextureCache.Add(url, tuple);
		request.Dispose();
		if ((bool)this && url == Url && (rawImage != null || image != null))
		{
			UpdateImageTexture(tuple);
			AutosizeForTexture(texture2D);
		}
	}

	private void AutosizeForTexture(Texture2D texture)
	{
		if (AutosizeHeight)
		{
			float num = (float)texture.width / (float)texture.height;
			if (rawImage != null)
			{
				rawImage.rectTransform.sizeDelta = new Vector2(rawImage.rectTransform.sizeDelta.x, rawImage.rectTransform.sizeDelta.x / num);
			}
			if (image != null)
			{
				image.rectTransform.sizeDelta = new Vector2(image.rectTransform.sizeDelta.x, image.rectTransform.sizeDelta.x / num);
			}
			SetImageEnabled(enabled: true);
		}
		UpdateCoverFill();
	}

	private void UpdateCoverFill()
	{
		if (UseCoverFill && !(rawImage == null))
		{
			Texture texture = rawImage.texture;
			Vector2 size = rawImage.GetPixelAdjustedRect().size;
			Vector2 vector = new Vector2(texture.width, texture.height);
			float num = size.x / size.y;
			float num2 = vector.x / vector.y;
			float num3 = ((num >= num2) ? (size.x / vector.x) : (size.y / vector.y));
			float num4 = vector.x * num3;
			float num5 = vector.y * num3;
			rawImage.uvRect = new Rect
			{
				x = (num4 - size.x) / 2f / num4,
				y = (num5 - size.y) / 2f / num5,
				width = size.x / num4,
				height = size.y / num5
			};
		}
	}

	private void SetImageEnabled(bool enabled)
	{
		if (AllowDisablingImage)
		{
			if (rawImage != null)
			{
				rawImage.enabled = enabled;
			}
			if (image != null)
			{
				image.enabled = enabled;
			}
		}
	}

	private void OnRectTransformDimensionsChange()
	{
		UpdateCoverFill();
	}

	private static Sprite CreateSprite(Texture2D texture)
	{
		return Sprite.Create(texture, new Rect(Vector2.zero, new Vector2(texture.width, texture.height)), new Vector2(0.5f, 0.5f));
	}
}
