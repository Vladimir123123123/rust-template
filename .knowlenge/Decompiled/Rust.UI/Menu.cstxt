using System;
using System.Collections.Generic;
using System.Linq;
using Facepunch.Extend;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.UI;

public class Menu : RustControl
{
	[Serializable]
	public class ChangedEvent : UnityEvent<Option>
	{
	}

	public bool AllowFiltering;

	public int MaxResults = 100;

	public Image Border;

	public Image Background;

	public Option[] Options;

	public RectTransform OptionCanvas;

	public RustInput FilterField;

	[NonSerialized]
	public Option SelectedOption;

	public ChangedEvent OnSelected;

	[NonSerialized]
	public Blocker Blocker;

	protected override void Awake()
	{
		base.Awake();
		FilterField.OnValueChanged.AddListener(delegate
		{
			Build();
		});
	}

	public void Build()
	{
		FilterField.transform.parent.gameObject.SetActive(AllowFiltering);
		OptionCanvas.DestroyAllChildren(immediate: true);
		foreach (Option option in GetOptions())
		{
			RustButton rustButton = Make.MenuOption(option.Label, option.Icon);
			rustButton.SetParent(OptionCanvas);
			rustButton.gameObject.hideFlags = HideFlags.HideAndDontSave;
			rustButton.OnPressed.AddListener(delegate
			{
				OnOptionSelected(option);
			});
			if (!string.IsNullOrEmpty(SelectedOption.Value) && option.Value == SelectedOption.Value)
			{
				rustButton.SetPressed(value: true);
			}
		}
	}

	private void OnOptionSelected(Option option)
	{
		OnSelected.Invoke(option);
		UnityEngine.Object.Destroy(base.gameObject);
		if ((bool)Blocker)
		{
			UnityEngine.Object.Destroy(Blocker.gameObject);
		}
	}

	private IEnumerable<Option> GetOptions()
	{
		if (!AllowFiltering)
		{
			return Options.Select((Option x) => x);
		}
		string searchString = FilterField.Text;
		return Options.Where((Option x) => string.IsNullOrEmpty(searchString) || x.Label.translated.Contains(searchString)).Take(MaxResults);
	}

	internal void Popup(RectTransform source)
	{
		Blocker = Make.Blocker();
		Blocker.SetParentRootCanvas(source);
		Blocker.rectTransform.Fill(-1f, -1f, -1f, -1f);
		float x = Blocker.transform.lossyScale.x;
		this.SetParent(Blocker);
		Build();
		OptionCanvas.GetComponent<RustLayout>().DoLayout();
		GetComponent<RustLayout>().DoLayout();
		Vector3[] array = new Vector3[4];
		source.GetLocalCorners(array);
		for (int i = 0; i < array.Length; i++)
		{
			array[i] = source.TransformPoint(array[i]);
		}
		if (array[0].y / (float)Screen.height < 0.33f)
		{
			base.rectTransform.pivot = new Vector2(0f, 0f);
			base.rectTransform.anchorMin = Vector3.zero;
			base.rectTransform.anchorMax = Vector3.zero;
			base.rectTransform.offsetMin = array[1] / x;
			base.rectTransform.offsetMax = array[1] / x;
			base.rectTransform.SetWidth(source.GetWidth());
		}
		else
		{
			base.rectTransform.pivot = new Vector2(0f, 1f);
			base.rectTransform.anchorMin = Vector3.zero;
			base.rectTransform.anchorMax = Vector3.zero;
			base.rectTransform.offsetMin = array[0] / x;
			base.rectTransform.offsetMax = array[0] / x;
			base.rectTransform.SetWidth(source.GetWidth());
			RestrainToScreen();
		}
	}

	private void RestrainToScreen()
	{
		OptionCanvas.GetComponent<RustLayout>().DoLayout();
		GetComponent<RustLayout>().DoLayout();
		int num = 4;
		if (base.rectTransform.offsetMin.y < (float)num)
		{
			float amount = Mathf.Abs(base.rectTransform.offsetMin.y) + (float)num;
			base.rectTransform.MoveY(amount);
		}
		if (base.rectTransform.offsetMin.y > (float)(Screen.height - 4))
		{
			float num2 = Mathf.Abs((float)Screen.height - base.rectTransform.offsetMin.y) + (float)num;
			base.rectTransform.MoveY(0f - num2);
		}
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		base.ApplyStyle(s);
		if ((bool)Background)
		{
			Background.color = s.Bg;
		}
		if ((bool)Border)
		{
			Border.color = s.Fg;
		}
	}
}
