using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/Image Button")]
public class RustImageButton : RustControl, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, ILayoutElement
{
	public Image Background;

	public Image Icon;

	public UnityEvent OnPressed;

	public UnityEvent OnReleased;

	public bool IsToggle;

	public bool UnpressSiblings;

	public bool PreventToggleOff;

	public Transform TabPanelTarget;

	public Sprite PressedImage;

	public Sprite UnpressedImage;

	public bool Value
	{
		get
		{
			return IsPressed;
		}
		set
		{
			if (value != Value)
			{
				if (value)
				{
					CurrentState |= State.Pressed;
				}
				else
				{
					CurrentState &= ~State.Pressed;
				}
				ApplyStyles();
			}
		}
	}

	public float minWidth
	{
		get
		{
			if (!Icon)
			{
				return 0f;
			}
			return Icon.rectTransform.rect.width;
		}
	}

	public float preferredWidth
	{
		get
		{
			if (!Icon)
			{
				return 0f;
			}
			return Icon.rectTransform.rect.width;
		}
	}

	public float flexibleWidth
	{
		get
		{
			if (!Icon)
			{
				return 0f;
			}
			return Icon.rectTransform.rect.width;
		}
	}

	public float minHeight
	{
		get
		{
			if (!Icon)
			{
				return 0f;
			}
			return Icon.minHeight;
		}
	}

	public float preferredHeight
	{
		get
		{
			if (!Icon)
			{
				return 0f;
			}
			return Icon.preferredHeight;
		}
	}

	public float flexibleHeight
	{
		get
		{
			if (!Icon)
			{
				return 0f;
			}
			return Icon.flexibleHeight;
		}
	}

	public int layoutPriority
	{
		get
		{
			if (!Icon)
			{
				return 0;
			}
			return Icon.layoutPriority;
		}
	}

	public void Press()
	{
		if (IsDisabled)
		{
			return;
		}
		if (IsToggle)
		{
			if (!PreventToggleOff || !Value)
			{
				Toggle(!Value);
			}
		}
		else
		{
			Toggle(v: true, forced: true);
		}
	}

	public void Unpress()
	{
		if (!IsDisabled)
		{
			if (!IsToggle)
			{
				CurrentState &= ~State.Pressed;
			}
			ApplyStyles();
		}
	}

	public virtual void OnPointerDown(PointerEventData eventData)
	{
		if (eventData.button == PointerEventData.InputButton.Left)
		{
			Press();
		}
	}

	public void Toggle(bool v, bool forced = false)
	{
		if (v)
		{
			if (UnpressSiblings)
			{
				DoUnpressSiblings();
			}
			if (Value && !forced)
			{
				return;
			}
			CurrentState |= State.Pressed;
			OnPressed.Invoke();
			ToggleTabPanel(onOff: true);
		}
		else
		{
			if (!Value && !forced)
			{
				return;
			}
			CurrentState &= ~State.Pressed;
			OnReleased.Invoke();
			ToggleTabPanel(onOff: false);
		}
		ApplyStyles();
	}

	private void ToggleTabPanel(bool onOff)
	{
		if (!(TabPanelTarget == null))
		{
			Transform transform = TabPanelTarget.Find(base.gameObject.name);
			if (!(transform == null))
			{
				transform.gameObject.SetActive(onOff);
			}
		}
	}

	private void DoUnpressSiblings()
	{
		foreach (Transform item in base.transform.parent)
		{
			if (!(item == base.transform))
			{
				RustImageButton component = item.GetComponent<RustImageButton>();
				if (!(component == null))
				{
					component.Toggle(v: false);
				}
			}
		}
	}

	public virtual void OnPointerUp(PointerEventData eventData)
	{
		Unpress();
	}

	protected override void OnDisable()
	{
		base.OnDisable();
		if (!IsToggle && Value)
		{
			CurrentState &= ~State.Pressed;
			ApplyStyles();
		}
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		if ((bool)Background)
		{
			Background.color = s.Bg;
		}
		if ((bool)Icon)
		{
			Icon.color = s.Icon;
			Icon.sprite = (Value ? PressedImage : UnpressedImage);
		}
	}

	public void CalculateLayoutInputHorizontal()
	{
		Icon?.CalculateLayoutInputHorizontal();
	}

	public void CalculateLayoutInputVertical()
	{
		Icon?.CalculateLayoutInputVertical();
	}
}
