using Rust.UI;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.Serialization;
using UnityEngine.UI;

public class RustLayout : UIBehaviour, ILayoutGroup, ILayoutController, IAutoLayout
{
	public enum LayoutMode
	{
		Top,
		Left,
		Right,
		Bottom
	}

	public LayoutMode Mode;

	public bool ReverseOrder;

	public float Spacing;

	public RectOffset Padding;

	[FormerlySerializedAs("SetChildrenWidth")]
	[Tooltip("Scale the children to fill in the opposite direction to the way you're laying out")]
	public bool ChildrenFill;

	[FormerlySerializedAs("SetHeight")]
	[Tooltip("Resize this container to fit children on the direction you're laying out")]
	public bool ResizeToChildren;

	[Tooltip("Resize this container to fit children on the opposite direction to the one you're laying out (does nothing if ChildrenFill is enabled)")]
	public bool ResizeToChildrenOpposite;

	public RectTransform[] IgnoreLayout;

	public int MaxHeight;

	[Tooltip("We'll call layout on this if our size changes")]
	public RustLayout ParentLayout;

	private bool doingLayout;

	private bool changedSize;

	protected override void Awake()
	{
		OnTransformParentChanged();
	}

	protected override void OnEnable()
	{
		DoLayout();
	}

	public virtual void SetLayoutHorizontal()
	{
		DoLayout();
	}

	public virtual void SetLayoutVertical()
	{
		DoLayout();
	}

	public virtual void DoLayout()
	{
		if (doingLayout)
		{
			return;
		}
		if (Padding == null)
		{
			Padding = new RectOffset();
		}
		doingLayout = true;
		try
		{
			changedSize = false;
			if (Mode == LayoutMode.Top)
			{
				DoTopLayout(RectTransform.Edge.Top);
			}
			if (Mode == LayoutMode.Bottom)
			{
				DoTopLayout(RectTransform.Edge.Bottom);
			}
			if (Mode == LayoutMode.Left)
			{
				DoHorizontalLayout(RectTransform.Edge.Left);
			}
			if (Mode == LayoutMode.Right)
			{
				DoHorizontalLayout(RectTransform.Edge.Right);
			}
			if (changedSize)
			{
				ParentLayout?.DoLayout();
			}
		}
		finally
		{
			doingLayout = false;
		}
	}

	protected override void OnTransformParentChanged()
	{
		ParentLayout = null;
		if ((bool)base.transform.parent)
		{
			ParentLayout = base.transform.parent.GetComponent<RustLayout>();
		}
	}

	private void DoHorizontalLayout(RectTransform.Edge edge)
	{
		RectTransform rectTransform = base.transform as RectTransform;
		Vector2 size = rectTransform.rect.size;
		int childCount = base.transform.childCount;
		float num = 0f;
		float num2 = ((edge == RectTransform.Edge.Left) ? Padding.left : Padding.right);
		float num3 = 0f;
		for (int i = 0; i < childCount; i++)
		{
			RectTransform rectTransform2 = base.transform.GetChild(ReverseOrder ? (childCount - i - 1) : i) as RectTransform;
			if (rectTransform2.gameObject.activeSelf && !Ignoring(rectTransform2))
			{
				Vector2 size2 = rectTransform2.rect.size;
				rectTransform2.SetInsetAndSizeFromParentEdge(edge, num2, size2.x);
				if (ChildrenFill)
				{
					rectTransform2.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Top, Padding.top, size.y - (float)Padding.vertical);
				}
				else
				{
					rectTransform2.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Top, Padding.top, size2.y);
				}
				num2 += size2.x + Spacing;
				num3 = Spacing;
				if (size2.y > num)
				{
					num = size2.y;
				}
			}
		}
		num2 -= num3;
		num2 += (float)Padding.right;
		bool flag = false;
		if (ResizeToChildren && size.x != num2)
		{
			changedSize = true;
			rectTransform.SetWidth(num2);
			flag = true;
		}
		if (ResizeToChildrenOpposite && !ChildrenFill && size.y != num)
		{
			changedSize = true;
			rectTransform.SetHeight((float)Padding.top + num + (float)Padding.bottom);
			flag = true;
		}
		if (flag)
		{
			ILayoutGroup componentInParent = GetComponentInParent<ILayoutGroup>();
			componentInParent?.SetLayoutHorizontal();
			componentInParent?.SetLayoutVertical();
		}
	}

	private void DoTopLayout(RectTransform.Edge edge)
	{
		RectTransform rectTransform = base.transform as RectTransform;
		Vector2 size = rectTransform.rect.size;
		int childCount = base.transform.childCount;
		float num = 0f;
		float num2 = ((edge == RectTransform.Edge.Top) ? Padding.top : Padding.bottom);
		float num3 = 0f;
		for (int i = 0; i < childCount; i++)
		{
			RectTransform rectTransform2 = base.transform.GetChild(ReverseOrder ? (childCount - i - 1) : i) as RectTransform;
			if ((bool)rectTransform2 && (bool)rectTransform2.gameObject && rectTransform2.gameObject.activeSelf && !Ignoring(rectTransform2))
			{
				Vector2 size2 = rectTransform2.rect.size;
				rectTransform2.SetInsetAndSizeFromParentEdge(edge, num2, size2.y);
				if (ChildrenFill)
				{
					rectTransform2.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Left, Padding.left, size.x - (float)Padding.horizontal);
				}
				else
				{
					rectTransform2.SetInsetAndSizeFromParentEdge(RectTransform.Edge.Left, Padding.left, size2.x);
				}
				num2 += size2.y + Spacing;
				num3 = Spacing;
				if (size2.x > num)
				{
					num = size2.x;
				}
			}
		}
		num2 -= num3;
		num2 += (float)Padding.bottom;
		if (MaxHeight > 0)
		{
			num2 = Mathf.Min(MaxHeight, num2);
		}
		bool flag = false;
		if (ResizeToChildren && size.y != num2)
		{
			changedSize = true;
			rectTransform.SetHeight(num2);
			flag = true;
		}
		if (ResizeToChildrenOpposite && !ChildrenFill && size.x != num)
		{
			changedSize = true;
			rectTransform.SetWidth((float)Padding.left + num + (float)Padding.right);
			flag = true;
		}
		if (flag)
		{
			ILayoutGroup componentInParent = GetComponentInParent<ILayoutGroup>();
			componentInParent?.SetLayoutHorizontal();
			componentInParent?.SetLayoutVertical();
		}
	}

	private bool Ignoring(RectTransform child)
	{
		if (IgnoreLayout == null)
		{
			return false;
		}
		for (int i = 0; i < IgnoreLayout.Length; i++)
		{
			if (child == IgnoreLayout[i])
			{
				return true;
			}
		}
		return false;
	}

	protected void SetDirty()
	{
		if (IsActive())
		{
			LayoutRebuilder.MarkLayoutForRebuild(base.transform as RectTransform);
		}
	}

	protected override void OnRectTransformDimensionsChange()
	{
		base.OnRectTransformDimensionsChange();
		SetDirty();
	}

	protected virtual void OnTransformChildrenChanged()
	{
		SetDirty();
	}
}
