using System;
using Rust.UI;
using UnityEngine;
using UnityEngine.Events;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class RustSlider : RustControl, IPointerDownHandler, IEventSystemHandler, IPointerUpHandler, IDragHandler, IInitializePotentialDragHandler
{
	[Serializable]
	public class ChangedEvent : UnityEvent<float>
	{
	}

	public RustInput NumberInput;

	public Image SliderCanvas;

	public string DecimalFormat = "0.00";

	public float MinValue;

	public float MaxValue;

	public bool Integer;

	public float ValueInternal;

	public ChangedEvent OnChanged;

	protected float lastCallbackValue;

	public virtual float Value
	{
		get
		{
			return ValueInternal;
		}
		set
		{
			value = Mathf.Clamp(value, MinValue, MaxValue);
			if (Integer)
			{
				value = Mathf.Round(value);
			}
			if (ValueInternal != value)
			{
				ValueInternal = value;
			}
			string text = (Integer ? $"{(int)value}" : string.Format("{0:" + DecimalFormat + "}", value));
			if (NumberInput != null && !NumberInput.IsFocused && NumberInput.Text != text)
			{
				NumberInput.Text = text;
			}
			SliderCanvas.fillAmount = ValueNormalized;
			if (lastCallbackValue != value)
			{
				lastCallbackValue = value;
				OnChanged?.Invoke(value);
			}
		}
	}

	public float ValueNormalized
	{
		get
		{
			return Mathf.InverseLerp(MinValue, MaxValue, Value);
		}
		set
		{
			Value = MinValue + (MaxValue - MinValue) * value;
		}
	}

	protected override void Awake()
	{
		base.Awake();
		if (NumberInput != null)
		{
			NumberInput.OnValueChanged.AddListener(TextChanged);
			NumberInput.OnEndEdit.AddListener(TextChanged);
		}
	}

	public void TextChanged(string text)
	{
		if (float.TryParse(text, out var result))
		{
			Value = result;
		}
	}

	public void SliderChanged(float slider)
	{
		Value = slider;
	}

	protected override void ApplyStyle(StyleColorSet s)
	{
		base.ApplyStyle(s);
		SliderCanvas.color = s.Fg;
		GetComponent<Image>().color = s.Bg;
	}

	public void OnPointerDown(PointerEventData eventData)
	{
		UpdateDrag(eventData.position, eventData.pressEventCamera);
		CurrentState |= State.Pressed;
		RustControl.IsDragging = true;
		ApplyStyles();
	}

	public void OnPointerUp(PointerEventData eventData)
	{
		CurrentState &= ~State.Pressed;
		RustControl.IsDragging = false;
		ApplyStyles();
	}

	public void OnInitializePotentialDrag(PointerEventData eventData)
	{
		eventData.useDragThreshold = false;
	}

	public void OnDrag(PointerEventData eventData)
	{
		UpdateDrag(eventData.position, eventData.pressEventCamera);
	}

	private void UpdateDrag(Vector2 pos, Camera cam)
	{
		if (RectTransformUtility.ScreenPointToLocalPointInRectangle(SliderCanvas.rectTransform, pos, cam, out var localPoint))
		{
			localPoint -= SliderCanvas.rectTransform.rect.position;
			localPoint.x /= SliderCanvas.rectTransform.rect.width;
			ValueNormalized = localPoint.x;
		}
	}
}
