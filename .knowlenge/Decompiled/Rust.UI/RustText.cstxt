using System;
using RTLTMPro;
using Rust.Localization;
using Rust.UI;
using TMPro;
using UnityEngine;
using UnityEngine.Serialization;
using UnityEngine.UI;

[AddComponentMenu("Rust/UI/RustText")]
public class RustText : TextMeshProUGUI, ILocalize
{
	public bool IsLocalized;

	public string Token;

	[TextArea]
	public string English;

	[NonSerialized]
	public Translate.Phrase Phrase;

	[FormerlySerializedAs("AutoSizeContainer")]
	public bool AutoSetWidth;

	public bool AutoSetHeight;

	public bool AutoSizeParent;

	public float MinWidth = 30f;

	public float MaxWidth = float.PositiveInfinity;

	public float MinHeight;

	public float MaxHeight = float.PositiveInfinity;

	private object[] localizationArguments;

	private static FastStringBuilder inputBuilder = new FastStringBuilder(2048);

	private bool invertedAlignment;

	public string LanguageToken => Token;

	public string LanguageEnglish => English;

	public void SetPhrase(Translate.Phrase phrase, params object[] args)
	{
		if (Application.isPlaying)
		{
			Phrase = phrase;
		}
		IsLocalized = true;
		Token = phrase.token;
		English = phrase.english;
		if (args != null && args.Length != 0)
		{
			SetPhraseArguments(args);
		}
		else
		{
			UpdateLocalizedText(forceEnglish: false);
		}
	}

	protected override void Awake()
	{
		base.Awake();
		UpdateLocalizedText(forceEnglish: false);
	}

	public void SetPhraseArguments(params object[] args)
	{
		localizationArguments = args;
		UpdateLocalizedText(forceEnglish: false);
	}

	public void SetText(string str)
	{
		SetText(str, localized: false);
	}

	public void SetText(string str, bool localized, bool forceRTLFormatting = false)
	{
		IsLocalized = localized;
		if (localized || forceRTLFormatting)
		{
			str = FormatLocalizedText(str, forceRTLFormatting);
			base.text = str;
			DoAutoSize();
			FormatAlignment();
		}
		else
		{
			base.text = str;
			DoAutoSize();
		}
	}

	public virtual void DoAutoSize()
	{
		if (base.font == null)
		{
			Debug.LogWarning("null font: " + base.gameObject.name, base.gameObject);
			return;
		}
		if (AutoSetWidth)
		{
			RectTransform trans = (RectTransform)base.transform;
			Vector2 preferredValues = GetPreferredValues(base.text, float.PositiveInfinity, float.PositiveInfinity);
			preferredValues.x = Mathf.Clamp(preferredValues.x, MinWidth, MaxWidth);
			trans.SetWidth(preferredValues.x + m_currentFontAsset.normalSpacingOffset);
			trans.DoAutoLayout();
			if (AutoSizeParent)
			{
				RectTransform trans2 = (RectTransform)base.transform.parent;
				trans2.SetWidth(preferredValues.x);
				trans2.DoAutoLayout();
			}
		}
		if (AutoSetHeight)
		{
			RectTransform obj = (RectTransform)base.transform;
			Rect rect = obj.rect;
			Vector2 preferredValues2 = GetPreferredValues(base.text, rect.width - (m_margin.x + m_margin.z), float.PositiveInfinity);
			preferredValues2.y = Mathf.Clamp(preferredValues2.y, MinHeight, MaxHeight);
			obj.SetHeight(preferredValues2.y);
			obj.DoAutoLayout();
			if (AutoSizeParent)
			{
				RectTransform trans3 = (RectTransform)base.transform.parent;
				trans3.SetHeight(preferredValues2.y);
				trans3.DoAutoLayout();
			}
		}
	}

	public override void Rebuild(CanvasUpdate update)
	{
		if (!(this == null))
		{
			base.Rebuild(update);
		}
	}

	private string GetLocalizedText(bool englishVersion)
	{
		if (Phrase != null)
		{
			if (localizationArguments != null)
			{
				return string.Format(Phrase.translated, localizationArguments);
			}
			return Phrase.translated;
		}
		string text = (englishVersion ? English : Translate.Get(Token, English));
		if (string.IsNullOrEmpty(text))
		{
			return string.Empty;
		}
		if (localizationArguments != null)
		{
			text = string.Format(text, localizationArguments);
		}
		return text;
	}

	private void UpdateLocalizedText(bool forceEnglish)
	{
		if (IsLocalized)
		{
			string localizedText = GetLocalizedText(forceEnglish);
			base.text = FormatLocalizedText(localizedText);
			DoAutoSize();
			FormatAlignment();
		}
	}

	public static void OnLanguageChanged()
	{
		RustText[] array = Resources.FindObjectsOfTypeAll<RustText>();
		for (int i = 0; i < array.Length; i++)
		{
			array[i].UpdateLocalizedText(forceEnglish: false);
		}
	}

	public string FormatLocalizedText(string str, bool force = false)
	{
		if (Translate.CurrentLanguageIsRTL() || force)
		{
			base.isRightToLeftText = TextUtils.ContainsRTLInput(str);
			if (base.isRightToLeftText)
			{
				inputBuilder.Clear();
				RTLSupport.FixRTL(str, inputBuilder);
				inputBuilder.Reverse();
				str = inputBuilder.ToString();
				base.text = str;
			}
			return str;
		}
		base.isRightToLeftText = false;
		return str;
	}

	private void FormatAlignment()
	{
		if (Translate.CurrentLanguageIsRTL() && TextUtils.ContainsRTLInput(base.text))
		{
			if ((base.textInfo.lineCount >= 3 && GetHorizontalAlignment() == _HorizontalAlignmentOptions.Left) || GetHorizontalAlignment() == _HorizontalAlignmentOptions.Justified)
			{
				SetHorizontalAlignment(_HorizontalAlignmentOptions.Right);
				invertedAlignment = true;
			}
		}
		else if (invertedAlignment)
		{
			SetHorizontalAlignment(_HorizontalAlignmentOptions.Left);
			invertedAlignment = false;
		}
	}

	public _HorizontalAlignmentOptions GetHorizontalAlignment()
	{
		return (_HorizontalAlignmentOptions)(base.alignment & (TextAlignmentOptions)63);
	}

	public _VerticalAlignmentOptions GetVerticalAligment()
	{
		return (_VerticalAlignmentOptions)(base.alignment & (TextAlignmentOptions)65280);
	}

	public void SetHorizontalAlignment(_HorizontalAlignmentOptions option)
	{
		base.alignment = (TextAlignmentOptions)((int)option | (int)GetVerticalAligment());
	}

	public void SetVerticalAlignment(_VerticalAlignmentOptions option)
	{
		base.alignment = (TextAlignmentOptions)((int)option | (int)GetHorizontalAlignment());
	}
}
