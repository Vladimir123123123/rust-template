using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using Facepunch.Extend;
using Facepunch.Utility;
using Newtonsoft.Json;
using Rust;
using Rust.Workshop;
using Steamworks;
using Steamworks.Data;
using Steamworks.Ugc;
using UnityEngine;
using UnityEngine.UI;

public class Publisher : MonoBehaviour
{
	public InputField ChangeLog;

	public Button PublishButton;

	public Texture2D IconBackground;

	private Skinnable Skinnable;

	private Skin Skin;

	private ulong ItemId;

	private string Title;

	private GameObject Prefab;

	protected WorkshopInterface Interface => SingletonComponent<WorkshopInterface>.Instance;

	protected WorkshopItemEditor Editor => SingletonComponent<WorkshopItemEditor>.Instance;

	public void StartExport()
	{
		DoExport(publishToSteam: true, OpenFolder: false);
	}

	public void Update()
	{
		PublishButton.interactable = CanPublish();
	}

	public bool CanPublish()
	{
		if (Interface.Editor.ItemTitle.Length == 0)
		{
			return false;
		}
		return true;
	}

	private async Task DoExport(bool publishToSteam, bool OpenFolder, string forceFolderName = null)
	{
		_ = 1;
		try
		{
			Skinnable = Editor.Skinnable;
			Skin = Editor.Skin;
			ItemId = Editor.ItemId;
			Title = Editor.ItemTitle;
			Prefab = Editor.Prefab;
			WorkshopItemEditor.Loading(v1: true, "Exporting..", "", 0f);
			string tempFolder = Path.GetTempFileName();
			File.Delete(tempFolder);
			Directory.CreateDirectory(tempFolder);
			if (forceFolderName != null)
			{
				tempFolder = forceFolderName;
			}
			Debug.Log(tempFolder);
			await ExportToFolder(tempFolder, OpenFolder);
			if (publishToSteam)
			{
				await PublishToSteam(tempFolder);
			}
			if (forceFolderName != tempFolder)
			{
				Directory.Delete(tempFolder, recursive: true);
			}
		}
		catch (Exception exception)
		{
			Debug.LogException(exception);
		}
		finally
		{
			WorkshopItemEditor.Loading(v1: false, "", "", 0f);
		}
	}

	private async Task ExportToFolder(string folder, bool OpenFolder)
	{
		Skin.Manifest data = new Skin.Manifest
		{
			ItemType = Skinnable.Name,
			Version = 3,
			Groups = new Skin.Manifest.Group[Skin.Materials.Length],
			PublishDate = DateTime.UtcNow,
			AuthorId = SteamClient.SteamId
		};
		for (int i = 0; i < Skin.Materials.Length; i++)
		{
			data.Groups[i] = new Skin.Manifest.Group();
			Material mat = Skin.Materials[i];
			Skin.Manifest.Group group = data.Groups[i];
			bool isCloth = mat.shader.name.Contains("Cloth");
			bool hasDetailLayer = mat.IsKeywordEnabled("_DETAILLAYER_ON");
			bool hasDirtLayer = mat.IsKeywordEnabled("_DIRTLAYER_ON");
			await ExportTexture(group.Textures, folder, i, "_MainTex", mat, Skin.DefaultMaterials[i]);
			await ExportTexture(group.Textures, folder, i, "_OcclusionMap", mat, Skin.DefaultMaterials[i]);
			await ExportTexture(group.Textures, folder, i, "_SpecGlossMap", mat, Skin.DefaultMaterials[i]);
			await ExportTexture(group.Textures, folder, i, "_BumpMap", mat, Skin.DefaultMaterials[i], isNormalMap: true);
			await ExportTexture(group.Textures, folder, i, "_EmissionMap", mat, Skin.DefaultMaterials[i]);
			if (isCloth)
			{
				await ExportTexture(group.Textures, folder, i, "_MicrofiberFuzzMask", mat, Skin.DefaultMaterials[i]);
			}
			if (hasDetailLayer)
			{
				await ExportTexture(group.Textures, folder, i, "_DetailAlbedoMap", mat, Skin.DefaultMaterials[i]);
				await ExportTexture(group.Textures, folder, i, "_DetailMask", mat, Skin.DefaultMaterials[i]);
				await ExportTexture(group.Textures, folder, i, "_DetailNormalMap", mat, Skin.DefaultMaterials[i], isNormalMap: true);
				await ExportTexture(group.Textures, folder, i, "_DetailOcclusionMap", mat, Skin.DefaultMaterials[i]);
			}
			if (hasDirtLayer)
			{
				await ExportTexture(group.Textures, folder, i, "_DirtColor", mat, Skin.DefaultMaterials[i]);
			}
			group.Floats.Add("_Cutoff", mat.GetFloat("_Cutoff"));
			group.Floats.Add("_BumpScale", mat.GetFloat("_BumpScale"));
			group.Floats.Add("_Glossiness", mat.GetFloat("_Glossiness"));
			group.Floats.Add("_OcclusionStrength", mat.GetFloat("_OcclusionStrength"));
			if (isCloth)
			{
				group.Floats.Add("_MicrofiberFuzzIntensity", mat.GetFloat("_MicrofiberFuzzIntensity"));
				group.Floats.Add("_MicrofiberFuzzScatter", mat.GetFloat("_MicrofiberFuzzScatter"));
				group.Floats.Add("_MicrofiberFuzzOcclusion", mat.GetFloat("_MicrofiberFuzzOcclusion"));
			}
			if (hasDetailLayer)
			{
				group.Floats.Add("_DetailNormalMapScale", mat.GetFloat("_DetailNormalMapScale"));
				group.Floats.Add("_DetailOcclusionStrength", mat.GetFloat("_DetailOcclusionStrength"));
				group.Floats.Add("_DetailOverlaySmoothness", mat.GetFloat("_DetailOverlaySmoothness"));
				group.Floats.Add("_DetailOverlaySpecular", mat.GetFloat("_DetailOverlaySpecular"));
			}
			if (hasDirtLayer)
			{
				group.Floats.Add("_DirtAmount", mat.GetFloat("_DirtAmount"));
			}
			group.Colors.Add("_Color", new Skin.Manifest.ColorEntry(mat.GetColor("_Color")));
			group.Colors.Add("_SpecColor", new Skin.Manifest.ColorEntry(mat.GetColor("_SpecColor")));
			group.Colors.Add("_EmissionColor", new Skin.Manifest.ColorEntry(mat.GetColor("_EmissionColor")));
			if (isCloth)
			{
				group.Colors.Add("_MicrofiberFuzzColor", new Skin.Manifest.ColorEntry(mat.GetColor("_MicrofiberFuzzColor")));
			}
			if (hasDetailLayer)
			{
				group.Colors.Add("_DetailColor", new Skin.Manifest.ColorEntry(mat.GetColor("_DetailColor")));
			}
		}
		PropRenderer.RenderScreenshot(Prefab, folder + "/icon.png", 512, 512, 4);
		CreateWorkshopIcon(folder);
		string contents = JsonConvert.SerializeObject((object)data, (Formatting)1);
		File.WriteAllText(folder + "/manifest.txt", contents);
		if (OpenFolder)
		{
			Os.OpenFolder(folder);
		}
	}

	private void CreateWorkshopIcon(string folder)
	{
		Texture2D texture2D = new Texture2D(512, 512, TextureFormat.ARGB32, mipChain: false);
		texture2D.LoadImage(File.ReadAllBytes(folder + "/icon.png"));
		RenderTexture renderTexture = new RenderTexture(512, 512, 0);
		renderTexture.Blit(IconBackground);
		renderTexture.BlitWithAlphaBlending(texture2D);
		renderTexture.ToTexture(texture2D);
		File.WriteAllBytes(bytes: texture2D.EncodeToPNG(), path: folder + "/icon_background.png");
		UnityEngine.Object.DestroyImmediate(texture2D);
		UnityEngine.Object.DestroyImmediate(renderTexture);
	}

	private async Task PublishToSteam(string folder)
	{
		Editor editor = ((ItemId != 0L) ? new Editor(ItemId) : Steamworks.Ugc.Editor.NewMicrotransactionFile).WithContent(folder).WithPreviewFile(folder + "/icon_background.png").WithTitle(Title)
			.WithTag("Version3")
			.WithTag(Skinnable.Name)
			.WithTag("Skin")
			.WithPublicVisibility();
		if (!string.IsNullOrEmpty(ChangeLog.text))
		{
			editor = editor.WithChangeLog(ChangeLog.text);
		}
		WorkshopItemEditor.Loading(v1: true, "Publishing To Steam", "", 0f);
		PublishResult publishResult = await editor.SubmitAsync();
		if (!publishResult.Success)
		{
			Debug.Log("Error: " + publishResult.Result);
		}
		else
		{
			PublishedFileId fileId = publishResult.FileId;
			Debug.Log("Published File: " + fileId.ToString());
		}
		Item? item = await SteamUGC.QueryFileAsync(publishResult.FileId);
		if (!item.HasValue)
		{
			Debug.Log("Error Retrieving item information!");
			WorkshopItemList.RefreshAll();
			return;
		}
		Editor.ItemId = item.Value.Id;
		Editor.ItemTitle = item.Value.Title;
		ChangeLog.text = "";
		UnityEngine.Application.OpenURL(item.Value.Url);
		WorkshopItemList.RefreshAll();
	}

	private async Task ExportTexture(Dictionary<string, string> data, string folder, int group, string paramname, Material mat, Material defaultMat, bool isNormalMap = false)
	{
		WorkshopItemEditor.Loading(v1: true, "Exporting Texture " + paramname, "", 0f);
		UnityEngine.Texture texture = mat.GetTexture(paramname);
		UnityEngine.Texture texture2 = defaultMat.GetTexture(paramname);
		if (!(texture == texture2))
		{
			if (texture == null)
			{
				data.Add(paramname, "none");
				return;
			}
			texture = Facepunch.Utility.Texture.LimitSize(texture as Texture2D, Skinnable.Groups[group].MaxTextureSize, Skinnable.Groups[group].MaxTextureSize);
			string text = string.Format("{0}{1}{2}", paramname, group, ".png");
			data.Add(paramname, text);
			texture.SaveAsPng(folder + "/" + text);
			await Task.Delay(1);
		}
	}

	public void Export()
	{
		DoExport();
	}

	public async Task DoExport()
	{
		string text = await Editor.FileDialog.SaveAsync();
		if (text != null && !File.Exists(text))
		{
			if (!Directory.Exists(text))
			{
				Directory.CreateDirectory(text);
			}
			await DoExport(publishToSteam: false, OpenFolder: true, text);
		}
	}
}
